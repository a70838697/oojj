-- phpMyAdmin SQL Dump
-- version 3.3.9
-- http://www.phpmyadmin.net
--
-- 主机: localhost
-- 生成日期: 2011 年 02 月 12 日 19:29
-- 服务器版本: 5.5.8
-- PHP 版本: 5.3.5

SET SQL_MODE="NO_AUTO_VALUE_ON_ZERO";


/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;

--
-- 数据库: `csp`
--

-- --------------------------------------------------------

--
-- 表的结构 `authassignment`
--

DROP TABLE IF EXISTS `authassignment`;
CREATE TABLE IF NOT EXISTS `authassignment` (
  `itemname` varchar(64) NOT NULL,
  `userid` varchar(64) NOT NULL,
  `bizrule` text,
  `data` text,
  PRIMARY KEY (`itemname`,`userid`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

--
-- 转存表中的数据 `authassignment`
--

INSERT INTO `authassignment` (`itemname`, `userid`, `bizrule`, `data`) VALUES
('RBAC Manager', '1', NULL, 'N;');

-- --------------------------------------------------------

--
-- 表的结构 `authitem`
--

DROP TABLE IF EXISTS `authitem`;
CREATE TABLE IF NOT EXISTS `authitem` (
  `name` varchar(64) NOT NULL,
  `type` int(11) NOT NULL,
  `description` text,
  `bizrule` text,
  `data` text,
  PRIMARY KEY (`name`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

--
-- 转存表中的数据 `authitem`
--

INSERT INTO `authitem` (`name`, `type`, `description`, `bizrule`, `data`) VALUES
('Auth Assignments Manager', 2, 'Manages Role Assignments. RBAM required role.', NULL, 'N;'),
('Auth Items Manager', 2, 'Manages Auth Items. RBAM required role.', NULL, 'N;'),
('Authenticated', 2, 'Default role for users that are logged in. RBAC default role.', 'return !Yii::app()->getUser()->getIsGuest();', 'N;'),
('Guest', 2, 'Default role for users that are not logged in. RBAC default role.', 'return Yii::app()->getUser()->getIsGuest();', 'N;'),
('RBAC Manager', 2, 'Manages Auth Items and Role Assignments. RBAM required role.', NULL, 'N;');

-- --------------------------------------------------------

--
-- 表的结构 `authitemchild`
--

DROP TABLE IF EXISTS `authitemchild`;
CREATE TABLE IF NOT EXISTS `authitemchild` (
  `parent` varchar(64) NOT NULL,
  `child` varchar(64) NOT NULL,
  PRIMARY KEY (`parent`,`child`),
  KEY `child` (`child`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

--
-- 转存表中的数据 `authitemchild`
--

INSERT INTO `authitemchild` (`parent`, `child`) VALUES
('RBAC Manager', 'Auth Assignments Manager'),
('RBAC Manager', 'Auth Items Manager');

-- --------------------------------------------------------

--
-- 表的结构 `tbl_collections`
--

DROP TABLE IF EXISTS `tbl_collections`;
CREATE TABLE IF NOT EXISTS `tbl_collections` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(40) NOT NULL,
  `description` text NOT NULL,
  `user_id` int(11) NOT NULL,
  `begin` int(11) NOT NULL,
  `end` int(11) NOT NULL,
  `exercise_id` int(11) NOT NULL,
  `created` int(11) NOT NULL,
  `modified` int(11) NOT NULL,
  `status` int(11) NOT NULL DEFAULT '0',
  PRIMARY KEY (`id`)
) ENGINE=MyISAM  DEFAULT CHARSET=utf8 AUTO_INCREMENT=2 ;

--
-- 转存表中的数据 `tbl_collections`
--

INSERT INTO `tbl_collections` (`id`, `name`, `description`, `user_id`, `begin`, `end`, `exercise_id`, `created`, `modified`, `status`) VALUES
(1, '2010暑假训练(1)链表', '链表相关内容', 1, 1280389800, 1285746600, 1, 0, 1280389843, 0);

-- --------------------------------------------------------

--
-- 表的结构 `tbl_courses`
--

DROP TABLE IF EXISTS `tbl_courses`;
CREATE TABLE IF NOT EXISTS `tbl_courses` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(256) NOT NULL,
  `description` text NOT NULL,
  `location` varchar(32) NOT NULL DEFAULT '',
  `environment` varchar(256) NOT NULL DEFAULT '',
  `due_time` varchar(30) NOT NULL DEFAULT '',
  `user_id` int(11) NOT NULL,
  `begin` int(11) NOT NULL,
  `end` int(11) NOT NULL,
  `status` int(11) NOT NULL DEFAULT '0',
  `created` int(11) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=MyISAM  DEFAULT CHARSET=utf8 AUTO_INCREMENT=2 ;

--
-- 转存表中的数据 `tbl_courses`
--

INSERT INTO `tbl_courses` (`id`, `name`, `description`, `location`, `environment`, `due_time`, `user_id`, `begin`, `end`, `status`, `created`) VALUES
(1, 'ACM程序设计实验', 'ACM程序设计实验', '实C302', 'C/C++开发环境', '双周周四 - 1,2节', 2, 2009, 2009, 0, 2009);

-- --------------------------------------------------------

--
-- 表的结构 `tbl_exercises`
--

DROP TABLE IF EXISTS `tbl_exercises`;
CREATE TABLE IF NOT EXISTS `tbl_exercises` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `status` int(11) NOT NULL DEFAULT '0',
  `type_id` int(11) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=MyISAM  DEFAULT CHARSET=utf8 AUTO_INCREMENT=10 ;

--
-- 转存表中的数据 `tbl_exercises`
--

INSERT INTO `tbl_exercises` (`id`, `status`, `type_id`) VALUES
(1, 0, 2010),
(2, 0, 2010),
(3, 0, 2010),
(4, 0, 2010),
(5, 0, 2010),
(6, 0, 2010),
(7, 0, 2010),
(8, 0, 2010),
(9, 0, 2010);

-- --------------------------------------------------------

--
-- 表的结构 `tbl_exercise_problems`
--

DROP TABLE IF EXISTS `tbl_exercise_problems`;
CREATE TABLE IF NOT EXISTS `tbl_exercise_problems` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `exercise_id` int(11) NOT NULL,
  `name` varchar(100) NOT NULL DEFAULT '',
  `problem_id` int(11) NOT NULL,
  `description` text NOT NULL,
  `created` datetime NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=MyISAM  DEFAULT CHARSET=utf8 AUTO_INCREMENT=19 ;

--
-- 转存表中的数据 `tbl_exercise_problems`
--

INSERT INTO `tbl_exercise_problems` (`id`, `exercise_id`, `name`, `problem_id`, `description`, `created`) VALUES
(1, 1, '约瑟夫问题', 3, '参考http://topic.csdn.net/t/20040707/14/3153291.html', '2010-08-06 08:32:26'),
(2, 2, '二进制数的变换', 335, '', '0000-00-00 00:00:00'),
(3, 2, '按1的数目排序', 336, '', '0000-00-00 00:00:00'),
(4, 3, '第K大和第K小的数', 338, '', '2010-09-30 00:53:44'),
(5, 3, '第K大的数', 339, '', '2010-09-30 00:54:52'),
(6, 4, '链表的圈', 344, '', '2010-10-13 22:42:48'),
(7, 4, '第一个公共节点', 345, '', '2010-10-14 07:57:47'),
(8, 5, '序列和', 374, '', '2010-10-27 18:23:10'),
(9, 5, '最大不降子序列数', 375, '', '2010-10-27 19:11:52'),
(10, 5, '最大乘积组合问题', 376, '', '2010-10-28 08:01:56'),
(11, 6, '计算交点数', 377, '', '2010-11-10 22:09:12'),
(12, 6, '点在多边形内？', 378, '', '2010-11-11 07:54:17'),
(13, 7, '香甜的黄油', 379, '', '2010-11-23 23:04:49'),
(14, 7, 'Minimum Transport Cost', 380, '', '2010-11-23 23:14:09'),
(15, 7, 'dizzy cow（此题暂不做）', 381, '需要special Judge', '2010-11-23 23:38:00'),
(16, 8, '大数加法', 402, '', '2010-12-08 22:22:18'),
(17, 8, '数的阶乘', 403, '', '2010-12-09 01:51:53'),
(18, 9, '矩阵乘法', 404, '', '2010-12-23 01:02:51');

-- --------------------------------------------------------

--
-- 表的结构 `tbl_experiments`
--

DROP TABLE IF EXISTS `tbl_experiments`;
CREATE TABLE IF NOT EXISTS `tbl_experiments` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `course_id` int(11) NOT NULL,
  `sequence` varchar(20) NOT NULL,
  `name` varchar(40) NOT NULL,
  `description` text NOT NULL,
  `due_time` int(11) NOT NULL,
  `experiment_type_id` int(11) NOT NULL DEFAULT '1',
  `user_id` int(11) NOT NULL,
  `begin` int(11) NOT NULL,
  `end` int(11) NOT NULL,
  `exercise_id` int(11) NOT NULL,
  `created` int(11) NOT NULL,
  `modified` int(11) NOT NULL,
  `status` int(11) NOT NULL DEFAULT '0',
  PRIMARY KEY (`id`)
) ENGINE=MyISAM  DEFAULT CHARSET=utf8 AUTO_INCREMENT=9 ;

--
-- 转存表中的数据 `tbl_experiments`
--

INSERT INTO `tbl_experiments` (`id`, `course_id`, `sequence`, `name`, `description`, `due_time`, `experiment_type_id`, `user_id`, `begin`, `end`, `exercise_id`, `created`, `modified`, `status`) VALUES
(1, 1, '', 'ACM实验1', 'ACM实验1', 1284557400, 1, 1, 1284557400, 1284557400, 2, 0, 1284557449, 0),
(2, 1, '', 'ACM实验2', '', 1285779120, 1, 1, 1285779120, 1285779120, 3, 0, 1285779177, 0),
(3, 1, '', 'ACM实验3', '链表', 1286980140, 1, 1, 1286980140, 1286980140, 4, 0, 1286980199, 0),
(4, 1, '', '动态规划', '', 1288174920, 1, 1, 1288174920, 1288174920, 5, 0, 1288174967, 0),
(5, 1, '', '计算几何', '', 1289397120, 1, 1, 1289397120, 1289397120, 6, 0, 1289397167, 0),
(6, 1, '', '图论', '', 1290524640, 1, 1, 1290524640, 1290524640, 7, 0, 1290524671, 0),
(7, 1, '', '大数运算', '', 1291818060, 1, 1, 1291818060, 1291818060, 8, 0, 1291818128, 0),
(8, 1, '', '优化运算', '', 1293036780, 1, 1, 1293036780, 1293036780, 9, 0, 1293036840, 0);

-- --------------------------------------------------------

--
-- 表的结构 `tbl_problems`
--

DROP TABLE IF EXISTS `tbl_problems`;
CREATE TABLE IF NOT EXISTS `tbl_problems` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `user_id` int(11) NOT NULL DEFAULT '0',
  `title` varchar(512) NOT NULL DEFAULT '',
  `time_limit` int(11) NOT NULL DEFAULT '1000',
  `memory_limit` int(11) NOT NULL DEFAULT '33554432',
  `submission_no` int(10) unsigned zerofill NOT NULL,
  `accepted_no` int(10) unsigned zerofill NOT NULL,
  `description` text NOT NULL,
  `source` varchar(128) NOT NULL DEFAULT '',
  `input` text NOT NULL,
  `output` text NOT NULL,
  `input_sample` text NOT NULL,
  `output_sample` text NOT NULL,
  `hint` text NOT NULL,
  `flag` tinyint(4) NOT NULL DEFAULT '0',
  `visibility` tinyint(4) NOT NULL DEFAULT '0',
  `created` datetime DEFAULT NULL,
  `modified` datetime DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=MyISAM  DEFAULT CHARSET=utf8 AUTO_INCREMENT=405 ;

--
-- 转存表中的数据 `tbl_problems`
--

INSERT INTO `tbl_problems` (`id`, `user_id`, `title`, `time_limit`, `memory_limit`, `submission_no`, `accepted_no`, `description`, `source`, `input`, `output`, `input_sample`, `output_sample`, `hint`, `flag`, `visibility`, `created`, `modified`) VALUES
(1, 1, 'A+B Problem', 1000, 8388608, 0000000000, 0000000000, '<p>\r\n	Calculate a+b</p>\r\n', '', '<p>\r\n	Two integer a,b (0&lt;=a,b&lt;=10)</p>\r\n', '<p>\r\n	Output a+b</p>\r\n', '1 2', '3', '<p>\r\n	Q: Where are the input and the output? A: Your program shall always <font color="red">read input from stdin (Standard Input) and write output to stdout (Standard Output)</font>. For example, you can use &#39;scanf&#39; in C or &#39;cin&#39; in C++ to read from stdin, and use &#39;printf&#39; in C or &#39;cout&#39; in C++ to write to stdout. You <font color="red">shall not output any extra data</font> to standard output other than that required by the problem, otherwise you will get a &quot;Wrong Answer&quot;. User programs are not allowed to open and read from/write to files. You will get a &quot;Runtime Error&quot; or a &quot;Wrong Answer&quot; if you try to do so. Here is a sample solution for problem 1000 using C++/G++:</p>\r\n<pre>\r\n#include &lt;iostream&gt;\r\nusing namespace std;\r\nint  main()\r\n{\r\n    int a,b;\r\n    cin &gt;&gt; a &gt;&gt; b;\r\n    cout &lt;&lt; a+b &lt;&lt; endl;\r\n    return 0;\r\n}</pre>\r\n<p>\r\n	It&#39;s important that the return type of main() must be int when you use G++/GCC,or you may get compile error. Here is a sample solution for problem 1000 using C/GCC:</p>\r\n<pre>\r\n#include &lt;stdio.h&gt;\r\n\r\nint main()\r\n{\r\n    int a,b;\r\n    scanf(&quot;%d %d&quot;,&amp;a, &amp;b);\r\n    printf(&quot;%d\\n&quot;,a+b);\r\n    return 0;\r\n}</pre>\r\n<p>\r\n	Here is a sample solution for problem 1000 using PASCAL:</p>\r\n<pre>\r\nprogram p1000(Input,Output); \r\nvar \r\n  a,b:Integer; \r\nbegin \r\n   Readln(a,b); \r\n   Writeln(a+b); \r\nend.</pre>\r\n<p>\r\n	Here is a sample solution for problem 1000 using JAVA: Now java compiler is jdk 1.6, next is program for 1000</p>\r\n<pre>\r\nimport java.io.*;\r\nimport java.util.*;\r\npublic class Main\r\n{\r\n            public static void main(String args[]) throws Exception\r\n            {\r\n                    Scanner cin=new Scanner(System.in);\r\n                    int a=cin.nextInt(),b=cin.nextInt();\r\n                    System.out.println(a+b);\r\n            }\r\n}</pre>', 0, 0, '2010-02-08 00:00:00', '2010-08-19 18:08:20'),
(2, 1, 'Redraiment的遭遇', 1000, 33554432, 0000000000, 0000000000, '<p>\r\n	<font face="Times New Roman" size="3">Redraiment的老家住在工业区，日耗电量非常大。是政府的眼中钉 肉中刺，但又没办法，这里头住的可都是纳税大户呀。<br />\r\n	今年7月，又传来了不幸的消息，政府要在7、8月对该区进行拉闸限电。但迫于压力，限电制度规则不会太抠门，政府决定从7月1日停电，然后隔一天 到7月3日再停电，再隔两天到7月6日停电，一次下去，每次都比上一次晚一天。<br />\r\n	Redraiment可是软件专业的学生，怎么离得开计算机。如果停电，就&ldquo;英雄无用武之地&rdquo;了。呵呵。<br />\r\n	所以他开始盘算起自己回家的日子了，他想知道自己到家后到底要经历多少天倒霉的停电。你能帮他算一算吗？</font></p>\r\n', '', '<p>\r\n	<font face="Times New Roman" size="3">输入包括多组数据。<br />\r\n	每组数据包括一行:redraiment到家的日期。<br />\r\n	输入以0/0结束。</font></p>\r\n', '<p>\r\n	<font face="Times New Roman" size="3">对应每个输入包括一个输出。<br />\r\n	<br />\r\n	为redraiment回家后停电的天数(包括到家那天)。</font></p>\r\n', '8/31\r\n0/0', '0', '', 0, 0, '2010-05-06 13:43:40', '2010-05-16 14:14:43'),
(3, 1, 'Assistance Required', 1000, 33554432, 0000000000, 0000000000, '<div>\r\n	After the 1997/1998 Southwestern European Regional Contest (which was held in Ulm) a large contest party took place. The organization team invented a special mode of choosing those participants that were to assist with washing the dirty dishes. The contestants would line up in a queue, one behind the other. Each contestant got a number starting with 2 for the first one, 3 for the second one, 4 for the third one, and so on, consecutively.</div>\r\n<div>\r\n	The first contestant in the queue was asked for his number (which was 2). He was freed from the washing up and could party on, but every second contestant behind him had to go to the kitchen (those with numbers 4, 6, 8, etc). Then the next contestant in the remaining queue had to tell his number. He answered 3 and was freed from assisting, but every third contestant behind him was to help (those with numbers 9, 15, 21, etc). The next in the remaining queue had number 5 and was free, but every fifth contestant behind him was selected (those with numbers 19, 35, 49, etc). The next had number 7 and was free, but every seventh behind him had to assist, and so on.</div>\r\n<div>\r\n	Let us call the number of a contestant who does not need to assist with washing up a lucky number. Continuing the selection scheme, the lucky numbers are the ordered sequence 2, 3, 5, 7, 11, 13, 17, etc. Find out the lucky numbers to be prepared for the next contest party.</div>\r\n', 'University of Ulm Local Contest 2003', '<p>\r\n	The input contains several test cases. Each test case consists of an integer <i>n</i>. You may assume that <i>1&lt;=n&lt;=3000</i>. A zero follows the input for the last test case.</p>\r\n', '<p>\r\n	For each test case specified by <i>n</i> output on a single line the <i>n</i>-th lucky number.</p>\r\n', '1\r\n2\r\n10\r\n20\r\n0\r\n', '2\r\n3\r\n29\r\n83\r\n', '', 0, 0, '2010-08-06 07:47:28', '2010-10-18 23:05:00'),
(4, 1, 'The Bottom of a Graph', 1000, 33554432, 0000000000, 0000000000, '<p>\r\n	We will use the following (standard) definitions from graph theory. Let <i>V</i> be a nonempty and finite set, its elements being called vertices (or nodes). Let <i>E</i> be a subset of the Cartesian product <i>V&times;V</i>, its elements being called edges. Then <i>G=(V,E)</i> is called a directed graph.</p>\r\n<p>\r\n	Let <i>n</i> be a positive integer, and let <i>p=(e<sub>1</sub>,...,e<sub>n</sub>)</i> be a sequence of length <i>n</i> of edges <i>e<sub>i</sub>&isin;E</i> such that <i>e<sub>i</sub>=(v<sub>i</sub>,v<sub>i+1</sub>)</i> for a sequence of vertices <i>(v<sub>1</sub>,...,v<sub>n+1</sub>)</i>. Then <i>p</i> is called a path from vertex <i>v<sub>1</sub></i> to vertex <i>v<sub>n+1</sub></i> in <i>G</i> and we say that <i>v<sub>n+1</sub></i> is reachable from <i>v<sub>1</sub></i>, writing <i>(v<sub>1</sub>&rarr;v<sub>n+1</sub>)</i>.</p>\r\n<p>\r\n	Here are some new definitions. A node <i>v</i> in a graph <i>G=(V,E)</i> is called a sink, if for every node <i>w</i> in <i>G</i> that is reachable from <i>v</i>, <i>v</i> is also reachable from <i>w</i>. The bottom of a graph is the subset of all nodes that are sinks, i.e., <i>bottom(G)={v&isin;V|&forall;w&isin;V:(v&rarr;w)&rArr;(w&rarr;v)}</i>. You have to calculate the bottom of certain graphs.</p>\r\n<p>\r\n	<img alt="" src="/joj/userfiles/admin/4_bottom.gif" style="width: 159px; height: 190px;" /></p>\r\n', 'University of Ulm Local Contest 2003', '<p>\r\n	The input contains several test cases, each of which corresponds to a directed graph <i>G</i>. Each test case starts with an integer number <i>v</i>, denoting the number of vertices of <i>G=(V,E)</i>, where the vertices will be identified by the integer numbers in the set <i>V={1,...,v}</i>. You may assume that <i>1&lt;=v&lt;=5000</i>. That is followed by a non-negative integer <i>e</i> and, thereafter, <i>e</i> pairs of vertex identifiers <i>v<sub>1</sub>,w<sub>1</sub>,...,v<sub>e</sub>,w<sub>e</sub></i> with the meaning that <i>(v<sub>i</sub>,w<sub>i</sub>)&isin;E</i>. There are no edges other than specified by these pairs. The last test case is followed by a zero.</p>\r\n', '<p>\r\n	For each test case output the bottom of the specified graph on a single line. To this end, print the numbers of all nodes that are sinks in sorted order separated by a single space character. If the bottom is empty, print an empty line.</p>\r\n', '3 3\r\n1 3 2 3 3 1\r\n2 1\r\n1 2\r\n0\r\n', '1 3\r\n2\r\n', '', 0, 0, '2010-08-07 02:03:04', '2010-11-18 14:38:22'),
(5, 1, 'Fixed Partition Contest Management', 1000, 33554432, 0000000000, 0000000000, '<p>\r\n	A technique used in early programming contest strategies involved partitioning the available intellectual capacity of a team into a number of members with each member having a fixed amount of intelligence, different members potentially having different amounts. The sum of the brightness of all members equals the total intellectual capacity of the team.</p>\r\n<p>\r\n	Given a set of problems, it was the task of the team to assign the problems to different team members, so that they could be solved concurrently. This was made difficult due to the fact that the solution time of a problem might depend on the amount of intelligence available to it. Every problem has a minimum intelligence requirement, but if assigned to a brighter member its solution time might increase or decrease.</p>\r\n<p>\r\n	In this task, you have to determine optimal assignments of problems to team members. Your program is given the intellectual capacities of the team members available for the solution of problems, and for each problem a description of how its solution time depends on the amount of intelligence available to it. Your program has to find the solution schedule of the problems that minimizes the average solution time for the problems. A solution schedule is an assignment of problems to team members and times, such that no two problems use the same member at the same time, and no problem is assigned to a team member with less brightness than its minimum requirement. The solution time of the problem is the difference between the time when the problem was submitted to be solved (which is the start of the contest at time zero for all problems in this task), and the time that the problem is solved.</p>\r\n', 'University of Ulm Local Contest 2003', '<p>\r\n	The input data will contain multiple test cases. Each test case begins with a line containing a pair of integers <i>m</i> and <i>n</i>. The number <i>m</i> specifies the number of team members (<i>1 &lt;= m &lt;= 3</i>), and <i>n</i> specifies the number of problems to be solved (<i>1 &lt;= n &lt;= 10</i>).</p>\r\n<p>\r\n	The next line contains <i>m</i> positive integers giving the intelligence amounts of the <i>m</i> team members. Following this are <i>n</i> lines, describing the time-brightness tradeoffs for each of the <i>n</i> problems. Each line starts with a positive integer <i>k</i> (<i>k &lt;= 10</i>), followed by <i>k</i> pairs of positive integers <i>s<sub>1</sub>,t<sub>1</sub>,s<sub>2</sub>,t<sub>2</sub>,...,s<sub>k</sub>,t<sub>k</sub></i> that satisfy <i>s<sub>i</sub> &lt; s<sub>i+1</sub></i> for <i>1 &lt;= i &lt; k</i>. The minimum intelligence requirement of the problem is <i>s<sub>1</sub></i>, i.e. it cannot be solved by a member with less intellectual capacity than this number. If the problem is solved by a team member with brightness <i>s</i>, where <i>s<sub>i</sub> &lt;= s &lt; s<sub>i+1</sub></i> for some <i>i</i>, then its solution time will be <i>t<sub>i</sub></i>. Finally, if the problem is solved by a team member with intellectual capacity <i>s<sub>k</sub></i> or more, then its execution time will be <i>t<sub>k</sub></i>.</p>\r\n<p>\r\n	A pair of zeroes will follow the input for the last test case.</p>\r\n<p>\r\n	You may assume that each problem will be solved in exactly the time specified for the given brightness, regardless of the number of other problems being solved by other team members at the same time. No problem will have an intelligence requirement larger than that of the brightest team member.</p>\r\n', '<p>\r\n	For each test case, first display the case number (starting with <i>1</i> and increasing sequentially). Then print the minimum average solution time for the set of problems with two digits to the right of the decimal point. Follow this by the description of a solution schedule that achieves this average solution time. Display one line for each problem, in the order they were given in the input, that identifies the problem number, the member used to solve it (numbered in the order given in the input), the time when the member started to solve the problem, and the time when the problem was solved. Follow the format shown in the sample output, and print a blank line after each test case.</p>\r\n', '2 4\r\n40 60\r\n1 35 4\r\n1 20 3\r\n1 40 10\r\n1 60 7\r\n3 5\r\n10 20 30\r\n2 10 50 12 30\r\n2 10 100 20 25\r\n1 25 19\r\n1 19 41\r\n2 10 18 30 42\r\n0 0\r\n', 'Case 1\r\nAverage solution time = 7.75\r\nProblem 1 is solved by member 2 from 0 to 4\r\nProblem 2 is solved by member 1 from 0 to 3\r\nProblem 3 is solved by member 1 from 3 to 13\r\nProblem 4 is solved by member 2 from 4 to 11\r\n\r\nCase 2\r\nAverage solution time = 35.40\r\nProblem 1 is solved by member 3 from 19 to 49\r\nProblem 2 is solved by member 2 from 0 to 25\r\nProblem 3 is solved by member 3 from 0 to 19\r\nProblem 4 is solved by member 2 from 25 to 66\r\nProblem 5 is solved by member 1 from 0 to 18\r\n\r\n', '', 0, 0, '2010-08-07 02:07:49', '2010-08-07 02:07:49'),
(6, 1, 'Drink, on Ice', 1000, 33554432, 0000000000, 0000000000, '<p>\r\n	A good drink is always served on ice. That said, the amount of ice is what makes the difference. If it is too much, the drink will be well cooled, however, this is a bit of fraud as there could be less ice (and more Vodka for example). On the other hand, if there is too little ice the drink is warm which is unacceptable. You are to help the bartender, of course neither with mixing nor drinking, but with calculating the expected outcome of such mixtures.</p>\r\n<p>\r\n	To make things easier, we assume that pure water is mixed with ice in a closed system, i.e., there is no problem with the outside temperature or the warming of the bottle, etc. Therefore, after a some time has passed, the system may be regarded as balanced (there is no further change in temperature and no more melting or freezing). Your job is to calculate the final temperature of this balanced system and the amount of ice and water in this equilibrium state.</p>\r\n<p>\r\n	As you know from physics, it takes 4.19 Joule to heat one gram of water one Kelvin, whereas it takes 2.09 Joule if it is ice. We define the capacities <i>c<sub>w</sub> = 4.19 J/(g*K)</i> and <i>c<sub>i</sub> = 2.09 J/(g*K)</i>. Melting one gram of ice takes 335 Joule, where the temperature remains constant at zero. We define the constant <i>e<sub>m</sub> = 335 J/g</i>. The total thermal energy of the ice and the water before the experiment is equal to the thermal energy of the final mixture.</p>\r\n<p>\r\n	The figure below shows the energy of one gram of ice, ice-water-mixture, or water, where the temperature is measured relative to -30 degrees Celsius. The jump at 0 degrees represents the melting of ice to water. The amount of energy gained is proportional to the amount of ice already melted.</p>\r\n<p>\r\n	<img alt="" src="/joj/userfiles/admin/6_drink.gif" style="width: 253px; height: 200px;" /></p>\r\n', 'University of Ulm Local Contest 2003', '<p>\r\n	The input contains several test cases. Each test case consists of four real numbers <i>m<sub>w</sub>, m<sub>i</sub>, t<sub>w</sub>, t<sub>i</sub></i>. The mass of water <i>m<sub>w</sub></i> and the mass of ice <i>m<sub>i</sub></i> are both non-negative, given in grams, and <i>m<sub>w</sub> + m<sub>i</sub> &gt; 0</i>. The water temperature <i>t<sub>w</sub></i> and the ice temperature <i>t<sub>i</sub></i> follow, both given in degrees Celsius, and you may assume that <i>-30 &lt; t<sub>i</sub> &lt;= 0 &lt;= t<sub>w</sub> &lt; 100</i>. The last test case is followed by four zeroes.</p>\r\n', '<p>\r\n	For each test case output the amount of ice and water in grams and the final temperature of the mixture in degrees Celsius. All numbers must be rounded to one digit. Adhere to the sample output for the exact format to use.</p>\r\n', '100 20 50 -10\r\n100 22 0  0\r\n100 35 25 -10.5\r\n10  90 25 -28\r\n0 0 0 0\r\n', '0.0 g of ice and 120.0 g of water at 27.5 C\r\n22.0 g of ice and 100.0 g of water at 0.0 C\r\n6.0 g of ice and 129.0 g of water at 0.0 C\r\n100.0 g of ice and 0.0 g of water at -4.2 C\r\n', '', 0, 0, '2010-08-07 02:12:22', '2010-08-07 02:12:22'),
(7, 1, 'Edge', 1000, 33554432, 0000000000, 0000000000, '<p>\r\n	For products that are wrapped in small packings it is necessary that the sheet of paper containing the directions for use is folded until its size becomes small enough. We assume that a sheet of paper is rectangular and only folded along lines parallel to its initially shorter edge. The act of folding along such a line, however, can be performed in two directions: either the surface on the top of the sheet is brought together, or the surface on its bottom. In both cases the two parts of the rectangle that are separated by the folding line are laid together neatly and we ignore any differences in thickness of the resulting folded sheet.</p>\r\n<p>\r\n	After several such folding steps have been performed we may unfold the sheet again and take a look at its longer edge holding the sheet so that it appears as a one-dimensional curve, actually a concatenation of line segments. If we move along this curve in a fixed direction we can classify every place where the sheet was folded as either <i>type A</i> meaning a clockwise turn or <i>type V</i> meaning a counter-clockwise turn. Given such a sequence of classifications, produce a drawing of the longer edge of the sheet assuming 90 degree turns at equidistant places.</p>\r\n<p>\r\n	<img alt="" src="/joj/app/webroot/userfiles/admin/7_edge.gif" style="width: 65px; height: 128px;" /></p>\r\n', 'University of Ulm Local Contest 2003', '<p>\r\n	The input contains several test cases, each on a separate line. Each line contains a nonempty string of characters <tt>A</tt> and <tt>V</tt> describing the longer edge of the sheet. You may assume that the length of the string is less than 200. The input file terminates immediately after the last test case.</p>\r\n', '<p>\r\n	For each test case generate a PostScript drawing of the edge with commands placed on separate lines. Start every drawing at the coordinates (300,420) with the command &quot;<tt>300 420 moveto</tt>&quot;. The first turn occurs at (310,420) using the command &quot;<tt>310 420 lineto</tt>&quot;. Continue with clockwise or counter-clockwise turns according to the input string, using a sequence of &quot;<i>x</i> <i>y</i> <tt>lineto</tt>&quot; commands with the appropriate coordinates. The turning points are separated at a distance of 10 units. Do not forget the end point of the edge and finish each test case by the commands <tt>stroke</tt> and <tt>showpage</tt>.</p>\r\n<p>\r\n	You may display such drawings with the <tt>gv</tt> PostScript interpreter, optionally after a conversion using the <tt>ps2ps</tt> utility.</p>\r\n', 'V\r\nAVV\r\n', '300 420 moveto\r\n310 420 lineto\r\n310 430 lineto\r\nstroke\r\nshowpage\r\n300 420 moveto\r\n310 420 lineto\r\n310 410 lineto\r\n320 410 lineto\r\n320 420 lineto\r\nstroke\r\nshowpage\r\n', '', 0, 0, '2010-08-07 02:16:08', '2010-08-07 02:16:08'),
(8, 1, 'Fold', 1000, 33554432, 0000000000, 0000000000, '<p>\r\n	Read the statement of problem E: Edge to understand how to fold a sheet of paper and how to interpret the input. We define a &quot;stripe&quot; to be a maximally large part of the sheet that has no folding line going through. Since the turns occur at equidistant places, all stripes are congruent.</p>\r\n<p>\r\n	In this problem you are given the description of the result of performing several folding steps as in problem E: Edge, i.e., in the unfolded state. Additionally, you know that the length of the sheet in its folded state is exactly the length of 1 stripe (again, we ignore thickness).</p>\r\n<p>\r\n	Find the minimum number of folding steps necessary to generate the described sheet from an initially flat sheet of paper. Note that performing a folding step may create more than one turn in the result because parts of the sheet already overlay due to previous folding steps. When a step is carried out, however, all overlaying parts of the sheet are affected, i.e., it is not allowed to fold, say, only the top three layers.</p>\r\n<p>\r\n	Finally, note that every result can be obtained by iterating through the turns in a fixed direction and performing a folding step at each turn, thereby accumulating a 1 stripe long stack of all stripes. If <i>n</i> is the number of turns in the input description, this procedure in fact requires <i>n</i> folding steps, which is not necessarily minimal as can be observed in the sample output.</p>\r\n', 'University of Ulm Local Contest 2003', '<p>\r\n	The input contains several test cases, each on a separate line. Each line contains a nonempty string of characters <tt>A</tt> and <tt>V</tt> describing the longer edge of the sheet. You may assume that the length of the string is less than 200. The input file terminates immediately after the last test case.</p>\r\n', '<p>\r\n	For each test case print on a line the minimum number of folding steps required to produce the described sheet of paper.</p>\r\n', 'V\r\nAVV\r\nAAVAAVVVAAV\r\n', '1\r\n2\r\n4\r\n', '', 0, 0, '2010-08-07 02:18:48', '2010-08-07 02:18:48'),
(9, 1, 'Genetic Code', 1000, 33554432, 0000000000, 0000000000, '<p>\r\n	The connections between mathematics and biology are complicated. Most of the time they do not run along nice-looking links that merrily join at first glance, but they are abstract and not always easily established.</p>\r\n<p>\r\n	Lake Vostok - about 14000 square kilometers large, up to 650 meters deep, and covered by 3743 meters of ice - was recently discovered on the Antarctic continent. The lake remained under conditions of high pressure and no sunlight for several millions of years. It is believed that ordinary life has evolved to a more efficient form using a genetic code composed of only three bases (the current state of ignorance proclaims the four bases adenine, cytosine, guanine, and thymine). Until reasonable names are found, the three bases will be abbreviated as <i>N</i>, <i>O</i>, and <i>P</i>.</p>\r\n<p>\r\n	Moreover, the genome is single-stranded and directed, i.e., we may see it as a sequence over the alphabet <i>{N,O,P}</i>. Unless risking instability, it is necessary that the genome is a Thue-sequence, due to the Norwegian mathematician A. Thue (1863-1922). Define a subsegment of a sequence to be a connected subsequence, and call two subsegments adjacent if one follows immediately after the other in the sequence. A Thue-sequence is a sequence where no adjacent subsegments are equal. For example, <i>NOPNO</i> is and <i>NOPNPNO</i> is not a Thue-sequence, so that the first may be a genome whereas the second may not.</p>\r\n<p>\r\n	To be able to simulate experiments with the new genomes, you are asked to generate genomes of certain lengths.</p>\r\n', 'University of Ulm Local Contest 2003', '<p>\r\n	The input contains several test cases. Each test case consists of an integer <i>n</i>. You may assume that <i>1&lt;=n&lt;=5000</i>. The last test case is followed by a zero.</p>\r\n', '<p>\r\n	For each test case specified by <i>n</i> output on a single line any genome of length <i>n</i>. If no genome of length <i>n</i> exists, output a blank line instead.</p>\r\n', '1\r\n2\r\n10\r\n20\r\n0\r\n', 'N\r\nNO\r\nNONPNOPNPO\r\nNONPNOPNPONOPNONPNOP\r\n', '', 0, 0, '2010-08-07 02:20:42', '2010-08-07 02:20:42'),
(10, 1, 'Largest Rectangle in a Histogram', 1000, 33554432, 0000000000, 0000000000, '<p>\r\n	A histogram is a polygon composed of a sequence of rectangles aligned at a common base line. The rectangles have equal widths but may have different heights. For example, the figure on the left shows the histogram that consists of rectangles with the heights 2, 1, 4, 5, 1, 3, 3, measured in units where 1 is the width of the rectangles:</p>\r\n<p>\r\n	<img alt="" src="/joj/userfiles/admin/10histogram.gif" style="width: 506px; height: 159px;" /></p>\r\n<p>\r\n	Usually, histograms are used to represent discrete distributions, e.g., the frequencies of characters in texts. Note that the order of the rectangles, i.e., their heights, is important. Calculate the area of the largest rectangle in a histogram that is aligned at the common base line, too. The figure on the right shows the largest aligned rectangle for the depicted histogram.</p>\r\n', 'University of Ulm Local Contest 2003', '<p>\r\n	The input contains several test cases. Each test case describes a histogram and starts with an integer <i>n</i>, denoting the number of rectangles it is composed of. You may assume that <i>1&lt;=n&lt;=100000</i>. Then follow <i>n</i> integers <i>h<sub>1</sub>,...,h<sub>n</sub></i>, where <i>0&lt;=h<sub>i</sub>&lt;=1000000000</i>. These numbers denote the heights of the rectangles of the histogram in left-to-right order. The width of each rectangle is <i>1</i>. A zero follows the input for the last test case.</p>\r\n', '<p>\r\n	For each test case output on a single line the area of the largest rectangle in the specified histogram. Remember that this rectangle must be aligned at the common base line.</p>\r\n', '7 2 1 4 5 1 3 3\r\n4 1000 1000 1000 1000\r\n0\r\n', '8\r\n4000\r\n', '', 0, 0, '2010-08-07 02:26:31', '2010-08-07 03:23:05'),
(11, 1, 'FatMouse and Cheese ', 2000, 33554432, 0000000000, 0000000000, '<p align="left" class="style2">\r\n	FatMouse has stored some cheese in a city. The city can be considered as a square grid of dimension n: each grid location is labelled (p,q) where 0 &lt;= p &lt; n and 0 &lt;= q &lt; n. At each grid location Fatmouse has hid between 0 and 100 blocks of cheese in a hole. Now he&#39;s going to enjoy his favorite food.</p>\r\n<p align="left" class="style2">\r\n	FatMouse begins by standing at location (0,0). He eats up the cheese where he stands and then runs either horizontally or vertically to another location. The problem is that there is a super Cat named Top Killer sitting near his hole, so each time he can run at most k locations to get into the hole before being caught by Top Killer. What is worse -- after eating up the cheese at one location, FatMouse gets fatter. So in order to gain enough energy for his next run, he has to run to a location which have more blocks of cheese than those that were at the current hole.</p>\r\n<p align="left" class="style2">\r\n	Given n, k, and the number of blocks of cheese at each grid location, compute the maximum amount of cheese FatMouse can eat before being unable to move.</p>\r\n<p align="left" class="style2">\r\n	<img alt="" src="/joj/userfiles/admin/11_image001.jpg" style="width: 350px; height: 400px;" /></p>\r\n', 'kaifa collected', '<p align="left" class="style2">\r\n	There are several test cases. Each test case consists of</p>\r\n<ul class="style2">\r\n	<li>\r\n		a line containing two integers between 1 and 100: n and k</li>\r\n	<li>\r\n		n lines, each with n numbers: the first line contains the number of blocks of cheese at locations (0,0) (0,1) ... (0,n-1); the next line contains the number of blocks of cheese at locations (1,0), (1,1), ... (1,n-1), and so on.</li>\r\n</ul>\r\n<p align="left" class="style2">\r\n	The input ends with a pair of -1&#39;s.</p>\r\n', '<p>\r\n	For each test case output in a line the single integer giving the number of blocks of cheese collected.</p>\r\n', '3 1\r\n1 2 5\r\n10 11 6\r\n12 12 7\r\n-1 -1 ', '37\r\n', '', 0, 0, '2010-08-07 03:36:03', '2010-08-07 10:30:57'),
(12, 1, 'Conductors', 1000, 33554432, 0000000000, 0000000000, '<p>\r\n	Everyone making translations from English to Russian knows an English phrase &quot;Naked conductor runs along the bus&quot;. It has two very different meanings.</p>\r\n<p>\r\n	Every bus in the Ekaterinburg city has a special man (or woman) called conductor. When you ride the bus, you have to give money to the conductor. We know that there are more then P% conductors and less then Q% conductors. Your task is to determine a minimal possible number of Ekaterinburg citizens.</p>\r\n', 'kaifa collected', '<p align="left" class="style3">\r\n	There are several test cases ， the input data of each case are as follows:</p>\r\n<p class="style3">\r\n	Two numbers P,Q such that 0.01 &lt;= P, Q &lt;= 99.99 numbers are given with 2 digits precision. These numbers are separated by some spaces .</p>\r\n', '<p class="style3">\r\n	For each test:</p>\r\n<p class="style3">\r\n	Output the minumal number of Ekaterinburg citizens in one line</p>\r\n', '13 14.1 ', '15', '', 0, 0, '2010-08-07 04:50:35', '2010-08-07 05:19:56'),
(13, 1, 'Incomplete chess boards', 1000, 33554432, 0000000000, 0000000000, '<p>\r\n	<span class="style3">Tom gets a riddle from his teacher showing 42 chess boards from each of which two squares are removed. The teacher wants to know which boards can be completely covered by 31 dominoes. He promises ten bars of chocolate for the person who solves the problem correctly. Tom likes chocolate, but he cannot solve this problem on his own. So he asks his older brother John for help. John (who likes chocolate as well) agrees, provided that he will get half the prize.<br />\r\n	John&#39;s abilities lie more in programming than in thinking and so decides to write a program. Can you help John? Unfortunately you will not win any bars of chocolate, but it might help you win this programming contest. </span></p>\r\n<p align="left">\r\n	<br />\r\n	<span class="style3">You are given are 31 dominoes and a chess board of size 8 * 8, two distinct squares of which are removed from the board. The square in row a and column b is denoted by (a, b) with a, b in {1, . . . , 8}.<br />\r\n	A domino of size 2 &times; 1 can be placed horizontally or vertically onto the chess board, so it can cover either the two squares {(a, b), (a, b + 1)} or {(b, a), (b + 1, a)} with a in {1, . . . , 8} and b in {1, . . . , 7}. The object is to determine if the so-modified chess board can be completely covered by 31 dominoes.<br />\r\n	For example, it is possible to cover the board with 31 dominoes if the squares (8, 4) and (2, 5) are removed, as you can see in Figure 1. </span></p>\r\n<p align="left">\r\n	<span class="style3"><img alt="" src="/joj/app/webroot/userfiles/admin/13figure1.jpg" style="width: 445px; height: 350px;" /></span></p>\r\n', 'kaifa collected', '<p>\r\n	The first input line contains the number of scenarios k. Each of the following k lines contains four integers a, b, c, and d, separated by single blanks. These integers in the range {1, . . . , 8} represent the chess board from which the squares (a, b) and (c, d) are removed. You may assume that (a, b) != (c, d).</p>\r\n', '<p>\r\n	The output for every scenario begins with a line containing &quot;Scenario #i:&quot;, where i is the number of the scenario starting at 1. Then print the number 1 if the board in this scenario can be completely covered by 31 dominoes, otherwise write a 0. Terminate the output of each scenario with a blank line.</p>\r\n', '3\r\n8 4 2 5\r\n8 8 1 1\r\n4 4 7 1 ', 'Scenario #1:\r\n1\r\n \r\nScenario #2:\r\n0\r\n\r\nScenario #3:\r\n0 \r\n', '', 0, 0, '2010-08-07 04:55:53', '2010-08-07 10:29:45'),
(14, 1, 'Ubiquitous Religions ', 1000, 33554432, 0000000000, 0000000000, '<p>\r\n	There are so many different religions in the world today that it is difficult to keep track of them all. You are interested in finding out how many different religions students in your university believe in.<br />\r\n	<br />\r\n	You know that there are n students in your university (0 &lt; n &lt;= 1000). It is infeasible for you to ask every student their religious beliefs. Furthermore, many students are not comfortable expressing their beliefs. One way to avoid these problems is to ask m (0 &lt;= m &lt;= n(n-1)/2) pairs of students and ask them whether they believe in the same religion (e.g. they may know if they both attend the same church). From this data, you may not know what each person believes in, but you can get an idea of the upper bound of how many different religions can be possibly represented on campus. You may assume that each student subscribes to at most one religion.</p>\r\n', 'kaifa collected', '<p>\r\n	The input consists of a number of cases. Each case starts with a line specifying the integers n and m. The next m lines each consists of two integers i and j, specifying that students i and j believe in the same religion. The students are numbered 1 to n. The end of input is specified by a line in which n = m = 0.</p>\r\n', '<p>\r\n	For each test case, print on a single line the case number (starting with 1) followed by the maximum number of different religions that the students in the university believe in.</p>\r\n', '10 9\r\n1 2\r\n1 3\r\n1 4\r\n1 5\r\n1 6\r\n1 7\r\n1 8\r\n1 9\r\n1 10\r\n10 4\r\n2 3\r\n4 5\r\n4 8\r\n5 8\r\n0 0 ', 'Case 1: 1\r\nCase 2: 7\r\n', '', 0, 0, '2010-08-07 04:58:30', '2010-08-07 10:32:10'),
(15, 1, '(Your)((Term)((Project)))(zju1423) ', 1000, 33554432, 0000000000, 0000000000, '<p align="left" class="style2">\r\n	You have typed the report of your term project in your personal computer. There are several one line arithmetic expressions in your report. There is no redundant parentheses in the expressions (omitting a pair of redundant matching parentheses does not change the value of the expression). In your absence, your little brother inserts some redundant matching parentheses in the expressions of your report. Assume that the expressions remain syntactically correct and evaluate to their original value (the value before inserting redundant parentheses). To restore your report to its original form, you are to write a program to omit all redundant parentheses.<br />\r\n	<br />\r\n	To make life easier, consider the following simplifying assumptions:<br />\r\n	<br />\r\n	1. The input file contains a number of expressions, each in one separate line.<br />\r\n	<br />\r\n	2. Variables in the expressions are only single uppercase letters.<br />\r\n	<br />\r\n	3. Operators in the expressions are only binary &#39;+&#39; and binary &#39;-&#39;.<br />\r\n	<br />\r\n	Note that the only transformation allowed is omission of redundant parentheses, and no algebraic simplification is allowed.</p>\r\n', 'kaifa collected', '<p>\r\n	<span class="style2">The input file consists of several test cases. The first line of the file contains a single number M, which is the number of test cases (1 &lt;= M &lt;= 10). Each of the following M lines, is exactly one correct expression. There may be arbitrarily space characters in each line. The length of each line (including spaces) is at most 255 characters. </span></p>\r\n', '<p>\r\n	<span class="style2">The output for each test case is the same expression without redundant parentheses. Notice that the order of operands in an input expression and its corresponding output should be the same. Each output expression must be on a separate line. Space characters should be omitted in the output expressions. </span></p>\r\n', '3\r\n(A-B + C) - (A+(B - C)) - (C-(D- E) )\r\n((A)-( (B)))\r\nA-(B+C) ', 'A-B+C-(A+B-C)-(C-(D-E))\r\nA-B\r\nA-(B+C) ', '', 0, 0, '2010-08-07 05:00:39', '2010-08-07 05:19:25'),
(16, 1, 'Multiple', 1000, 33554432, 0000000000, 0000000000, '<p>\r\n	A program that, given a natural number N between 0 and 4999 (inclusively), and M distinct decimal digits X1,X2..XM (at least one), finds the smallest strictly positive multiple of N that has no other digits besides X1,X2..XM (if such a multiple exists).</p>\r\n', 'kaifa collected', '<p>\r\n	<br />\r\n	The input file has several data sets separated by an empty line, each data set having the following format:<br />\r\n	<br />\r\n	On the first line - the number N<br />\r\n	On the second line - the number M<br />\r\n	On the following M lines - the digits X1,X2..XM.</p>\r\n', '<p>\r\n	For each data set, the program should write to standard output on a single line the multiple, if such a multiple exists, and 0 otherwise.</p>\r\n', '22\r\n3\r\n7\r\n0\r\n1\r\n2\r\n1\r\n1 ', '110\r\n0 ', '', 0, 0, '2010-08-07 05:05:27', '2010-08-07 05:19:10'),
(17, 1, 'Arbitrage', 1000, 33554432, 0000000000, 0000000000, '<p align="left" class="style2">\r\n	Arbitrage is the use of discrepancies in currency exchange rates to transform one unit of a currency into more than one unit of the same currency. For example, suppose that 1 US Dollar buys 0.5 British pound, 1 British pound buys 10.0 French francs, and 1 French franc buys 0.21 US dollar. Then, by converting currencies, a clever trader can start with 1 US dollar and buy 0.5 * 10.0 * 0.21 = 1.05 US dollars, making a profit of 5 percent.</p>\r\n<p align="left" class="style2">\r\n	Your job is to write a program that takes a list of currency exchange rates as input and then determines whether arbitrage is possible or not.</p>\r\n', 'University of Ulm Local Contest 1996', '<p>\r\n	The input file will contain one or more test cases. Om the first line of each test case there is an integer <em>n </em> (1&lt;= <em>n </em>&lt;=30), representing the number of different currencies. The next <em>n </em> lines each contain the name of one currency. Within a name no spaces will appear. The next line contains one integer <em>m </em>, representing the length of the table to follow. The last <em>m </em> lines each contain the name <em>c i </em> of a source currency, a real number <em>r ij </em> which represents the exchange rate from <em>c i </em> to <em>c j </em> and a name <em>c j </em> of the destination currency. Exchanges which do not appear in the table are impossible.<br />\r\n	Test cases are separated from each other by a blank line. Input is terminated by a value of zero (0) for <em>n </em>.&nbsp;</p>\r\n', '<p>\r\n	For each test case, print one line telling whether arbitrage is possible or not in the format &quot;Case <em>case </em>: Yes&quot; respectively &quot;Case <em>case </em>: No&quot;.</p>\r\n', '3\r\nUSDollar\r\nBritishPound\r\nFrenchFranc\r\n3\r\nUSDollar 0.5 BritishPound\r\nBritishPound 10.0 FrenchFranc\r\nFrenchFranc 0.21 USDollar\r\n\r\n3\r\nUSDollar\r\nBritishPound\r\nFrenchFranc\r\n6\r\nUSDollar 0.5 BritishPound\r\nUSDollar 4.9 FrenchFranc\r\nBritishPound 10.0 FrenchFranc\r\nBritishPound 1.99 USDollar\r\nFrenchFranc 0.09 BritishPound\r\nFrenchFranc 0.19 USDollar\r\n \r\n0 ', 'Case 1: Yes\r\nCase 2: No \r\n', '', 0, 0, '2010-08-07 05:11:22', '2010-08-10 08:30:24'),
(18, 1, 'Discrete Function(Ural 1010) ', 1000, 33554432, 0000000000, 0000000000, '<p>\r\n	There is a discrete function. It is specified for integer arguments from 1 to N (2&lt;=N&lt;=100000). Each value of the function is longint (signed long in C++). You have to find such two points of the function for which all points between them are below than straight line connecting them and inclination of this straight line is the largest.</p>\r\n', 'kaifa collected', '<p class="style3">\r\n	The input consists of a number of cases. the input data of each case are as follows:</p>\r\n<p class="style3">\r\n	There is an N in the first line. Than N lines follow with the values of the function for the arguments 1, 2, ..., N respectively.</p>\r\n', '<p>\r\n	A pair of integers, which are abscissas of the desired points, should be written into one line of output. The first number must be less then the second one. If it is any ambiguity your program should write the pair with the smallest first number.</p>\r\n', '3\r\n2\r\n6\r\n4 ', '1 2', '', 0, 0, '2010-08-07 05:16:02', '2010-08-07 10:33:53'),
(19, 1, 'Dividing up', 1000, 33554432, 0000000000, 0000000000, '<p>\r\n	Marsha and Bill own a collection of marbles. They want to split the collection among themselves so that both receive an equal share of the marbles. This would be easy if all the marbles had the same value, because then they could just split the collection in half. But unfortunately, some of the marbles are larger, or more beautiful than others. So, Marsha and Bill start by assigning a value, a natural number between one and six, to each marble. Now they want to divide the marbles so that each of them gets the same total value.</p>\r\n<p>\r\n	Unfortunately, they realize that it might be impossible to divide the marbles in this way (even if the total value of all marbles is even). For example, if there are one marble of value 1, one of value 3 and two of value 4, then they cannot be split into sets of equal value. So, they ask you to write a program that checks whether there is a fair partition of the marbles.</p>\r\n', 'kaifa collected zero_contest', '<p>\r\n	Each line in the input describes one collection of marbles to be divided. The lines consist of six non-negative integers n1, n2, ..., n6, where ni is the number of marbles of value i. So, the example from above would be described by the input-line ``1 0 1 2 0 0&#39;&#39;. The maximum total number of marbles will be 20000.</p>\r\n<p>\r\n	The last line of the input file will be ``0 0 0 0 0 0&#39;&#39;; do not process this line.</p>\r\n', '<p>\r\n	For each colletcion, output ``Collection #k:&#39;&#39;, where k is the number of the test case, and then either ``Can be divided.&#39;&#39; or ``Can&#39;t be divided.&#39;&#39;.</p>\r\n<p>\r\n	Output a blank line after each test case.</p>\r\n', '1 0 1 2 0 0\r\n1 0 0 0 1 1\r\n0 0 0 0 0 0', 'Collection #1:\r\nCan''t be divided.\r\n\r\nCollection #2:\r\nCan be divided.\r\n', '', 0, 0, '2010-08-07 06:09:32', '2010-08-07 06:09:32'),
(20, 1, '神经网络', 1000, 33554432, 0000000000, 0000000000, '<p>\r\n	<span lang="EN-US">人工神经网络（Artificial Neural Network）是一种新兴的具有自我学习能力的计算系统，在模式识别、函数逼近及贷款风险评估等诸多领域有广泛的应用。对神经网络的研究一直是当今的热 门方向，兰兰同学在自学了一本神经网络的入门书籍后，提出了一个简化模型，他希望你能帮助他用程序检验这个神经网络模型的实用性。</span></p>\r\n<p>\r\n	<span lang="EN-US"><span style="">&nbsp;&nbsp; </span>在兰兰的模型中，神经网络就是一张有向图，图中的节点称为神经元，而且两个神经元之间至多有一条边相连，下图是一个神经元的例子：</span></p>\r\n<p>\r\n	<span lang="EN-US"><img alt="" src="/joj/userfiles/admin/19networ1.gif" style="width: 276px; height: 146px;" /></span></p>\r\n<p>\r\n	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 神经元〔编号为1）</p>\r\n<p>\r\n	&nbsp;&nbsp;&nbsp; 图中，X1&mdash;X3是信息输入渠道，Y1－Y2是信息输出渠道，C1表示神经元目前的状态，Ui是阈值，可视为神经元的一个内在参数。</p>\r\n<p>\r\n	&nbsp;&nbsp;&nbsp; 神经元按一定的顺序排列，构成整个神经网络。在兰兰的模型之中，神经网络中的神经无分为几层；称为输入层、输出层，和若干个中间层。每层神经元只向下一层的神经元</p>\r\n<p>\r\n	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <img alt="" src="/joj/userfiles/admin/19networ2.gif" style="width: 276px; height: 199px;" /></p>\r\n<p>\r\n	<span lang="EN-US">输出信息，只从上一层神经元接受信息。下图是一个简单的三层神经网络的例子。</span>兰兰规定，<span lang="EN-US">C<sub>i</sub>服从公式：（其中n是网络中所有神经元的数目）</span></p>\r\n<p>\r\n	<span lang="EN-US"><img alt="" src="/joj/app/webroot/userfiles/admin/19networ3.gif" style="width: 136px; height: 37px;" /></span></p>\r\n<p>\r\n	公式中的Wji（可能为负值）表示连接j号神经元和 i号神经元的边的权值。当 Ci大于0时，该神经元处于兴奋状态，否则就处于平静状态。当神经元处于兴奋状态时，下一秒它会向其他神经元传送信号，信号的强度为Ci。</p>\r\n<p>\r\n	&nbsp;&nbsp;&nbsp; 如此．在输入层神经元被激发之后，整个网络系统就在信息传输的推动下进行运作。现在，给定一个神经网络，及当前输入层神经元的状态（Ci），要求你的程序运算出最后网络输出层的状态。</p>', 'kaifa collected zero_contest', '<p>\r\n	输入有多组数据，每组数据格式如下，第一行是两个整数<span lang="EN-US">n（1&le;n&le;200）和p。接下来n行，每行两个整数，第i＋1行是神经元i最初状态和其阈值（Ui），非输入层的神经元开始时状态必然为0。再下面P行，每行由两个整数i，j及一个整数Wij，表示连接神经元i、j的边权值为Wij。</span></p>\r\n', '<p>\r\n	有多组输出，每组格式如下，包含若干行，每行有两个整数，分别对应一个神经元的编号，及其最后的状态，两个整数间以空格分隔。<u>仅输出最后状态非零的输出层神经元状态，并且按照编号由小到大顺序输出！</u></p>\r\n<p>\r\n	&nbsp;&nbsp;&nbsp; 若输出层的神经元最后状态均为 0，则输出 NULL。</p>\r\n', '5 6\r\n1 0\r\n1 0\r\n0 1\r\n0 1\r\n0 1\r\n1 3 1\r\n1 4 1\r\n1 5 1\r\n2 3 1\r\n2 4 1\r\n2 5 1', '3 1\r\n4 1\r\n5 1', '', 0, 0, '2010-08-07 06:24:24', '2010-08-07 06:24:24'),
(21, 1, 'Divide Apples', 1000, 33554432, 0000000000, 0000000000, '<p>\r\n	JamesBond is a clever boy. One day he thought out a good idea to divide apples into several piles and gave them out to his classmates. In order to show his fairness, he tried his best to divide all apples into several equal piles, with a pile per person.<br />\r\n	<br />\r\n	JamesBond had six apples and was thinking about how to do so. Suddenly, he broke into smiles because he had found a good way. If he had only a classmate, he could give them as a pile to his classmate. If he had two classmates, he must divide them into two piles, with three apples each pile. In the same way, he could divide these six apples into three equal piles and six equal piles. But he couldn&rsquo;t divide them into four piles, or five piles neither. Luckily, he was sure that the number of his classmates was less than the number of apples he had. Thus, he found out that he could do fairly only when he had one, two or three classmates, but not four or five. Furthermore, he found something interesting that, in the three cases, the number of classmates he had are 1, 2 and 3, whose sum is 6 exactly equal to the number of apples he had.<br />\r\n	JamesBond was thinking furthermore. If he dad N apples, whether the number N is&nbsp;right when could do fairly to divide these apples?<br />\r\n	<br />\r\n	Now he needs your help to solve this problem.</p>\r\n', 'kaifa collected zero_contest', '<p>\r\n	There are several test cases. For each case only has a single line including a positive integer N, which is not exceeded 2<sup>63</sup>.</p>\r\n', '<p>\r\n	For each input, if the number N is right, your program prints out &ldquo;Yes!&rdquo; otherwise prints out &ldquo;No!&rdquo; in a single line.</p>\r\n', '4\r\n6', 'No!\r\nYes!', '', 0, 0, '2010-08-07 06:47:11', '2010-08-07 06:47:11');
INSERT INTO `tbl_problems` (`id`, `user_id`, `title`, `time_limit`, `memory_limit`, `submission_no`, `accepted_no`, `description`, `source`, `input`, `output`, `input_sample`, `output_sample`, `hint`, `flag`, `visibility`, `created`, `modified`) VALUES
(22, 1, 'Letter', 1000, 33554432, 0000000000, 0000000000, '<p>\r\n	<font face="arial" size="3">link is strange, he like make every file in his disk in a different form. </font></p>\r\n<p>\r\n	<font face="arial" size="3">the rules are follow: </font></p>\r\n<p>\r\n	<font face="arial" size="3">1.use %n to describe the number of the blank spaces.(1&lt;=n&lt;100000) </font></p>\r\n<p>\r\n	<font face="arial" size="3">2.use #n to describe the nuber of the blank lines.(1&lt;=n&lt;100000) </font></p>\r\n<p>\r\n	<font face="arial" size="3">3.use @ to describe the finishing of a paragraphs and there still has others paragraphs. </font></p>\r\n<p>\r\n	<font face="arial" size="3">for example: </font></p>\r\n<p>\r\n	<font face="arial" size="3">link have a deflated file as: </font></p>\r\n<p>\r\n	<font face="arial" size="3">dear%1proboy:@%5i%1have%1somethings%1to%1ask%1you.%1do%1you%1feel%1tire%1after%1riciting%1vocabulary%1every%1night%1until%1two%1o&#39;clock?%1if%1so,%1i%1wish%1you%1can%1go%1to%1sleep%1earlier,%1for%1that%1will%1make%1your%1ricitment%1more%1efficience.%1if%1no%1so,%1can%1you%1think%1about%1others%1poor%1man%1in%1you%1dormitary?%1you%1make%1them%1could%1sleep%1hardly.%1so%1for%1you%1and%1for%1others,%1please%1sleep%1earlier.@%5best%1wishes@#2%6link </font></p>\r\n<p>\r\n	<font face="arial" size="3">the file it really to be is: </font></p>\r\n<pre>\r\ndear proboy:\r\n     i have somethings to ask you. do you feel tire after riciting vocabulary every night until two o&#39;clock? if so, i wish you can go to \r\nsleep earlier, for that will make your ricitment more efficience. if no so, can you think about others poor man in you dormitary? you make \r\nthem could sleep hardly. so for you and for others, please sleep earlier.\r\n     best wishes\r\n\r\n\r\n      link\r\n</pre>', 'kaifa collected zero_contest', '<p>\r\n	<font face="arial" size="3"><font size="3">there is just one case, input the deflated form. notice that case just one line,but it show n lines because of the length of the screen! the chars in the file don&#39;t contain any digits and char &#39;#&#39;,&#39;@&#39;,&#39;%&#39;! Also,no any blank spaces or lines in the deflated files. </font></font></p>\r\n<p>\r\n	<br />\r\n	tip：数据量有2M左右</p>\r\n', '<p>\r\n	<font face="arial" size="3"><font size="3">Output what the file really to be. </font></font></p>\r\n', 'dear%1proboy:@%5i%1have%1somethings%1to%1ask%1you.%1do%1you%1feel%1tire%1after%1riciting%1vocabulary%1every%1night%1until%1two%1o''clock?%1if%1so,%1i%1wish%1you%1can%1go%1to%1sleep%1earlier,%1for%1that%1will%1make%1your%1ricitment%1more%1efficience.%1if%1no%1so,%1can%1you%1think%1about%1others%1poor%1man%1in%1you%1dormitary?%1you%1make%1them%1could%1sleep%1hardly.%1so%1for%1you%1and%1for%1others,%1please%1sleep%1earlier.@%5best%1wishes@#2%6link\r\n\r\n', 'dear proboy:\r\n     i have somethings to ask you. do you feel tire after riciting vocabulary every night until two o''clock? if so, i wish you can go to \r\nsleep earlier, for that will make your ricitment more efficience. if no so, can you think about others poor man in you dormitary? you make \r\nthem could sleep hardly. so for you and for others, please sleep earlier.\r\n     best wishes\r\n\r\n\r\n      link\r\n\r\n\r\n', '', 0, 0, '2010-08-07 07:26:19', '2010-08-07 07:26:19'),
(23, 1, 'Fire Net', 1000, 33554432, 0000000000, 0000000000, '<p>\r\n	Suppose that we have a square city with straight streets. A map of a city is a square board with n rows and n columns, each representing a street or a piece of wall.</p>\r\n<p>\r\n	A blockhouse is a small castle that has four openings through which to shoot. The four openings are facing North, East, South, and West, respectively. There will be one machine gun shooting through each opening.</p>\r\n<p>\r\n	Here we assume that a bullet is so powerful that it can run across any distance and destroy a blockhouse on its way. On the other hand, a wall is so strongly built that can stop the bullets.</p>\r\n<p>\r\n	The goal is to place as <i>many</i> blockhouses in a city as possible so that no two can destroy each other. A configuration of blockhouses is legal provided that no two blockhouses are on the same horizontal row or vertical column in a map unless there is at least one wall separating them. In this problem we will consider small square cities (at most 4x4) that contain walls through which bullets cannot run through.</p>\r\n<p>\r\n	The following image shows five pictures of the same board. The first picture is the empty board, the second and third pictures show legal configurations, and the fourth and fifth pictures show illegal configurations. For this board, the maximum number of blockhouses in a legal configuration is 5; the second picture shows one way to do it, but there are several other ways.</p>\r\n<p>\r\n	<img alt="" src="/joj/userfiles/admin/0/23showimg.gif" style="width: 800px; height: 152px;" /></p>\r\n<p>\r\n	Your task is to write a program that, given a description of a map, calculates the maximum number of blockhouses that can be placed in the city in a legal configuration.</p>\r\n', 'kaifa collected zero_contest', '<p>\r\n	The input file contains one or more map descriptions, followed by a line containing the number 0 that signals the end of the file. Each map description begins with a line containing a positive integer <i>n</i> that is the size of the city; <i>n</i> will be at most 4. The next <i>n</i> lines each describe one row of the map, with a &#39;<tt>.</tt>&#39; indicating an open space and an uppercase &#39;<tt>X</tt>&#39; indicating a wall. There are no spaces in the input file.</p>\r\n', '<p>\r\n	For each test case, output one line containing the maximum number of blockhouses that can be placed in the city in a legal configuration.</p>\r\n', '4\r\n.X..\r\n....\r\nXX..\r\n....\r\n2\r\nXX\r\n.X\r\n3\r\n.X.\r\nX.X\r\n.X.\r\n3\r\n...\r\n.XX\r\n.XX\r\n4\r\n....\r\n....\r\n....\r\n....\r\n0\r\n', '5\r\n1\r\n5\r\n2\r\n4\r\n\r\n\r\n', '<br />\r\n', 0, 0, '2010-08-07 07:31:32', '2010-11-09 21:48:53'),
(24, 1, 'Immediate Decodability', 1000, 33554432, 0000000000, 0000000000, '<p>\r\n	An encoding of a set of symbols is said to be immediately decodable if no code for one symbol is the prefix of a code for another symbol. We will assume for this problem that all codes are in binary, that no two codes within a set of codes are the same, that each code has at least one bit and no more than ten bits, and that each set has at least two codes and no more than eight.</p>\r\n<p>\r\n	Examples: Assume an alphabet that has symbols {A, B, C, D}</p>\r\n<p>\r\n	The following code is immediately decodable:<br />\r\n	A:01 B:10 C:0010 D:0000</p>\r\n<p>\r\n	but this one is not:<br />\r\n	A:01 B:10 C:010 D:0000 (Note that A is a prefix of C)</p>\r\n', 'kaifa collected zero_contest', '<p>\r\n	Write a program that accepts as input a series of groups of records from input. Each record in a group contains a collection of zeroes and ones representing a binary code for a different symbol. Each group is followed by a single separator record containing a single 9; the separator records are not part of the group. Each group is independent of other groups; the codes in one group are not related to codes in any other group (that is, each group is to be processed independently).</p>\r\n', '<p>\r\n	For each group, your program should determine whether the codes in that group are immediately decodable, and should print a single output line giving the group number and stating whether the group is, or is not, immediately decodable.</p>\r\n', '01\r\n10\r\n0010\r\n0000\r\n9\r\n01\r\n10\r\n010\r\n0000\r\n9', 'Set 1 is immediately decodable\r\nSet 2 is not immediately decodable', '', 0, 0, '2010-08-07 07:37:52', '2010-08-07 07:37:52'),
(25, 1, 'To the Max', 1000, 33554432, 0000000000, 0000000000, '<p>\r\n	<span lang="EN-US" style="font-family: SimSun; font-size: 12pt;"><span class="GramE">Given</span> a two-dimensional array of positive and negative integers, a sub-rectangle is any contiguous sub-array of size 1 x 1 or greater located within the whole array. The sum of a rectangle is the sum of all the elements in that rectangle. In this problem the sub-rectangle with the largest sum is referred to as the maximal sub-rectangle.<br />\r\n	<br />\r\n	As an example, the maximal sub-rectangle of the array<span class="GramE">:</span><br />\r\n	<br />\r\n	0 -2 -7 0<br />\r\n	9 2 -6 2<br />\r\n	-4 1 -4 1<br />\r\n	-1 8 0 -2<br />\r\n	<br />\r\n	is in the lower left corner:<br />\r\n	<br />\r\n	9 2<br />\r\n	-4 1<br />\r\n	-1 8<br />\r\n	<br />\r\n	and has a sum of 15.<br />\r\n	<o:p></o:p></span></p>\r\n', 'kaifa collected 元', '<p>\r\n	<br />\r\n	<span lang="EN-US" style="font-family: SimSun; font-size: 12pt;">The input consists of an N x N array of integers. The input begins with a single positive integer N on a line by itself, indicating the size of the square two-dimensional array. This is followed by N 2 integers separated by <span class="SpellE">whitespace</span> (spaces and <span class="SpellE">newlines</span>). These are the N 2 integers of the array, presented in row-major order. That is, all numbers in the first row, left to right, then all numbers in the second row, left to right, etc. N may be as large as 100. The numbers in the array will be in the range [-127,127].</span></p>\r\n', '<p>\r\n	Output the sum of the maximal sub-rectangle.</p>\r\n', '4\r\n0 -2 -7 0 9 2 -6 2\r\n-4 1 -4 1 -1\r\n8 0 -2\r\n', '15 \r\n', '', 0, 0, '2010-08-07 07:43:47', '2010-08-07 07:43:47'),
(26, 1, 'Lotto', 1000, 33554432, 0000000000, 0000000000, '<p>\r\n	<span lang="EN-US">In a Lotto I have ever played, one has to select 6 numbers from the set {1<span class="GramE">,2</span>,...,49}. A popular strategy to play Lotto - although it doesn&#39;t increase your chance of winning - is to select a subset S containing <i>k</i> (<i>k</i>&gt;6) of these 49 numbers, and then play several games with choosing numbers only from S. For example, for <i>k</i>=8 and S = {1,2,3,5,8,13,21,34} there are 28 possible games: [1,2,3,5,8,13], [1,2,3,5,8,21], [1,2,3,5,8,34], [1,2,3,5,13,21], ... [3,5,8,13,21,34]. </span></p>\r\n<p>\r\n	<span lang="EN-US">Your job is to write a program that reads in the number <i>k</i> and the set S and then prints all possible games choosing numbers only from S.</span></p>\r\n', 'kaifa collected 元', '<p>\r\n	The input file will contain one or more test cases. Each test case consists of one line containing several integers separated from each other by spaces. The first integer on the line will be the number <em>k</em> (6 &lt; <em>k</em> &lt; 13). Then <em>k</em> integers, specifying the set S, will follow in ascending order. Input will be terminated by a value of zero (0) for <em>k</em>.</p>\r\n', '<p>\r\n	For each test case, print all possible games, each game on one line. And at last print the number of all possible games.The numbers of each game have to be sorted in ascending order and separated from each other by exactly one space. The games themselves have to be sorted lexicographically, that means sorted by the lowest number first, then by the second lowest and so on, as demonstrated in the sample output below. The test cases have to be separated from each other by exactly one blank line. Do not put a blank line after the last test case.</p>\r\n', '7 1 2 3 4 5 6 7\r\n8 1 2 3 5 8 13 21 34\r\n0\r\n', '1 2 3 4 5 6\r\n1 2 3 4 5 7\r\n1 2 3 4 6 7\r\n1 2 3 5 6 7\r\n1 2 4 5 6 7\r\n1 3 4 5 6 7\r\n2 3 4 5 6 7\r\n7\r\n \r\n1 2 3 5 8 13\r\n1 2 3 5 8 21\r\n1 2 3 5 8 34\r\n1 2 3 5 13 21\r\n1 2 3 5 13 34\r\n1 2 3 5 21 34\r\n1 2 3 8 13 21\r\n1 2 3 8 13 34\r\n1 2 3 8 21 34\r\n1 2 3 13 21 34\r\n1 2 5 8 13 21\r\n1 2 5 8 13 34\r\n1 2 5 8 21 34\r\n1 2 5 13 21 34\r\n1 2 8 13 21 34\r\n1 3 5 8 13 21\r\n1 3 5 8 13 34\r\n1 3 5 8 21 34\r\n1 3 5 13 21 34\r\n1 3 8 13 21 34\r\n1 5 8 13 21 34\r\n2 3 5 8 13 21\r\n2 3 5 8 13 34\r\n2 3 5 8 21 34\r\n2 3 5 13 21 34\r\n2 3 8 13 21 34\r\n2 5 8 13 21 34\r\n3 5 8 13 21 34\r\n28\r\n', '', 0, 0, '2010-08-07 07:50:03', '2010-08-10 09:02:28'),
(27, 1, 'FatMouse''s Speed', 1000, 33554432, 0000000000, 0000000000, '<p align="left">\r\n	<span class="SpellE"><span lang="EN-US" style="font-family: SimSun; font-size: 12pt;">FatMouse</span></span><span lang="EN-US" style="font-family: SimSun; font-size: 12pt;"> believes that the fatter a mouse is, the faster it runs. To disprove this, you want to take the data on a collection of mice and put as large a subset of this data as possible into a sequence so that the weights are increasing, but the speeds are decreasing.</span></p>\r\n<p align="left">\r\n	<span lang="EN-US" style="font-family: SimSun; font-size: 12pt;"><img alt="" src="/joj/userfiles/admin/0/26image001.jpg" style="width: 640px; height: 435px;" /></span></p>\r\n<p align="left">\r\n	&nbsp;</p>\r\n<p align="left">\r\n	<span lang="EN-US" style="font-family: SimSun; font-size: 12pt;"><o:p></o:p></span></p>\r\n', 'kaifa collected 元', '<p align="left">\r\n	Input contains data for a bunch of mice, one mouse per line, terminated by end of file.</p>\r\n<p align="left">\r\n	The data for a particular mouse will consist of a pair of integers: the first representing its size in grams and the second representing its speed in centimeters per second. Both integers are between 1 and 10000. The data in each test case will contain information for at most 1000 mice.</p>\r\n<p align="left">\r\n	Two mice may have the same weight, the same speed, or even the same weight and speed.</p>\r\n', '<p align="left">\r\n	Your program should output a number n; If these n integers are m[1], m[2],..., m[n] then it must be the case that</p>\r\n<p align="left">\r\n	&nbsp;&nbsp; W[m[1]] &lt; W[m[2]] &lt; ... &lt; W[m[n]]</p>\r\n<p align="left">\r\n	and</p>\r\n<p align="left">\r\n	&nbsp;&nbsp; S[m[1]] &gt; S[m[2]] &gt; ... &gt; S[m[n]]</p>\r\n<p align="left">\r\n	In order for the answer to be correct, n should be as large as possible.</p>\r\n<p align="left">\r\n	All inequalities are strict: weights must be strictly increasing, and speeds must be strictly decreasing. There may be many correct outputs for a given input, your program only needs to find one.</p>\r\n', '6008 1300\r\n6000 2100\r\n500 2000\r\n1000 4000\r\n1100 3000\r\n6000 2000\r\n8000 1400\r\n6000 1200\r\n2000 1900\r\n\r\n', '4\r\n', '', 0, 0, '2010-08-07 08:01:22', '2010-08-07 10:36:29'),
(43, 1, 'C语言程序设计教程（第三版）课后习题1.6', 1000, 33554432, 0000000000, 0000000000, '<pre>\r\n<span class="di">编写一个程序，输入a、b、c三个值，输出其中最大值。</span></pre>', 'freeproblemset', '<pre>\r\n<span class="di">一行数组，分别为a b c</span></pre>', '<pre>\r\n<span class="di">a b c其中最大的数</span></pre>\r\n<p>\r\n	<span class="b">&nbsp;</span></p>\r\n', '10 20 30\r\n', '30', '', 0, 0, '2010-08-07 10:46:14', '2010-08-07 10:46:14'),
(28, 1, 'u Calculate e', 1000, 33554432, 0000000000, 0000000000, '<p align="left">\r\n	A simple mathematical formula for e is</p>\r\n<p align="left">\r\n	<img alt="" src="/joj/userfiles/admin/0/27image001.gif" style="width: 72px; height: 52px;" /></p>\r\n<p align="left">\r\n	wheren is allowed to go to infinity. This can actually yield very accurate approximations of e using relatively small values of n.</p>\r\n', 'kaifa collected 元', '', '<p>\r\n	Output the approximations of e generated by the above formula for the values of n from 0 to 9. The beginning of your output should appear similar to that shown below.</p>\r\n', '', 'n e\r\n- -----------\r\n0 1\r\n1 2\r\n2 2.5\r\n3 2.666666667\r\n4 2.708333333\r\n\r\n', '', 0, 0, '2010-08-07 08:08:26', '2010-08-07 08:08:26'),
(29, 1, 'Human Gene Functions', 1000, 33554432, 0000000000, 0000000000, '<p>\r\n	It is well known that a human gene can be considered as a sequence, consisting of four nucleotides, which are simply denoted by four letters, A, C, G, and T. Biologists have been interested in identifying human genes and determining their functions, because these can be used to diagnose human diseases and to design new drugs for them.<br />\r\n	<br />\r\n	A human gene can be identified through a series of time-consuming biological experiments, often with the help of computer programs. Once a sequence of a gene is obtained, the next job is to determine its function. One of the methods for biologists to use in determining the function of a new gene sequence that they have just identified is to search a database with the new gene as a query. The database to be searched stores many gene sequences and their functions &ndash;many researchers have been submitting their genes and functions to the database and the database is freely accessible through the Internet.<br />\r\n	<br />\r\n	A database search will return a list of gene sequences from the database that are similar to the query gene. Biologists assume that sequence similarity often implies functional similarity. So, the function of the new gene might be one of the functions that the genes from the list have. To exactly determine which one is the right one another series of biological experiments will be needed.<br />\r\n	<br />\r\n	Your job is to make a program that compares two genes and determines their similarity as explained below. Your program may be used as a part of the database search if you can provide an efficient one.<br />\r\n	<br />\r\n	Given two genes AGTGATG and GTTAG, how similar are they? One of the methods to measure the similarity of two genes is called alignment. In an alignment, spaces are inserted, if necessary, in appropriate positions of the genes to make them equally long and score the resulting genes according to a scoring matrix.<br />\r\n	<br />\r\n	For example, one space is inserted into AGTGATG to result in AGTGAT-G, and three spaces are inserted into GTTAG to result in &ndash;GT--TAG. A space is denoted by a minus sign (-). The two genes are now of equal length. These two strings are aligned:<br />\r\n	<br />\r\n	AGTGAT-G<br />\r\n	-GT--TAG<br />\r\n	<br />\r\n	In this alignment, there are four matches, namely, G in the second position, T in the third, T in the sixth, and G in the eighth. Each pair of aligned characters is assigned a score according to the following scoring matrix.</p>\r\n<p>\r\n	<img alt="" src="/joj/userfiles/admin/0/29image001.gif" style="width: 229px; height: 165px;" /></p>\r\n<p align="left">\r\n	* denotes that a space-space match is not allowed. The score of the alignment above is (-3)+5+5+(-2)+(-3)+5+(-3)+5=9.<br />\r\n	<br />\r\n	Of course, many other alignments are possible. One is shown below (a different number of spaces are inserted into different positions):<br />\r\n	<br />\r\n	AGTGATG<br />\r\n	-GTTA-G<br />\r\n	<br />\r\n	This alignment gives a score of (-3)+5+5+(-2)+5+(-1) +5=14. So, this one is better than the previous one. As a matter of fact, this one is optimal since no other alignment can have a higher score. So, it is said that the similarity of the two genes is 14.</p>\r\n', 'kaifa collected 元', '<p>\r\n	The input consists of T test cases. The number of test cases ) (T is given in the first line of the input. Each test case consists of two lines: each line contains an integer, the length of a gene, followed by a gene sequence. The length of each gene sequence is at least one and does not exceed 100.</p>\r\n', '<p>\r\n	The output should print the similarity of each test case, one per line.</p>\r\n', '2 \r\n7 AGTGATG \r\n5 GTTAG \r\n7 AGCTATT \r\n9 AGCTTTAAA \r\n', '14 \r\n21\r\n', '', 0, 0, '2010-08-07 08:12:57', '2010-08-07 08:12:57'),
(30, 1, 'The Circumference of the Circle', 1000, 33554432, 0000000000, 0000000000, '<p align="left">\r\n	To calculate the circumference of a circle seems to be an easy task - provided you know its diameter. But what if you don&#39;t?</p>\r\n<p align="left">\r\n	You are given the cartesian coordinates of three non-collinear points in the plane.<br />\r\n	Your job is to calculate the circumference of the unique circle that intersects all three points.</p>\r\n', 'University of Ulm Local Contest 1996', '<p align="left">\r\n	The input file will contain one or more test cases. Each test case consists of one line containing six real numbers <em>x<sub>1</sub>,y<sub>1</sub>, x<sub>2</sub>,y<sub>2</sub>,x<sub>3</sub>,y<sub>3</sub></em>, representing the coordinates of the three points. The diameter of the circle determined by the three points will never exceed a million. Input is terminated by end of file.</p>\r\n', '<p align="left">\r\n	For each test case, print one line containing one real number telling the circumference of the circle determined by the three points. The circumference is to be printed accurately rounded to two decimals. The value of pi is approximately 3.141592653589793.</p>\r\n', '0.0 -0.5 0.5 0.0 0.0 0.5\r\n0.0 0.0 0.0 1.0 1.0 1.0\r\n5.0 5.0 5.0 7.0 4.0 6.0\r\n0.0 0.0 -1.0 7.0 7.0 7.0\r\n50.0 50.0 50.0 70.0 40.0 60.0\r\n0.0 0.0 10.0 0.0 20.0 1.0\r\n0.0 -500000.0 500000.0 0.0 0.0 500000.0\r\n', '3.14\r\n4.44\r\n6.28\r\n31.42\r\n62.83\r\n632.24\r\n3141592.65\r\n', '', 0, 0, '2010-08-07 08:16:36', '2010-08-10 09:19:46'),
(31, 1, 'Jugs     special judge', 1000, 33554432, 0000000000, 0000000000, '<p>\r\n	<span lang="EN-US">In the movie &quot;Die Hard 3&quot;, Bruce Willis and Samuel L. Jackson were confronted with the following puzzle. They were given a 3-gallon jug and a 5-gallon jug and were asked to fill the 5-gallon jug with exactly 4 gallons. This problem generalizes that puzzle. </span></p>\r\n<p>\r\n	<span lang="EN-US">You have two jugs, A and B, and an infinite supply of water. There are three types of actions that you can use: (1) you can fill a jug, (2) you can empty a jug, and (3) you can pour from one jug to the other. Pouring from one jug to the other stops when the first jug is empty or the second jug is full, whichever comes first. For example, if A has 5 gallons and B has 6 gallons and a capacity of 8, then pouring from A to B leaves B full and 3 gallons in A. </span></p>\r\n<p>\r\n	<span lang="EN-US">A problem is given by a triple (<span class="SpellE">Ca<span class="GramE">,Cb,N</span></span>), where Ca and <span class="SpellE">Cb</span> are the capacities of the jugs A and B, respectively, and N is the goal. A solution is a sequence of steps that leaves exactly N gallons in jug B. The possible steps are </span></p>\r\n<p>\r\n	<span class="GramE"><span lang="EN-US">fill</span></span><span lang="EN-US"> A<br />\r\n	fill B<br />\r\n	empty A<br />\r\n	empty B<br />\r\n	pour A B<br />\r\n	pour B A<br />\r\n	success </span></p>\r\n<p>\r\n	<span class="GramE"><span lang="EN-US">where</span></span><span lang="EN-US"> &quot;pour A B&quot; means &quot;pour the contents of jug A into jug B&quot;, and &quot;success&quot; means that the goal has been accomplished. </span></p>\r\n<p>\r\n	<span lang="EN-US">You may assume that the input you are given does have a solution. </span></p>\r\n', 'kaifa collected 元', '<p>\r\n	<span lang="EN-US">Input to your program consists of a series of input lines each defining one puzzle. Input for each puzzle is a single line of three positive integers: Ca, <span class="SpellE">Cb</span>, and N. Ca and <span class="SpellE">Cb</span> are the capacities of jugs A and B, and N is the goal. You can assume 0 &lt; Ca &lt;= <span class="SpellE">Cb</span> and N &lt;= <span class="SpellE">Cb</span> &lt;=1000 and that A and B are relatively prime to one another. </span></p>\r\n', '<p>\r\n	<span lang="EN-US">Output from your program will consist of a series of instructions from the list of the potential output lines which will result in either of the jugs containing exactly N gallons of water. The last line of output for each puzzle should be the line &quot;success&quot;. Output lines start in column 1 and there should be <span class="GramE">no empty lines nor</span> any trailing spaces. </span></p>\r\n', '3 5 4\r\n5 7 3\r\n', 'fill B\r\npour B A\r\nempty A\r\npour B A\r\nfill B\r\npour B A\r\nsuccess\r\nfill A\r\npour A B\r\nfill A\r\npour A B\r\nempty B\r\npour A B\r\nsuccess\r\n', '', 0, 0, '2010-08-07 08:19:19', '2010-08-07 08:19:19'),
(32, 1, 'Knight Moves', 1000, 33554432, 0000000000, 0000000000, '<p>\r\n	<span lang="EN-US">A friend of you is doing research on the <i>Traveling Knight Problem (TKP)</i> where you are to find the shortest closed tour of knight moves that visits each square of a given set of <i>n</i> squares on a chessboard exactly once. He thinks that the most difficult part of the problem is determining the smallest number of knight moves between two given squares and that, once you have accomplished this, finding the tour would be easy.<br />\r\n	Of course you know that it is vice versa. So you offer him to write a program that solves the &quot;difficult&quot; part. <o:p></o:p></span></p>\r\n<p>\r\n	<span lang="EN-US">Your job is to write a program that takes two squares <span class="GramE"><i>a</i> and</span> <i>b</i> as input and then determines the number of knight moves on a shortest route from <i>a</i> to <i>b</i>. <o:p></o:p></span></p>\r\n', 'University of Ulm Local Contest 1996', '<p>\r\n	The input file will contain one or more test cases. Each test case consists of one line containing two squares separated by one space. A square is a string consisting of a letter (a-h) representing the column and a digit (1-8) representing the row on the chessboard.</p>\r\n', '<p>\r\n	For each test case, print one line saying &quot;To get from <em>xx</em> to <em>yy</em> takes <em>n</em> knight moves.&quot;.</p>\r\n', 'e2 e4\r\na1 b2\r\nb2 c3\r\na1 h8\r\na1 h7\r\nh8 a1\r\nb1 c3\r\nf6 f6\r\n', 'To get from e2 to e4 takes 2 knight moves.\r\nTo get from a1 to b2 takes 4 knight moves.\r\nTo get from b2 to c3 takes 2 knight moves.\r\nTo get from a1 to h8 takes 6 knight moves.\r\nTo get from a1 to h7 takes 5 knight moves.\r\nTo get from h8 to a1 takes 6 knight moves.\r\nTo get from b1 to c3 takes 1 knight moves.\r\nTo get from f6 to f6 takes 0 knight moves.\r\n', '', 0, 0, '2010-08-07 08:21:55', '2010-08-10 09:20:15'),
(33, 1, 'Transmitters ', 1000, 33554432, 0000000000, 0000000000, '<p>\r\n	In a wireless network with multiple transmitters sending on the same frequencies, it is often a requirement that signals don&#39;t overlap, or at least that they don&#39;t conflict. One way of accomplishing this is to restrict a transmitter&#39;s coverage area. This problem uses a shielded transmitter that only broadcasts in a semicircle.<br />\r\n	<br />\r\n	A transmitter T is located somewhere on a 1,000 square meter grid. It broadcasts in a semicircular area of radius r. The transmitter may be rotated any amount, but not moved. Given N points anywhere on the grid, compute the maximum number of points that can be simultaneously reached by the transmitter&#39;s signal. Figure 1 shows the same data points with two different transmitter rotations.</p>\r\n<p>\r\n	<img alt="" src="/joj/userfiles/admin/0/32image001.gif" style="width: 560px; height: 211px;" /></p>\r\n<p>\r\n	All input coordinates are integers (0-1000). The radius is a positive real number greater than 0. Points on the boundary of a semicircle are considered within that semicircle. There are 1-150 unique points to examine per transmitter. No points are at the same location as the transmitter.<br />\r\n	&nbsp;</p>\r\n', 'kaifa collected 元', '<p align="left">\r\n	Input consists of information for one or more independent transmitter problems. Each problem begins with one line containing the (x,y) coordinates of the transmitter followed by the broadcast radius, r. The next line contains the number of points N on the grid, followed by N sets of (x,y) coordinates, one set per line. The end of the input is signalled by a line with a negative radius; the (x,y) values will be present but indeterminate. Figures 1 and 2 represent the data in the first two example data sets below, though they are on different scales. Figures 1a and 2 show transmitter rotations that result in maximal coverage.</p>\r\n', '<p>\r\n	<br />\r\n	For each transmitter, the output contains a single line with the maximum number of points that can be contained in some semicircle.</p>\r\n', '25 25 3.5\r\n7\r\n25 28\r\n23 27\r\n27 27\r\n24 23\r\n26 23\r\n24 29\r\n26 29\r\n350 200 2.0\r\n5\r\n350 202\r\n350 199\r\n350 198\r\n348 200\r\n352 200\r\n995 995 10.0\r\n4\r\n1000 1000\r\n999 998\r\n990 992\r\n1000 999\r\n100 100 -2.5\r\n', '3\r\n4\r\n4\r\n', '', 0, 0, '2010-08-07 08:26:51', '2010-08-07 08:26:51'),
(34, 1, 'All in All', 1000, 33554432, 0000000000, 0000000000, '<p>\r\n	You have devised a new encryption technique which encodes a message by inserting between its characters randomly generated strings in a clever way. Because of pending patent issues we will not discuss in detail how the strings are generated and inserted into the original message. To validate your method, however, it is necessary to write a program that checks if the message is really encoded in the final string.<br />\r\n	Given two strings s and t, you have to decide whether s is a subsequence of t, i.e. if you can remove characters from t such that the concatenation of the remaining characters is s.</p>\r\n', 'kaifa collected 2yan', '<p>\r\n	The input contains several testcases. Each is specified by two strings s, t of alphanumeric ASCII characters separated by whitespace. Input is terminated by EOF.</p>\r\n', '<p>\r\n	For each test case output, if s is a subsequence of t.</p>\r\n', 'sequence subsequence\r\nperson compression\r\nVERDI vivaVittorioEmanueleReDiItalia\r\ncaseDoesMatter CaseDoesMatter\r\n', 'Yes\r\nNo\r\nYes\r\nNo', '', 0, 0, '2010-08-07 08:35:20', '2010-08-07 08:35:20'),
(35, 1, 'A goat in a kitchen garden', 1000, 33554432, 0000000000, 0000000000, '<p>\r\n	Someone has let a goat in a square kitchen-garden and had bound it to a stake. The stake is driven into the ground in the very midst of the square. The goat is hungry as a hunter and very voracious, and eats everything that can be reached without leaving the square and tearing the roap. What area of the kitchen-garden will be ate round?</p>\r\n', 'kaifa collected 2yan', '<p>\r\n	contains lengths of the garden sides and a cord length in meters (natural numbers not exceeding 100, located in one line and separated with a space).<br />\r\n	&nbsp;</p>\r\n', '<p>\r\n	should contain an area of the kitchen-garden (in square meters to within 3 symbols after a decimal point), ate round by the goat.</p>\r\n', '10 6', '95.091', '', 0, 0, '2010-08-07 08:37:39', '2010-11-22 18:44:37'),
(36, 1, 'Ugly numbers', 1000, 33554432, 0000000000, 0000000000, '<p>\r\n	Ugly numbers are numbers whose only prime factors are 2, 3 or 5. The sequence<br />\r\n	<br />\r\n	1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, ...<br />\r\n	<br />\r\n	shows the first 11 ugly numbers. By convention, 1 is included.<br />\r\n	<br />\r\n	Write a program to find and print the 1500&#39;th ugly number.</p>\r\n', 'kaifa collected 2yan', '<p>\r\n	There is no input to this program.</p>\r\n', '<p>\r\n	Output should consist of a single line as shown below, with xxxxxx replaced by the number computed.</p>\r\n', '', 'The 1500''th ugly number is xxxxxx.', '', 0, 0, '2010-08-07 08:42:00', '2010-08-07 10:40:29'),
(37, 1, 'FatMouse'' Trade', 1000, 33554432, 0000000000, 0000000000, '<p>\r\n	FatMouse prepared M pounds of cat food, ready to trade with the cats guarding the warehouse containing his favorite food, JavaBean. The warehouse has N rooms. The i-th room contains J[i] pounds of JavaBeans and requires F[i] pounds of cat food. FatMouse does not have to trade for all the JavaBeans in the room, instead, he may get J[i]* a% pounds of JavaBeans if he pays F[i]* a% pounds of cat food. Here a is a real number. Now he is assigning this homework to you: tell him the maximum amount of JavaBeans he can obtain.</p>\r\n', 'kaifa collected 2yan', '<p>\r\n	The input consists of multiple test cases. Each test case begins with a line containing two non-negative integers M and N. Then N lines follow, each contains two non-negative integers J[i] and F[i] respectively. The last test case is followed by two -1&#39;s. All integers are not greater than 1000.</p>\r\n', '<p>\r\n	For each test case, print in a single line a real number accurate up to 3 decimal places, which is the maximum amount of JavaBeans that FatMouse can obtain.</p>\r\n', '5 3\r\n7 2\r\n4 3\r\n5 2\r\n20 3\r\n25 18\r\n24 15\r\n15 10\r\n-1 -1', '13.333\r\n31.500', '', 0, 0, '2010-08-07 08:44:45', '2010-08-07 08:44:45'),
(38, 1, 'Hello world', 1000, 33554432, 0000000000, 0000000000, '<p>\r\n	It is said that the first application wrotten in c produces &#39;Hello world!&#39;.</p>\r\n<p>\r\n	It is a very simple task to write such an application.</p>\r\n<p>\r\n	Let&#39;s go ahead.</p>\r\n', '', '<p>\r\n	none</p>\r\n', '<p>\r\n	A &#39;Hello world!&#39; in one line.</p>\r\n', '', 'Hello world\r\n', '', 0, 0, '2010-08-07 08:51:50', '2010-08-07 18:39:26'),
(94, 1, 'Just  a Cost Problem只是一个花费问题', 10000, 33554432, 0000000000, 0000000000, '<p>\r\n	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在一条河的两岸有M家公司，每家公司有N个计算中心，政府决定沿河修建若干个网点，以方便各公司共享数据，每个公司都可以有一个连接点，并将自己公司的所有计算中心直接连到自己公司的连接点上，这个费用由公司出，之后政府再将各个连接点连起来，这个费用由政府出。由于每个公司的N个计算中心位置可能各不相同，而这些计算中心又必须与自己的公司的连接点直接相连，所以每个公司都会确定一个使自己需要线路最少的连接点。之后，由于政府也想减少花费，所以政府也会确定一种方法，使得所有公司的连接点直接或间接地连起来而且花费最少。</p>\r\n<p>\r\n	&nbsp;&nbsp;&nbsp;&nbsp; 在一个二维直角坐标系上，我们可以假设河两岸分别为直线L：y=1 和直线P: y=-1,</p>\r\n<p>\r\n	&nbsp;&nbsp;&nbsp; 对于编号为奇数的公司，这个公司的连接点只能在直线L上，对于编号为偶数的公司，这个公司的连接点只能直线P上。公司确定一个连接点的位置后，将自己的所有计算中心直接与这个连接点相连。</p>\r\n<p>\r\n	当所有公司确定了连接点后，政府会将这些连接点直接或间接连起来，使得从任一个连接点总有某条路径到另一个连接点.</p>\r\n', '湖南师大数计院ACM—ICPC个人邀请赛', '<p>\r\n	输入有多组测试数据，对于每一组测试数据：</p>\r\n<p>\r\n	第一行：一个正整数M，表示公司数目，M&lt;=20000;</p>\r\n<p>\r\n	接下有M组公司的数据：</p>\r\n<p>\r\n	第一行：一个正整数N，表示公司的计算中心数目，N&lt;=6;</p>\r\n<p>\r\n	接下来N行，每行都是两个整数x 和y,表示公司各个计算中心的位置。</p>\r\n<p>\r\n	-1000000&lt;=x&lt;=1000000, -1000000&lt;=y&lt;=1000000.</p>\r\n', '<p>\r\n	对于每组测试数据，输出两行：</p>\r\n<p>\r\n	第一行：所有公司花费的最小的线路总长,只输出结果的整数部分,小数部分全部舍去。</p>\r\n<p>\r\n	第二行：政府花费的最小线路总长，只输出结果的整数部分，小数部分全部舍去。</p>\r\n', '8\r\n1\r\n328360 799448\r\n3\r\n142697 -881120\r\n-719650 -801090\r\n-525480 396220\r\n3\r\n-742072 -654462\r\n-852355 658106\r\n68761 320230\r\n1\r\n-154278 790640\r\n6\r\n-209603 539002\r\n-87586 -998520\r\n-152948 373821\r\n425320 -871174\r\n499196 -462450\r\n-989578 301809\r\n2\r\n753778 407965\r\n258352 677532\r\n2\r\n-395325 -118567\r\n620950 -158760\r\n2\r\n273464 18676\r\n217800 451588\r\n', '13356635\r\n1047765\r\n', '', 0, 0, '2010-08-07 18:43:39', '2010-08-07 19:37:17'),
(39, 1, 'QS Network', 1000, 33554432, 0000000000, 0000000000, '<p>\r\n	In the planet w-503 of galaxy cgb, there is a kind of intelligent creature named QS. QScommunicate with each other via networks. If two QS want to get connected, they need to buy two network adapters (one for each QS) and a segment of network cable. Please be advised that ONE NETWORK ADAPTER CAN ONLY BE USED IN A SINGLE CONNECTION.(ie. if a QS want to setup four connections, it needs to buy four adapters). In the procedure of communication, a QS broadcasts its message to all the QS it is connected with, the group of QS who receive the message broadcast the message to all the QS they connected with, the procedure repeats until all the QS&#39;s have received the message.</p>\r\n<p>\r\n	A sample is shown below:</p>\r\n<p>\r\n	<img alt="" src="/joj/userfiles/admin/0/38ProblemE.gif" style="width: 232px; height: 197px;" /></p>\r\n<p>\r\n	<br />\r\n	A sample QS network, and QS A want to send a message.<br />\r\n	<br />\r\n	Step 1. QS A sends message to QS B and QS C;<br />\r\n	<br />\r\n	Step 2. QS B sends message to QS A ; QS C sends message to QS A and QS D;<br />\r\n	<br />\r\n	Step 3. the procedure terminates because all the QS received the message.</p>\r\n<p>\r\n	Each QS has its favorate brand of network adapters and always buys the brand in all of its connections. Also the distance between QS vary. Given the price of each QS&#39;s favorate brand of network adapters and the price of cable between each pair of QS, your task is to write a program to determine the minimum cost to setup a QS network.</p>\r\n', 'kaifa collected 2yan', '<p>\r\n	The 1st line of the input contains an integer t which indicates the number of data sets.<br />\r\n	<br />\r\n	From the second line there are t data sets.<br />\r\n	<br />\r\n	In a single data set,the 1st line contains an interger n which indicates the number of QS.<br />\r\n	<br />\r\n	The 2nd line contains n integers, indicating the price of each QS&#39;s favorate network adapter.<br />\r\n	<br />\r\n	In the 3rd line to the n+2th line contain a matrix indicating the price of cable between ecah pair of QS.</p>\r\n<p>\r\n	Constrains:</p>\r\n<p>\r\n	all the integers in the input are non-negative and not more than 1000.</p>\r\n', '<p>\r\n	for each data set,output the minimum cost in a line. NO extra empty lines needed.</p>\r\n', '1\r\n3\r\n10 20 30\r\n0 100 200\r\n100 0 300\r\n200 300 0\r\n', '370\r\n', '', 0, 0, '2010-08-07 08:51:51', '2010-08-07 08:51:51'),
(40, 1, 'Pi', 1000, 33554432, 0000000000, 0000000000, '<p>\r\n	Professor Robert A. J. Matthews of the Applied Mathematics and Computer Science Department at the University of Aston in Birmingham, England has recently described how the positions of stars across the night skymay be used to deduce a surprisingly accurate value of &pi;. This result followed from the application of certain theorems in number theory. Here, we don&#39;t have the night sky, but can use the same theoretical basis to form an estimate for &pi;: Given any pair of whole numbers chosen from a large, random collection of numbers, the probability that the twonumbers have no common factor other than one (1) is 6/&pi;^2 For example, using the small collection of numbers: 2, 3, 4, 5, 6; there are 10 pairs that can be formed: (2,3), (2,4), etc. Six of the 10 pairs: (2,3), (2,5), (3,4), (3,5), (4,5) and (5,6) have no common factor other than one. Using the ratio of the counts as the probability we have: 6/(&pi;^2) &asymp; 6/10 &pi; &asymp; 3.162 In this problem, you&#39;ll receive a series of data sets. Each data set contains a set of pseudo-random positive integers. For each data set, find the portion of the pairs which may be formed that have nocommon factor other than one (1), and use the method illustrated above to obtain an estimate for &pi;. Report this estimate for each data set.</p>\r\n', 'kaifa collected 2yan', '<p>\r\n	The input consists of a series of data sets. The first line of each data set contains a positive integer value, N, greater than one (1) and less than 50. There is one positive integer per line for the next N lines that constitute the set for which the pairs are to be examined. These integers are each greater than 0 and less than 32768. Each integer of the input stream has its first digit as the first character on the input line. The set size designator, N, will be zero to indicate the end of data.</p>\r\n', '<p>\r\n	A line with a single real value is to be emitted for each input data set encountered. This value is the estimate &pi; for the data set. An output format like the sample below should be used. Answers must be rounded to six digits after the decimal point. For some data sets, it may be impossible to estimate a value for &pi;. This occurs when there are no pairs without common factors. In these cases, emit the single-line message: No estimate for this data set. exactly, starting with the first character, &quot;N&quot;, as the first character on the line.</p>\r\n', '5\r\n2\r\n3\r\n4\r\n5\r\n6\r\n2\r\n13\r\n39\r\n0', '3.162278\r\nNo estimate for this data set.\r\n', '', 0, 0, '2010-08-07 08:54:30', '2010-08-07 08:54:30'),
(41, 1, 'An Equation', 1000, 33554432, 0000000000, 0000000000, '<p>\r\n	There is a equation x*x*x+C*x=100, Given a positive integer C, Solve the variable x.</p>\r\n', 'kaifa collected 2yan', '<p>\r\n	The input data consists of several test cases. Each test case consists of a positive integer C.</p>\r\n', '<p>\r\n	For each case, one line of output should be produced containing one number rounded to three fractional digits giving the value of x.</p>\r\n', '99\r\n46 ', '1.000\r\n2.000', '', 0, 0, '2010-08-07 08:56:19', '2010-08-07 08:56:19'),
(42, 1, 'C语言程序设计教程（第三版）课后习题1.5', 1000, 33554432, 0000000000, 0000000000, '<p>\r\n	请参照本章例题，编写一个C程序，输出以下信息：</p>\r\n<p>\r\n	**************************</p>\r\n<p>\r\n	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Very&nbsp;&nbsp;&nbsp; Good!</p>\r\n<p>\r\n	**************************</p>\r\n<p>\r\n	数＊号可看出，Very前面9空格，Good前面&hellip;&hellip;</p>\r\n<p>\r\n	*也是输出的一部分，别光打印Very Good!</p>\r\n', 'freeproblemset', '<p>\r\n	无需输入</p>\r\n', '<p>\r\n	**************************<br />\r\n	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Very&nbsp;&nbsp;&nbsp; Good!<br />\r\n	**************************</p>\r\n', '', '**************************\r\n         Very    Good!\r\n**************************\r\n', '', 0, 0, '2010-08-07 09:44:27', '2010-08-07 10:23:58'),
(44, 1, 'C语言程序设计教程（第三版）课后习题3.7', 1000, 33554432, 0000000000, 0000000000, '<p>\r\n	要将&quot;China&quot;译成密码，译码规律是：用原来字母后面的第4个字母代替原来的字母．例如，字母&quot;A&quot;后面第4个字母是&quot;E&quot;．&quot;E&quot;代替&quot;A&quot;。因此，&quot;China&quot;应译为&quot;Glmre&quot;。请编一程序，用赋初值的方法使cl、c2、c3、c4、c5五个变量的值分别为，&rsquo;C&rsquo;、&rsquo;h&rsquo;、&rsquo;i&rsquo;、&rsquo;n&rsquo;、&rsquo;a&rsquo;，经过运算，使c1、c2、c3、c4、c5分别变为&rsquo;G&rsquo;、&rsquo;l&rsquo;、&rsquo;m&rsquo;、&rsquo;r&rsquo;、&rsquo;e&rsquo;，并输出。</p>\r\n', 'freeproblemset', '<p>\r\n	China</p>\r\n', '<p>\r\n	加密后的China</p>\r\n', 'China\r\n', 'Glmre', '', 0, 0, '2010-08-07 10:49:24', '2010-08-07 10:57:27'),
(45, 1, 'C语言程序设计教程（第三版）课后习题4.8', 1000, 33554432, 0000000000, 0000000000, '<pre>\r\n设圆半径r，圆柱高h\r\n\r\n求圆周长C1、圆面积Sa、圆球表面积Sb、圆球体积Va、圆柱体积Vb。\r\n用scanf输入数据，输出计算结果，输出时要求文字说明，取小数点后两位数字。请编程序。\r\n\r\nPI＝3.14 </pre>', 'freeproblemset', '<pre>\r\n<span class="di">两个浮点数，r和h</span></pre>', '<pre>\r\n圆周长C1、圆面积Sa、圆球表面积Sb、圆球体积Va、圆柱体积Vb。\r\n保留两位小数，每个结果后换行。</pre>', '1.5 3\r\n', 'C1=9.42\r\nSa=7.07\r\nSb=28.26\r\nVa=14.13\r\nVb=21.19\r\n', '', 0, 0, '2010-08-07 10:52:40', '2010-08-07 10:52:40'),
(46, 1, 'C语言程序设计教程（第三版）课后习题4.9', 1000, 33554432, 0000000000, 0000000000, '<pre>\r\n<span class="db" style="display: block;">输入一个华氏温度，要求输出摄氏温度。公式为  \r\nc=5(F-32)/9  \r\n输出要求有文字说明，取位2小数。</span></pre>', 'freeproblemset', '<pre>\r\n<span class="di">一个华氏温度，浮点数</span></pre>', '<pre>\r\n<span class="di">摄氏温度，浮点两位小数</span></pre>', '-40\r\n', 'c=-40.00\r\n', '', 0, 0, '2010-08-07 10:55:28', '2010-08-07 10:55:28'),
(47, 1, 'C语言程序设计教程（第三版）课后习题5.4', 1000, 33554432, 0000000000, 0000000000, '<pre>\r\n<span class="di">有三个整数a b c,由键盘输入，输出其中的最大的数。\r\n\r\nhint:\r\n</span>max ?\r\nif(a&gt;b) ?\r\n\r\nint main(){\r\n\r\n  return 0;\r\n}\r\n</pre>', 'freeproblemset', '<pre>\r\n<span class="di">一行数组，分别为a b c</span></pre>\r\n', '<pre>\r\n<span class="di">a b c其中最大的数</span></pre>\r\n', '10 20 30\r\n', '30', '', 0, 0, '2010-08-07 14:42:32', '2010-08-07 14:44:14'),
(48, 1, ' C语言程序设计教程（第三版）课后习题5.5', 1000, 33554432, 0000000000, 0000000000, '<p>\r\n	有一个函数<br />\r\n	&nbsp; &nbsp; &nbsp; &nbsp; x&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; x&lt;1<br />\r\n	y={&nbsp; 2x-1&nbsp;&nbsp; 1&lt;=x&lt;10<br />\r\n	&nbsp;&nbsp;&nbsp;&nbsp; |3x-11&nbsp; x&gt;=10</p>\r\n<p>\r\n	写一段程序，输入x，输出y</p>\r\n<p>\r\n	&nbsp;</p>\r\n<p>\r\n	hint:</p>\r\n<pre>\r\n<span class="di">使用函数</span></pre>', 'freeproblemset', '<p>\r\n	一个数x</p>\r\n', '<p>\r\n	一个数y</p>\r\n', '14\r\n', '31\r\n', '', 0, 0, '2010-08-07 14:47:30', '2010-08-07 14:47:30'),
(49, 1, 'C语言程序设计教程（第三版）课后习题5.6', 1000, 33554432, 0000000000, 0000000000, '<pre>\r\n<span class="db" style="display: block;">给出一百分制成绩，要求输出成绩等级&lsquo;A&rsquo;、&lsquo;B&rsquo;、&lsquo;C&rsquo;、&lsquo;D&rsquo;、&lsquo;E&rsquo;。\r\n90分以上为A\r\n80-89分为B\r\n70-79分为C\r\n60-69分为D\r\n60分以下为E\r\n</span></pre>', 'freeproblemset', '<pre>\r\n<span class="di">一个整数0－100以内</span></pre>', '<pre>\r\n<span class="di">一个字符，表示成绩等级</span></pre>', '90\r\n', 'A', '', 0, 0, '2010-08-07 14:49:02', '2010-08-07 14:49:02'),
(50, 1, 'C语言程序设计教程（第三版）课后习题5.7', 1000, 33554432, 0000000000, 0000000000, '<pre>\r\n给出一个不多于5位的整数，要求\r\n1、求出它是几位数\r\n2、分别输出每一位数字\r\n3、按逆序输出各位数字，例如原数为321,应输出123\r\n\r\nhint:\r\n<span class="di">哈姆雷特：数字还是字符？这是一个问题！</span>\r\n</pre>', 'freeproblemset', '<pre>\r\n<span class="di">一个不大于5位的数字</span></pre>\r\n', '<pre>\r\n三行\r\n第一行 位数\r\n第二行 用空格分开的每个数字，注意最后一个数字后没有空格\r\n第三行 按逆序输出这个数</pre>\r\n', '12345\r\n', '5\r\n1 2 3 4 5\r\n54321\r\n', '', 0, 0, '2010-08-07 14:54:36', '2010-08-07 14:55:47'),
(51, 1, 'C语言程序设计教程（第三版）课后习题5.8', 1000, 33554432, 0000000000, 0000000000, '<p>\r\n	企业发放的奖金根据利润提成。利润低于或等于100000元的，奖金可提10%;<br />\r\n	利润高于100000元，低于200000元（100000&lt;I&le;200000）时，低于100000元的部分按10％提成，高于100000元的部分，可提成 7.5%;<br />\r\n	200000&lt;I&le;400000时，低于200000元部分仍按上述办法提成，（下同），高于200000元的部分按5％提成；<br />\r\n	400000&lt;I&le;600000元时，高于400000元的部分按3％提成；600000&lt;I&le;1000000时，高于600000元的部分按1.5%提成；<br />\r\n	I&gt;1000000时，超过1000000元的部分按1%提成。从键盘输入当月利润I,求应发奖金总数。</p>\r\n<p>\r\n	&nbsp;</p>\r\n<p>\r\n	hint:</p>\r\n<pre>\r\n<span class="di">用Switch要比用if的看起来更清晰。</span></pre>', 'freeproblemset', '<p>\r\n	一个整数，当月利润。</p>\r\n', '<p>\r\n	一个整数，奖金。</p>\r\n', '900', '90', '', 0, 0, '2010-08-07 14:57:36', '2010-08-07 14:57:36'),
(52, 1, 'C语言程序设计教程（第三版）课后习题6.1', 1000, 33554432, 0000000000, 0000000000, '<pre>\r\n<span class="di" id="clean">输入两个正整数m和n，求其最大公约数和最小公倍数。</span></pre>', 'freeproblemset', '<pre>\r\n<span class="di" id="clean">两个整数</span></pre>', '<pre>\r\n<span class="di" id="clean">最大公约数，最小公倍数</span></pre>', '5 7\r\n', '1 35', '', 0, 0, '2010-08-07 15:07:48', '2010-08-07 15:07:48'),
(53, 1, 'C语言程序设计教程（第三版）课后习题6.2', 1000, 33554432, 0000000000, 0000000000, '<pre>\r\n<span class="di" id="clean">输入一行字符，分别统计出其中英文字母、空格、数字和其他字符的个数。</span></pre>', 'freeproblemset', '<pre>\r\n<span class="di" id="clean">一行字符</span></pre>', '<pre>\r\n<span class="di" id="clean">统计值</span></pre>', 'aklsjflj123 sadf918u324 asdf91u32oasdf/.'';123', '23 16 2 4\r\n', '', 0, 0, '2010-08-07 15:10:37', '2010-08-07 15:10:37');
INSERT INTO `tbl_problems` (`id`, `user_id`, `title`, `time_limit`, `memory_limit`, `submission_no`, `accepted_no`, `description`, `source`, `input`, `output`, `input_sample`, `output_sample`, `hint`, `flag`, `visibility`, `created`, `modified`) VALUES
(54, 1, 'C语言程序设计教程（第三版）课后习题6.3', 1000, 33554432, 0000000000, 0000000000, '<pre>\r\n<span class="di" id="clean">求Sn=a+aa+aaa+&hellip;+aa&hellip;aaa（有n个a）之值，其中a是一个数字。\r\n例如：2+22+222+2222+22222（n=5），n由键盘输入。</span></pre>', 'freeproblemset', '<pre>\r\n<span class="di" id="clean">a</span></pre>', '<pre>\r\n<span class="di" id="clean">和</span></pre>', '5', '24690', '', 0, 0, '2010-08-07 15:12:44', '2010-08-07 15:12:44'),
(55, 1, 'C语言程序设计教程（第三版）课后习题6.4', 1000, 33554432, 0000000000, 0000000000, '<pre>\r\n<span class="di" id="clean">求Sn=1!+2!+3!+4!+5!+&hellip;+n!之值，其中n是一个数字。\r\n\r\nhint:\r\n</span>数据可能很大，你知道long long类型吗？\r\n</pre>', 'freeproblemset', '<pre>\r\n<span class="di" id="clean">n</span></pre>\r\n', '<pre>\r\n<span class="di" id="clean">和</span></pre>\r\n', '5\r\n', '153\r\n', '', 0, 0, '2010-08-07 15:14:25', '2010-08-07 15:16:55'),
(56, 1, 'C语言程序设计教程（第三版）课后习题6.5', 1000, 33554432, 0000000000, 0000000000, '<pre>\r\n<span class="di" id="clean">求以下三数的和,保留2位小数\r\n1~a之和\r\n1~b的平方和\r\n1~c的倒数和</span></pre>\r\n<p>\r\n	<span class="b">&nbsp;</span></p>\r\n', 'freeproblemset', '<pre>\r\n<span class="di" id="clean">a b c</span></pre>', '<pre>\r\n<span class="di" id="clean">1+2+...+a + 1^2+2^2+...+b^2 + 1/1+1/2+...+1/c</span></pre>', '100 50 10', '47977.93', '', 0, 0, '2010-08-07 15:19:17', '2010-08-07 15:19:17'),
(57, 1, 'C语言程序设计教程（第三版）课后习题6.6', 1000, 33554432, 0000000000, 0000000000, '<pre>\r\n<span class="di" id="clean">打印出所有&quot;水仙花数&quot;，所谓&quot;水仙花数&quot;是指一个三位数，其各位数字立方和等于该本身。\r\n例如：153是一个水仙花数，因为153=1^3+5^3+3^3。</span></pre>', 'freeproblemset', '', '<pre>\r\n<span class="di" id="clean">所有的水仙花数，从小的开始。\r\n每行一个</span></pre>', '', '153\r\n???\r\n???\r\n???\r\n', '', 0, 0, '2010-08-07 15:21:06', '2010-08-07 15:21:06'),
(58, 1, ' C语言程序设计教程（第三版）课后习题6.7   ', 1000, 33554432, 0000000000, 0000000000, '<pre>\r\n<span class="di" id="clean">一个数如果恰好等于它的因子之和，这个数就称为&quot;完数&quot;。\r\n例如，6的因子为1、2、3，而6=1+2+3，因此6是&quot;完数&quot;。\r\n编程序找出N之内的所有完数，并按下面格式输出其因子： </span></pre>', 'freeproblemset', '<pre>\r\n<span class="di" id="clean">N</span></pre>', '<pre>\r\n<span class="di" id="clean">? its factors are ? ? ?</span></pre>', '1000', '6 its fastors are 1 2 3 \r\n28 its fastors are 1 2 4 7 14 \r\n496 its fastors are 1 2 4 8 16 31 62 124 248 \r\n', '', 0, 0, '2010-08-07 15:25:28', '2010-08-07 15:25:28'),
(59, 1, 'C语言程序设计教程（第三版）课后习题6.8', 1000, 33554432, 0000000000, 0000000000, '<pre>\r\n<span class="di" id="clean">有一分数序列：  \r\n2/1 3/2 5/3 8/5 13/8 21/13......\r\n求出这个数列的前N项之和，保留两位小数。</span></pre>', 'freeproblemset', '<pre>\r\n<span class="di" id="clean">N</span></pre>', '<pre>\r\n<span class="di" id="clean">数列前N项和</span></pre>', '10\r\n', '16.48', '', 0, 0, '2010-08-07 15:27:03', '2010-08-07 15:27:03'),
(60, 1, 'C语言程序设计教程（第三版）课后习题6.9', 1000, 33554432, 0000000000, 0000000000, '<pre>\r\n<span class="di" id="clean">一球从M米高度自由下落，每次落地后返回原高度的一半，再落下。\r\n它在第N次落地时反弹多高？共经过多少米？\r\n保留两位小数</span></pre>', 'freeproblemset', '<pre>\r\n<span class="di" id="clean">M N</span></pre>', '<pre>\r\n<span class="di" id="clean">它在第N次落地时反弹多高？共经过多少米？\r\n保留两位小数，空格隔开，放在一行</span></pre>', '1000 5\r\n', '31.25 2875.00', '', 0, 0, '2010-08-07 15:28:53', '2010-08-07 15:28:53'),
(61, 1, ' C语言程序设计教程（第三版）课后习题6.10', 1000, 33554432, 0000000000, 0000000000, '<pre>\r\n<span class="di" id="clean">猴子吃桃问题。猴子第一天摘下若干个桃子，当即吃了一半，还不过瘾，又多吃了一个。\r\n第二天早上又将剩下的桃子吃掉一半，又多吃一个。以后每天早上都吃了前一天剩下的一半零一个。\r\n到第N天早上想再吃时，见只剩下一个桃子了。求第一天共摘多少桃子。</span></pre>', 'freeproblemset', '<pre>\r\n<span class="di" id="clean">N</span></pre>', '<pre>\r\n<span class="di" id="clean">桃子总数</span></pre>', '10', '1534', '', 0, 0, '2010-08-07 15:33:38', '2010-08-07 15:33:38'),
(62, 1, 'C语言程序设计教程（第三版）课后习题6.11   ', 1000, 33554432, 0000000000, 0000000000, '<pre>\r\n<span class="di" id="clean">用迭代法求平方根的迭代公式为：  \r\nX[n+1]=1/2(X[n]+a/X[n])\r\n要求前后两次求出的得差的绝对值少于0.00001。\r\n输出保留3位小数</span></pre>', 'freeproblemset', '<pre>\r\n<span class="di" id="clean">X</span></pre>', '<pre>\r\n<span class="di" id="clean">X的平方根</span></pre>', '4', '2.000', '', 0, 0, '2010-08-07 15:35:10', '2010-08-07 15:35:10'),
(63, 1, 'C语言程序设计教程（第三版）课后习题7.1  ', 1000, 33554432, 0000000000, 0000000000, '<pre>\r\n<span class="di" id="clean">用筛法求之N内的素数。</span></pre>', 'freeproblemset', '<pre>\r\n<span class="di" id="clean">N</span></pre>', '<pre>\r\n<span class="di" id="clean">0～N的素数</span></pre>', '100\r\n  ', '2\r\n3\r\n5\r\n7\r\n11\r\n13\r\n17\r\n19\r\n23\r\n29\r\n31\r\n37\r\n41\r\n43\r\n47\r\n53\r\n59\r\n61\r\n67\r\n71\r\n73\r\n79\r\n83\r\n89\r\n97\r\n', '', 0, 0, '2010-08-07 15:37:46', '2010-08-07 15:37:46'),
(64, 1, 'C语言程序设计教程（第三版）课后习题7.2  ', 1000, 33554432, 0000000000, 0000000000, '<pre>\r\n<span class="di" id="clean">用选择法对10个整数从小到大排序。</span></pre>', 'freeproblemset', '<pre>\r\n<span class="di" id="clean">10个整数</span></pre>', '<pre>\r\n<span class="di" id="clean">排序好的10个整数</span></pre>', '4 85  3 234 45 345 345 122 30 12\r\n', '3\r\n4\r\n12\r\n30\r\n45\r\n85\r\n122\r\n234\r\n345\r\n345\r\n ', '', 0, 0, '2010-08-07 15:40:26', '2010-08-07 15:40:26'),
(65, 1, 'C语言程序设计教程（第三版）课后习题7.3', 1000, 33554432, 0000000000, 0000000000, '<pre>\r\n<span class="di" id="clean">求一个3&times;3矩阵对角线元素之和。</span></pre>', 'freeproblemset', '<pre>\r\n<span class="di" id="clean">矩阵</span></pre>', '<pre>\r\n<span class="di" id="clean">主对角线 副对角线 元素和</span></pre>', '1 2 3\r\n1 1 1\r\n3 2 1\r\n', '3 7\r\n', '', 0, 0, '2010-08-07 15:42:19', '2010-08-07 15:42:19'),
(66, 1, 'C语言程序设计教程（第三版）课后习题7.4', 1000, 33554432, 0000000000, 0000000000, '<pre>\r\n<span class="di" id="clean">已有一个已排好的9个元素的数组，今输入一个数要求按原来排序的规律将它插入数组中。</span></pre>', 'freeproblemset', '<pre>\r\n<span class="di" id="clean">第一行，原始数列。\r\n第二行，需要插入的数字。</span></pre>', '<pre>\r\n<span class="di" id="clean">排序后的数列</span></pre>', ' 1 7 8 17 23 24 59 62 101\r\n50\r\n ', '1\r\n7\r\n8\r\n17\r\n23\r\n24\r\n50\r\n59\r\n62\r\n101\r\n', '', 0, 0, '2010-08-07 15:44:12', '2010-08-07 15:44:12'),
(67, 1, 'C语言程序设计教程（第三版）课后习题7.5', 1000, 33554432, 0000000000, 0000000000, '<pre>\r\n<span class="di" id="clean">输入10个数字，然后逆序输出。</span></pre>', 'freeproblemset', '<pre>\r\n<span class="di" id="clean">十个整数</span></pre>', '<pre>\r\n<span class="di" id="clean">逆序输出，空格分开</span></pre>\r\n<p>\r\n	<span class="b">&nbsp;</span></p>\r\n', '1 2 3 4 5 6 7 8 9 0\r\n', ' 0 9 8 7 6 5 4 3 2 1', '', 0, 0, '2010-08-07 15:45:49', '2010-08-07 15:45:49'),
(68, 1, 'C语言程序设计教程（第三版）课后习题8.1  ', 1000, 33554432, 0000000000, 0000000000, '<pre>\r\n<span class="di" id="clean">写两个函数，分别求两个整数的最大公约数和最小公倍数，用主函数调用这两个函数，并输出结果两个整数由键盘输入。</span></pre>', 'freeproblemset', '<pre>\r\n<span class="di" id="clean">两个数</span></pre>', '<pre>\r\n<span class="di" id="clean">最大公约数 最小公倍数</span></pre>', '6 15\r\n', '3 30\r\n', '', 0, 0, '2010-08-07 15:49:19', '2010-08-07 15:49:19'),
(69, 1, 'C语言程序设计教程（第三版）课后习题8.2', 1000, 33554432, 0000000000, 0000000000, '<pre>\r\n<span class="di" id="clean">求方程 的根，用三个函数分别求当b^2-4ac大于0、等于0、和小于0时的根，并输出结果。从主函数输入a、b、c的值。</span></pre>', 'freeproblemset', '<pre>\r\n<span class="di" id="clean">a b c</span></pre>', '<pre>\r\n<span class="di" id="clean">x1=? x2=?</span></pre>\r\n<p>\r\n	<span class="b">&nbsp;</span></p>\r\n', '4 1 1\r\n', 'x1=-0.125+0.484i x2=-0.125-0.484i', '', 0, 0, '2010-08-07 15:51:45', '2010-08-07 15:51:45'),
(70, 1, ' C语言程序设计教程（第三版）课后习题8.3', 1000, 33554432, 0000000000, 0000000000, '<pre>\r\n<span class="di" id="clean">写一个判断素数的函数，在主函数输入一个整数，输出是否是素数的消息。</span></pre>', 'freeproblemset', '<pre>\r\n<span class="di" id="clean">一个数</span></pre>', '<pre>\r\n<span class="di" id="clean">如果是素数输出prime\r\n如果不是输出not prime</span></pre>\r\n<p>\r\n	<span class="b">&nbsp;</span> </p>\r\n', '97\r\n  ', 'prime', '', 0, 0, '2010-08-07 15:53:51', '2010-08-07 15:53:51'),
(71, 1, 'C语言程序设计教程（第三版）课后习题8.4', 1000, 33554432, 0000000000, 0000000000, '<pre>\r\n<span class="di" id="clean">写一个函数，使给定的一个二维数组（３&times;３）转置，即行列互换。</span></pre>', 'freeproblemset', '<pre>\r\n<span class="di" id="clean">一个3x3的矩阵</span></pre>', '<pre>\r\n<span class="di" id="clean">转置后的矩阵</span></pre>', '1 2 3\r\n4 5 6\r\n7 8 9\r\n', '1 4 7 \r\n2 5 8 \r\n3 6 9 \r\n', '', 0, 0, '2010-08-07 15:57:31', '2010-08-07 15:57:31'),
(72, 1, 'C语言程序设计教程（第三版）课后习题8.5', 1000, 33554432, 0000000000, 0000000000, '<pre>\r\n<span class="di" id="clean">写一函数，使输入的一个字符串按反序存放，在主函数中输入输出反序后的字符串。</span></pre>', 'freeproblemset', '<pre>\r\n<span class="di" id="clean">一行字符</span></pre>', '<pre>\r\n<span class="di" id="clean">逆序后的字符串</span></pre>', '123456abcdef\r\n', 'fedcba654321\r\n', '', 0, 0, '2010-08-07 15:59:41', '2010-08-07 15:59:41'),
(73, 1, 'C语言程序设计教程（第三版）课后习题8.6', 1000, 33554432, 0000000000, 0000000000, '<pre>\r\n<span class="di" id="clean">写一函数，将两个字符串连接</span></pre>', 'freeproblemset', '<pre>\r\n<span class="di" id="clean">两行字符串</span></pre>', '<pre>\r\n<span class="di" id="clean">链接后的字符串</span></pre>', '123\r\nabc\r\n', '123abc\r\n', '', 0, 0, '2010-08-07 16:01:13', '2010-08-07 16:01:13'),
(74, 1, 'C语言程序设计教程（第三版）课后习题8.7', 1000, 33554432, 0000000000, 0000000000, '<pre>\r\n<span class="di" id="clean">写一函数，将两个字符串中的元音字母复制到另一个字符串，然后输出。</span></pre>', 'freeproblemset', '<pre>\r\n<span class="di" id="clean">一行字符串</span></pre>', '<pre>\r\n<span class="di" id="clean">顺序输出其中的元音字母（aeiuo）</span></pre>', 'abcde\r\n  ', 'ae\r\n', '', 0, 0, '2010-08-07 16:03:39', '2010-08-07 16:03:39'),
(75, 1, 'C语言程序设计教程（第三版）课后习题8.8', 1000, 33554432, 0000000000, 0000000000, '<pre>\r\n<span class="di" id="clean">写一函数，输入一个四位数字，要求输出这四个数字字符，但每两个数字间空格。如输入1990，应输出&quot;1 9 9 0&quot;。</span></pre>\r\n<p>\r\n	<span class="b">&nbsp;</span></p>\r\n', 'freeproblemset', '<pre>\r\n<span class="di" id="clean">一个四位数</span></pre>\r\n', '<pre>\r\n<span class="di" id="clean">增加空格输出</span></pre>\r\n', '1990\r\n  ', '1 9 9 0', '', 0, 0, '2010-08-07 16:05:15', '2010-08-07 16:07:10'),
(76, 1, 'C语言程序设计教程（第三版）课后习题8.9', 1000, 33554432, 0000000000, 0000000000, '<pre>\r\n<span class="di" id="clean">编写一函数，由实参传来一个字符串，统计此字符串中字母、数字、空格和其它字符的个数，在主函数中输入字符串以及输出上述结果。\r\n\r\n只要结果，别输出什么提示信息。</span></pre>', 'freeproblemset', '<pre>\r\n<span class="di" id="clean">一行字符串</span></pre>', '<pre>\r\n<span class="di" id="clean">统计数据，4个数字，空格分开。</span></pre>', '!@#$%^QWERT    1234567\r\n  ', '5 7 4 6\r\n', '', 0, 0, '2010-08-07 16:08:18', '2010-08-07 16:08:18'),
(77, 1, 'C语言程序设计教程（第三版）课后习题9.1', 1000, 33554432, 0000000000, 0000000000, '<pre>\r\n<span class="di" id="clean">定义一个带参的宏，使两个参数的值互换，并写出程序，输入两个数作为使用宏时的实参。输出已交换后的两个值。</span></pre>', 'freeproblemset', '<pre>\r\n<span class="di" id="clean">两个数，空格隔开</span></pre>', '<pre>\r\n<span class="di" id="clean">交换后的两个数，空格隔开</span></pre>', '1 2', '2 1', '', 0, 0, '2010-08-07 16:17:09', '2010-08-07 16:17:09'),
(78, 1, 'C语言程序设计教程（第三版）课后习题9.2', 1000, 33554432, 0000000000, 0000000000, '<pre>\r\n<span class="di" id="clean">输入两个整数，求他们相除的余数。用带参的宏来实现，编程序。</span></pre>', 'freeproblemset', '<pre>\r\n<span class="di" id="clean">a b两个数</span></pre>', '<pre>\r\n<span class="di" id="clean">a/b的余数</span></pre>', '3 2\r\n', '1', '', 0, 0, '2010-08-07 16:18:26', '2010-08-07 16:18:26'),
(79, 1, 'C语言程序设计教程（第三版）课后习题9.3  ', 1000, 33554432, 0000000000, 0000000000, '<pre>\r\n<span class="di" id="clean">三角形面积=SQRT(S*(S-a)*(S-b)*(S-c))\r\n其中S=(a+b+c)/2，a、b、c为三角形的三边。\r\n定义两个带参的宏，一个用来求area，\r\n另一个宏用来求S。\r\n\r\n写程序，在程序中用带实参的宏名来求面积area。</span></pre>', 'freeproblemset', '<pre>\r\n<span class="di" id="clean">a b c三角形的三条边,可以是小数。</span></pre>', '<pre>\r\n<span class="di" id="clean">三角形面积，保留3位小数</span></pre>', '3 4 5\r\n', '6.000\r\n', '', 0, 0, '2010-08-07 16:20:20', '2010-08-07 16:20:20'),
(80, 1, ' C语言程序设计教程（第三版）课后习题9.4', 1000, 33554432, 0000000000, 0000000000, '<pre>\r\n<span class="di" id="clean">给年份year，定义一个宏，以判别该年份是否闰年。提示：宏名可以定义为LEAP_YEAR，形参为y，既定义宏的形式为  \r\n#define LEAP_YEAR(y) （读者设计的字符串）</span></pre>', 'freeproblemset', '<pre>\r\n<span class="di" id="clean">一个年份</span></pre>', '<pre>\r\n<span class="di" id="clean">根据是否闰年输出，是输出&quot;L&quot;,否输出&quot;N&quot;</span></pre>', '2000\r\n  ', 'L', '', 0, 0, '2010-08-07 16:22:01', '2010-08-07 16:22:01'),
(81, 1, 'C语言程序设计教程（第三版）课后习题9.6', 1000, 33554432, 0000000000, 0000000000, '<pre>\r\n<span class="di" id="clean">请设计输出实数的格式，包括：⑴一行输出一个实数；⑵一行内输出两个实数；⑶一行内输出三个实数。实数用&quot;6.2f&quot;格式输出。</span></pre>', 'freeproblemset', '<pre>\r\n<span class="di" id="clean">一个实数，float范围</span></pre>', '<pre>\r\n<span class="di" id="clean">输出3行，第一行打印一遍输入的数，第二行打印两遍，第三行打印三遍。\r\n第二行和第三行，用空格分隔同一行的数字。\r\n实数用&quot;6.2f&quot;格式输出。</span></pre>', '0.618\r\n', '  0.62\r\n  0.62   0.62\r\n  0.62   0.62   0.62\r\n', '', 0, 0, '2010-08-07 16:24:47', '2010-08-07 16:24:47'),
(82, 1, 'C语言程序设计教程（第三版）课后习题9.8', 1000, 33554432, 0000000000, 0000000000, '<pre>\r\n<span class="di" id="clean">分别用函数和带参的宏，从三个数中找出最大的数。</span></pre>', 'freeproblemset', '<pre>\r\n<span class="di" id="clean">3个实数</span></pre>', '<pre>\r\n<span class="di" id="clean">最大的数,输出两遍，先用函数，再用宏。\r\n保留3位小数。</span></pre>', '1 2 3\r\n', '3.000\r\n3.000\r\n', '', 0, 0, '2010-08-07 16:38:50', '2010-08-07 16:38:50'),
(83, 1, 'C语言程序设计教程（第三版）课后习题9.10   ', 1000, 33554432, 0000000000, 0000000000, '<pre>\r\n<span class="di" id="clean">输入一行电报文字，将字母变成其下一字母（如&rsquo;a&rsquo;变成&rsquo;b&rsquo;&hellip;&hellip;&rsquo;z&rsquo;变成&rsquo;ａ&rsquo;其它字符不变）。</span></pre>\r\n<p>\r\n	<span class="b">&nbsp;</span></p>\r\n', 'freeproblemset', '<pre>\r\n<span class="di" id="clean">一行字符</span></pre>', '<pre>\r\n<span class="di" id="clean">加密处理后的字符</span></pre>', 'a b\r\n', 'b c\r\n', '', 0, 0, '2010-08-07 16:43:16', '2010-08-07 16:43:16'),
(84, 1, 'C语言程序设计教程（第三版）课后习题10.1', 1000, 33554432, 0000000000, 0000000000, '<pre>\r\n<span class="di" id="clean">输入三个整数，按由小到大的顺序输出。</span></pre>', 'freeproblemset', '<pre>\r\n<span class="di" id="clean">三个整数</span></pre>', '<pre>\r\n<span class="di" id="clean">由小到大输出成一行，每个数字后面跟一个空格</span></pre>', '2 3 1\r\n', '1 2 3 \r\n', '', 0, 0, '2010-08-07 16:46:04', '2010-08-07 16:46:04'),
(85, 1, 'C语言程序设计教程（第三版）课后习题10.2', 1000, 33554432, 0000000000, 0000000000, '<pre>\r\n<span class="di" id="clean">输入三个字符串，按由小到大的顺序输出</span></pre>', 'freeproblemset', '<pre>\r\n<span class="di" id="clean">3行字符串</span></pre>', '<pre>\r\n<span class="di" id="clean">按照从小到大输出成3行</span></pre>', 'cde\r\nafg\r\nabc\r\n', 'abc\r\nafg\r\ncde\r\n', '', 0, 0, '2010-08-07 16:49:24', '2010-08-07 16:49:24'),
(86, 1, 'C语言程序设计教程（第三版）课后习题10.3', 1000, 33554432, 0000000000, 0000000000, '<pre>\r\n<span class="di" id="clean">输入10个整数，将其中最小的数与第一个数对换，把最大的数与最后一个数对换。写三个函数；\r\n①输入10个数；②进行处理；③输出10个数。</span></pre>\r\n', 'freeproblemset', '<pre>\r\n<span class="di" id="clean">10个整数</span></pre>\r\n', '<pre>\r\n<span class="di" id="clean">整理后的十个数，每个数后跟一个空格（注意最后一个数后也有空格）</span>换行符</pre>', '2 1 3 4 5 6 7 8 10 9\r\n ', '1 2 3 4 5 6 7 8 9 10 \r\n', '', 0, 0, '2010-08-07 16:53:54', '2010-08-07 16:55:22'),
(87, 1, 'C语言程序设计教程（第三版）课后习题10.4', 1000, 33554432, 0000000000, 0000000000, '<pre>\r\n<span class="di" id="clean">有n个整数，使前面各数顺序向后移m个位置，最后m个数变成前面m个数，见图。写一函数：实现以上功能，在主函数中输入n个数和输出调整后的n个数。</span></pre>\r\n', 'freeproblemset', '<pre>\r\n<span class="di" id="clean">输入数据的个数n\r\nn个整数\r\n移动的位置m</span></pre>\r\n<p>\r\n	<span class="b">&nbsp;</span></p>\r\n', '<pre>\r\n<span class="di" id="clean">移动后的n个数 </span>每个数后有空格</pre>\r\n', '10\r\n1 2 3 4 5 6 7 8 9 10\r\n2', '9 10 1 2 3 4 5 6 7 8 \r\n', '', 0, 0, '2010-08-07 16:57:50', '2010-08-07 17:07:11'),
(88, 1, 'C语言程序设计教程（第三版）课后习题10.5', 1000, 33554432, 0000000000, 0000000000, '<pre>\r\n<span class="di" id="clean">有n人围成一圈，顺序排号。从第1个人开始报数（从1到3报数），凡报到3的人退出圈子，问最后留下的是原来的第几号的那位。</span></pre>', 'freeproblemset', '<pre>\r\n<span class="di" id="clean">初始人数n</span></pre>', '<pre>\r\n<span class="di" id="clean">最后一人的初始编号</span></pre>', '3', '2', '', 0, 0, '2010-08-07 17:07:59', '2010-08-07 17:07:59'),
(89, 1, 'C语言程序设计教程（第三版）课后习题10.7', 1000, 33554432, 0000000000, 0000000000, '<pre>\r\n<span class="di" id="clean">有一字符串，包含n个字符。写一函数，将此字符串中从第m个字符开始的全部字符复制成为另一个字符串。</span></pre>', 'freeproblemset', '<pre>\r\n<span class="di" id="clean">数字n\r\n一行字符串\r\n数字m</span></pre>', '<pre>\r\n<span class="di" id="clean">从m开始的子串</span></pre>', '6\r\nabcdef\r\n3\r\n', 'cdef', '', 0, 0, '2010-08-07 17:09:58', '2010-08-07 17:09:58'),
(90, 1, 'C语言程序设计教程（第三版）课后习题11.1', 1000, 33554432, 0000000000, 0000000000, '<pre>\r\n<span class="di" id="clean">定义一个结构体变量（包括年、月、日）。计算该日在本年中是第几天，注意闰年问题。</span></pre>', 'freeproblemset', '<pre>\r\n<span class="di" id="clean">年月日</span></pre>', '<pre>\r\n<span class="di" id="clean">当年第几天</span></pre>', '2000 12 31\r\n', '366', '', 0, 0, '2010-08-07 17:15:51', '2010-08-07 17:15:51'),
(91, 1, 'C语言程序设计教程（第三版）课后习题11.3', 1000, 33554432, 0000000000, 0000000000, '<pre>\r\n<span class="di" id="clean">现有有N个学生的数据记录，每个记录包括学号、姓名、三科成绩。\r\n编写一个函数input,用来输入一个学生的数据记录。\r\n编写一个函数print,打印一个学生的数据记录。\r\n在主函数调用这两个函数，读取N条记录输入，再按要求输出。\r\nN&lt;100</span></pre>', 'freeproblemset', '<pre>\r\n<span class="di" id="clean">学生数量N占一行\r\n每个学生的学号、姓名、三科成绩占一行，空格分开。</span></pre>', '<pre>\r\n<span class="di" id="clean">每个学生的学号、姓名、三科成绩占一行，逗号分开。</span></pre>', '2\r\na100 zhblue 70 80 90\r\nb200 newsclan 90 85 75\r\n', 'a100,zhblue,70,80,90\r\nb200,newsclan,90,85,75\r\n', '', 0, 0, '2010-08-07 17:17:27', '2010-08-07 17:17:27'),
(92, 1, 'C语言程序设计教程（第三版）课后习题11.5', 1000, 33554432, 0000000000, 0000000000, '<pre>\r\n<span class="di" id="clean">有N个学生，每个学生的数据包括学号、姓名、3门课的成绩，从键盘输入N个学生的数据，要求打印出3门课的总平均成绩，以及最高分的学生的数据（包括学号、姓名、3门课成绩）</span></pre>', 'freeproblemset', '<pre>\r\n<span class="di" id="clean">学生数量N占一行每个学生的学号、姓名、三科成绩占一行，空格分开。</span></pre>', '<pre>\r\n<span class="di" id="clean">各门课的平均成绩\r\n最高分的学生的数据（包括学号、姓名、3门课成绩）</span></pre>', '2\r\n1 blue 90 80 70\r\nb clan 80 70 60\r\n', '85 75 65\r\n1 blue 90 80 70\r\n', '', 0, 0, '2010-08-07 17:19:05', '2010-08-07 17:19:05'),
(93, 1, 'C语言程序设计教程（第三版）课后习题11.8', 1000, 33554432, 0000000000, 0000000000, '<pre>\r\n<span class="di" id="clean">已有a、b两个链表，每个链表中的结点包括学号、成绩。要求把两个链表合并，按学号升序排列。</span></pre>', 'freeproblemset', '<pre>\r\n<span class="di" id="clean">第一行，a、b两个链表元素的数量N、M,用空格隔开。\r\n接下来N行是a的数据\r\n然后M行是b的数据\r\n每行数据由学号和成绩两部分组成\r\n</span></pre>\r\n', '<pre>\r\n<span class="di" id="clean">按照学号升序排列的数据</span></pre>\r\n', '2 3\r\n5 100\r\n6 89\r\n3 82\r\n4 95\r\n2 10\r\n', '2 10\r\n3 82\r\n4 95\r\n5 100\r\n6 89\r\n', '', 0, 0, '2010-08-07 17:21:31', '2010-10-24 16:43:39'),
(95, 1, 'A Multiply Problem', 2000, 33554432, 0000000000, 0000000000, '<p>\r\n	Our problem is,for a giving M rows and M columns matrix A,output another matrix B=A<sup>N</sup>.</p>\r\n', '湖南师大数计院ACM—ICPC个人邀请赛', '<p>\r\n	There are multiple test cases. The first line of the input contains an integer T, meaning the number of the test cases.<br />\r\n	For each test cases, there are two integers M and N in a single line.<br />\r\n	You can assume that 1&lt;=M&lt;=4,,0&lt;=N&lt;=4.</p>\r\n<p>\r\n	Then,M row M column integers value v followed.The ith row and jth column v represent a the ith row and jth column of matrix A.You can assume that for each v, -10&lt;=v&lt;=10.</p>\r\n', '<p>\r\n	For each testcase,first output the case number in a single line.Then,output M rows M columns integers represent the matrix B.</p>\r\n<p>\r\n	Each line of the output should contain M integers and these M integers should be separated by blank spaces.You must know no blank space after the last integer of each line.</p>\r\n', '1\r\n2 2\r\n9 7\r\n5 1\r\n', 'Case 1:\r\n116 70\r\n50 36\r\n', '', 0, 0, '2010-08-07 19:35:50', '2010-08-07 19:36:24'),
(96, 1, 'Be Good at Gaussing', 1000, 33554432, 0000000000, 0000000000, '<p>\r\n	Give you many positive integer N (N&lt;=23),for each N,just output&nbsp; N*(N+1)/2 integers in a single line,separated by space. (Don&#39;t ask me why.)For each N,the output&nbsp; line contains integers from 1 to N,and each just once.Again,do not ask me why,thank you.I&#39;m so busy.But I can tell you a secret,the output&nbsp; has relationship with number triangle.As:(N=3)</p>\r\n<p>\r\n	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1</p>\r\n<p>\r\n	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp; 6</p>\r\n<p>\r\n	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3&nbsp;&nbsp; 4&nbsp;&nbsp; 5</p>\r\n<p>\r\n	See the sample for more information.</p>\r\n', '湖南师大数计院ACM—ICPC个人邀请赛', '<p>\r\n	Many lines,each line contains a positive integer N (N&lt;=23).</p>\r\n', '<p>\r\n	For each N,output N*(N+1)/2 integers in a single line,separated by a blank space.</p>\r\n', '3\r\n4\r\n2\r\n6\r\n', '1 2 6 3 4 5\r\n1 2 9 3 10 8 4 5 6 7\r\n1 2 3\r\n1 2 15 3 16 14 4 17 21 13 5 18 19 20 12 6 7 8 9 10 11\r\n', '', 0, 0, '2010-08-07 19:38:28', '2010-08-07 19:38:28'),
(97, 1, 'Count', 1000, 33554432, 0000000000, 0000000000, '<p>\r\n	Many ACM team name may be very funny,such as &quot;Complier_Error&quot;,&quot;VVVVV&quot;.Oh,wait for a minute here.</p>\r\n<p>\r\n	Is it &quot;W W&quot;+&quot;V&quot;,or &quot;W&quot;+&quot;V V V&quot;,or something others we can treat as?There are several ways we can treat this name &quot;VVVVV&quot; (5 &#39;V&#39;s),as V V can be treat as a W.</p>\r\n<p>\r\n	For 5 &#39;V&#39;s,our have 8 ways.They are:</p>\r\n<ol>\r\n	<li>\r\n		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;V&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; V&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; V&nbsp;&nbsp;&nbsp;&nbsp; V&nbsp;&nbsp;&nbsp;&nbsp; V</li>\r\n	<li>\r\n		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;V&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; W&nbsp;&nbsp;&nbsp;&nbsp; W&nbsp;</li>\r\n	<li>\r\n		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;W&nbsp;&nbsp;&nbsp;&nbsp; W&nbsp;&nbsp;&nbsp;&nbsp; V</li>\r\n	<li>\r\n		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;V&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; W&nbsp;&nbsp;&nbsp;&nbsp; V&nbsp;&nbsp;&nbsp;&nbsp; V</li>\r\n	<li>\r\n		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;W&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; V&nbsp;&nbsp; &nbsp;&nbsp;W</li>\r\n	<li>\r\n		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;W&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; V&nbsp;&nbsp;&nbsp;&nbsp; V&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; V</li>\r\n	<li>\r\n		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;V&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; V&nbsp;&nbsp;&nbsp;&nbsp; W&nbsp;&nbsp;&nbsp;&nbsp; V</li>\r\n	<li>\r\n		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;V&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; V&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; V&nbsp;&nbsp;&nbsp;&nbsp; W</li>\r\n</ol>\r\n<p>\r\n	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The problem here is that for n &#39;V&#39;s,how many ways do we have to treat it?Because the answer may be too large, you should output the answer module by p.(If&nbsp; n is 0,then we have just one way.)</p>\r\n', '湖南师大数计院ACM—ICPC个人邀请赛', '<p>\r\n	There are multiple test cases. The first line of the input contains an integer M, meaning the number of the test cases.<br />\r\n	For each test cases, there are two integers n and p in a single line.<br />\r\n	You can assume that 0&lt;=n&lt;=2100000000, 0&lt;p&lt;=2009.</p>\r\n', '<p>\r\n	For each test case, output the answer with case number in a single line.</p>\r\n', '2\r\n5 5\r\n4 7\r\n', '3\r\n5\r\n', '', 0, 0, '2010-08-07 19:40:05', '2010-08-07 19:40:05'),
(98, 1, 'Doude Zhu斗地主', 1000, 33554432, 0000000000, 0000000000, '<p align="left">\r\n	斗地主是一种在中国几乎人人都会玩的扑克牌游戏。</p>\r\n<p align="left">\r\n	简介：该游戏由三人玩一副牌，地主为一方，其余两家为另一方，双方对战，先出完手中牌的一方胜。</p>\r\n<p align="left">\r\n	<strong>游戏可出牌型（一副牌规则）</strong></p>\r\n<p align="left">\r\n	火箭：即双王（大王和小王），最大的牌。<br />\r\n	炸弹：四张同数值牌（如四个7 ）。<br />\r\n	单牌：单个牌（如红桃5 ）。<br />\r\n	对牌：数值相同的两张牌（如梅花4+ 方块4 ）。<br />\r\n	三张牌：数值相同的三张牌（如三个J ）。<br />\r\n	三带一：数值相同的三张牌+ 一张单牌或一对牌。例如：333+6 或444+99<br />\r\n	单顺：五张或更多的连续单牌（如：45678 或78910JQK ）。不包括2 点和双王。<br />\r\n	双顺：三对或更多的连续对牌（如：334455 、7788991010JJ ）。不包括2 点和双王。<br />\r\n	三顺：二个或更多的连续三张牌（如：333444 、555666777888 ）。不包括2 点和双王。<br />\r\n	飞机带翅膀：三顺＋同数量的单牌（或同数量的对牌）。</p>\r\n<p align="left">\r\n	如：444555+79 或333444555+7799JJ&nbsp;</p>\r\n<p align="left">\r\n	(注意：带的单牌里不能有与三顺里相同的牌。即&nbsp; 55556669不是飞机带翅膀。而且带的单牌也应互不相同，即44456665 不算此种类型。)<br />\r\n	四带二：四张牌＋两张单牌(两张单牌互不相同)&nbsp;&nbsp; 或者&nbsp;&nbsp; 四张牌+两对牌。（注意：四带二不是炸弹,而且不能出连续的四带二）。<br />\r\n	如：5555 ＋3 ＋8 或4444 ＋55 ＋77 。</p>\r\n<p align="left">\r\n	空牌型：即什么都不出，在任何时候，任何人都可以放弃这一次出牌机会。</p>\r\n<p align="left">\r\n	<strong>6</strong><strong>、牌型的大小</strong></p>\r\n<p align="left">\r\n	火箭最大，可以打任意其他的牌。<br />\r\n	炸弹比火箭小，比其他牌大。都是炸弹时按牌的分值比大小。<br />\r\n	除火箭和炸弹外，其他牌必须要牌型相同且总张数相同才能比大小。<br />\r\n	单牌按分值比大小，依次是 大王&gt; 小王&gt;2&gt;A&gt;K&gt;Q&gt;J&gt;10&gt;9&gt;8&gt;7&gt;6&gt;5&gt;4&gt;3 ，不分花色。<br />\r\n	对牌、三张牌都按分值比大小。<br />\r\n	顺牌按最大的一张牌的分值来比大小。<br />\r\n	飞机带翅膀和四带二按其中的三顺和四张部分来比，带的牌不影响大小。</p>\r\n<p>\r\n	假设现在由Alice出牌，Bob接牌，你的任务就是判断Alice出的牌是否符合规则，Bob手中有没有牌能够大过Alice.</p>\r\n', '湖南师大数计院ACM—ICPC个人邀请赛', '<p>\r\n	输入有多组测试数据，对于每组测试数据：</p>\r\n<p>\r\n	第一行：若干张Alice出的牌，以0结束，Alice出的牌的数目在0-20之间（含0和20），</p>\r\n<p>\r\n	第二行：若干个数字，表示Bob手中有的牌，以0结束。Bob手中的牌数在1-20之间（含1和20）。</p>\r\n<p>\r\n	以上数据凡是表示出的牌的整数t均满足-2&lt;=t&lt;=13，其中-2表示大王，-1表示小王，J，Q，K，A分别用11,12,13,1来表示,t=0时说明输入Alice出的牌或Bob手中的牌结束。</p>\r\n<p>\r\n	很明显，斗地主牌的大小与花色无关，这里也不给出花色。</p>\r\n', '<p>\r\n	对于每组测试数据，如果Alice出的牌不符合任何规则，则在一行输出&ldquo;Wrong&rdquo;(要注意Alice可以一张牌都不出，这表示Alice自己放弃这次出牌机会，这是符合规则的。而且Bob一定能接住空牌型。)如果Alice出的牌符合规则而且Bob手中有牌能够大过她出的牌，则在一行输出&ldquo;Yes&rdquo;，如果Alice出的牌符合规则而Bob手中没有牌能大过她出的牌，则在一行输出&ldquo;No&rdquo;。</p>\r\n', '3 0\r\n5 6 9 3 0\r\n3 5 0\r\n3 3 4 4 6 6 0\r\n5 5 0\r\n3 4 9 10 0\r\n', 'Yes\r\nWrong\r\nNo\r\n', '', 0, 0, '2010-08-07 19:41:47', '2010-08-07 19:41:47'),
(99, 1, '路程期望', 1000, 33554432, 0000000000, 0000000000, '<p>\r\n	无聊时也好，有事时也罢，很多同学都喜欢在校园里溜达， 小胡也不例外，每天从江边宿舍到学校后，小胡每天都会去一下别的学院或别的楼（总不能一整天都待在理学院吧？），小胡从一个地方到另一个地方的路程与概率是有可能不同的，比如如果现在在理学院，那么他可能去图书馆，也可去至善楼，当然，偶尔也会去外国语学院逛逛。当然，小胡最后还是想要回江边宿舍的，如果他回到了江边宿舍，那么他这一天要走的路就走完了。</p>\r\n<p>\r\n	&nbsp;&nbsp;&nbsp; 现在，给出小胡从每栋楼到另一栋楼的可能性和要走的路程，问：小胡从江边宿舍出发，是否一定能回到江边宿舍？如果能，那么他一天会走的路程的期望是多少？</p>\r\n', '湖南师大数计院ACM—ICPC个人邀请赛', '<p>\r\n	输入有多组测试数据。第一行为一个正整数T，表示测试数据组数。</p>\r\n<p>\r\n	接下来为T组测试数据，每组第一个为正整数N(N&lt;20)，表示小胡可能去的地方（所有地方当然各不相同）的数目（包括出发点江边宿舍）。</p>\r\n<p>\r\n	接下来是两个矩阵，一个是概率矩阵，一个是路程矩阵。</p>\r\n<p>\r\n	概率矩阵为N行N列整数，第i行第j列表示如果小胡在地点i，那么他去地点j的可能性，注意所有概率都是用0到100的整数表示的百分比，如21表示可能性为0.21，而且第1行第j列总表示从出发点江边宿舍去地点j的可能性，第i行第1列总表示从地点i去江边宿舍的可能性，而且输入保证第i行第i列（1&lt;=i&lt;=N）一定为0，而且第i行上所有整数之和一定等于100。</p>\r\n<p>\r\n	空一行后为路程矩阵，有N行N列整数，第i行第j列表示小胡从第点i到地点j所需走的路程s（0&lt;=s&lt;20），</p>\r\n<p>\r\n	从地点i到地点j与从地点j到地点i要走的路程是一样的，而且第i行第i列上数据也一定为0,</p>\r\n<p>\r\n	表示概率与表示路程的地点是对应的。</p>\r\n<p>\r\n	接下来再空一行。</p>\r\n', '<p>\r\n	小胡从江边宿舍出发，如果他有可能回不了江边宿舍（无论这种可能性多么小），对应的测试数据输出一行&quot;No solution.&quot;（不含双引号），如果他一定能在有限步回江边宿舍，则输出他从江边宿舍出发，到回到江边宿舍所走的路程的期望值，结果四舍五入保留5位小数。（小胡从江边宿舍出发后，再次回到江边宿舍则路程已经走完了，不会回了宿舍后又出发。）</p>\r\n', '2\r\n7\r\n0 21 9 10 20 30 10 \r\n55 0 0 45 0 0 0 \r\n28 29 0 43 0 0 0 \r\n100 0 0 0 0 0 0 \r\n17 33 31 19 0 0 0 \r\n23 26 17 14 20 0 0 \r\n35 7 29 8 14 7 0 \r\n\r\n0 16 6 9 0 6 4 \r\n16 0 7 19 3 10 4 \r\n6 7 0 5 11 10 12 \r\n9 19 5 0 3 1 9 \r\n0 3 11 3 0 7 3 \r\n6 10 10 1 7 0 10 \r\n4 4 12 9 3 10 0 \r\n\r\n4\r\n0 19 44 37 \r\n65 0 35 0 \r\n100 0 0 0 \r\n36 25 39 0 \r\n\r\n0 15 4 9 \r\n15 0 3 10 \r\n4 3 0 2 \r\n9 10 2 0 \r\n', '25.50046\r\n16.13610\r\n', '', 0, 0, '2010-08-07 19:43:43', '2010-08-07 19:43:43'),
(100, 1, 'Fixed Point', 1000, 33554432, 0000000000, 0000000000, '<p>\r\n	&nbsp;&nbsp;&nbsp; In mathematics, a fixed point (sometimes shortened to fixpoint, also known as an invariant point) of a function is a point that is mapped to itself by the function. That is to say, <em>x</em> is a fixed point of the function <em>f</em> &nbsp;if and only if <em>f</em>(<em>x</em>) = <em>x</em>. For example, if <em>f</em> is defined on the real numbers by f(x)=x*x-3*x+4.,then 2 is a fixed point of <em>f</em>, because <em>f</em>(2) = 2.</p>\r\n<p>\r\n	Not all functions have fixed points: for example, if <em>f</em> is a function defined on the real numbers as <em>f</em>(<em>x</em>) = <em>x</em> + 1, then it has no fixed points, since <em>x</em> is never equal to <em>x</em> + 1 for any real number. In graphical terms, a fixed point means the point (<em>x</em>, <em>f</em>(<em>x</em>)) is on the line <em>y</em> = <em>x</em>, or in other words the graph of <em>f</em> &nbsp;has a point in common with that line. The example <em>f</em>(<em>x</em>) = <em>x</em> + 1 is a case where the graph and the line are a pair of parallel lines.</p>\r\n<p>\r\n	------ http://en.wikipedia.org/wiki/Fixed_point_%28mathematics%29</p>\r\n<p>\r\n	Our problem is,for a defined on real number function:&nbsp;&nbsp;&nbsp;</p>\r\n<p>\r\n	f(x)=a*x*x*x+b*x*x+c*x+d,how many different fixed points does it have?&nbsp;</p>\r\n', '湖南师大数计院ACM—ICPC个人邀请赛', '<p>\r\n	There are multiple test cases.For each test cases, there are four integers a, b, c and d in a single line.<br />\r\n	You can assume that -2<sup>13</sup>&lt;=a&lt;=2<sup>13</sup>, -2<sup>13</sup>&lt;=b&lt;=2<sup>13</sup>, -2<sup>13</sup>&lt;=c&lt;=2<sup>13</sup>, -2<sup>13</sup>&lt;=d&lt;=2<sup>13</sup>,and the number of the result is countable.</p>\r\n', '<p>\r\n	For each test case, output the answer &nbsp;in a single line.</p>\r\n', '3 111 793 -3456\r\n5 -135 811 0\r\n-1 9 10 -81\r\n', '3\r\n3\r\n3\r\n', '', 0, 0, '2010-08-07 19:47:20', '2010-08-07 19:47:20'),
(101, 1, '项链', 5000, 33554432, 0000000000, 0000000000, '<p>\r\n	师大有很多女孩子都喜欢戴项链，这天，小胡来到魔法礼品店想买一串珍珠项链给一个女孩。但当他看到珍珠项链时，他犯难了，因为有两串都很好看的珍珠项链摆在他眼前，他身上的钱的却只能购买一串。</p>\r\n<p>\r\n	环状状的项链上串着白色的，黑色的和红色的珍珠，两个项链上总共的珍珠数是一样的，只是颜色和顺序不同，老板告诉小胡，只要小胡愿意，红色的珍珠可以变成白色的，也可以变成黑色的，可是黑白色的珍珠却不能变化。于是，小胡想要一串能够变出更多类型的项链，（所谓两个项链类型不同，就是无论你怎么转动这两个项链，两个项链总有至少一个珍珠的颜色是不同的，如rbbb与bbrb是类型相同的，而rbbr与rbbb是类型不同的）他想那样更能讨她欢心，同时，他希望得到一个最长的相同颜色的子珍珠串，因为如果她不想戴着的话，小胡可能将项链剪断（最多只能剪两刀，即剪出来的相邻的珍珠在原来的项链上也是相邻的），剪出一串相同颜色的珍珠串送给她。</p>\r\n<p>\r\n	我们的问题当然不是诸如&ldquo;她是谁&rdquo;这种问题，我们的问题是：那么，小胡究竟该买哪一串呢？请你来帮他。</p>\r\n', '湖南师大数计院ACM—ICPC个人邀请赛', '<p>\r\n	输入有多组测试数据。</p>\r\n<p>\r\n	对于每组数据：</p>\r\n<p>\r\n	第一行：一个正整数len(1&lt;=len&lt;=100000)，表示两串项链的珍珠数目。</p>\r\n<p>\r\n	第二行：一个表示第一串项链的字符串，其中只可能有&#39;w&#39;（表示白色），&#39;b&#39;（表示黑色）,&#39;&#39;r&#39;（表示红色）三种字符。</p>\r\n<p>\r\n	第三行：一个表示第二串项链的字符串，表示方式与第一串相同。</p>\r\n<p>\r\n	你要特别注意，珍珠项链是环状的，即最后一个字母与第一个字母表示的珍珠是相邻的。</p>\r\n', '<p>\r\n	对每组测试数据：</p>\r\n<p>\r\n	设第一串能变出的所有不同种类的项链为集合A，第二串能变出的所有不同种类的项链为集合B。</p>\r\n<p>\r\n	第一行输出如下：</p>\r\n<p>\r\n	如果集合A等于集合B，单独的一行输出&quot;same&quot;,</p>\r\n<p>\r\n	如果集合A真包含集合B，即第一串能变出所有第二串变出的类型，而第二串却未必能变出第一串能变出的所有类型，单独的一行输出&quot;first&quot;,</p>\r\n<p>\r\n	如果集合A真包含于集合B，即第二串能变出所有第一串变出的类型，而第一串却未必能变出第二串能变出的所有类型，单独的一行输出&quot;second&quot;,</p>\r\n<p>\r\n	其它情况，输出&quot;other&quot;。</p>\r\n<p>\r\n	第二行：输出第一串项链所能剪出的最长的相同颜色的珍珠串的长度。</p>\r\n<p>\r\n	第三行：输出第二串项链所能剪出的最长的相同颜色的珍珠串的长度。</p>\r\n', '5\r\nrbbrr\r\nrbbwb\r\n', 'first\r\n5\r\n4\r\n', '', 0, 0, '2010-08-07 19:48:53', '2010-08-07 19:50:01'),
(102, 1, 'Intersect', 1000, 33554432, 0000000000, 0000000000, '<p>\r\n	&nbsp;&nbsp;&nbsp;&nbsp; If a point P is on the segment AB and another segment CD at the same time,we say that P is an intersect point for AB and CD.</p>\r\n<p>\r\n	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; For two segments in two dimensions,how many intersect point do they have?</p>\r\n', '湖南师大数计院ACM—ICPC个人邀请赛', '<p>\r\n	There are multiple test cases.</p>\r\n<p>\r\n	For each test case:the first line contains 4 integers represent th x-coordinate of point A, y-coordinate of point A,x-coordinate of point B,y-coordinate of point B,the second line contains 4 integers represent th x-coordinate of point C, y-coordinate of point C,x-coordinate of point D,y-coordinate of point D.</p>\r\n<p>\r\n	You can assume for all input integers v,-2&lt;=v&lt;=2,and A and B are always at different position,,C and D are always at different position,too.</p>\r\n', '<p>\r\n	For each test case:</p>\r\n<p>\r\n	If AB and CD have no intersect point,output a single line contains the string &quot;None&quot;,</p>\r\n<p>\r\n	If AB and CD have just one intersect point,output a single line contains the string &quot;One&quot;,</p>\r\n<p>\r\n	If AB and CD have more than one intersect point(such as many),output a single line contains the string &quot;Many&quot;.</p>\r\n', '-2 -2 -2 -1\r\n-2 -2 -2 2\r\n-2 -2 -2 -1\r\n-2 -2 -1 0\r\n', 'Many\r\nOne\r\n', '', 0, 0, '2010-08-07 19:53:10', '2010-08-07 19:53:10');
INSERT INTO `tbl_problems` (`id`, `user_id`, `title`, `time_limit`, `memory_limit`, `submission_no`, `accepted_no`, `description`, `source`, `input`, `output`, `input_sample`, `output_sample`, `hint`, `flag`, `visibility`, `created`, `modified`) VALUES
(103, 1, 'Help Mr Need Help', 10000, 33554432, 0000000000, 0000000000, '<p class="p0" style="text-indent: 24pt; margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 12pt; font-family: ''微软雅黑'';">As&nbsp;an&nbsp;acmer,&nbsp;Mr&nbsp;Need&nbsp;Help&nbsp;always&nbsp;submits&nbsp;his&nbsp;solutions&nbsp;on&nbsp;Online&nbsp;Judge.However,his&nbsp;programs&nbsp;can&nbsp;not&nbsp;always&nbsp;get&nbsp;an&nbsp;&quot;Aceept&quot;&nbsp;because&nbsp;of&nbsp;&nbsp;many&nbsp;strange&nbsp;reasons.And&nbsp;followed&nbsp;is&nbsp;his&nbsp;C/C++/Java&nbsp;solution&nbsp;for&nbsp;a&nbsp;problem.These&nbsp;3&nbsp;programs&nbsp;are&nbsp;of&nbsp;the&nbsp;same&nbsp;algorithm.&nbsp;</span><span style="font-size: 12pt; font-family: ''微软雅黑'';"><o:p></o:p></span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 12pt; font-family: ''微软雅黑'';">It&nbsp;his&nbsp;C&nbsp;source&nbsp;code:</span><span style="font-size: 12pt; font-family: ''微软雅黑'';"><o:p></o:p></span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 12pt; font-family: ''微软雅黑'';">#include&lt;stdio.h&gt;</span><span style="font-size: 12pt; font-family: ''微软雅黑'';"><o:p></o:p></span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 12pt; font-family: ''微软雅黑'';">int&nbsp;main()</span><span style="font-size: 12pt; font-family: ''微软雅黑'';"><o:p></o:p></span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 12pt; font-family: ''微软雅黑'';">{</span><span style="font-size: 12pt; font-family: ''微软雅黑'';"><o:p></o:p></span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 12pt; font-family: ''微软雅黑'';">&nbsp;&nbsp;&nbsp;&nbsp;long&nbsp;long&nbsp;n,x,z,k,b;</span><span style="font-size: 12pt; font-family: ''微软雅黑'';"><o:p></o:p></span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 12pt; font-family: ''微软雅黑'';">&nbsp;&nbsp;&nbsp;&nbsp;while(EOF!=scanf(&quot;%lld%lld%lld%lld%lld&quot;,&amp;n,&amp;x,&amp;z,&amp;k,&amp;b))</span><span style="font-size: 12pt; font-family: ''微软雅黑'';"><o:p></o:p></span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 12pt; font-family: ''微软雅黑'';">&nbsp;&nbsp;&nbsp;&nbsp;{</span><span style="font-size: 12pt; font-family: ''微软雅黑'';"><o:p></o:p></span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 12pt; font-family: ''微软雅黑'';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;long&nbsp;long&nbsp;first,second,tmp2=1%z,third=1%z,tmp3=x%b,i;</span><span style="font-size: 12pt; font-family: ''微软雅黑'';"><o:p></o:p></span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 12pt; font-family: ''微软雅黑'';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(first=n-1;n%first!=0;--first)</span><span style="font-size: 12pt; font-family: ''微软雅黑'';"><o:p></o:p></span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 12pt; font-family: ''微软雅黑'';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;</span><span style="font-size: 12pt; font-family: ''微软雅黑'';"><o:p></o:p></span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 12pt; font-family: ''微软雅黑'';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(second=0;second&lt;z&amp;&amp;tmp2!=k%z;++second)</span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 12pt; font-family: ''微软雅黑'';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tmp2=tmp2*x%z;</span><span style="font-size: 12pt; font-family: ''微软雅黑'';"><o:p></o:p></span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 12pt; font-family: ''微软雅黑'';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(i=1;i&lt;=n;++i,tmp3=tmp3*x%b)</span><span style="font-size: 12pt; font-family: ''微软雅黑'';"><o:p></o:p></span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 12pt; font-family: ''微软雅黑'';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;third=third*tmp3%b;</span><span style="font-size: 12pt; font-family: ''微软雅黑'';"><o:p></o:p></span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 12pt; font-family: ''微软雅黑'';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;%lld&nbsp;%lld&nbsp;%lld\\n&quot;,first,second,third);</span><span style="font-size: 12pt; font-family: ''微软雅黑'';"><o:p></o:p></span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 12pt; font-family: ''微软雅黑'';">&nbsp;&nbsp;&nbsp;&nbsp;}</span><span style="font-size: 12pt; font-family: ''微软雅黑'';"><o:p></o:p></span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 12pt; font-family: ''微软雅黑'';">&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;</span><span style="font-size: 12pt; font-family: ''微软雅黑'';"><o:p></o:p></span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 12pt; font-family: ''微软雅黑'';">}</span><span style="font-size: 12pt; font-family: ''微软雅黑'';"><o:p></o:p></span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 12pt; font-family: ''微软雅黑'';">It&nbsp;his&nbsp;C++&nbsp;source&nbsp;code:</span><span style="font-size: 12pt; font-family: ''微软雅黑'';"><o:p></o:p></span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 12pt; font-family: ''微软雅黑'';">#include&lt;iostream&gt;</span><span style="font-size: 12pt; font-family: ''微软雅黑'';"><o:p></o:p></span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 12pt; font-family: ''微软雅黑'';">using&nbsp;namespace&nbsp;std;</span><span style="font-size: 12pt; font-family: ''微软雅黑'';"><o:p></o:p></span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 12pt; font-family: ''微软雅黑'';">int&nbsp;main()</span><span style="font-size: 12pt; font-family: ''微软雅黑'';"><o:p></o:p></span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 12pt; font-family: ''微软雅黑'';">{</span><span style="font-size: 12pt; font-family: ''微软雅黑'';"><o:p></o:p></span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 12pt; font-family: ''微软雅黑'';">&nbsp;&nbsp;&nbsp;&nbsp;long&nbsp;long&nbsp;n,x,z,k,b;</span><span style="font-size: 12pt; font-family: ''微软雅黑'';"><o:p></o:p></span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 12pt; font-family: ''微软雅黑'';">&nbsp;&nbsp;&nbsp;&nbsp;while(cin&gt;&gt;n&gt;&gt;x&gt;&gt;z&gt;&gt;k&gt;&gt;b)</span><span style="font-size: 12pt; font-family: ''微软雅黑'';"><o:p></o:p></span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 12pt; font-family: ''微软雅黑'';">&nbsp;&nbsp;&nbsp;&nbsp;{</span><span style="font-size: 12pt; font-family: ''微软雅黑'';"><o:p></o:p></span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 12pt; font-family: ''微软雅黑'';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;long&nbsp;long&nbsp;first,second,tmp2=1%z,third=1%z,tmp3=x%b;</span><span style="font-size: 12pt; font-family: ''微软雅黑'';"><o:p></o:p></span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 12pt; font-family: ''微软雅黑'';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(first=n-1;n%first!=0;--first)</span><span style="font-size: 12pt; font-family: ''微软雅黑'';"><o:p></o:p></span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 12pt; font-family: ''微软雅黑'';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;</span><span style="font-size: 12pt; font-family: ''微软雅黑'';"><o:p></o:p></span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 12pt; font-family: ''微软雅黑'';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(second=0;second&lt;z&amp;&amp;tmp2!=k%z;++second)</span><span style="font-size: 12pt; font-family: ''微软雅黑'';"><o:p></o:p></span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 12pt; font-family: ''微软雅黑'';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tmp2=tmp2*x%z;</span><span style="font-size: 12pt; font-family: ''微软雅黑'';"><o:p></o:p></span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 12pt; font-family: ''微软雅黑'';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;i=1;i&lt;=n;++i,tmp3=tmp3*x%b)</span><span style="font-size: 12pt; font-family: ''微软雅黑'';"><o:p></o:p></span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 12pt; font-family: ''微软雅黑'';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;third=third*tmp3%b;</span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 12pt; font-family: ''微软雅黑'';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout&lt;&lt;first&lt;&lt;&quot;&nbsp;&quot;&lt;&lt;second&lt;&lt;&quot;&nbsp;&quot;&lt;&lt;third&lt;&lt;endl;</span><span style="font-size: 12pt; font-family: ''微软雅黑'';"><o:p></o:p></span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 12pt; font-family: ''微软雅黑'';">&nbsp;&nbsp;&nbsp;&nbsp;}</span><span style="font-size: 12pt; font-family: ''微软雅黑'';"><o:p></o:p></span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 12pt; font-family: ''微软雅黑'';">&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;</span><span style="font-size: 12pt; font-family: ''微软雅黑'';"><o:p></o:p></span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 12pt; font-family: ''微软雅黑'';">}</span><span style="font-size: 12pt; font-family: ''微软雅黑'';"><o:p></o:p></span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 12pt; font-family: ''微软雅黑'';">It&nbsp;his&nbsp;Java&nbsp;source&nbsp;code:</span><span style="font-size: 12pt; font-family: ''微软雅黑'';"><o:p></o:p></span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 12pt; font-family: ''微软雅黑'';">import&nbsp;java.util.*;</span><span style="font-size: 12pt; font-family: ''微软雅黑'';"><o:p></o:p></span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 12pt; font-family: ''微软雅黑'';">public&nbsp;class&nbsp;Main</span><span style="font-size: 12pt; font-family: ''微软雅黑'';"><o:p></o:p></span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 12pt; font-family: ''微软雅黑'';">{</span><span style="font-size: 12pt; font-family: ''微软雅黑'';"><o:p></o:p></span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 12pt; font-family: ''微软雅黑'';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)</span><span style="font-size: 12pt; font-family: ''微软雅黑'';"><o:p></o:p></span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 12pt; font-family: ''微软雅黑'';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</span><span style="font-size: 12pt; font-family: ''微软雅黑'';"><o:p></o:p></span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 12pt; font-family: ''微软雅黑'';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Scanner&nbsp;cin=new&nbsp;Scanner(System.in);</span><span style="font-size: 12pt; font-family: ''微软雅黑'';"><o:p></o:p></span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 12pt; font-family: ''微软雅黑'';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;long&nbsp;n,x,z,k,b;&nbsp;</span><span style="font-size: 12pt; font-family: ''微软雅黑'';"><o:p></o:p></span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 12pt; font-family: ''微软雅黑'';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(cin.hasNext())</span><span style="font-size: 12pt; font-family: ''微软雅黑'';"><o:p></o:p></span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 12pt; font-family: ''微软雅黑'';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;</span><span style="font-size: 12pt; font-family: ''微软雅黑'';"><o:p></o:p></span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 12pt; font-family: ''微软雅黑'';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n=cin.nextLong();</span><span style="font-size: 12pt; font-family: ''微软雅黑'';"><o:p></o:p></span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 12pt; font-family: ''微软雅黑'';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x=cin.nextLong();</span><span style="font-size: 12pt; font-family: ''微软雅黑'';"><o:p></o:p></span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 12pt; font-family: ''微软雅黑'';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;z=cin.nextLong();</span><span style="font-size: 12pt; font-family: ''微软雅黑'';"><o:p></o:p></span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 12pt; font-family: ''微软雅黑'';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;k=cin.nextLong();</span><span style="font-size: 12pt; font-family: ''微软雅黑'';"><o:p></o:p></span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 12pt; font-family: ''微软雅黑'';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b=cin.nextLong();&nbsp;&nbsp;&nbsp;</span><span style="font-size: 12pt; font-family: ''微软雅黑'';"><o:p></o:p></span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 12pt; font-family: ''微软雅黑'';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;long&nbsp;first,second,tmp2=1%z,third=1%z,tmp3=x%b;</span><span style="font-size: 12pt; font-family: ''微软雅黑'';"><o:p></o:p></span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 12pt; font-family: ''微软雅黑'';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(first=n-1;n%first!=0;--first)</span><span style="font-size: 12pt; font-family: ''微软雅黑'';"><o:p></o:p></span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 12pt; font-family: ''微软雅黑'';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; </span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 12pt; font-family: ''微软雅黑'';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(second=0;second&lt;z&amp;&amp;tmp2!=k%z;++second)</span><span style="font-size: 12pt; font-family: ''微软雅黑'';"><o:p></o:p></span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 12pt; font-family: ''微软雅黑'';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tmp2=tmp2*x%z;</span><span style="font-size: 12pt; font-family: ''微软雅黑'';"><o:p></o:p></span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 12pt; font-family: ''微软雅黑'';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(long&nbsp;i=1;i&lt;=n;++i,tmp3=tmp3*x%b)</span><span style="font-size: 12pt; font-family: ''微软雅黑'';"><o:p></o:p></span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 12pt; font-family: ''微软雅黑'';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;third=third*tmp3%b;</span><span style="font-size: 12pt; font-family: ''微软雅黑'';"><o:p></o:p></span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 12pt; font-family: ''微软雅黑'';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(first+&quot;&nbsp;&quot;+second+&quot;&nbsp;&quot;+third);</span><span style="font-size: 12pt; font-family: ''微软雅黑'';"><o:p></o:p></span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 12pt; font-family: ''微软雅黑'';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span><span style="font-size: 12pt; font-family: ''微软雅黑'';"><o:p></o:p></span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 12pt; font-family: ''微软雅黑'';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span><span style="font-size: 12pt; font-family: ''微软雅黑'';"><o:p></o:p></span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 12pt; font-family: ''微软雅黑'';">}</span><span style="font-size: 12pt; font-family: ''微软雅黑'';"><o:p></o:p></span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 12pt; font-family: ''微软雅黑'';"><o:p></o:p></span></p>\r\n<p class="p0" style="text-indent: 24pt; margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 12pt; font-family: ''微软雅黑'';">For&nbsp;all&nbsp;the&nbsp;input&nbsp;data,Mr&nbsp;Need&nbsp;Help&#39;s&nbsp;programs&nbsp;get&nbsp;the&nbsp;right&nbsp;answer.However,any&nbsp;fool&nbsp;but&nbsp;Mr&nbsp;Need&nbsp;Help&nbsp;knows&nbsp;that&nbsp;these&nbsp;programs&nbsp;will&nbsp;cost&nbsp;too&nbsp;much&nbsp;time&nbsp;and&nbsp;surely&nbsp;an&nbsp;&quot;Time&nbsp;Limit&nbsp;Exceed&quot;&nbsp;is&nbsp;expected.&nbsp;&nbsp;</span><span style="font-size: 12pt; font-family: ''微软雅黑'';"><o:p></o:p></span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 12pt; font-family: ''微软雅黑'';">Mr&nbsp;Need&nbsp;Help&nbsp;turned&nbsp;to&nbsp;you&nbsp;for&nbsp;help.Your&nbsp;task&nbsp;is&nbsp;to&nbsp;help&nbsp;Mr&nbsp;Need&nbsp;Help&nbsp;solve&nbsp;this&nbsp;problem.</span></p>\r\n', '湖南师大数计院ACM—ICPC个人邀请赛', '<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 12pt; font-family: ''微软雅黑'';">Just&nbsp;as&nbsp;Mr&nbsp;Need&nbsp;Help&#39;s&nbsp;programs&nbsp;show.What&#39;s&nbsp;more,n,x,z,k,b&nbsp;are&nbsp;integers&nbsp;and&nbsp;2&lt;=n&lt;=2</span><span style="font-size: 12pt; font-family: ''微软雅黑''; vertical-align: super;">54</span><span style="font-size: 12pt; font-family: ''微软雅黑'';">,1&lt;=x&lt;=10</span><span style="font-size: 12pt; font-family: ''微软雅黑''; vertical-align: super;">9</span><span style="font-size: 12pt; font-family: ''微软雅黑'';">,1&lt;=z&lt;=10</span><span style="font-size: 12pt; font-family: ''微软雅黑''; vertical-align: super;">9</span><span style="font-size: 12pt; font-family: ''微软雅黑'';">,0&lt;=k&lt;=10</span><span style="font-size: 12pt; font-family: ''微软雅黑''; vertical-align: super;">9</span><span style="font-size: 12pt; font-family: ''微软雅黑'';">,1&lt;=b&lt;=10</span><span style="font-size: 12pt; font-family: ''微软雅黑''; vertical-align: super;">6</span><span style="font-size: 12pt; font-family: ''微软雅黑'';">.</span></p>\r\n', '<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 12pt; font-family: ''微软雅黑'';">Just&nbsp;an&nbsp;Mr&nbsp;Need&nbsp;Help&#39;s&nbsp;programs&nbsp;show.</span><span style="font-size: 12pt; font-family: ''微软雅黑'';">See&nbsp;the&nbsp;sample&nbsp;output&nbsp;for&nbsp;further&nbsp;details.</span></p>\r\n', '1729 4 4 0 883883\r\n294409 3 4 2 9493', '247 1 221134\r\n7957 4 7492', '', 0, 0, '2010-08-07 20:00:30', '2010-08-07 20:02:19'),
(104, 1, 'Group', 1000, 33554432, 0000000000, 0000000000, '<p>\r\n	&nbsp;&nbsp;&nbsp; There is a sequences of N numbers, cut them into no more than K groups without change there order, and each group at least L numbers. Calculate the sum of all the groups&#39; value. From left to right, the value of the i-th group is the the sum of all numbers in the group multiply i. Give me the minimum sum.<br />\r\n	&nbsp;</p>\r\n', 'HUST Monthly 2010.04.05', '<p>\r\n	&nbsp;&nbsp;&nbsp; The first line is a number T indicate the number of test cases.(T &lt; 20)<br />\r\n	&nbsp;&nbsp; &nbsp;Then T cases, for each case:<br />\r\n	&nbsp;&nbsp; &nbsp;First line is three numbers N, K, L as description.(1&lt;=L&lt;=N&lt;=20000, 1&lt;=K&lt;=100)<br />\r\n	&nbsp;&nbsp; &nbsp;Then N numbers ranged in [-1000, 1000].<br />\r\n	&nbsp;</p>\r\n', '<p>\r\n	&nbsp;&nbsp;&nbsp; For each case, output the minimum sum in a line.<br />\r\n	&nbsp;</p>\r\n', '2\r\n5 3 1\r\n3 -2 -1 -4 5\r\n5 3 2\r\n3 -2 -1 -4 5\r\n', '-1\r\n1\r\nHint：\r\nTo get the best answer you can try:\r\nCase 1: \r\n(3)(-2 -1 -4 5) or (3)(-2)(-1 -4 -5)\r\nCase 2:\r\n(3 -2)(-1 -4 5)\r\n', '', 0, 0, '2010-08-08 01:20:30', '2010-08-08 01:20:30'),
(105, 1, 'Repetitions of Substrings', 5000, 33554432, 0000000000, 0000000000, '<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 10.5pt; font-family: ''Times New Roman'';">The&nbsp;&ldquo;repetitions&rdquo;&nbsp;of&nbsp;a&nbsp;string&nbsp;S(whose&nbsp;length&nbsp;is&nbsp;n)&nbsp;is&nbsp;a&nbsp;maximum&nbsp;number&nbsp;&ldquo;k&rdquo;&nbsp;such&nbsp;that:</span><span style="font-size: 10.5pt; font-family: ''Times New Roman'';"><o:p></o:p></span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 10.5pt; font-family: ''Times New Roman'';">1)&nbsp;k&nbsp;is&nbsp;a&nbsp;factor&nbsp;of&nbsp;n</span><span style="font-size: 10.5pt; font-family: ''Times New Roman'';"><o:p></o:p></span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 10.5pt; font-family: ''Times New Roman'';">2)&nbsp;S[0..n/k-1]&nbsp;=&nbsp;S[p*(n/k)..(p+1)*(n/k)-1]</span><span style="font-size: 10.5pt; font-family: ''Times New Roman'';"> </span><span style="font-size: 10.5pt; font-family: ''Times New Roman'';"> </span><span style="font-size: 10.5pt; font-family: ''Times New Roman'';">for&nbsp;all&nbsp;that&nbsp;(1&nbsp;&lt;=&nbsp;p&nbsp;&lt;&nbsp;n/k)</span><span style="font-size: 10.5pt; font-family: ''Times New Roman'';"><o:p></o:p></span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 10.5pt; font-family: ''Times New Roman'';">for&nbsp;example:</span><span style="font-size: 10.5pt; font-family: ''Times New Roman'';"><o:p></o:p></span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 10.5pt; font-family: ''Times New Roman'';">the&nbsp;repetitions&nbsp;of&nbsp;&ldquo;aaaaaa&rdquo;is&nbsp;6.</span><span style="font-size: 10.5pt; font-family: ''Times New Roman'';"><o:p></o:p></span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 10.5pt; font-family: ''Times New Roman'';">the&nbsp;repetitions&nbsp;of&nbsp;&ldquo;abababab&rdquo;is&nbsp;4.</span><span style="font-size: 10.5pt; font-family: ''Times New Roman'';"><o:p></o:p></span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 10.5pt; font-family: ''Times New Roman'';">the&nbsp;repetitions&nbsp;of&nbsp;&ldquo;abcdef&rdquo;is&nbsp;1.</span><span style="font-size: 10.5pt; font-family: ''Times New Roman'';"> </span><span style="font-size: 10.5pt; font-family: ''Times New Roman'';"><o:p></o:p></span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 10.5pt; font-family: ''Times New Roman'';">Now,&nbsp;given&nbsp;a&nbsp;string&nbsp;S&nbsp;and&nbsp;a&nbsp;number&nbsp;K,&nbsp;please&nbsp;tell&nbsp;me&nbsp;how&nbsp;many&nbsp;substrings&nbsp;of&nbsp;S&nbsp;have&nbsp;repetitions&nbsp;NOT&nbsp;less&nbsp;than&nbsp;K.</span><span style="font-size: 10.5pt; font-family: ''Times New Roman'';"><o:p></o:p></span></p>\r\n', 'HUST Monthly 2010.04.05', '<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 10.5pt; font-family: ''Times New Roman'';">The&nbsp;input&nbsp;consists&nbsp;of&nbsp;several&nbsp;instances,&nbsp;each&nbsp;one&nbsp;for&nbsp;a&nbsp;single&nbsp;line.</span><span style="font-size: 10.5pt; font-family: ''Times New Roman'';"><o:p></o:p></span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 10.5pt; font-family: ''Times New Roman'';">S&nbsp;K</span><span style="font-size: 10.5pt; font-family: ''Times New Roman'';"><o:p></o:p></span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 10.5pt; font-family: ''Times New Roman'';">S&nbsp;is&nbsp;a&nbsp;string,&nbsp;K&nbsp;is&nbsp;a&nbsp;number.&nbsp;Check&nbsp;the&nbsp;Description&nbsp;for&nbsp;their&nbsp;meanings.</span><span style="font-size: 10.5pt; font-family: ''Times New Roman'';"><o:p></o:p></span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 10.5pt; font-family: ''Times New Roman'';">S&nbsp;contains&nbsp;lowercase&nbsp;letters(ie&nbsp;&#39;a&#39;..&#39;z&#39;)&nbsp;only.</span><span style="font-size: 10.5pt; font-family: ''Times New Roman'';"><o:p></o:p></span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 10.5pt; font-family: ''Times New Roman'';">1&nbsp;&lt;=&nbsp;length&nbsp;of&nbsp;S&nbsp;&lt;=&nbsp;100000.</span><span style="font-size: 10.5pt; font-family: ''Times New Roman'';"><o:p></o:p></span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 10.5pt; font-family: ''Times New Roman'';">1&nbsp;&lt;=&nbsp;K&nbsp;&lt;=&nbsp;length&nbsp;of&nbsp;S.</span></p>\r\n', '<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 10.5pt; font-family: ''Times New Roman'';">For&nbsp;each&nbsp;instance,&nbsp;output&nbsp;the&nbsp;number&nbsp;of&nbsp;substring&nbsp;whose&nbsp;repetitions&nbsp;is&nbsp;NOT&nbsp;less&nbsp;than&nbsp;K.</span></p>\r\n', 'abcabc 2\r\nacmac 3', '1\r\n0', '', 0, 0, '2010-08-08 01:33:55', '2010-08-08 01:34:57'),
(106, 1, 'Dartboard', 1000, 33554432, 0000000000, 0000000000, '<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 11pt; font-family: ''Verdana'';">A&nbsp;dartboard&nbsp;is&nbsp;a&nbsp;disc&nbsp;divided&nbsp;into&nbsp;</span><span style="font-style: italic; font-size: 11pt; font-family: ''Verdana'';">n</span><span style="font-size: 11pt; font-family: ''Verdana'';">&nbsp;segments,&nbsp;with&nbsp;each&nbsp;segment&nbsp;labeled&nbsp;with&nbsp;a&nbsp;distinct&nbsp;positive&nbsp;integer&nbsp;between&nbsp;1&nbsp;and&nbsp;</span><span style="font-style: italic; font-size: 11pt; font-family: ''Verdana'';">n</span><span style="font-size: 11pt; font-family: ''Verdana'';">.&nbsp;That&nbsp;integer&nbsp;indicates&nbsp;the&nbsp;score&nbsp;for&nbsp;hitting&nbsp;the&nbsp;segment.&nbsp;To&nbsp;make&nbsp;the&nbsp;game&nbsp;more&nbsp;interesting,&nbsp;the&nbsp;arrangement&nbsp;of&nbsp;numbers&nbsp;is&nbsp;chosen&nbsp;in&nbsp;such&nbsp;a&nbsp;way&nbsp;that&nbsp;the&nbsp;risk&nbsp;is&nbsp;maximized.&nbsp;The&nbsp;risk&nbsp;is&nbsp;estimated&nbsp;based&nbsp;on&nbsp;the&nbsp;differences&nbsp;in&nbsp;scores&nbsp;of&nbsp;adjacent&nbsp;segments.</span><br />\r\n	<br />\r\n	<span style="font-size: 11pt; font-family: ''Verdana'';">We&#39;re&nbsp;studying&nbsp;the&nbsp;following&nbsp;&#39;double-layered&#39;&nbsp;structure&nbsp;of&nbsp;segments&nbsp;in&nbsp;this&nbsp;problem:</span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 11pt; font-family: ''Verdana'';"><img alt="" src="/joj/userfiles/admin/0/Dartboard-676.png" style="width: 200px; height: 200px;" /></span></p>\r\n<p class="p0" style="margin-bottom: 12pt; margin-top: 0pt; text-align: left; line-height: 15.6pt;">\r\n	<span style="font-size: 11pt; font-family: ''Verdana'';">I.e.,&nbsp;</span><span style="font-style: italic; font-size: 11pt; font-family: ''Verdana'';">n</span><span style="font-size: 11pt; font-family: ''Verdana'';">&nbsp;is&nbsp;always&nbsp;even,&nbsp;and&nbsp;we&nbsp;split&nbsp;the&nbsp;disc&nbsp;into&nbsp;two&nbsp;layers&nbsp;of </span><span>n/2 </span><span style="font-size: 11pt; font-family: ''Verdana'';">parts&nbsp;along&nbsp;the&nbsp;circumference.&nbsp;We&nbsp;enumerate&nbsp;the&nbsp;segments&nbsp;in&nbsp;the&nbsp;following&nbsp;manner:&nbsp;the&nbsp;first&nbsp;segment&nbsp;is&nbsp;some&nbsp;outer&nbsp;segment,&nbsp;the&nbsp;second&nbsp;segment&nbsp;is&nbsp;the&nbsp;corresponding&nbsp;inner&nbsp;segment,&nbsp;the&nbsp;third&nbsp;segment&nbsp;is&nbsp;some&nbsp;adjacent&nbsp;outer&nbsp;segment,&nbsp;etc.&nbsp;An&nbsp;example&nbsp;of&nbsp;this&nbsp;enumeration&nbsp;is&nbsp;shown&nbsp;on&nbsp;the&nbsp;picture&nbsp;above.</span><br />\r\n	<br />\r\n	<span style="font-size: 11pt; font-family: ''Verdana'';">The&nbsp;total&nbsp;risk&nbsp;is&nbsp;defined&nbsp;as&nbsp;the&nbsp;sum&nbsp;of&nbsp;squared&nbsp;differences&nbsp;between&nbsp;the&nbsp;scores&nbsp;of&nbsp;adjacent&nbsp;segments.&nbsp;If&nbsp;the&nbsp;value&nbsp;assigned&nbsp;to&nbsp;segment&nbsp;</span><span style="font-style: italic; font-size: 11pt; font-family: ''Verdana'';">i</span><span style="font-size: 11pt; font-family: ''Verdana'';">&nbsp;is&nbsp;</span><span style="font-style: italic; font-size: 11pt; font-family: ''Verdana'';">a</span><span style="font-style: italic; font-size: 11pt; font-family: ''Verdana''; vertical-align: sub;">i</span><span style="font-size: 11pt; font-family: ''Verdana'';">,&nbsp;then&nbsp;the&nbsp;risk&nbsp;is:</span><br />\r\n	<br />\r\n	<span style="font-style: italic; font-size: 11pt; font-family: ''Verdana'';">R</span><span style="font-size: 11pt; font-family: ''Verdana'';">=&sum;</span><span style="font-style: italic; font-size: 11pt; font-family: ''Verdana''; vertical-align: sub;">i</span><span style="font-size: 11pt; font-family: ''Verdana''; vertical-align: sub;">=1</span><span style="font-style: italic; font-size: 11pt; font-family: ''Verdana''; vertical-align: super;">n</span><span style="font-size: 11pt; font-family: ''Verdana'';">(</span><span style="font-size: 28px;"><span style="font-style: italic; font-family: ''Verdana'';">a</span></span><sub><span style="font-style: italic; font-size: 11pt; font-family: ''Verdana''; vertical-align: sub;">i</span></sub><span style="font-size: 11pt; font-family: ''Verdana'';">-</span><span style="font-size: 28px;"><span style="font-style: italic; font-family: ''Verdana'';">a</span></span><sub><span style="font-style: italic; font-size: 11pt; font-family: ''Verdana''; vertical-align: sub;">i</span><span style="font-size: 11pt; font-family: ''Verdana''; vertical-align: sub;">+2</span></sub><span style="font-size: 11pt; font-family: ''Verdana'';">)</span><span style="font-size: 11pt; font-family: ''Verdana''; vertical-align: super;">2</span><span style="font-size: 11pt; font-family: ''Verdana'';">+&sum;</span><span style="font-style: italic; font-size: 11pt; font-family: ''Verdana''; vertical-align: sub;">i</span><span style="font-size: 11pt; font-family: ''Verdana''; vertical-align: sub;">=1</span><span style="font-style: italic; font-size: 11pt; font-family: ''Verdana''; vertical-align: super;">n</span><span style="font-size: 11pt; font-family: ''Verdana''; vertical-align: super;">/2</span><span style="font-size: 11pt; font-family: ''Verdana'';">(</span><span style="font-size: 28px;"><span style="font-style: italic; font-family: ''Verdana'';">a</span></span><sub><span style="font-size: 11pt; font-family: ''Verdana''; vertical-align: sub;">2i-1</span></sub><span style="font-size: 11pt; font-family: ''Verdana'';">-</span><span style="font-size: 28px;"><span style="font-style: italic; font-family: ''Verdana'';">a</span></span><sub><span style="font-size: 11pt; font-family: ''Verdana''; vertical-align: sub;">2i</span></sub><span style="font-size: 11pt; font-family: ''Verdana'';">)</span><span style="font-size: 11pt; font-family: ''Verdana''; vertical-align: super;">2</span><br />\r\n	<br />\r\n	<span style="font-size: 11pt; font-family: ''Verdana'';">(we&nbsp;assume&nbsp;</span><span style="font-style: italic; font-size: 11pt; font-family: ''Verdana'';">a</span><span style="font-style: italic; font-size: 11pt; font-family: ''Verdana''; vertical-align: sub;">n</span><span style="font-size: 11pt; font-family: ''Verdana''; vertical-align: sub;">+1</span><span style="font-size: 11pt; font-family: ''Verdana'';">=a</span><span style="font-size: 11pt; font-family: ''Verdana''; vertical-align: sub;">1</span><span style="font-size: 11pt; font-family: ''Verdana'';">&nbsp;and&nbsp;</span><span style="font-style: italic; font-size: 11pt; font-family: ''Verdana'';">a</span><span style="font-style: italic; font-size: 11pt; font-family: ''Verdana''; vertical-align: sub;">n</span><span style="font-size: 11pt; font-family: ''Verdana''; vertical-align: sub;">+2</span><span style="font-size: 11pt; font-family: ''Verdana'';">=a</span><span style="font-size: 11pt; font-family: ''Verdana''; vertical-align: sub;">2</span><span style="font-size: 11pt; font-family: ''Verdana'';">&nbsp;in&nbsp;this&nbsp;formula).</span><br />\r\n	<br />\r\n	<span style="font-size: 11pt; font-family: ''Verdana'';">You&nbsp;are&nbsp;to&nbsp;place&nbsp;the&nbsp;numbers&nbsp;from&nbsp;1&nbsp;through&nbsp;</span><span style="font-style: italic; font-size: 11pt; font-family: ''Verdana'';">n</span><span style="font-size: 11pt; font-family: ''Verdana'';">&nbsp;into&nbsp;the&nbsp;segments&nbsp;in&nbsp;such&nbsp;a&nbsp;way&nbsp;that&nbsp;the&nbsp;total&nbsp;risk&nbsp;</span><span style="font-style: italic; font-size: 11pt; font-family: ''Verdana'';">R</span><span style="font-size: 11pt; font-family: ''Verdana'';">&nbsp;is&nbsp;maximized.</span><span style="font-size: 11pt; font-family: ''Verdana'';"><o:p></o:p></span></p>', 'HUST Monthly 2010.04.05', '<p class="p0" style="margin-bottom: 12pt; margin-top: 0pt; text-align: left; line-height: 15.6pt;">\r\n	<span style="font-size: 11pt; font-family: ''Verdana'';">The&nbsp;input&nbsp;file&nbsp;contains&nbsp;an&nbsp;</span><span style="font-size: 11pt; font-family: ''宋体'';">integer&nbsp;T&nbsp;means&nbsp;there&nbsp;are&nbsp;T&nbsp;cases&nbsp;followed.</span><span style="font-size: 11pt; font-family: ''宋体'';"><o:p></o:p></span></p>\r\n<p class="p0" style="margin-bottom: 12pt; margin-top: 0pt; text-align: left; line-height: 15.6pt;">\r\n	<span style="font-size: 11pt; font-family: ''Verdana'';">T</span><span style="font-size: 11pt; font-family: ''宋体'';">he&nbsp;next&nbsp;T&nbsp;lines:&nbsp;there&nbsp;is&nbsp;an&nbsp;even&nbsp;integer</span><span style="font-size: 11pt; font-family: ''Verdana'';">&nbsp;</span><span style="font-style: italic; font-size: 11pt; font-family: ''Verdana'';">n</span><span style="font-size: 11pt; font-family: ''Verdana'';">&nbsp;(6&nbsp;&le;&nbsp;</span><span style="font-style: italic; font-size: 11pt; font-family: ''Verdana'';">n</span><span style="font-size: 11pt; font-family: ''Verdana'';">&nbsp;&le;&nbsp;100)</span><span style="font-size: 11pt; font-family: ''宋体'';">&nbsp;&nbsp;in&nbsp;each&nbsp;line.</span><span style="font-size: 11pt; font-family: ''宋体'';"><o:p></o:p></span></p>\r\n', '<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 11pt; font-family: ''Verdana'';">Output&nbsp;</span><span style="font-size: 11pt; font-family: ''宋体'';">t</span><span style="font-size: 11pt; font-family: ''Verdana'';">h</span><span style="font-size: 11pt; font-family: ''宋体'';">e&nbsp;MAX(R)</span></p>\r\n', '2\r\n10\r\n6', '461\r\n87\r\n\r\nHINT：\r\nWhen n equals to 10, “ 2 9 7 4 6 5 3 8 10 1”is one of the solutions. It makes R maximized(MAX(R)=461).', '', 0, 0, '2010-08-08 01:42:44', '2010-08-08 01:42:44'),
(107, 1, 'Rubiks', 1000, 33554432, 0000000000, 0000000000, '<p class="p0" style="text-indent: 21pt; margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 10.5pt; font-family: ''宋体'';">Isun&nbsp;is&nbsp;a&nbsp;genius.&nbsp;Not&nbsp;only&nbsp;he&nbsp;is&nbsp;an&nbsp;expert&nbsp;in&nbsp;algorithm,&nbsp;but&nbsp;also&nbsp;he&nbsp;plays&nbsp;damn-good&nbsp;in&nbsp;many&nbsp;funny&nbsp;games.&nbsp;Besides,&nbsp;he&nbsp;can&nbsp;recover&nbsp;a&nbsp;</span><span style="font-size: 10.5pt; font-family: ''Times New Roman'';">Rubik</span><span style="font-size: 10.5pt; font-family: ''宋体'';">&nbsp;in&nbsp;16&nbsp;seconds&nbsp;or&nbsp;even&nbsp;less.&nbsp;The&nbsp;man&nbsp;is&nbsp;very&nbsp;crazy&nbsp;about&nbsp;Rubiks,&nbsp;and&nbsp;he&nbsp;has&nbsp;bought&nbsp;a&nbsp;lot&nbsp;of&nbsp;Rubiks.&nbsp;As&nbsp;we&nbsp;know,&nbsp;there&nbsp;are&nbsp;so&nbsp;many&nbsp;kinds&nbsp;of&nbsp;Rubiks&nbsp;in&nbsp;the&nbsp;world.&nbsp;Isun&nbsp;wants&nbsp;to&nbsp;buy&nbsp;the&nbsp;most&nbsp;valuable&nbsp;ones&nbsp;with&nbsp;his&nbsp;limited&nbsp;money.&nbsp;</span><span style="font-size: 10.5pt; font-family: ''宋体'';"><o:p></o:p></span></p>\r\n<p class="p0" style="text-indent: 21pt; margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 10.5pt; font-family: ''宋体'';">There&nbsp;are&nbsp;N&nbsp;kinds&nbsp;of&nbsp;Rubiks&nbsp;in&nbsp;all.&nbsp;Each&nbsp;of&nbsp;them&nbsp;has&nbsp;a&nbsp;</span><span style="font-weight: bold; font-size: 10.5pt; font-family: ''宋体'';">price</span><span style="font-size: 10.5pt; font-family: ''宋体'';">&nbsp;Pi(1&lt;=i&lt;=N)&nbsp;RMB&nbsp;and&nbsp;a&nbsp;</span><span style="font-weight: bold; font-size: 10.5pt; font-family: ''宋体'';">value</span><span style="font-size: 10.5pt; font-family: ''宋体'';">&nbsp;Vi(1&lt;=i&lt;=N).&nbsp;Isun&nbsp;will&nbsp;pay&nbsp;no&nbsp;more&nbsp;than&nbsp;M&nbsp;(RMB)&nbsp;in&nbsp;total.</span><span style="font-size: 10.5pt; font-family: ''宋体'';"><o:p></o:p></span></p>\r\n<p class="p0" style="text-indent: 21pt; margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 10.5pt; font-family: ''宋体'';">In&nbsp;addition,&nbsp;there&nbsp;are&nbsp;some&nbsp;Rubik&nbsp;families&nbsp;like&nbsp;</span><span style="font-size: 10.5pt; font-family: ''Times New Roman'';">&ldquo;</span><span style="font-size: 10.5pt; font-family: ''宋体'';">甲<font face="Times New Roman">X</font></span><span style="font-size: 10.5pt; font-family: ''Times New Roman'';">&rdquo;</span><span style="font-size: 10.5pt; font-family: ''宋体'';">&nbsp;or&nbsp;</span><span style="font-size: 10.5pt; font-family: ''Times New Roman'';">&ldquo;</span><span style="font-size: 10.5pt; font-family: ''宋体'';">封<font face="Times New Roman">X</font></span><span style="font-size: 10.5pt; font-family: ''Times New Roman'';">&rdquo;</span><span style="font-size: 10.5pt; font-family: ''宋体'';">.&nbsp;And&nbsp;a&nbsp;kind&nbsp;of&nbsp;Rubik&nbsp;belongs&nbsp;to&nbsp;one&nbsp;family&nbsp;at&nbsp;most.&nbsp;If&nbsp;Isun&nbsp;buys&nbsp;a&nbsp;group&nbsp;of&nbsp;them,&nbsp;the&nbsp;value&nbsp;of&nbsp;them&nbsp;as&nbsp;a&nbsp;family&nbsp;will&nbsp;increase.&nbsp;</span><span style="font-size: 10.5pt; font-family: ''宋体'';"><o:p></o:p></span></p>\r\n<p class="p0" style="text-indent: 21pt; margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 10.5pt; font-family: ''宋体'';">Can&nbsp;you&nbsp;get&nbsp;the&nbsp;largest&nbsp;value&nbsp;of&nbsp;the&nbsp;Rubiks&nbsp;that&nbsp;Isun&nbsp;can&nbsp;get&nbsp;with&nbsp;M&nbsp;(RMB).&nbsp;(Isun&nbsp;just&nbsp;buy&nbsp;one&nbsp;Rubik&nbsp;each&nbsp;kind&nbsp;at&nbsp;most)</span><span style="font-size: 10.5pt; font-family: ''宋体'';"><o:p></o:p></span></p>\r\n', 'HUST Monthly 2010.04.05', '<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 10.5pt; font-family: ''Times New Roman'';">The&nbsp;input&nbsp;contains&nbsp;several&nbsp;test&nbsp;cases</span><span style="font-size: 10.5pt; font-family: ''宋体'';">&nbsp;and&nbsp;is&nbsp;</span><span style="font-size: 10.5pt; font-family: ''Times New Roman'';">ended&nbsp;by</span><span style="font-size: 10.5pt; font-family: ''宋体'';">&nbsp;EOF.&nbsp;</span><span style="font-size: 10.5pt; font-family: ''Times New Roman'';">Each&nbsp;test&nbsp;case&nbsp;begins&nbsp;</span><span style="font-size: 10.5pt; font-family: ''宋体'';">with&nbsp;two&nbsp;integers:&nbsp;N&nbsp;(1&lt;=N&lt;=1000)&nbsp;and&nbsp;M&nbsp;(1&lt;=M&lt;=10000).</span><span style="font-size: 10.5pt; font-family: ''宋体'';"><o:p></o:p></span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 10.5pt; font-family: ''Times New Roman'';">T</span><span style="font-size: 10.5pt; font-family: ''宋体'';">he&nbsp;second&nbsp;line&nbsp;</span><span style="font-size: 10.5pt; font-family: ''Times New Roman'';">contains&nbsp;</span><span style="font-size: 10.5pt; font-family: ''宋体'';">N&nbsp;integers&nbsp;</span><span style="font-size: 10.5pt; font-family: ''Times New Roman'';">representing&nbsp;</span><span style="font-size: 10.5pt; font-family: ''宋体'';">the&nbsp;prices&nbsp;of&nbsp;the&nbsp;Rubiks.&nbsp;(1&lt;=Pi&lt;=10000)</span><span style="font-size: 10.5pt; font-family: ''宋体'';"><o:p></o:p></span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 10.5pt; font-family: ''宋体'';">The&nbsp;third&nbsp;line&nbsp;</span><span style="font-size: 10.5pt; font-family: ''Times New Roman'';">contains&nbsp;</span><span style="font-size: 10.5pt; font-family: ''宋体'';">N&nbsp;integers&nbsp;</span><span style="font-size: 10.5pt; font-family: ''Times New Roman'';">representing&nbsp;</span><span style="font-size: 10.5pt; font-family: ''宋体'';">the&nbsp;value&nbsp;of&nbsp;the&nbsp;Rubiks.&nbsp;(1&lt;=Vi&lt;=10000)</span><span style="font-size: 10.5pt; font-family: ''宋体'';"><o:p></o:p></span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 10.5pt; font-family: ''Times New Roman'';">T</span><span style="font-size: 10.5pt; font-family: ''宋体'';">hen&nbsp;a&nbsp;line&nbsp;</span><span style="font-size: 10.5pt; font-family: ''Times New Roman'';">contains&nbsp;</span><span style="font-size: 10.5pt; font-family: ''宋体'';">an&nbsp;integer&nbsp;G(0&lt;=G&lt;=15)&nbsp;</span><span style="font-size: 10.5pt; font-family: ''Times New Roman'';">representing</span><span style="font-size: 10.5pt; font-family: ''宋体'';">&nbsp;the&nbsp;number&nbsp;of&nbsp;the&nbsp;Rubik&nbsp;families.</span><span style="font-size: 10.5pt; font-family: ''宋体'';"><o:p></o:p></span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 10.5pt; font-family: ''Times New Roman'';">N</span><span style="font-size: 10.5pt; font-family: ''宋体'';">ext&nbsp;G&nbsp;lines&nbsp;each&nbsp;with&nbsp;a&nbsp;start&nbsp;of&nbsp;an&nbsp;integer&nbsp;Si(1&lt;=Si&lt;=N)&nbsp;</span><span style="font-size: 10.5pt; font-family: ''Times New Roman'';">representing</span><span style="font-size: 10.5pt; font-family: ''宋体'';">&nbsp;the&nbsp;number&nbsp;of&nbsp;Rubiks&nbsp;in&nbsp;the&nbsp;ith&nbsp;family.&nbsp;</span><span style="font-size: 10.5pt; font-family: ''Times New Roman'';">The&nbsp;following&nbsp;</span><span style="font-size: 10.5pt; font-family: ''宋体'';">Si</span><span style="font-size: 10.5pt; font-family: ''Times New Roman'';">&nbsp;integers&nbsp;represent</span><span style="font-size: 10.5pt; font-family: ''宋体'';">&nbsp;Rubik</span><span style="font-size: 10.5pt; font-family: ''Times New Roman'';">&rsquo;</span><span style="font-size: 10.5pt; font-family: ''宋体'';">s&nbsp;id&nbsp;(which&nbsp;start&nbsp;from&nbsp;1&nbsp;to&nbsp;N).&nbsp;And&nbsp;an&nbsp;integer&nbsp;Yi&nbsp;at&nbsp;the&nbsp;end&nbsp;means&nbsp;the&nbsp;value&nbsp;increased&nbsp;if&nbsp;you&nbsp;buy&nbsp;them&nbsp;all.(1&lt;=Yi&lt;=10000)</span><span style="font-size: 10.5pt; font-family: ''宋体'';"><o:p></o:p></span></p>\r\n', '<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 10.5pt; font-family: ''Times New Roman'';">There&nbsp;should&nbsp;be&nbsp;one&nbsp;line&nbsp;per&nbsp;test&nbsp;case&nbsp;containing&nbsp;the&nbsp;largest&nbsp;</span><span style="font-size: 10.5pt; font-family: ''宋体'';">value</span><span style="font-size: 10.5pt; font-family: ''Times New Roman'';">.</span></p>\r\n', '4 10\r\n4 5 3 6\r\n1 2 100 200\r\n1\r\n2 1 2 330', '333\r\n\r\nHint\r\n	Isun will buy Rubik 1 and Rubik 2, which make up family 1 and get 330 value increased. So they value 333 in all which is the largest value Isun can get with 10 RMB.\r\n', '', 0, 0, '2010-08-08 01:45:20', '2010-08-08 01:45:20');
INSERT INTO `tbl_problems` (`id`, `user_id`, `title`, `time_limit`, `memory_limit`, `submission_no`, `accepted_no`, `description`, `source`, `input`, `output`, `input_sample`, `output_sample`, `hint`, `flag`, `visibility`, `created`, `modified`) VALUES
(108, 1, 'SUPER CHORUS', 1000, 33554432, 0000000000, 0000000000, '<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 12pt; font-family: ''Times New Roman'';">Song&nbsp;is&nbsp;the&nbsp;leader&nbsp;of&nbsp;HUST&nbsp;chorus&nbsp;team.&nbsp;</span><span style="font-size: 12pt; font-family: ''宋体'';">3</span><span style="font-size: 12pt; font-family: ''Times New Roman'';">&nbsp;second&nbsp;before&nbsp;a&nbsp;chorus&nbsp;competition&nbsp;he&nbsp;found&nbsp;his&nbsp;team&nbsp;which&nbsp;was&nbsp;already&nbsp;been&nbsp;arranged&nbsp;in&nbsp;a&nbsp;line&nbsp;was&nbsp;out&nbsp;of&nbsp;order,&nbsp;so&nbsp;he&nbsp;decided&nbsp;to&nbsp;eliminate&nbsp;</span><span style="font-size: 12pt; font-family: ''宋体'';">some</span><span style="font-size: 12pt; font-family: ''Times New Roman'';">&nbsp;people&nbsp;to&nbsp;make&nbsp;sure&nbsp;that&nbsp;those&nbsp;</span><span style="font-size: 12pt; font-family: ''宋体'';">m&nbsp;remaining&nbsp;students</span><span style="font-size: 12pt; font-family: ''Times New Roman'';">&nbsp;are&nbsp;bilateral&nbsp;symmetric&nbsp;in&nbsp;</span><span style="font-size: 12pt; font-family: ''宋体'';">height&nbsp;and&nbsp;gender.(The&nbsp;ith&nbsp;person&nbsp;and&nbsp;the&nbsp;(m-i)th&nbsp;person&nbsp;have&nbsp;the&nbsp;same&nbsp;height&nbsp;and&nbsp;gender.)&nbsp;The&nbsp;person&nbsp;in&nbsp;the&nbsp;middle&nbsp;was&nbsp;the&nbsp;tallest&nbsp;and&nbsp;the&nbsp;height&nbsp;strictly&nbsp;decreased&nbsp;from&nbsp;the&nbsp;middle&nbsp;to&nbsp;both&nbsp;sides.<font face="宋体">（</font><font face="Times New Roman">If&nbsp;m&nbsp;is&nbsp;a&nbsp;even&nbsp;number&nbsp;,then&nbsp;the&nbsp;person&nbsp;in&nbsp;the&nbsp;middle&nbsp;refers&nbsp;to&nbsp;the&nbsp;m/2th&nbsp;and&nbsp;(m/2+1)th&nbsp;student.</font><font face="宋体">）&nbsp;</font><font face="Times New Roman">However,&nbsp;it&nbsp;was&nbsp;too&nbsp;difficult&nbsp;for&nbsp;him&nbsp;so&nbsp;he&nbsp;asked&nbsp;for&nbsp;your&nbsp;help.</font></span></p>\r\n', 'HUST Monthly 2010.04.05', '<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 12pt; font-family: ''Times New Roman'';">Multiple&nbsp;cases,&nbsp;end&nbsp;with&nbsp;EOF.&nbsp;Each&nbsp;case&#39;s&nbsp;first&nbsp;line&nbsp;is&nbsp;a&nbsp;positive&nbsp;integer&nbsp;n(0&lt;=n&lt;=3000)&nbsp;which&nbsp;means&nbsp;the&nbsp;length&nbsp;of&nbsp;the&nbsp;chorus&nbsp;team.&nbsp;n&nbsp;lines&nbsp;followed&nbsp;and&nbsp;each&nbsp;line&nbsp;has&nbsp;two&nbsp;numbers,&nbsp;Hi&nbsp;and&nbsp;Gi.&nbsp;Hi&nbsp;is&nbsp;the&nbsp;height&nbsp;of&nbsp;the&nbsp;ist&nbsp;person.(measured&nbsp;by&nbsp;mm,1650&lt;=Hi&lt;=1900)&nbsp;Gi&nbsp;is&nbsp;the&nbsp;gender&nbsp;of&nbsp;the&nbsp;the&nbsp;ist&nbsp;person.&nbsp;Gi=1&nbsp;means&nbsp;male&nbsp;and&nbsp;Gi=0&nbsp;means&nbsp;female.</span><span style="font-size: 12pt; font-family: ''Times New Roman'';"><o:p></o:p></span></p>\r\n', '<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 12pt; font-family: ''Times New Roman'';">In&nbsp;each&nbsp;case&nbsp;you&nbsp;should&nbsp;output&nbsp;one&nbsp;integer&nbsp;indicating&nbsp;the&nbsp;max&nbsp;number&nbsp;of&nbsp;</span><span style="font-size: 12pt; font-family: ''宋体'';">m.</span><span style="font-size: 12pt; font-family: ''宋体'';"><o:p></o:p></span></p>\r\n', '2\r\n173 1\r\n173 1\r\n3\r\n165 0\r\n170 1\r\n165 0\r\n3\r\n175 0\r\n167 1\r\n175 1', '2\r\n3\r\n1', '', 0, 0, '2010-08-08 01:46:59', '2010-08-08 01:46:59'),
(109, 1, 'Push over', 1000, 33554432, 0000000000, 0000000000, '<p class="p0" style="margin-bottom: 5pt; margin-top: 5pt; text-align: left;">\r\n	<span style="font-size: 12pt; font-family: ''Verdana'';">LL&nbsp;and&nbsp;ErBao&nbsp;</span><span style="font-size: 12pt; font-family: ''宋体'';">were&nbsp;back!!!...along&nbsp;with&nbsp;them&nbsp;was&nbsp;HH.&nbsp;HH&nbsp;was&nbsp;angry&nbsp;about&nbsp;being&nbsp;tricked&nbsp;last&nbsp;time,&nbsp;so&nbsp;he&nbsp;decided&nbsp;to&nbsp;push&nbsp;them&nbsp;over&nbsp;this&nbsp;time.&nbsp;On&nbsp;this&nbsp;beautiful&nbsp;Sunday,&nbsp;LL&nbsp;and&nbsp;ErBao&nbsp;were&nbsp;playing&nbsp;</span><span style="font-size: 12pt; font-family: ''Verdana'';">&ldquo;</span><span style="font-size: 12pt; font-family: ''宋体'';">Duo&nbsp;Mao&nbsp;Mao</span><span style="font-size: 12pt; font-family: ''Verdana'';">&rdquo;</span><span style="font-size: 12pt; font-family: ''宋体'';">&nbsp;and&nbsp;HH&nbsp;saw&nbsp;his&nbsp;chances&nbsp;come.&nbsp;At&nbsp;this&nbsp;time,&nbsp;LL&nbsp;was&nbsp;counting&nbsp;numbers&nbsp;blindfolded&nbsp;at&nbsp;point&nbsp;</span><span style="font-weight: bold; font-size: 12pt; font-family: ''宋体'';">A</span><span style="font-size: 12pt; font-family: ''宋体'';">,&nbsp;and&nbsp;ErBao&nbsp;stood&nbsp;at&nbsp;point&nbsp;</span><span style="font-weight: bold; font-size: 12pt; font-family: ''宋体'';">B</span><span style="font-size: 12pt; font-family: ''宋体'';">&nbsp;a&nbsp;distance&nbsp;from&nbsp;LL.&nbsp;HH&nbsp;is&nbsp;standing&nbsp;at&nbsp;point&nbsp;</span><span style="font-weight: bold; font-size: 12pt; font-family: ''宋体'';">S</span><span style="font-size: 12pt; font-family: ''宋体'';">.&nbsp;Now&nbsp;HH&nbsp;wanted&nbsp;to&nbsp;push&nbsp;them&nbsp;over&nbsp;one&nbsp;by&nbsp;one&nbsp;(in&nbsp;any&nbsp;order),&nbsp;and&nbsp;escape&nbsp;to&nbsp;point&nbsp;</span><span style="font-weight: bold; font-size: 12pt; font-family: ''宋体'';">T</span><span style="font-size: 12pt; font-family: ''宋体'';">&nbsp;immediately.&nbsp;There&nbsp;are&nbsp;no&nbsp;obstacles.&nbsp;</span><span style="font-size: 12pt; font-family: ''宋体'';"><o:p></o:p></span></p>\r\n<p class="p0" style="margin-bottom: 5pt; margin-top: 5pt; text-align: left;">\r\n	<span style="font-size: 12pt; font-family: ''宋体'';">Here&nbsp;comes&nbsp;the&nbsp;problem.&nbsp;Since&nbsp;it&nbsp;had&nbsp;just&nbsp;snowed,&nbsp;the&nbsp;ground&nbsp;was&nbsp;very&nbsp;s</span><span style="font-size: 12pt; font-family: ''Verdana'';">lippery</span><span style="font-size: 12pt; font-family: ''宋体'';">.&nbsp;Since&nbsp;HH&nbsp;wanted&nbsp;to&nbsp;do&nbsp;it&nbsp;quickly,&nbsp;the&nbsp;r</span><span style="font-size: 12pt; font-family: ''Verdana'';">adius&nbsp;of&nbsp;curvature</span><span style="font-size: 12pt; font-family: ''宋体'';">&nbsp;on&nbsp;any&nbsp;point&nbsp;of&nbsp;his&nbsp;path&nbsp;couldn</span><span style="font-size: 12pt; font-family: ''Verdana'';">&rsquo;</span><span style="font-size: 12pt; font-family: ''宋体'';">t&nbsp;be&nbsp;too&nbsp;large,&nbsp;in&nbsp;particular,&nbsp;not&nbsp;larger&nbsp;than&nbsp;</span><span style="font-weight: bold; font-size: 12pt; font-family: ''宋体'';">R</span><span style="font-size: 12pt; font-family: ''宋体'';">.&nbsp;In&nbsp;order&nbsp;to&nbsp;</span><span style="font-size: 12pt; font-family: ''Verdana'';">surprise</span><span style="font-size: 12pt; font-family: ''宋体'';">&nbsp;them&nbsp;suddenly,&nbsp;HH&nbsp;decided&nbsp;to&nbsp;push&nbsp;them&nbsp;over&nbsp;from&nbsp;their&nbsp;back&nbsp;side,&nbsp;which&nbsp;means&nbsp;HH&nbsp;must&nbsp;face&nbsp;the&nbsp;same&nbsp;direction&nbsp;with&nbsp;</span><span style="font-size: 12pt; font-family: ''Verdana'';">the</span><span style="font-size: 12pt; font-family: ''宋体'';">&nbsp;push-over&nbsp;object&nbsp;when&nbsp;he&nbsp;passed&nbsp;through&nbsp;the&nbsp;pushing&nbsp;point.&nbsp;Please&nbsp;help&nbsp;HH&nbsp;plan&nbsp;a&nbsp;path&nbsp;satisfying&nbsp;the&nbsp;above&nbsp;restriction&nbsp;with&nbsp;the&nbsp;</span><span style="font-size: 12pt; font-family: ''Verdana'';">minimum</span><span style="font-size: 12pt; font-family: ''宋体'';">&nbsp;total&nbsp;length.&nbsp;For&nbsp;simplicity,&nbsp;you&nbsp;should&nbsp;only&nbsp;calculate&nbsp;the&nbsp;length&nbsp;of&nbsp;this&nbsp;path.</span><span style="font-size: 12pt; font-family: ''宋体'';"><o:p></o:p></span></p>\r\n', 'HUST Monthly 2010.04.05', '<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt; text-align: left;">\r\n	<span style="font-size: 12pt; font-family: ''Verdana'';">The&nbsp;input&nbsp;contains&nbsp;multiple&nbsp;cases&nbsp;</span><span style="font-size: 12pt; font-family: ''宋体'';">separated&nbsp;by&nbsp;a&nbsp;blank&nbsp;line&nbsp;</span><span style="font-size: 12pt; font-family: ''Verdana'';">terminated&nbsp;with&nbsp;EOF.</span><span style="font-size: 12pt; font-family: ''Verdana'';"><o:p></o:p></span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt; text-align: left;">\r\n	<span style="font-size: 12pt; font-family: ''Verdana'';">For&nbsp;each&nbsp;case,&nbsp;first&nbsp;line&nbsp;contains&nbsp;</span><span style="font-size: 12pt; font-family: ''宋体'';">one</span><span style="font-size: 12pt; font-family: ''Verdana'';">&nbsp;integer:&nbsp;</span><span style="font-weight: bold; font-size: 12pt; font-family: ''宋体'';">R</span><span style="font-size: 12pt; font-family: ''Verdana'';">.</span><span style="font-size: 12pt; font-family: ''宋体'';"><o:p></o:p></span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt; text-align: left;">\r\n	<span style="font-size: 12pt; font-family: ''宋体'';">Then&nbsp;four&nbsp;lines&nbsp;describes&nbsp;coordinates&nbsp;of&nbsp;</span><span style="font-weight: bold; font-size: 12pt; font-family: ''宋体'';">S</span><span style="font-size: 12pt; font-family: ''宋体'';">,&nbsp;</span><span style="font-weight: bold; font-size: 12pt; font-family: ''宋体'';">A</span><span style="font-size: 12pt; font-family: ''宋体'';">,&nbsp;</span><span style="font-weight: bold; font-size: 12pt; font-family: ''宋体'';">B</span><span style="font-size: 12pt; font-family: ''宋体'';">,&nbsp;and&nbsp;</span><span style="font-weight: bold; font-size: 12pt; font-family: ''宋体'';">T.</span><span style="font-weight: bold; font-size: 12pt; font-family: ''宋体'';"><o:p></o:p></span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt; text-align: left;">\r\n	<span style="font-size: 12pt; font-family: ''Verdana'';">X</span><span style="font-size: 12pt; font-family: ''宋体''; vertical-align: sub;">S</span><span style="font-size: 12pt; font-family: ''Verdana'';">,&nbsp;Y</span><span style="font-size: 12pt; font-family: ''宋体''; vertical-align: sub;">S</span><span style="font-size: 12pt; font-family: ''宋体''; vertical-align: sub;"><o:p></o:p></span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt; text-align: left;">\r\n	<span style="font-size: 12pt; font-family: ''Verdana'';">X</span><span style="font-size: 12pt; font-family: ''宋体''; vertical-align: sub;">A</span><span style="font-size: 12pt; font-family: ''Verdana'';">,&nbsp;Y</span><span style="font-size: 12pt; font-family: ''宋体''; vertical-align: sub;">A</span><span style="font-size: 12pt; font-family: ''Verdana'';">,</span><span style="font-size: 12pt; font-family: ''宋体'';">&nbsp;DX</span><span style="font-size: 12pt; font-family: ''宋体''; vertical-align: sub;">A</span><span style="font-size: 12pt; font-family: ''Verdana'';">,</span><span style="font-size: 12pt; font-family: ''宋体'';">&nbsp;DY</span><span style="font-size: 12pt; font-family: ''宋体''; vertical-align: sub;">A</span><span style="font-size: 12pt; font-family: ''宋体''; vertical-align: sub;"><o:p></o:p></span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt; text-align: left;">\r\n	<span style="font-size: 12pt; font-family: ''Verdana'';">X</span><span style="font-size: 12pt; font-family: ''宋体''; vertical-align: sub;">B</span><span style="font-size: 12pt; font-family: ''Verdana'';">,&nbsp;Y</span><span style="font-size: 12pt; font-family: ''宋体''; vertical-align: sub;">B</span><span style="font-size: 12pt; font-family: ''Verdana'';">,</span><span style="font-size: 12pt; font-family: ''宋体'';">&nbsp;DX</span><span style="font-size: 12pt; font-family: ''宋体''; vertical-align: sub;">B</span><span style="font-size: 12pt; font-family: ''Verdana'';">,</span><span style="font-size: 12pt; font-family: ''宋体'';">&nbsp;DY</span><span style="font-size: 12pt; font-family: ''宋体''; vertical-align: sub;">B</span><span style="font-size: 12pt; font-family: ''宋体''; vertical-align: sub;"><o:p></o:p></span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt; text-align: left;">\r\n	<span style="font-size: 12pt; font-family: ''Verdana'';">X</span><span style="font-size: 12pt; font-family: ''宋体''; vertical-align: sub;">T</span><span style="font-size: 12pt; font-family: ''Verdana'';">,&nbsp;Y</span><span style="font-size: 12pt; font-family: ''宋体''; vertical-align: sub;">T</span><span style="font-size: 12pt; font-family: ''宋体''; vertical-align: sub;"><o:p></o:p></span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt; text-align: left;">\r\n	<span style="font-size: 12pt; font-family: ''宋体'';">DX&nbsp;and&nbsp;DY&nbsp;stands&nbsp;for&nbsp;the&nbsp;direction&nbsp;LL&nbsp;and&nbsp;ErBao&nbsp;faced&nbsp;to.</span><span style="font-size: 12pt; font-family: ''宋体'';"><o:p></o:p></span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt; text-align: left;">\r\n	<span style="font-size: 12pt; font-family: ''宋体'';">All&nbsp;</span><span style="font-size: 12pt; font-family: ''Verdana'';">the&nbsp;</span><span style="font-size: 12pt; font-family: ''宋体'';">values</span><span style="font-size: 12pt; font-family: ''Verdana'';">&nbsp;</span><span style="font-size: 12pt; font-family: ''宋体'';">are&nbsp;integers&nbsp;and&nbsp;the&nbsp;</span><span style="font-size: 12pt; font-family: ''Verdana'';">absolute</span><span style="font-size: 12pt; font-family: ''宋体'';">&nbsp;value&nbsp;of&nbsp;them&nbsp;will&nbsp;not&nbsp;</span><span style="font-size: 12pt; font-family: ''Verdana'';">exceed&nbsp;</span><span style="font-size: 12pt; font-family: ''宋体'';">100</span><span style="font-size: 12pt; font-family: ''Verdana'';">.</span><span style="font-size: 12pt; font-family: ''宋体'';"><o:p></o:p></span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt; text-align: left;">\r\n	<span style="font-size: 12pt; font-family: ''宋体'';">It&nbsp;is&nbsp;guaranteed&nbsp;that&nbsp;the&nbsp;distance&nbsp;</span><span style="font-size: 12pt; font-family: ''Verdana'';">between</span><span style="font-size: 12pt; font-family: ''宋体'';">&nbsp;any&nbsp;two&nbsp;of&nbsp;</span><span style="font-weight: bold; font-size: 12pt; font-family: ''宋体'';">S</span><span style="font-size: 12pt; font-family: ''宋体'';">,</span><span style="font-weight: bold; font-size: 12pt; font-family: ''宋体'';">&nbsp;A</span><span style="font-size: 12pt; font-family: ''宋体'';">,</span><span style="font-weight: bold; font-size: 12pt; font-family: ''宋体'';">&nbsp;B</span><span style="font-size: 12pt; font-family: ''宋体'';">,&nbsp;and&nbsp;</span><span style="font-weight: bold; font-size: 12pt; font-family: ''宋体'';">T</span><span style="font-size: 12pt; font-family: ''宋体'';">&nbsp;is&nbsp;larger&nbsp;than&nbsp;0</span><span style="font-weight: bold; font-size: 12pt; font-family: ''宋体'';">.</span><span style="font-weight: bold; font-size: 12pt; font-family: ''宋体'';"><o:p></o:p></span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt; text-align: left;">\r\n	<span style="font-size: 12pt; font-family: ''Verdana'';">You</span><span style="font-size: 12pt; font-family: ''宋体'';">&nbsp;can&nbsp;assume&nbsp;the&nbsp;push&nbsp;action&nbsp;do&nbsp;not&nbsp;affect&nbsp;the&nbsp;movement&nbsp;of&nbsp;HH.</span><span style="font-size: 12pt; font-family: ''宋体'';"><o:p></o:p></span></p>\r\n', '<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 12pt; font-family: ''Verdana'';">For&nbsp;each&nbsp;case&nbsp;output&nbsp;the&nbsp;</span><span style="font-size: 12pt; font-family: ''宋体'';">length&nbsp;of&nbsp;the&nbsp;shortest&nbsp;path&nbsp;for&nbsp;HH,&nbsp;</span><span style="font-size: 12pt; font-family: ''Verdana'';">accurate&nbsp;to&nbsp;two&nbsp;decimal&nbsp;place</span><span style="font-size: 12pt; font-family: ''宋体'';">s.</span><span style="font-size: 12pt; font-family: ''Verdana'';"> </span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	&nbsp;</p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 12pt; font-family: ''Verdana'';">Hint</span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 12pt; font-family: ''Verdana'';"><img alt="" src="/joj/userfiles/admin/0/PushOver-1888.png" style="width: 643px; height: 20px;" /></span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt; text-align: center;">\r\n	&nbsp;</p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 12pt; font-family: ''Verdana'';">S</span><span style="font-size: 12pt; font-family: ''宋体'';">ample&nbsp;#1</span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 12pt; font-family: ''宋体'';"><img alt="" src="/joj/userfiles/admin/0/PushOver-1932.png" style="width: 298px; height: 385px;" /></span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 12pt; font-family: ''Verdana'';">S</span><span style="font-size: 12pt; font-family: ''宋体'';">ample&nbsp;#2</span><span style="font-size: 12pt; font-family: ''宋体'';"><o:p></o:p></span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 12pt; font-family: ''宋体'';"><img alt="" src="/joj/userfiles/admin/0/PushOver-1977.png" style="width: 292px; height: 439px;" /></span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 12pt; font-family: ''Verdana'';">S</span><span style="font-size: 12pt; font-family: ''宋体'';">ample&nbsp;#3</span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 12pt; font-family: ''宋体'';"><img alt="" src="/joj/userfiles/admin/0/PushOver-2021.png" style="width: 343px; height: 343px;" /></span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 12pt; font-family: ''Verdana'';">S</span><span style="font-size: 12pt; font-family: ''宋体'';">ample&nbsp;#4</span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 12pt; font-family: ''宋体'';"><o:p></o:p></span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 12pt; font-family: ''宋体'';"><o:p></o:p></span></p>\r\n', '1\r\n0 0\r\n1 0 1 0\r\n2 0 1 0\r\n3 0\r\n\r\n1\r\n0 0\r\n1 0 -1 0\r\n2 0 -1 0\r\n3 0\r\n\r\n1\r\n0 0\r\n1 0 1 0\r\n1 3 -1 0\r\n0 3\r\n\r\n1\r\n0 0\r\n1 1 0 1\r\n0 2 -1 0\r\n-1 1', '3.00\r\n13.14\r\n6.14\r\n4.71', '', 0, 0, '2010-08-08 01:54:26', '2010-08-08 01:54:26'),
(110, 1, 'The XLPT Registration System', 1000, 33554432, 0000000000, 0000000000, '<p>\r\n	One day, INFINITE_Li decided to attend the XLPT exam. Then he visited the XLPT registration website and register his information. He found the registration system for XLPT is very interesting, and decided to write a program to simulate the system. But, it is well known that he is poor at programming. So he turns to you and asks for your help.<br />\r\n	<br />\r\n	There are 3 steps to register for XLPT exam:<br />\r\n	<br />\r\n	1. register your personal information on the website.<br />\r\n	2. choose a test center to take the exam.<br />\r\n	3. pay for the exam.<br />\r\n	<br />\r\n	All the test centers has a capacity K, which means the amount of the students that chosen this center must not excceed K at the same time.<br />\r\n	<br />\r\n	in more details, there are 4 kinds of request for the system:<br />\r\n	<br />\r\n	REG student_name<br />\r\n	GET student_name test_center_name<br />\r\n	PAY student_name<br />\r\n	CAL student_name<br />\r\n	<br />\r\n	REG is the request for step 1 above, GET is for step 2, and PAY is for step 3. The CAL request means the student want to rechoose a test center to take the exam, the system should will delete his name from his current chosen test center&#39;s namelist.<br />\r\n	<br />\r\n	What&#39;s more, if you had chosen your test center and didn&#39;t pay for the exam for T seconds, the system will delete your name from the namelist of the test center automatically. There are 4 more rules below:<br />\r\n	<br />\r\n	1. the REG request is always the first request of an student, and one student will register only once.<br />\r\n	2. if a person chose a test center and didn&#39;t use CAL to cancel that he could&#39;t choose another test center.<br />\r\n	3. if a person chosed a test center and paid for the exam, then he couldn&#39;t cancel that anyway.<br />\r\n	4. before you pay, your name must be in a test center&#39;s namelist<br />\r\n	<br />\r\n	All illegal requests will be ignored.<br />\r\n	<br />\r\n	now given all the requests, you are to determine where the paid student will take the exam.<br />\r\n	&nbsp;</p>\r\n', 'HUST Monthly 2010.04.05', '<p>\r\n	There are less than 10 test cases. For each test case there are 3 integers in the first line: N K T (N &lt;= 50000). Then N lines, each line contains an request in the follow form:<br />\r\n	<br />\r\n	TIME REQ student_name [test_center_name]<br />\r\n	<br />\r\n	TIME is the time that the request will be processed by the system, and it is guaranteed it will be ascending in the input.<br />\r\n	<br />\r\n	note that only GET request contains &quot;test_center_name&quot;<br />\r\n	the length of student_name and test_center_name will not excceed 20.<br />\r\n	&nbsp;</p>\r\n', '<p>\r\n	for each test case print &quot;Case #i:&quot; in a line first, i means the case number. Then print a list that contains all the paid person and his chosen test center in the &quot;student_name test_center_name&quot; form, one item per line. the list should be sorted in alphabetical order according to student_name.<br />\r\n	<br />\r\n	print a blank line after each test case<br />\r\n	&nbsp;</p>\r\n', '6 1 100\r\n10  REG INFINITE_Li \r\n20  GET INFINITE_Li    HUST\r\n120 PAY INFINITE_Li\r\n210 REG frederic\r\n220 GET frederic       HUST\r\n319 PAY frederic\r\n\r\n8 1 100\r\n10  REG INFINITE_Li \r\n20  GET INFINITE_Li    HUST\r\n119 PAY INFINITE_Li\r\n210 REG frederic\r\n220 GET frederic       HUST\r\n315 CAL frederic\r\n316 GET frederic       HUSTCS\r\n319 PAY frederic\r\n\r\n12 2 1000\r\n10 REG frederic\r\n20 REG amamiya_yuuko\r\n30 GET amamiya_yuuko   otoha\r\n40 REG miyamura_miyako\r\n50 GET miyamura_miyako otoha\r\n60 GET frederic        otoha\r\n70 REG yuri   \r\n80 GET yuri            SSS\r\n90 PAY frederic\r\n100 PAY amamiya_yuuko\r\n110 PAY miyamura_miyako \r\n120 PAY yuri\r\n', 'Case #1:\r\nfrederic HUST\r\n\r\nCase #2:\r\nINFINITE_Li HUST\r\nfrederic HUSTCS\r\n\r\nCase #3:\r\namamiya_yuuko otoha\r\nmiyamura_miyako otoha\r\nyuri SSS\r\n', '', 0, 0, '2010-08-08 01:56:30', '2010-08-08 01:56:30'),
(111, 1, 'Substitution cipher', 1000, 33554432, 0000000000, 0000000000, '<p class="p0" style="margin-bottom: 5pt; margin-top: 5pt; text-align: left;">\r\n	<span style="font-size: 12pt; font-family: ''宋体'';">Last&nbsp;few&nbsp;months&nbsp;ago,&nbsp;I&nbsp;enjoyed&nbsp;Challenge&nbsp;problems&nbsp;in&nbsp;hacker.org,&nbsp;in&nbsp;which&nbsp;there&nbsp;are&nbsp;many&nbsp;c</span><span style="font-size: 12pt; font-family: ''Verdana'';">ryptography</span><span style="font-size: 12pt; font-family: ''宋体'';">&nbsp;problems.&nbsp;Among&nbsp;these&nbsp;problems&nbsp;there&nbsp;are&nbsp;many&nbsp;using&nbsp;s</span><span style="font-size: 12pt; font-family: ''Verdana'';">ubstitution&nbsp;cipher</span><span style="font-size: 12pt; font-family: ''宋体'';">&nbsp;method.&nbsp;To&nbsp;know&nbsp;more&nbsp;about&nbsp;it,&nbsp;I&nbsp;went&nbsp;to&nbsp;</span><span style="font-size: 12pt; font-family: ''Verdana'';">Wikipedia</span><span style="font-size: 12pt; font-family: ''宋体'';">:&nbsp;</span><span style="font-size: 12pt; font-family: ''宋体'';"><o:p></o:p></span></p>\r\n<p class="p0" style="margin-bottom: 5pt; margin-top: 5pt; text-align: left;">\r\n	<span style="font-style: italic; font-size: 12pt; font-family: ''宋体'';">I</span><span style="font-style: italic; font-size: 12pt; font-family: ''Verdana'';">n&nbsp;cryptography,&nbsp;a&nbsp;substitution&nbsp;cipher&nbsp;is&nbsp;a&nbsp;method&nbsp;of&nbsp;encryption&nbsp;by&nbsp;which&nbsp;units&nbsp;of&nbsp;plaintext&nbsp;are&nbsp;replaced&nbsp;with&nbsp;ciphertext&nbsp;according&nbsp;to&nbsp;a&nbsp;regular&nbsp;system;&nbsp;the&nbsp;&quot;units&quot;&nbsp;may&nbsp;be&nbsp;single&nbsp;letters&nbsp;(the&nbsp;most&nbsp;common),&nbsp;pairs&nbsp;of&nbsp;letters,&nbsp;triplets&nbsp;of&nbsp;letters,&nbsp;mixtures&nbsp;of&nbsp;the&nbsp;above,&nbsp;and&nbsp;so&nbsp;forth.&nbsp;The&nbsp;receiver&nbsp;deciphers&nbsp;the&nbsp;text&nbsp;by&nbsp;performing&nbsp;an&nbsp;inverse&nbsp;substitution.</span><span style="font-style: italic; font-size: 12pt; font-family: ''Verdana'';"><o:p></o:p></span></p>\r\n<p class="p0" style="margin-bottom: 5pt; margin-top: 5pt; text-align: left;">\r\n	<span style="font-style: italic; font-size: 12pt; font-family: ''Verdana'';">Substitution&nbsp;ciphers&nbsp;can&nbsp;be&nbsp;compared&nbsp;with&nbsp;transposition&nbsp;ciphers.&nbsp;In&nbsp;a&nbsp;transposition&nbsp;cipher,&nbsp;the&nbsp;units&nbsp;of&nbsp;the&nbsp;plaintext&nbsp;are&nbsp;rearranged&nbsp;in&nbsp;a&nbsp;different&nbsp;and&nbsp;usually&nbsp;quite&nbsp;complex&nbsp;order,&nbsp;but&nbsp;the&nbsp;units&nbsp;themselves&nbsp;are&nbsp;left&nbsp;unchanged.&nbsp;By&nbsp;contrast,&nbsp;in&nbsp;a&nbsp;substitution&nbsp;cipher,&nbsp;the&nbsp;units&nbsp;of&nbsp;the&nbsp;plaintext&nbsp;are&nbsp;retained&nbsp;in&nbsp;the&nbsp;same&nbsp;sequence&nbsp;in&nbsp;the&nbsp;ciphertext,&nbsp;but&nbsp;the&nbsp;units&nbsp;themselves&nbsp;are&nbsp;altered.</span><span style="font-style: italic; font-size: 12pt; font-family: ''Verdana'';"><o:p></o:p></span></p>\r\n<p class="p0" style="margin-bottom: 5pt; margin-top: 5pt; text-align: left;">\r\n	<span style="font-style: italic; font-size: 12pt; font-family: ''Verdana'';">There&nbsp;are&nbsp;a&nbsp;number&nbsp;of&nbsp;different&nbsp;types&nbsp;of&nbsp;substitution&nbsp;cipher.&nbsp;If&nbsp;the&nbsp;cipher&nbsp;operates&nbsp;on&nbsp;single&nbsp;letters,&nbsp;it&nbsp;is&nbsp;termed&nbsp;a</span><span style="font-weight: bold; font-style: italic; font-size: 12pt; font-family: ''Verdana'';">&nbsp;simple&nbsp;substitution&nbsp;cipher</span><span style="font-style: italic; font-size: 12pt; font-family: ''Verdana'';">;&nbsp;a&nbsp;cipher&nbsp;that&nbsp;operates&nbsp;on&nbsp;larger&nbsp;groups&nbsp;of&nbsp;letters&nbsp;is&nbsp;termed&nbsp;</span><span style="font-weight: bold; font-style: italic; font-size: 12pt; font-family: ''Verdana'';">polygraphic</span><span style="font-style: italic; font-size: 12pt; font-family: ''Verdana'';">.&nbsp;A&nbsp;</span><span style="font-weight: bold; font-style: italic; font-size: 12pt; font-family: ''Verdana'';">monoalphabetic&nbsp;cipher</span><span style="font-style: italic; font-size: 12pt; font-family: ''Verdana'';">&nbsp;uses&nbsp;fixed&nbsp;substitution&nbsp;over&nbsp;the&nbsp;entire&nbsp;message,&nbsp;whereas&nbsp;a&nbsp;</span><span style="font-weight: bold; font-style: italic; font-size: 12pt; font-family: ''Verdana'';">polyalphabetic&nbsp;cipher</span><span style="font-style: italic; font-size: 12pt; font-family: ''Verdana'';">&nbsp;uses&nbsp;a&nbsp;number&nbsp;of&nbsp;substitutions&nbsp;at&nbsp;different&nbsp;times&nbsp;in&nbsp;the&nbsp;message,&nbsp;where&nbsp;a&nbsp;unit&nbsp;from&nbsp;the&nbsp;plaintext&nbsp;is&nbsp;mapped&nbsp;to&nbsp;one&nbsp;of&nbsp;several&nbsp;possibilities&nbsp;in&nbsp;the&nbsp;</span><span style="font-style: italic; font-size: 12pt; font-family: ''宋体'';">C</span><span style="font-style: italic; font-size: 12pt; font-family: ''Verdana'';">iphertext&nbsp;and&nbsp;vice-versa.</span><span style="font-weight: bold; font-style: italic; font-size: 12pt; font-family: ''Verdana'';">&nbsp;</span><span style="font-weight: bold; font-style: italic; font-size: 12pt; font-family: ''宋体'';"><o:p></o:p></span></p>\r\n<p class="p0" style="margin-bottom: 5pt; margin-top: 5pt; text-align: left;">\r\n	<span style="font-size: 12pt; font-family: ''宋体'';">This&nbsp;time&nbsp;I&nbsp;give&nbsp;you&nbsp;such&nbsp;a&nbsp;problem,&nbsp;in&nbsp;which&nbsp;</span><span style="font-weight: bold; font-size: 12pt; font-family: ''Verdana'';">Description</span><span style="font-size: 12pt; font-family: ''宋体'';">,&nbsp;</span><span style="font-weight: bold; font-size: 12pt; font-family: ''Verdana'';">Input</span><span style="font-size: 12pt; font-family: ''宋体'';">,&nbsp;</span><span style="font-weight: bold; font-size: 12pt; font-family: ''Verdana'';">Output</span><span style="font-size: 12pt; font-family: ''宋体'';">,&nbsp;</span><span style="font-weight: bold; font-size: 12pt; font-family: ''Verdana'';">Sample</span><span style="font-size: 12pt; font-family: ''Verdana'';">&nbsp;</span><span style="font-weight: bold; font-size: 12pt; font-family: ''Verdana'';">Input</span><span style="font-size: 12pt; font-family: ''宋体'';">&nbsp;are&nbsp;all&nbsp;ciphertext,&nbsp;whereas&nbsp;</span><span style="font-weight: bold; font-size: 12pt; font-family: ''Verdana'';">Sample</span><span style="font-size: 12pt; font-family: ''Verdana'';">&nbsp;</span><span style="font-weight: bold; font-size: 12pt; font-family: ''Verdana'';">Output</span><span style="font-size: 12pt; font-family: ''宋体'';">&nbsp;is&nbsp;using&nbsp;plaintext.&nbsp;Of&nbsp;course,&nbsp;this&nbsp;problem&nbsp;is&nbsp;</span><span style="font-size: 12pt; font-family: ''Verdana'';">using</span><span style="font-size: 12pt; font-family: ''宋体'';">&nbsp;</span><span style="font-size: 12pt; font-family: ''Verdana'';">simple&nbsp;substitution&nbsp;cipher</span><span style="font-size: 12pt; font-family: ''宋体'';">&nbsp;and&nbsp;</span><span style="font-size: 12pt; font-family: ''Verdana'';">monoalphabetic&nbsp;cipher</span><span style="font-size: 12pt; font-family: ''宋体'';">.</span><span style="font-size: 12pt; font-family: ''宋体'';"><o:p></o:p></span></p>\r\n<p class="p0" style="margin-bottom: 5pt; margin-top: 5pt; text-align: left;">\r\n	<span style="font-size: 12pt; font-family: ''宋体'';">To&nbsp;solve&nbsp;</span><span style="font-size: 12pt; font-family: ''Verdana'';">monoalphabetic&nbsp;cipher&nbsp;</span><span style="font-size: 12pt; font-family: ''宋体'';">efficiently,&nbsp;you&nbsp;can&nbsp;refer&nbsp;to&nbsp;</span><span style="font-style: italic; font-size: 12pt; font-family: ''Verdana'';">http://www.secretcodebreaker.com/SCBSolvr.zip</span><span style="font-style: italic; font-size: 12pt; font-family: ''宋体'';"><o:p></o:p></span></p>\r\n', 'HUST Monthly 2010.04.05', '<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt; text-align: left;">\r\n	<span style="font-size: 12pt; font-family: ''宋体'';">The&nbsp;input&nbsp;contains&nbsp;multiple&nbsp;cases.&nbsp;Each&nbsp;case&nbsp;has&nbsp;only&nbsp;one&nbsp;line&nbsp;-&nbsp;c</span><span style="font-size: 12pt; font-family: ''宋体'';">iphertext&nbsp;with&nbsp;no&nbsp;more&nbsp;than&nbsp;100&nbsp;characters.</span><span style="font-size: 12pt; font-family: ''宋体'';"><o:p></o:p></span></p>\r\n<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt; text-align: left;">\r\n	<span style="font-size: 12pt; font-family: ''宋体'';">In&nbsp;each&nbsp;</span><span style="font-size: 12pt; font-family: ''宋体'';">c</span><span style="font-size: 12pt; font-family: ''宋体'';">iphertext,&nbsp;there&nbsp;are&nbsp;only&nbsp;lower&nbsp;letters&nbsp;and&nbsp;spaces.</span><span style="font-size: 12pt; font-family: ''宋体'';"><o:p></o:p></span></p>\r\n', '<p class="p0" style="margin-bottom: 0pt; margin-top: 0pt;">\r\n	<span style="font-size: 12pt; font-family: ''宋体'';">For&nbsp;each&nbsp;case,&nbsp;output&nbsp;one&nbsp;line&nbsp;-&nbsp;the&nbsp;</span><span style="font-size: 12pt; font-family: ''Verdana'';">plaintext</span><span style="font-size: 12pt; font-family: ''宋体'';">&nbsp;corresponding&nbsp;to&nbsp;the&nbsp;input.&nbsp;Remember&nbsp;that&nbsp;leave&nbsp;spaces&nbsp;alone. </span></p>\r\n', 'g g g', 'q q q', '', 0, 0, '2010-08-08 01:58:15', '2010-08-08 01:58:15'),
(112, 1, 'Arbiter', 1000, 33554432, 0000000000, 0000000000, '<p>\r\n	Arbiter is a kind of starship in the StarCraft science-fiction series. The Arbiter-class starship is a Protoss warship specializing in providing psychic support. Arbiters were crewed exclusively by Judicators; unlike other warships that were manned predominantly by Templar. The Judicator used the Arbiter as a base to provide support using space-time manipulation.<br />\r\n	Arbiters could weaken space-time, tearing rifts in the fabric of space-time, creating a vortex linking another location to the Arbiter&rsquo;s location. This could be used to move personnel over long distances between stars.<br />\r\n	In the meantime of widely used Arbiter to transfer, KMXS, the captain of one Arbiter, was warning that some person had got a serious mental disorder after the trip on his Arbiter. By using mice as model animals, he found the sake, it&rsquo;s because of chirality!<br />\r\n	Every person has chirality, either left-handed or right-handed. Actually all the persons must live with the food which has the same chirality. When one person took Arbiter from one star to another one, his chirality will be changed (from left-handed to right-handed or from right-handed to left-handed). If a person took a long trip and finally got back to his own star, however, his chirality might be changed to the opposite state other than his original, which would cause fatal mental disorder, or even death.<br />\r\n	KMXS has the channels map among the starts and he need to prohibit minimum number of channels from traveling so that wherever a person starts his traveling from when he gets his original star he&rsquo;ll be safe. KMXS turns to your help</p>\r\n', '2009 Asia Wuhan Regional Contest Online ', '<p>\r\n	The first line of input consists of an integer T, indicating the number of test cases.<br />\r\n	The first line of each case consists of two integers N and M, indicating the number of stars and the number of channels. Each of the next M lines indicates one channel (u, v) which means there is a bidirectional channel between star u and star v (u is not equal to v).</p>\r\n', '<p>\r\n	Output one integer on a single line for each case, indicating the minimum number of channels KMXS must prohibit to avoid mental disorder.<br />\r\n	<br />\r\n	Constraints<br />\r\n	0 &lt; T &lt;= 10<br />\r\n	0 &lt;= N &lt;= 15 0 &lt;= M &lt;= 300<br />\r\n	0 &lt;= u, v &lt; N and there may be more than one channel between two stars.</p>\r\n', '1\r\n3 3\r\n0 1\r\n1 2\r\n2 0', '1', '', 0, 0, '2010-08-08 02:29:47', '2010-08-08 02:29:47'),
(113, 1, 'ChaeYeon', 1000, 33554432, 0000000000, 0000000000, '<p>\r\n	Chae Yeon is a popular pop female singer who rose to fame with her amazing sexy dance style and the sounds of nature voice she has. She proved to be a great dancer, and she showed off her vocals in her live performances. If you had ever seen her dance, I bet you&rsquo;d love it.<br />\r\n	I felt stage lighting interesting when I was enjoying Chae Yeon&rsquo;s performance. We all know that stage lighting instruments are used for the concerts and other performances taking place in live performance venues. They are also used to light the stages. Actually this is a color mixing process. There are two types of color mixing: Additive and Subtractive. Most stages use the former and in this case there are three primary colors: red, green, and blue. In the absence of color, or when no colors are showing, the stage is black. If all three primary colors are showing, the result is white. When red and green combine together, the result is yellow. When red and blue combine together, the result is magenta. When blue and green combine together, the result is cyan. When two same color combine together, the result is still that color.</p>\r\n<p>\r\n	<img alt="" src="/joj/userfiles/admin/0/ChaeYeon.JPG" style="width: 179px; height: 136px;" /></p>\r\n<p>\r\n	We have got the coordinate and the primary color of the figure that each Stage Lighting Instrument sent out. For simplicity&rsquo;s sake, we can just treat the figure as a circle. Of course we&rsquo;ll know the radius of each colored circle. Some color may be changed based on the Color Mixed Theory we mentioned above. Can you find the area of each color?</p>\r\n', '2009 Asia Wuhan Regional Contest Online', '<p>\r\n	The first line consists of an integer T, indicating the number of test cases.<br />\r\n	The first line of each case consists of three integers R, G, B, indicating the number of red circles, green circles and blue circles. The next R + G + B lines, each line consists of three integer x, y, r, indicating the coordinate and the radius. The first R lines descript the red circles, the second G lines descript the green circles and the last B lines descript the blue circles.</p>\r\n', '<p>\r\n	Output seven floating numbers, they are the area of red, green, blue, white, yellow, magenta and cyan. Please take each number with two factional digits.<br />\r\n	Constraints<br />\r\n	0 &lt; T &lt;= 20<br />\r\n	0 &lt;= R, G, B &lt;= 100<br />\r\n	-100 &lt;= x, y &lt;= 100; 0 &lt;= r &lt;= 100</p>\r\n', '1\r\n1 1 1\r\n0 2 3\r\n2 0 3\r\n-2 0 3', '9.28 15.04 15.04 4.92 7.04 7.04 1.28\r\n\r\nHint\r\n\r\nGentleman’s Reminder: please make sure that your program won’t output “-0.00”.\r\n', '', 0, 0, '2010-08-08 02:34:37', '2010-08-08 02:34:37'),
(114, 1, 'Dolphin', 1000, 33554432, 0000000000, 0000000000, '<p>\r\n	Dolphins are marine mammals that are closely related to whales and porpoises. They might have some kind of the biggest brains in the water, but are dolphins really smart? Some scientists say that they use their big brains to stay warm in the sea, rather than for lots of thinking. Obviously those scientists don&rsquo;t think dolphins are smart.<br />\r\n	We know that the brain is made up of two types of cells &ndash; neurons and glia. Neurons do the thinking, while glia do things like keeping the brain warm to help the neurons. After looking at how dolphins&rsquo; brains are put together, they claim that dolphins have lots of glia and not many neurons.<br />\r\n	In order to find out how smart the dolphins are, we throw one of them into a maze we&#39;ve just created, to see how long it&#39;ll take the dolphin to get out.<br />\r\n	The maze consists of nodes and bidirectional edges connecting them.<br />\r\n	The dolphin needs power to swim, so we place exactly one fish at each node for him to enjoy.<br />\r\n	The dolphin is not interested in eating the same kind of fish more than once, but he can&#39;t resist any food if it&#39;s just in front to him! As a result, the dolphin decided to PLAN a route before going, so that it will not REACH any kind of fish more than once.<br />\r\n	Given the information above, can you tell me the minimum time that the dolphin needs to get out?</p>\r\n', '2009 Asia Wuhan Regional Contest Online', '<p>\r\n	The first line consists of an integer T, indicating the number of test cases.<br />\r\n	The first line of each case consists of four integers N, M, S and E, indicating the number of nodes, the number of edges, the starting node and destination.<br />\r\n	Each of the next M lines consists of three integers U, V, C, indicating that there is an edge with length C between node U and V. It will take a dolphin C time to pass this edge.<br />\r\n	The next line consists of N integers. Ki indicates the label of which kind fishes i-th node has.</p>\r\n', '<p>\r\n	Output the minimum time that a dolphin needs to get to the destination on a single line. If a dolphin can never get to the destination, please output -1.<br />\r\n	Constraints<br />\r\n	0 &lt; T &lt;= 20<br />\r\n	2 &lt;= N &lt;= 100; 0 &lt;= M &lt;= 10000; 0 &lt;= S, E &lt; N<br />\r\n	0 &lt;= U, V &lt; N; 0 &lt; C &lt;= 1000<br />\r\n	0 &lt;= Ki &lt; 1000<br />\r\n	There may be more than one edge between two nodes, and may be loop, an edge that begins and ends both on the same vertex. All edges are bidirectional.</p>\r\n', '2\r\n2 1 0 1\r\n0 1 1\r\n0 0\r\n4 4 0 3\r\n0 1 1\r\n1 3 1\r\n0 2 2\r\n2 3 2\r\n0 0 1 2', '-1 4\r\n\r\n', '', 0, 0, '2010-08-08 02:36:52', '2010-08-08 02:36:52'),
(115, 1, 'FreeOpen', 1000, 33554432, 0000000000, 0000000000, '<div class="panel_content">\r\n	FreeOpen is an organization which arranges blind data for girls and boys. The moral of that name is &ldquo;Open your free mind to find your other half&rdquo;. FreeOpen use a pet to make a match to a girl and a boy. FreeOpen believe that if a girl and a boy like each other and they like the same pet, they will be happy when they are living together with that pet.<br />\r\n	There are n boys, m girls and k pets. FreeOpen want know the maximum matches. Each match consists of one girl, one boy and one pet, and each girl, boy or pet can only be in one single match.</div>\r\n', '2009 Asia Wuhan Regional Contest Online', '<div class="panel_content">\r\n	The first line consists of an integer T, indicating the number of test cases.<br />\r\n	The first line of each case consists of three integers G, B, P, indicating the number of girls, the number of boys and the number of pets. The next G * B matrix indicates whether a girl and a boy like each other. The i-th girl and j-th boy like each other if and only if Matrix (i, j) = 1; the next G * P matrix indicates whether a girl likes a pet and the next B * P matrix indicates whether a boy likes a pet.</div>\r\n', '<p>\r\n	Output the maximum matches on a single line for each test case.<br />\r\n	<br />\r\n	Constrains<br />\r\n	0 &lt; T &lt;= 10<br />\r\n	0 &lt; G, B, P &lt;= 20<br />\r\n	0 &lt; G + B + P &lt;= 60</p>\r\n', '2\r\n2 1 3\r\n1\r\n1\r\n1 1 1\r\n1 1 1\r\n0 0 0\r\n15 15 15\r\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\r\n1 1 1 1 1 1 1 1 1 1 0 1 1 1 1\r\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\r\n1 1 1 1 1 1 1 1 1 1 0 1 1 1 1\r\n1 1 1 1 1 1 1 1 1 1 0 1 1 1 1\r\n1 1 1 1 1 1 1 1 1 1 0 1 1 1 1\r\n1 1 1 1 1 1 1 1 1 1 0 1 1 1 1\r\n1 1 1 1 1 1 1 1 1 1 0 1 1 1 1\r\n1 1 1 1 1 1 1 1 1 1 0 1 1 1 1\r\n1 1 1 1 1 1 1 1 1 1 0 1 1 1 1\r\n1 1 1 1 1 1 1 1 1 1 0 1 1 1 1\r\n1 1 1 1 1 1 1 1 1 1 0 1 1 1 1\r\n1 1 1 1 1 1 1 1 1 1 0 1 1 1 1\r\n1 1 1 1 1 1 1 1 1 1 0 1 1 1 1\r\n1 1 1 1 1 1 1 1 1 1 0 1 1 1 1\r\n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\r\n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\r\n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\r\n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\r\n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\r\n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\r\n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\r\n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\r\n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\r\n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\r\n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\r\n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\r\n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\r\n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\r\n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\r\n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\r\n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\r\n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\r\n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\r\n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\r\n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\r\n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\r\n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\r\n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\r\n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\r\n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\r\n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\r\n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\r\n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\r\n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1', '0\r\n13', '', 0, 0, '2010-08-08 02:38:14', '2010-08-08 02:38:14'),
(116, 1, 'FreeRadiant', 2000, 67108864, 0000000000, 0000000000, '<p>\r\n	Desolators are the elite troops of the WHU army in the alternate world of ICPC.<br />\r\n	When the Desolator plant a powerful Radiation Cannon in the ground, the cannon emits a radiation field over a circular area with radius R, poisoning everything within the circle (including boundary).The desolator must remain immobile while using this attack; if he wishes to move he has to uproot the cannon, disabling the radiation field. To protect desolator himself from the harm of radiation, the Desolator wears an armored Radiation suit. This suit is protected against the radiation emitted by the cannon.<br />\r\n	There are N enemies need to be destroyed. Each enemy can be destroyed if their total attacked times reach a certain value. Fortunately we know that value for each enemy.<br />\r\n	Our honored desolator FreeRadiant is executing this mission. He can use his cannon freely: e.g. plant it somewhere, wait for some time, uproot it and plant it somewhere else again and so on. The Desolator is so fast that planting, uprooting and moving the cannon takes no time, only the poisoning time matters. He just wants to know the total time needed in which he has to plant the cannon into the ground.</p>\r\n', '2009 Asia Wuhan Regional Contest Online', '<p>\r\n	The first line consists of an integer of T, indicating the test cases in the file.<br />\r\n	Each case begins with two integers, N and R, indicating the number of enemies and the radius of the circle. The next N lines, each line consists of two integers Xi, Yi, Pi, indicating the coordinate and the time needed to destroy each enemy.</p>\r\n', '<div class="panel_content">\r\n	Output one float number rounded to 2 fractional digits, indicating the minimum time for the cannon needs to be planted in the ground.<br />\r\n	Constrains<br />\r\n	T &lt;= 20<br />\r\n	0 &lt; N &lt;= 100 0 &lt; R &lt;= 10000<br />\r\n	0 &lt;= Xi, Yi, Pi &lt;= 10000</div>\r\n', '2\r\n4 1\r\n1 1 3\r\n1 -1 3\r\n-1 1 3\r\n-1 -1 3\r\n5 1\r\n100 100 10000\r\n1 1 3\r\n1 -1 3\r\n-1 1 3\r\n-1 -1 3', '6.00\r\n10006.00', '', 0, 0, '2010-08-08 02:39:45', '2010-08-08 02:42:26'),
(117, 1, 'GCC', 1000, 33554432, 0000000000, 0000000000, '<p>\r\n	The GNU Compiler Collection (usually shortened to GCC) is a compiler system produced by the GNU Project supporting various programming languages. But it doesn&rsquo;t contains the math operator &ldquo;!&rdquo;.<br />\r\n	In mathematics the symbol represents the factorial operation. The expression n! means &quot;the product of the integers from 1 to n&quot;. For example, 4! (read four factorial) is 4 &times; 3 &times; 2 &times; 1 = 24. (0! is defined as 1, which is a neutral element in multiplication, not multiplied by anything.)<br />\r\n	We want you to help us with this formation: (0! + 1! + 2! + 3! + 4! + ... + n!)%m</p>\r\n', '2009 Asia Wuhan Regional Contest Online', '<div class="panel_content">\r\n	The first line consists of an integer T, indicating the number of test cases.<br />\r\n	Each test on a single consists of two integer n and m.</div>\r\n', '<p>\r\n	Output the answer of (0! + 1! + 2! + 3! + 4! + ... + n!)%m.<br />\r\n	<br />\r\n	Constrains<br />\r\n	0 &lt; T &lt;= 20<br />\r\n	0 &lt;= n &lt; 10^100 (without leading zero)<br />\r\n	0 &lt; m &lt; 1000000</p>\r\n', '1\r\n10 861017', '593846', '', 0, 0, '2010-08-08 02:43:20', '2010-08-08 02:43:20'),
(118, 1, 'Moonmist', 10000, 67108864, 0000000000, 0000000000, '<div class="panel_content">\r\n	An Unidentified Flying Object (Commonly abbreviated as UFO) is the popular term for any aerial phenomenon whose cause cannot be easily or immediately identified. We always believe UFO is the vehicle of aliens. But there is an interrogation about why UFO always likes a circular saucer? There must be a reason. Actually our scientists are developing a new traffic system &ldquo;Moonmist&rdquo;. It is distinguished from the traditional traffic. We use circular saucers in this new traffic system and the saucers moves extremely fast. When our scientists did their test, they found that traffic accident was too hard to be avoided because of the high speed of the advanced saucer. They need us to develop a system that can tell them the nearest saucer. The distance between two saucers is defined as the shortest distance between any two points in different saucers.</div>\r\n', '2009 Asia Wuhan Regional Contest Online', '<p>\r\n	The first line consists of an integer T, indicating the number of test cases.<br />\r\n	The first line of each case consists of an integer N, indicating the number of saucers. Each saucer is represented on a single line, consisting of three integers X, Y, R, indicating the coordinate and the radius. You can assume that the distance between any two saucers will never be zero.</p>\r\n', '<div class="panel_content">\r\n	For each test case, please output a floating number with six fractional numbers, indicating the shortest distance.<br />\r\n	Constraints<br />\r\n	0 &lt; T &lt;= 10<br />\r\n	2 &lt;= N &lt;= 50000<br />\r\n	0 &lt;= X, Y, R &lt;= 100000</div>\r\n', '1\r\n2\r\n0 0 1\r\n10 10 1', '12.142136', '', 0, 0, '2010-08-08 02:44:46', '2010-08-08 02:47:54');
INSERT INTO `tbl_problems` (`id`, `user_id`, `title`, `time_limit`, `memory_limit`, `submission_no`, `accepted_no`, `description`, `source`, `input`, `output`, `input_sample`, `output_sample`, `hint`, `flag`, `visibility`, `created`, `modified`) VALUES
(119, 1, 'Nova', 1000, 33554432, 0000000000, 0000000000, '<p>\r\n	The Lich is a powerful hero that he can kill a wisp with his skill Frost Nova. The Burning Legion wants to conquer the forest so they sent some liches to kill all the wisps. A lich can kill a wisp once he could see the wisp and the wisp in his attack range. So the lich can attack a wisp when the distance between them is less than or equal to specific R and no trees are on the segment between the lich and wisp. Each lich has a cool down time that once he used Frost Nova he has to wait a few seconds for the next attack. Different liches may have different attack range and cool down time. The Lich King is the leader of the Burning Legion and he wants to arrange the attack order so the liches can wipe out all the wisps as soon as possible.</p>\r\n', '2009 Asia Wuhan Regional Contest Online', '<p>\r\n	The first line consists of an integer T, indicating the number of test cases.<br />\r\n	The first line of each case consists of three integers N, M, K, indicating the number of lich, the number of wisps and the number of trees. The next N lines, each line consists of four integers x, y, r, t indicating the coordinate of that a lich, the radius of the attack range that lich&rsquo;s Frost Nova can reach and the value of cool down time. The next M lines, each line consists of two integers x, y indicating the coordinate of each wisp. The last K lines, each line consists of three integers x, y, r, indicating the coordinate and radius of a tree. A lich cannot attack a wisp if the segment between them has a common point with the tree. The lich, wisp and trees will not overlap with each other.</p>\r\n', '<div class="panel_content">\r\n	Output the minimum time lich need to kill all the wisps on a single line, or -1 if lich cannot kill all the wisps.<br />\r\n	<br />\r\n	Constrains<br />\r\n	0 &lt; T &lt;= 20<br />\r\n	0 &lt;= N, M, K &lt;= 200<br />\r\n	-10000 &lt;= x, y &lt;= 10000<br />\r\n	0 &lt;= r, t &lt;= 10002</div>\r\n', '1\r\n2 3 1\r\n-100 0 100 3\r\n100 0 100 5\r\n-100 -10\r\n100 10\r\n110 11\r\n5 5 10', '5', '', 0, 0, '2010-08-08 02:49:39', '2010-08-08 02:49:39'),
(120, 1, 'Slash', 1000, 33554432, 0000000000, 0000000000, '<p>\r\n	The American English slash (/) is a punctuation mark. In the early modern period, in the Fraktur script, which was widespread through Europe in the Middle Ages, one slash(/) represented a comma, while two slashes (//) represented a dash.<br />\r\n	With the wide use of computers, slash appeared far more than at any previous time in history. On Unix-like systems and in URLs, the slash is to separate directory and file components of a path:<br />\r\n	/home/whuacm/chaeyeon/Sherlockpp.jpg<br />\r\n	http://acm.whu.edu.cn/<br />\r\n	But in Windows systems, it uses (\\) to separate directory and file components of a path:<br />\r\n	C:\\Users\\v-yungao\\Music\\Shake<br />\r\n	That really confuses me. Could you help me to judge if the string I wrote is right.<br />\r\n	Please notice that I would only make a mistake by changing (\\) to (/) or (/) to (\\). All the strings were constituted by a-z, A-Z, 0-9, (.) , (\\) and (/), no other characters would appear in the strings.<br />\r\n	A string of URL always begins with &ldquo;[a-zA-Z]+://&rdquo; (Notice (/) maybe changed to (\\) ), in which &ldquo;[a-zA-Z]+&rdquo; represents any non-empty string of letters.<br />\r\n	Windows path begins with &ldquo;[a-zA-Z]:\\&rdquo; (Notice (\\) maybe changed to (/)), in which &ldquo;[a-zA-Z]&rdquo; means an English letter. (e.g. &ldquo;C:\\\\windows&rdquo; is a URL not a Windows path)<br />\r\n	The path of Unix-like system begins with (/) or (\\).<br />\r\n	I&rsquo;ll give you some strings, can you tell me which type those strings belong to and those correct forms.</p>\r\n', '2009 Asia Wuhan Regional Contest Online', '<p>\r\n	The first line consists of an integer T, indicating the number of strings.<br />\r\n	The next T lines, each line consists of a single non-empty string. All of those are really data from our daily life.</p>\r\n', '<p>\r\n	For each string:<br />\r\n	If it belongs to a path in Unix-like systems, output &ldquo;It&rsquo;s a path in Unix-like systems!&rdquo; in a new line and the correct string in the next line.<br />\r\n	If it belongs to a path in Windows system, output &ldquo;It&rsquo;s a path in Windows system!&rdquo; in a new line and the correct string in the next line.<br />\r\n	If it&rsquo;s a URL, output &ldquo;It&rsquo;s a URL!&rdquo; in a new line and the correct string in the next line.<br />\r\n	The kind of each input string can be uniquely determined.<br />\r\n	<br />\r\n	Constrains<br />\r\n	0 &lt; T &lt;= 20<br />\r\n	The length of each string will not be longer than 50.</p>\r\n', '4\r\nhttp://acm.whu.edu.cn/felioj\r\nhttp:/\\acm.whu.edu.cn/11111011001/\r\n\\home\\whuacm\\Slash\\yama\r\nZ:\\movie/chaeyeon', 'It''s a URL!\r\nhttp://acm.whu.edu.cn/felioj\r\nIt''s a URL!\r\nhttp://acm.whu.edu.cn/11111011001/\r\nIt''s a path in Unix-like systems!\r\n/home/whuacm/Slash/yama\r\nIt''s a path in Windows system!\r\nZ:\\movie\\chaeyeon', '', 0, 0, '2010-08-08 02:51:32', '2010-08-08 02:51:32'),
(121, 1, 'WHUgirls', 5000, 67108864, 0000000000, 0000000000, '<p>\r\n	There are many pretty girls in Wuhan University, and as we know, every girl loves pretty clothes, so do they. One day some of them got a huge rectangular cloth and they want to cut it into small rectangular pieces to make scarves. But different girls like different style, and they voted each style a price wrote down on a list. They have a machine which can cut one cloth into exactly two smaller rectangular pieces horizontally or vertically, and ask you to use this machine to cut the original huge cloth into pieces appeared in the list. Girls wish to get the highest profit from the small pieces after cutting, so you need to find out a best cutting strategy. You are free to make as many scarves of a given style as you wish, or none if desired. Of course, the girls do not require you to use all the cloth.</p>\r\n', '2009 Asia Wuhan Regional Contest Online', '<div class="panel_content">\r\n	The first line of input consists of an integer T, indicating the number of test cases.<br />\r\n	The first line of each case consists of three integers N, X, Y, N indicating there are N kinds of rectangular that you can cut in and made to scarves; X, Y indicating the dimension of the original cloth. The next N lines, each line consists of two integers, xi, yi, ci, indicating the dimension and the price of the ith rectangular piece cloth you can cut in.</div>\r\n', '<div class="panel_content">\r\n	Output the maximum sum of prices that you can get on a single line for each case.<br />\r\n	<br />\r\n	Constrains<br />\r\n	0 &lt; T &lt;= 20<br />\r\n	0 &lt;= N &lt;= 10; 0 &lt; X, Y &lt;= 1000<br />\r\n	0 &lt; xi &lt;= X; 0 &lt; yi &lt;= Y; 0 &lt;= ci &lt;= 1000</div>\r\n', '1\r\n2 4 4\r\n2 2 2\r\n3 3 9', '9', '', 0, 0, '2010-08-08 02:53:25', '2010-08-08 02:59:39'),
(122, 1, 'A+B Problem ', 1000, 33554432, 0000000000, 0000000000, '<pre>\r\n<span class="di" id="clean">Calculate a+b</span></pre>', 'zjicm 2009', '<pre>\r\n<span class="di" id="clean">Two integer a,b (0&lt;=a,b&lt;=10) in each line.</span></pre>\r\n<p>\r\n	<span class="b">&nbsp;</span></p>\r\n', '<pre>\r\n<span class="di" id="clean">Output a+b in a line</span></pre>', '1 2\r\n2 3', '3\r\n5\r\n', '', 0, 0, '2010-08-08 03:02:09', '2010-08-17 04:46:03'),
(145, 1, 'Mincost', 1000, 33554432, 0000000000, 0000000000, '<p>\r\n	The cost of taking a taxi in Hangzhou is not a constant for each kilometer you travel: the first 4 kilometers costs 10 yuan (yuan is the monetary unit in China), even if you don&#39;t finish it; the next 4 kilometers costs 2 yuan each and the price for the rest of the trip is 2.4 yuan per kilometer; the last part of the trip is regarded as 1 kilometer even if it&#39;s shorter. A traveller may reduce the cost by reseting the meter at the middle of the trip if used wisely. For example, if the trip is 16 kilometers, he should cut it into two parts with the same length, each half will cost 18 yuan, with an overall cost of 36, less than the original price of 37.2. Now, given the length of the trip, find the minimum cost.</p>\r\n', 'freeproblemset ZOJ Monthly, November 2004   ', '<p>\r\n	The input contains several cases, each has one positive integer in a seperate line, representing the length of the trip. All input data are less than 10000000. Proceed until a case with zero, which should be ignored.</p>\r\n', '<pre>\r\n<span class="di" id="clean">For each case, output the minimum cost, leave one digit after decimal point if NECESSARY.</span></pre>\r\n', '3\r\n9\r\n16\r\n0\r\n', '10\r\n20.4\r\n36\r\n', '', 0, 0, '2010-08-17 04:51:20', '2010-08-17 04:58:00'),
(123, 1, 'Cup', 1000, 33554432, 0000000000, 0000000000, '<p>\r\n	The WHU ACM Team has a big cup, with which every member drinks water. Now, we know the volume of the water in the cup, can you tell us it height?<br />\r\n	<br />\r\n	The radius of the cup&#39;s top and bottom circle is known, the cup&#39;s height is also known.</p>\r\n', '2009 Asia Wuhan Regional Contest Online Warmup', '<p>\r\n	The input consists of several test cases. The first line of input contains an integer T, indicating the num of test cases.<br />\r\n	Each test case is on a single line, and it consists of four floating point numbers: r, R, H, V, representing the bottom radius, the top radius, the height and the volume of the hot water.<br />\r\n	<br />\r\n	Technical Specification<br />\r\n	<br />\r\n	1. T &le; 20.<br />\r\n	2. 1 &le; r, R, H &le; 100; 0 &le; V &le; 1000,000,000.<br />\r\n	3. r &le; R.<br />\r\n	4. r, R, H, V are separated by ONE whitespace.<br />\r\n	5. There is NO empty line between two neighboring cases.</p>\r\n', '<p>\r\n	For each test case, output the height of hot water on a single line. Please round it to six fractional digits.</p>\r\n', '1\r\n100 100 100 3141562', '99.999024', '', 0, 0, '2010-08-08 03:02:35', '2010-08-08 03:02:35'),
(124, 1, 'Find the Path', 5000, 67108864, 0000000000, 0000000000, '<p>\r\n	Scofield is a hero in American show &quot;Prison Break&quot;. He had broken the prison and started a big runaway.<br />\r\n	Scofield has a map of US with cities and bidirectional roads between them. The lengths of roads are known. Some cities get a lot of cops who are very troublesome. Now Scofield needs your help to arrange his runaway route.<br />\r\n	<br />\r\n	He needs a shortest path between two cities, while the quantity of the police in any city, except the start city and end city, on the route is no more than k.<br />\r\n	<br />\r\n	You should know that it is very hard to escape. Scofield is very smart but not good at computer. Now Scofield is in trouble, can you help him with your computer?</p>\r\n', '2009 Asia Wuhan Regional Contest Online Warmup', '<p>\r\n	The input consists of several test cases. There is an integer T on the first line indicating the number of test cases.<br />\r\n	For each case, the first line consists of two integers N and M. N is the number of cities; M is the number of roads. The next line contains N integers C1, C2... CN, where Ci is the number of cops in city i.<br />\r\n	<br />\r\n	Then followed M lines, each line consists of three integer, u, v, w, indicating there is a road with length w between city u and city v.<br />\r\n	<br />\r\n	The following line consists of an integer Q, indicating the number of queries. Each of the following Q lines consists of three integers, u, v, k, indicating the query for the shortest path between city u and city v with limitation of k cops.<br />\r\n	<br />\r\n	Technical Specification<br />\r\n	<br />\r\n	1. T &le; 20<br />\r\n	2. 2 &le; N &le; 200, 0 &le; M &le; n * (n &ndash; 1) / 2<br />\r\n	3. 0 &le; Ci &le; 1000,000,000<br />\r\n	4. 0 &le; u, v &lt; N, 0 &le; w &le; 1000, 0 &le; k &le; 1000,000,000<br />\r\n	5. 0 &le; Q &le; 100000<br />\r\n	6. There is no more than ONE road between two cities and no road between the same cities.<br />\r\n	7. For each query, u is not equal to v.<br />\r\n	8. There is ONE empty line after each test case.</p>\r\n', '<p>\r\n	For each query, output a single line contains the length of the shortest path. Output &quot;-1&quot; if you can&#39;t find the path. Please output an empty line after each test case.</p>\r\n', '1\r\n4 4\r\n100 2 3 100\r\n0 1 1\r\n0 2 1\r\n1 3 2\r\n2 3 3\r\n2\r\n0 3 2\r\n0 3 1', '3\r\n-1', '', 0, 0, '2010-08-08 03:04:39', '2010-08-08 03:06:23'),
(125, 1, 'Five in a Row, Again', 1000, 33554432, 0000000000, 0000000000, '<p>\r\n	Each member of WHU ACM Team developed his/her own Five in a row AI application. They are planning to hold an AI competition on the online arena they just developed.<br />\r\n	Each AI competitor has to compete with every other participator once. The winner of each game is awarded with credits while the loser gets nothing. No one gets credits in a tied game.<br />\r\n	<br />\r\n	Every competitor has an experience point, which is crucial to the game. In each game, the competitor with higher experience point wins, except for tied games, in which two competitors have the same experience point.<br />\r\n	<br />\r\n	Those AIs are so clever that they will learn from every game. That is to say, no matter win or lose, AIs&#39; experience point may increase after each game.<br />\r\n	<br />\r\n	Alex, the team leader, has the privilege to arrange the game order. He wants to maximum his credit. Please help him solve the problem.</p>\r\n', '2009 Asia Wuhan Regional Contest Online Warmup', '<div class="panel_content">\r\n	The input consists of several test cases. The first line of the input consists of an integer T, indicating the number of test cases.<br />\r\n	Each test case starts with a line consist of an integer N, indicating the number of competitors. Each of the following N lines consists of N integers Eij, indicating the experience point the i-th competitor will increase after the game with the j-th competitor. Then, each of the following N lines consists of N integers Wij, indicating the credit the i-th competitor will gain if wins the game with the j-th competitor.<br />\r\n	<br />\r\n	The last line of each test case consists of N integers Si, indicating the initial experience point of each competitor.<br />\r\n	<br />\r\n	By the way, Alex is the first player.<br />\r\n	Technical Specification<br />\r\n	<br />\r\n	1. 1 &le; T &le; 11<br />\r\n	2. 1 &le; N &le; 13<br />\r\n	3. 0 &le; Wij &le; 10<br />\r\n	4. 0 &le; Eij, Si &le; 1000</div>\r\n', '<p>\r\n	For each test case, output a single line consists of the maximum credit Alex may get.</p>\r\n', '2\r\n2\r\n0 1\r\n1 0\r\n0 1\r\n1 0\r\n1 1\r\n3\r\n0 5 2\r\n0 0 0\r\n0 0 0\r\n0 10 1\r\n1 0 1\r\n1 0 0\r\n1 10 5', '0\r\n1\r\n', '', 0, 0, '2010-08-08 03:08:19', '2010-08-08 03:08:19'),
(126, 1, 'Minimum Heap', 1000, 33554432, 0000000000, 0000000000, '<div>\r\n	Alex is curious about data structures. He is working on binary trees recently and particularly interested in complete binary trees.</div>\r\n<div>\r\n	<img alt="" src="/joj/userfiles/admin/0/minimumHeap.jpg" style="width: 555px; height: 380px;" /></div>\r\n<div>\r\n	A complete binary tree satisfies that all levels of the tree, except possibly the last one (deepest) are fully filled, and, if the last level of the tree is not complete, the nodes of that level are filled from left to right.<br />\r\n	Alex defines his own complete binary tree: each node has a weight, while father&#39;s is always less than or equal to its sons&#39;. He names this complete binary tree as minimum heap.<br />\r\n	<br />\r\n	Now he wants to know: With N nodes weighted from 1 to N (each appears once), how many heaps can be created. The answer (represented by Q) may be very large, so please output a number P while P = Q mod M.</div>\r\n', '2009 Asia Wuhan Regional Contest Online Warmup', '<p>\r\n	The input consists of several test cases. The first line contains a number T, indicating the number of test cases. Each test case is on a single line, and it consists the number N and M.<br />\r\n	Technical Specification<br />\r\n	1. 1 &le; T &le; 10<br />\r\n	2. 1 &le; N &le; 1000<br />\r\n	3. 2 &le; M &le; 1000,000,000</p>\r\n', '<p>\r\n	For each test case, output the number P on a single line.</p>\r\n', '2\r\n1 9973\r\n100 9973', '1\r\n174\r\n', '', 0, 0, '2010-08-08 03:10:49', '2010-10-18 23:09:15'),
(127, 1, 'Name PK', 1000, 33554432, 0000000000, 0000000000, '<div class="panel_content">\r\n	Name PK is a funny game on the Internet. The game will calculate character&#39;s property based on its name.<br />\r\n	Now we&#39;re simulating a simple Name PK game. Each character has 3 parameters: HP, STR and SPD (HP for health point, STR for strength and SPD for attacking speed).<br />\r\n	<br />\r\n	For a name string of length N, Ci is ASCII code (decimal) of the i-th char.<br />\r\n	<img alt="" src="/joj/userfiles/admin/0/NamePK.jpg" style="width: 280px; height: 194px;" /><br />\r\n	PK rule:<br />\r\n	1. Timer begins to increase from 1. When it is a multiple of (20-SPD), the corresponding character A has that SPD attack once, the opposite lose STR(A&#39;s) HP.<br />\r\n	<br />\r\n	2. When any side has a HP &le; 0, the PK is over.</div>\r\n', '2009 Asia Wuhan Regional Contest Online Warmup', '<p>\r\n	The input consists of several test cases. The first line of input consists of an integer T, indicating the number of test cases. Each test case is on a separate line, and it consists two strings separated by a whitespace, indicating the name of the characters.<br />\r\n	Technical Specification<br />\r\n	<br />\r\n	1. Names contain only English letters.<br />\r\n	2. The length of each character&#39;s name is more than 1 and no more than 20.<br />\r\n	3. T &le; 1000.</p>\r\n', '<p>\r\n	For each test case, output a line consisting of the result of the first character: &quot;win&quot;, &quot;lose&quot; or &quot;tie&quot;.</p>\r\n', '3\r\nSylvia xay\r\nIvan Stacy\r\nBoyd Greg', 'lose\r\nwin\r\nlose', '', 0, 0, '2010-08-08 03:13:39', '2010-08-08 03:13:39'),
(128, 1, 'Pendant', 1000, 33554432, 0000000000, 0000000000, '<p>\r\n	On Saint Valentine&#39;s Day, Alex imagined to present a special pendant to his girl friend made by K kind of pearls. The pendant is actually a string of pearls, and its length is defined as the number of pearls in it. As is known to all, Alex is very rich, and he has N pearls of each kind. Pendant can be told apart according to permutation of its pearls. Now he wants to know how many kind of pendant can he made, with length between 1 and N. Of course, to show his wealth, every kind of pendant must be made of K pearls.<br />\r\n	Output the answer taken modulo 1234567891.</p>\r\n', '2009 Asia Wuhan Regional Contest Online Warmup', '<p>\r\n	The input consists of multiple test cases. The first line contains an integer T indicating the number of test cases. Each case is on one line, consisting of two integers N and K, separated by one space.<br />\r\n	Technical Specification<br />\r\n	<br />\r\n	1 &le; T &le; 10<br />\r\n	1 &le; N &le; 1,000,000,000<br />\r\n	1 &le; K &le; 30</p>\r\n', '<p>\r\n	Output the answer on one line for each test case.</p>\r\n', '2\r\n2 1\r\n3 2', '2\r\n8', '', 0, 0, '2010-08-08 03:15:43', '2010-08-08 03:15:43'),
(129, 1, 'Radar', 1000, 33554432, 0000000000, 0000000000, '<p>\r\n	N cities of the Java Kingdom need to be covered by radars for being in a state of war. Since the kingdom has M radar stations but only K operators, we can at most operate K radars. All radars have the same circular coverage with a radius of R. Our goal is to minimize R while covering the entire city with no more than K radars.</p>\r\n', '2009 Asia Wuhan Regional Contest Online Warmup', '<p>\r\n	The input consists of several test cases. The first line of the input consists of an integer T, indicating the number of test cases. The first line of each test case consists of 3 integers: N, M, K, representing the number of cities, the number of radar stations and the number of operators. Each of the following N lines consists of the coordinate of a city.<br />\r\n	Each of the last M lines consists of the coordinate of a radar station.<br />\r\n	<br />\r\n	All coordinates are separated by one space.<br />\r\n	Technical Specification<br />\r\n	<br />\r\n	1. 1 &le; T &le; 20<br />\r\n	2. 1 &le; N, M &le; 50<br />\r\n	3. 1 &le; K &le; M<br />\r\n	4. 0 &le; X, Y &le; 1000</p>\r\n', '<div class="panel_content">\r\n	For each test case, output the radius on a single line, rounded to six fractional digits.</div>', '1\r\n3 3 2\r\n3 4\r\n3 1\r\n5 4\r\n1 1\r\n2 2\r\n3 3', '2.236068', '', 0, 0, '2010-08-08 03:17:22', '2010-08-08 03:17:22'),
(130, 1, 'Ring', 1000, 33554432, 0000000000, 0000000000, '<p>\r\n	For the hope of a forever love, Steven is planning to send a ring to Jane with a romantic string engraved on. The string&#39;s length should not exceed N. The careful Steven knows Jane so deeply that he knows her favorite words, such as &quot;love&quot;, &quot;forever&quot;. Also, he knows the value of each word. The higher value a word has the more joy Jane will get when see it.<br />\r\n	The weight of a word is defined as its appeared times in the romantic string multiply by its value, while the weight of the romantic string is defined as the sum of all words&#39; weight. You should output the string making its weight maximal.</p>\r\n', '2009 Asia Wuhan Regional Contest Online Warmup', '<p>\r\n	The input consists of several test cases. The first line of input consists of an integer T, indicating the number of test cases. Each test case starts with a line consisting of two integers: N, M, indicating the string&#39;s length and the number of Jane&#39;s favorite words. Each of the following M lines consists of a favorite word Si. The last line of each test case consists of M integers, while the i-th number indicates the value of Si.<br />\r\n	Technical Specification<br />\r\n	<br />\r\n	1. T &le; 15<br />\r\n	2. 0 &lt; N &le; 50, 0 &lt; M &le; 100.<br />\r\n	3. The length of each word is less than 11 and bigger than 0.<br />\r\n	4. 1 &le; Hi &le; 100.<br />\r\n	5. All the words in the input are different.<br />\r\n	6. All the words just consist of &#39;a&#39; - &#39;z&#39;.</p>\r\n', '<p>\r\n	For each test case, output the string to engrave on a single line.<br />\r\n	If there&#39;s more than one possible answer, first output the shortest one. If there are still multiple solutions, output the smallest in lexicographically order.<br />\r\n	<br />\r\n	The answer may be an empty string.</p>\r\n', '2\r\n7 2\r\nlove\r\never\r\n5 5\r\n5 1\r\nab\r\n5', 'lovever\r\nabab\r\n\r\nHint\r\nSample 1: weight(love) = 5, weight(ever) = 5, so weight(lovever) = 5 + 5 = 10\r\nSample 2: weight(ab) = 2 * 5 = 10, so weight(abab) = 10 ', '', 0, 0, '2010-08-08 03:20:04', '2010-08-08 03:20:04'),
(131, 1, 'Run', 1000, 33554432, 0000000000, 0000000000, '<p>\r\n	Since members of Wuhan University ACM Team are lack of exercise, they plan to participate in a ten-thousand-people Marathon. It is common that the athletes run very fast at first but slow down later on. Start from this moment, we can assume that everyone is moving forward in a constant speed. ACMers love algorithms, so they want to know not only the result but also who may be in the leading position. Now we know all athletes&#39; position and speed at a specific moment. The problem is, starting from this moment, how many athletes may be the leader. Please notice that there&#39;s no leader if two or more athletes are at the leading position at the same time. No two athletes may have the same speed.</p>\r\n', '2009 Asia Wuhan Regional Contest Online Warmup', '<p>\r\n	The input consists of several test cases. The first line of input consists of an integer T, indicating the number of test cases. The first line of each test case consists of an integer N, indicating the number of athletes. Each of the following N lines consists of two integers: p, v, indicating an athlete&#39;s position and speed.<br />\r\n	<br />\r\n	Technical Specification<br />\r\n	<br />\r\n	1. T &le; 20<br />\r\n	2. 0 &lt; N &le; 50000<br />\r\n	3. 0 &lt; p, v &le; 2000,000,000<br />\r\n	4. An athlete&#39;s position is the distant between him/her and the start line.<br />\r\n	5. The Marathon is so long that you can assume there&#39;s no finishline.</p>\r\n', '<p>\r\n	For each test case, output the number of possible leaders on a separate line.</p>\r\n', '1\r\n3\r\n1 1\r\n2 3\r\n3 2', '2', '', 0, 0, '2010-08-08 03:22:00', '2010-08-08 03:22:00'),
(132, 1, 'Toxophily ', 1000, 33554432, 0000000000, 0000000000, '<p>\r\n	The recreation center of WHU ACM Team has indoor billiards, Ping Pang, chess and bridge, toxophily, deluxe ballrooms KTV rooms, fishing, climbing, and so on.<br />\r\n	We all like toxophily.<br />\r\n	<br />\r\n	Bob is hooked on toxophily recently. Assume that Bob is at point (0,0) and he wants to shoot the fruits on a nearby tree. He can adjust the angle to fix the trajectory. Unfortunately, he always fails at that. Can you help him?<br />\r\n	<br />\r\n	Now given the object&#39;s coordinates, please calculate the angle between the arrow and x-axis at Bob&#39;s point. Assume that g=9.8N/m.</p>\r\n', '2009 Asia Wuhan Regional Contest Online Warmup', '<p>\r\n	The input consists of several test cases. The first line of input consists of an integer T, indicating the number of test cases. Each test case is on a separated line, and it consists three floating point numbers: x, y, v. x and y indicate the coordinate of the fruit. v is the arrow&#39;s exit speed.<br />\r\n	Technical Specification<br />\r\n	<br />\r\n	1. T &le; 100.<br />\r\n	2. 0 &le; x, y, v &le; 10000.</p>\r\n', '<p>\r\n	For each test case, output the smallest answer rounded to six fractional digits on a separated line.<br />\r\n	Output &quot;-1&quot;, if there&#39;s no possible answer.<br />\r\n	<br />\r\n	Please use radian as unit.</p>\r\n', '3\r\n0.222018 23.901887 121.909183\r\n39.096669 110.210922 20.270030\r\n138.355025 2028.716904 25.079551', '1.561582\r\n-1\r\n-1', '', 0, 0, '2010-08-08 03:24:08', '2010-08-08 03:24:08'),
(133, 1, 'Factorial Frequencies', 1000, 33554432, 0000000000, 0000000000, '<p>\r\n	In an attempt to bolster her sagging palm-reading business, Madam Phoenix has decided to offer several numerological treats to her customers. She has been able to convince them that the frequency of occurrence of the digits in the decimal representation of factorials bear witness to their futures. Unlike palm-reading, however, she can&#39;t just conjure up these frequencies, so she has employed you to determine these values.</p>\r\n<p>\r\n	Recall that the definition of n! (that is, n factorial) is just 1&times;2&times;3&times;...&times;n. As she expects to use the day of the week, the day of the month, or the day of the year as the value of n, you must be able to determine the number of occurrences of each decimal digit in numbers as large as 366 factorial (366!), which has 781 digits.</p>\r\n', '1993 North Central Region problem set', '<p>\r\n	The input data for the program is simply a list of integers for which the digit counts are desired. All of these input values will be less than or equal to 366 and greater than 0, except for the last integer, which will be zero. Don&#39;t bother to process this zero value; just stop your program at that point.</p>\r\n', '<p>\r\n	The output format isn&#39;t too critical, but you should make your program produce results that look similar to those shown below.</p>\r\n<p>\r\n	Madam Phoenix will be forever (or longer) in your debt; she might even give you a trip if you do your job well!</p>\r\n', '3\r\n8\r\n100\r\n0\r\n', '3! --\r\n   (0)    0    (1)    0    (2)    0    (3)    0    (4)    0\r\n   (5)    0    (6)    1    (7)    0    (8)    0    (9)    0\r\n8! --\r\n   (0)    2    (1)    0    (2)    1    (3)    1    (4)    1\r\n   (5)    0    (6)    0    (7)    0    (8)    0    (9)    0\r\n100! --\r\n   (0)   30    (1)   15    (2)   19    (3)   10    (4)   10\r\n   (5)   14    (6)   19    (7)    7    (8)   14    (9)   20\r\n', '', 0, 0, '2010-08-09 08:22:12', '2010-08-09 09:05:25'),
(134, 1, 'Identifying Legal Pascal Real Constants', 1000, 33554432, 0000000000, 0000000000, '<p>\r\n	Pascal requires that real constants have either a decimal point, or an exponent (starting with the letter e or E, and officially called a scale factor), or both, in addition to the usual collection of decimal digits. If a decimal point is included it must have at least one decimal digit on each side of it. As expected, a sign (+ or -) may precede the entire number, or the exponent, or both. Exponents may not include fractional digits. Blanks may precede or follow the real constant, but they may not be embedded within it. Note that the Pascal syntax rules for real constants make no assumptions about the range of real values, and neither does this problem. Your task in this problem is to identify legal Pascal real constants.</p>\r\n', '1993 North Central Region problem set', '<p>\r\n	Each line of the input data contains a candidate which you are to classify.</p>\r\n<p>\r\n	The input terminates with a line that contains only an asterisk in column one.</p>\r\n', '<p>\r\n	For each line of the input, display your finding as illustrated in the example shown below.</p>\r\n', '1.2\r\n   1.\r\n  1.0e-55\r\n  e-12\r\n    6.5E\r\n     1e-12\r\n  +4.1234567890E-99999\r\n   7.6e+12.5\r\n99\r\n*\r\n', '1.2 is legal.\r\n1. is illegal.\r\n1.0e-55 is legal.\r\ne-12 is illegal.\r\n6.5E is illegal.\r\n1e-12 is legal.\r\n+4.1234567890E-99999 is legal.\r\n7.6e+12.5 is illegal.\r\n99 is illegal.\r\n', '', 0, 0, '2010-08-09 08:47:12', '2010-08-09 09:05:07'),
(135, 1, 'Extrapolation Using a Difference Table', 1000, 33554432, 0000000000, 0000000000, '<p>\r\n	A very old technique for extrapolating a sequence of values is based on the use of a difference table. The difference table used in the extrapolation of a sequence of 4 values, say 3, 6, 10, and 15, might be displayed as follows:</p>\r\n<p>\r\n	&nbsp;</p>\r\n<center>\r\n	<p>\r\n		<img align="top" src="/joj/userfiles/admin/0/132table1.gif" style="width: 273px; height: 186px;" /></p>\r\n</center>\r\n<p>\r\n	The original sequence of values appears in the first column of the table. Each entry in the second column of the table is formed by computing the difference between the adjacent entries in the first column. These values (in the second column) are called first differences. Each entry in the third column is similarly the difference between the adjacent entries in the second column; the third column entries are naturally called second differences. Computation of the last column in this example should now be obvious (but beware that this value is not always zero). Note that the last column will always contain only a single value. If we begin with a sequence of n values, the completed difference table will have n columns, with the single value in column n representing the single n-1st difference.</p>\r\n<p>\r\n	To extrapolate using a difference table we assume the n-1st differences are constant (since we have no additional information to refute that assumption). Given that assumption, we can compute the next entry in the n-2nd difference column, the n-3rd difference column, and so forth until we compute the next entry in the first column which, of course, is the next value in the sequence. The table below shows the four additional entries (in boxes) added to the table to compute the next entry in the example sequence, which in this case is 21. We could obviously continue this extrapolation process as far as desired by adding additional entries to the columns using the assumption that the n-1st differences are constant.</p>\r\n<p>\r\n	&nbsp;</p>\r\n<center>\r\n	<p>\r\n		<img align="top" src="/joj/userfiles/admin/0/132table2.gif" style="width: 248px; height: 226px;" /></p>\r\n</center>\r\n', '1993 North Central Region problem set', '<p>\r\n	The input for this problem will be a set of extrapolation requests. For each request the input will contain first an integer n, which specifies the number of values in the sequence to be extended. When n is zero your program should terminate. If n is non-zero (it will never be larger than 10), it will be followed by n integers representing the given elements in the sequence. The last item in the input for each extrapolation request is k, the number of extrapolation operations to perform; it will always be at least 1. In effect, you are to add k entries to each column of the difference table, finally reporting the last value of the sequence computed by such extrapolation. More precisely, assume the first n entries (the given values) in the sequence are numbered 1 through n.</p>\r\n', '<p>\r\n	Your program is to determine the n+kth value in the sequence by extrapolation of the original sequence k times. (Hint: no upper limit is given for k, and you might not be able to acquire enough memory to construct a complete difference table.)</p>\r\n', '4  3  6  10  15  1\r\n4  3  6  10  15  2\r\n3  2  4  6  20\r\n6  3  9  12  5  18  -4  10\r\n0\r\n', 'Term 5 of the sequence is 21\r\nTerm 6 of the sequence is 28\r\nTerm 23 of the sequence is 46\r\nTerm 16 of the sequence is -319268', '', 0, 0, '2010-08-09 09:03:28', '2010-08-09 09:04:54'),
(136, 1, 'Evaluating Simple C Expressions', 1000, 33554432, 0000000000, 0000000000, '<p>\r\n	The task in this problem is to evaluate a sequence of simple C expressions, but you need not know C to solve the problem! Each of the expressions will appear on a line by itself and will contain no more than 80 characters. The expressions to be evaluated will contain only simple integer variables and a limited set of operators; there will be no constants in the expressions. There are 26 variables which may appear in our simple expressions, namely those with the names a through z (lower-case letters only). At the beginning of evaluation of each expression, these 26 variables will have the integer values 1 through 26, respectively (that is, a = 1, b = 2, ...). Each variable will appear at most once in an expression and many variables may not be used at all.</p>\r\n<p>\r\n	The operators that may appear in expressions include the binary (two-operand) + and -, with the usual interpretation. Thus the expression <code>a + c - d + b</code> has the value 2 (computed as <code>1 + 3 - 4 + 2</code>). The only other operators that may appear in expressions are <code>++</code> and <code>--</code>. These are unary (one-operand) operators, and may appear before or after any variable. When the <code>++</code> operator appears before a variable, that variable&#39;s value is incremented (by one) before the variable&#39;s value is used in determining the value of the entire expression. Thus the value of the expression <code>++ c - b</code> is 2, with c being incremented to 4 prior to evaluation the entire expression. When the <code>++</code> operator appears after a variable, that variable is incremented (again, by one) after its value is used to determine the value of the entire expression. Thus the value of the expression <code>c ++ - b</code> is 1, but c is incremented after the complete expression is evaluated; its value will still be 4. The <code>--</code> operator can also be used before or after a variable to decrement (by one) the variable; its placement before or after the variable has the same significance as for the <code>++</code> operator. Thus the value of the expression <code>--</code> c + b -- has the value 4, with variables b and c having the values 1 and 2 following the evaluation of the expression.</p>\r\n<p>\r\n	Here&#39;s another, more algorithmic, approach to explaining the <code>++</code> and <code>--</code> operators. We&#39;ll consider only the <code>++</code> operator, for brevity:</p>\r\n<p>\r\n	&nbsp;</p>\r\n<ol>\r\n	<li>\r\n		Identify each variable that has a ++ operator before it. Write a simple assignment statement that increments the value of each such variable, and remove the ++ from before that variable in the expression.</li>\r\n	<li>\r\n		In a similar manner, identify each variable that has a ++ operator after it. Write a simple assignment statement that increments the value of each of these, and remove the ++ operator from after that variable in the expression.</li>\r\n	<li>\r\n		Now the expression has no ++ operators before or after any variables. Write the statement that evaluates the remaining expression after those statements written in step 1, and before those written in step 2.</li>\r\n	<li>\r\n		Execute the statements generated in step 1, then those generated in step 3, and finally the one generated in step 2, in that order.</li>\r\n</ol>\r\n<p>\r\n	Using this approach, evaluating the expression <code>++ a + b ++</code> is equivalent to computing <code>a = a + 1</code> (from step 1 of the algorithm) <code>expression = a + b</code> (from step 3) <code>b = b + 1</code> (from step 2) where expression would receive the value of the complete expression.</p>\r\n', '1993 North Central Region problem set', '<p>\r\n	Blanks are to be ignored in evaluating expressions, and you are assured that ambiguous expressions like <code>a+++b</code> (ambiguous because it could be treated as <code>a++ + b or a + ++b</code>) will not appear in the input. Likewise, <code>++</code> or <code>--</code> operators will never appear both before and after a single variable. Thus expressions like <code>++a++</code> will not be in the input data.</p>\r\n', '<p>\r\n	Your program is to read expressions, one per line, until a totally blank (or empty) line is read. Display each expression exactly as it was read, then display the value of the entire expression, and on separate lines, the value of each variable after the expression was evaluated. Do not display the value of variables that were not used in the expression. The samples shown below illustrate the desired output format.</p>\r\n', 'a + b\r\nb - z\r\na+b--+c++\r\nc+f--+--a\r\n   f-- + c-- + d-++e\r\n', 'Expression: a + b\r\n    value = 3\r\n    a = 1\r\n    b = 2\r\nExpression: b - z\r\n    value = -24\r\n    b = 2\r\n    z = 26\r\nExpression: a+b--+c++\r\n    value = 6\r\n    a = 1\r\n    b = 1\r\n    c = 4\r\nExpression: c+f--+--a\r\n    value = 9\r\n    a = 0\r\n    c = 3\r\n    f = 5\r\nExpression:    f-- + c-- + d-++e\r\n    value = 7\r\n    c = 2\r\n    d = 4\r\n    e = 6\r\n    f = 5\r\n', '', 0, 0, '2010-08-09 09:07:10', '2010-08-09 09:07:10'),
(137, 1, 'The Finite State Text-Processing Machine', 1000, 33554432, 0000000000, 0000000000, '<p>\r\n	A finite state machine (FSM) is essentially a directed graph. Each node in the graph is called a state; at any point during execution of the FSM, one of the states is said to be the current state. Each directed edge between two states is called a transition. When the conditions are right, one of the transitions from the current state is said to occur, and the current state changes to a new state as determined by the transition. Consider the following very simple example.</p>\r\n<p>\r\n	&nbsp;</p>\r\n<center>\r\n	<img align="top" src="/joj/userfiles/admin/0/statemachine.gif" style="width: 379px; height: 206px;" /></center>\r\n<p>\r\n	There are two states in this FSM, labeled A and B, and three transitions, labeled 1, 2, and 3. If the current state is A, and the conditions for transition 1 are met, then the current state becomes B. When the current state is B, and the conditions for transition 2 are met, the current states becomes A again. If the current state is B and the conditions for transition 3 are met, the current state remains B.</p>\r\n<p>\r\n	In this problem the input will be descriptions of several FSMs. Each transition in these FSMs has an associated set of characters called the input set, and a string called the output string. A transition can occur when the current input data character is in the transition&#39;s input set. When the transition occurs, the output string is printed.</p>\r\n', '1993 North Central Region problem set', '<p>\r\n	The input consists of a sequence of pairs {FSM description, input for the FSM}. A FSM is described by the following sequence of items separated by whitespace (blanks, tabs, and end of line characters):</p>\r\n<ul>\r\n	<li>\r\n		An integer specifying the number of states in the FSM. for each of these states there will be the following items, in order:\r\n		<ul>\r\n			<li>\r\n				A one to eight character name for the state. State names are case significant, and unique</li>\r\n			<li>\r\n				An integer specifying the number of transitions that leave the current state. For each of these transitions there will be the following data items, in order:\r\n				<ul>\r\n					<li>\r\n						The set of input characters that enable the transition (see below). the name of the new current state when this transition occurs</li>\r\n					<li>\r\n						The output string (see below).</li>\r\n				</ul>\r\n			</li>\r\n		</ul>\r\n	</li>\r\n</ul>\r\n<p>\r\n	The input set and the output string are given as sequences of printable characters with no imbedded whitespace. Several special constructions may appear in these, however. When \\b appears it is to be interpreted as a blank. Treat \\n as an end of line, and \\\\ as a single backslash. The construction \\0 (that is, backslash followed by zero) will appear only as an output string, and means to print nothing when the transition occurs. The construction \\c appearing as an input set matches anything. That is, if none of the other transitions are enabled and a transition has \\c specified as its input set, then it is enabled. When \\c appears in an output string, it means to print the current input character. this could appear several times in the same output string.</p>\r\n<p>\r\n	After the last item in the description of and FSM has been read begin executing the FSM using the characters that start on the first complete line following the description. the beginning state will always be called START. The final state will always e called END, but will not appear as a state in the description of a FSM. All input is guaranteed to be correct.</p>\r\n', '<p>\r\n	For each input your program should display the FSM number (1, 2, ...) and, beginning on the next line, the output that results from those transitions that occur. The examples below illustrate this.</p>\r\n<p>\r\n	The first example FSM replaces each vowel in a single line of input with an asterisk. The second example will delete each vowel that follows a lower or upper case X, again processing only a single line of input. The final example changes the case of each odd-numbered vowel in the input; processing stops when an exclamation point is encountered, and the remainder of the input line is ignored.</p>\r\n', '1\r\nSTART 3\r\n      AEIOUaeiou  START *\r\n      \\n          END   \\n\r\n      \\c          START \\c \r\nThis is input for example one.\r\n2\r\nSTART 3\r\n      \\c    START \\c\r\n      Xx    SKIP  \\c\r\n      \\n    END   \\n\r\nSKIP  4\r\n      AEIOU START \\0\r\n      aeiou START \\0\r\n      Xx    SKIP  \\c\r\n      \\n    END   \\n\r\nXaXxe     Test   XIo  iXixO\r\n3\r\nSTART 12\r\n   \\c START \\c    !     FINIS \\0\r\n   A  TWO   a     E     TWO   e\r\n   I  TWO   i     O     TWO   o\r\n   U  TWO   u     a     TWO   A\r\n   e  TWO   E     i     TWO   I\r\n   o  TWO   O     u     TWO   U\r\nTWO   4\r\n  \\c  TWO   \\c    AEIOU START \\c\r\n   aeiou  START \\c  !  FINIS  \\0\r\nFINIS 2\r\n   \\c  FINIS \\0   \\n    END   \\n\r\nThis is some data for FSM number 3.\r\n!    IGNORED\r\n0\r\n', 'Finite State Machine 1:\r\nTh*s *s *np*t f*r *x*mpl* *n*.\r\nFinite State Machine 2:\r\nXXx     Test   Xo  iXx\r\nFinite State Machine 3:\r\nThIs is sOme dAta fOr FSM numbEr 3.', '', 0, 0, '2010-08-09 09:18:29', '2010-08-09 09:21:39');
INSERT INTO `tbl_problems` (`id`, `user_id`, `title`, `time_limit`, `memory_limit`, `submission_no`, `accepted_no`, `description`, `source`, `input`, `output`, `input_sample`, `output_sample`, `hint`, `flag`, `visibility`, `created`, `modified`) VALUES
(138, 1, 'PostScript Emulation', 1000, 33554432, 0000000000, 0000000000, '<p>\r\n	PostScript &reg; is widely used as a page description language for laser printers. The basic unit of measurement in PostScript is the point, and there are assumed to be exactly 72 points per inch. The default coordinate system used at the beginning of a PostScript program is the familiar Cartesian system, with the origin (the point with x and y coordinates both equal to zero) at the lower left corner of the page.</p>\r\n<p>\r\n	In this problem you are required to recognize a small part of the PostScript language. Specifically, the commands listed below must be recognized. All commands will be given in lower-case letters. When the word number appears in the command description, a floating point value, with an optional sign and decimal point will be present in the input data. When two numbers appear in a command, the first refers to the x coordinate, and the second to the y coordinate. For simplicity, each command will appear on a line by itself, and a single blank will separate each component of the command. The end of line character will immediately follow each command, and a line with a single asterisk in column one will terminate the input.</p>\r\n<p>\r\n	&nbsp;</p>\r\n<dl>\r\n	<dt>\r\n		<code><strong>number rotate</strong></code></dt>\r\n	<dt>\r\n		&nbsp;</dt>\r\n	<dd>\r\n		<strong><code>number</code> </strong> represents the measure of an angle. This command rotates the coordinate system that may degrees counter clockwise about the current origin. his does not affect any lines that have already been drawn on the page. Example: <code><strong>90 rotate</strong></code> will rotate the axes 90 degrees counterclockwise, so the positive y axis now points to the left, and the positive x axis points up.</dd>\r\n	<dt>\r\n		<code><strong>number number translate</strong></code><br />\r\n		&nbsp;</dt>\r\n	<dd>\r\n		Moves the origin of the coordinate system to the position specified. The values are interpreted relative to the current origin. Example: <code><strong>612 792 translate</strong></code> would move the origin of the coordinate system to the upper right corner of the page. Now only points with negative x and y components will correspond to points on the physical page (assuming an 8.5&quot; by 11&quot; page in the portrait orientation).</dd>\r\n	<dt>\r\n		<code><strong>number number scale </strong> </code></dt>\r\n	<dt>\r\n		&nbsp;</dt>\r\n	<dd>\r\n		This command applies the scaling factors given to the x and y coordinates. In effect, the actual x and y sizes of objects are multiplied by the respective scale factors. Example: <code><strong>3 2 scale</strong></code> would cause a line drawn from (0,0) to (72,72) to appear as if it was drawn from the lower left corner of the page to a point three inches to the right of the left edge of the paper and two inches up from the bottom edge of the paper, assuming the original coordinate system was in effect just before the command.</dd>\r\n	<dt>\r\n		<code><strong>number number moveto</strong></code></dt>\r\n	<dt>\r\n		&nbsp;</dt>\r\n	<dd>\r\n		The current point is moved to the coordinates specified. Example: <code><strong>72 144 moveto</strong></code> would move the current point to one inch from the left edge of the paper, and two inches up from the bottom edge, assuming the original coordinate system was in effect.</dd>\r\n	<dt>\r\n		<code><strong>number number rmoveto</strong></code></dt>\r\n	<dt>\r\n		&nbsp;</dt>\r\n	<dd>\r\n		This command is like <code><strong>moveto</strong></code>, except the numbers specified give the coordinates of the new current point relative to the current position. Example: <code><strong>144 -36 rmoveto</strong></code> would move the current point set by the previous example two inches further to the right and one-half inch lower on the page. Thus the coordinates of the current point become (216,108). Notice that numbers can be negative!</dd>\r\n	<dt>\r\n		<code><strong>number number lineto</strong></code></dt>\r\n	<dt>\r\n		&nbsp;</dt>\r\n	<dd>\r\n		Draws a line from the current position to the position specified by the numbers. The current position becomes the position specified in the command. Example: (216,144), would draw a line from the current position to the point (216,144), and leave the current point there. If we assume the current position from the previous example, this would be a line from (216,108) to (216,144), or a half-inch vertical line.</dd>\r\n	<dt>\r\n		<code><strong>number number rlineto</strong></code></dt>\r\n	<dt>\r\n		&nbsp;</dt>\r\n	<dd>\r\n		This is similar to <code><strong>lineto</strong></code>, but the coordinates given in the command are relative o the current position. Again, the end of the line that is drawn becomes the new current position. Example: <code><strong>0 144 rlineto</strong></code> will draw a two inch horizontal line from the current position two inches to the right. Using the current position left in the previous example, this draws a line from (216,144) to (216,288), and leaves the current point at (216,288).</dd>\r\n</dl>\r\n<p>\r\n	Your task is to read one of these small PostScript programs and to display a program that will produce the same effect <em>without</em> using the <code><strong>rotate</strong></code>, <code><strong>translate</strong></code>, or <code><strong>scale</strong></code> commands. That is, each <code><strong>moveto</strong></code>, <code><strong>rmoveto,</strong></code> <code><strong>lineto</strong></code>, and <code><strong>rlineto</strong></code> command in the original (input) program should appear in your output (most likely with modified numbers), but the <code><strong>rotate</strong></code>, <code><strong>translate</strong></code>, and <code><strong>scale</strong></code> commands in the input must not appear in the output. Assume the original coordinate system is in effect at the beginning of execution. The numbers used with the commands in the program you produce must be accurate to at least two fractional digits.</p>\r\n', '1993 North Central Region problem set', '<br />\r\n', '<p>\r\n	The figure drawn by these commands is illustrated to the right. Each of the lines is exactly one inch long.</p>\r\n<p>\r\n	<img alt="" src="/joj/userfiles/admin/0/postscrp.gif" style="width: 286px; height: 175px;" /></p>\r\n', '300 300 moveto\r\n0 72 rlineto\r\n2 1 scale\r\n36 0 rlineto\r\n1 -4 scale\r\n0 18 rlineto\r\n1 -0.25 scale\r\n0.5 1 scale\r\n300 300 translate\r\n90 rotate\r\n0 0 moveto\r\n0 72 rlineto\r\n2 1 scale\r\n36 0 rlineto\r\n1 -4 scale\r\n0 18 rlineto\r\n*\r\n', '300 300 moveto\r\n0 72 rlineto\r\n72 0 rlineto\r\n0 -72 rlineto\r\n300 300 moveto\r\n-72 0 rlineto\r\n0 72 rlineto\r\n72 0 rlineto\r\n', '', 0, 0, '2010-08-09 09:25:08', '2010-08-09 09:27:45'),
(139, 1, 'Inventory Maintenance', 1000, 33554432, 0000000000, 0000000000, '<p>\r\n	Madam Phoenix (from Problem A) hasn&#39;t been too successful with her new numerology business, so she&#39;s moving to the southwest to open a &quot;Fun In The Sun&quot; store selling sunglasses, sunscreen, and other such items. Even though she didn&#39;t make a profit using your last program, she&#39;s decided to employ you again to write an inventory program for her new store. Here&#39;s how it will work.</p>\r\n<p>\r\n	Eachd &quot;activity&quot; your program is to process will appear as a separate line in the input file. Then end of the input is marked by a line containing an asterisk in column one; no other activity lines will be so marked. Activity lines begin with a lower-case keyword identifying he action to be performed. The names of the items in her inventory are case sensitive, and each contains no more than ten non-blank characters. All fields in the activity lines are separated by blanks, and Madam Phoenix guarantees you that there will be no errors in the input. Here are the various types of activity lines your program is to process.</p>\r\n<p>\r\n	&nbsp;</p>\r\n<dl>\r\n	<dt>\r\n		<code><strong>new item-name item-cost item-selling-price</strong></code></dt>\r\n	<dt>\r\n		&nbsp;</dt>\r\n	<dd>\r\n		This line adds a new item (not previously carried in the store) to the potential inventory. The <code><strong>item-cost</strong></code> and <code><strong>item-selling-price</strong></code> are given as normal dollar amounts, without the dollar sign. That is, they will contain one or more decimal digits, a decimal point, and two more decimal digits. Note that this activity line doesn&#39;t actually result in a change n the inventory, but is used in anticipation of adding units of the new item to the store&#39;s offerings. <code><strong>item-cost</strong></code> is what Madam phoenix pays for each unit of the item, and <code><strong>item-selling-price</strong></code> is the price for which she sells the item. There will be no more than 100 total item-names ever included in the the list of items. <code><strong>item-cost</strong></code> and <code><strong>item-selling-price</strong></code> will never be larger than 100.00.</dd>\r\n	<dt>\r\n		<code><strong>delete item-name</strong></code></dt>\r\n	<dt>\r\n		&nbsp;</dt>\r\n	<dd>\r\n		If an item isn&#39;t selling well, Madam Phoenix can remove it from the inventory by including this line in the program input. All units of <code><strong>item-name</strong></code> in the inventory are written off as a loss.</dd>\r\n	<dt>\r\n		<code><strong>buy item-name quantity</strong></code></dt>\r\n	<dt>\r\n		&nbsp;</dt>\r\n	<dd>\r\n		When Madam Phoenix buys some units (at the <code><strong>unit-cost</strong></code>, previously indicated) of an <code><strong>item-name</strong></code> to offer for sale, she&#39;ll indicate that with one of these lines in the program input. <code><strong>quantity</strong></code> indicates the number of units she purchased. The quantity she purchases will never be larger than 5000 at a time, but the number of units in the inventory may be as large as 10,000.</dd>\r\n	<dt>\r\n		<code><strong>sell item-name quantity</strong></code></dt>\r\n	<dt>\r\n		&nbsp;</dt>\r\n	<dd>\r\n		When one or more units of an item are sold, that fact is recorded by placing one of these lines in the input. <code><strong>quantity</strong></code> indicates the number of units sold (at the <code><strong>item-selling-price</strong></code> previously indicated). Obviously, the quantity sold cannot exceed the number of items in stock.</dd>\r\n	<dt>\r\n		<code><strong>report</strong></code></dt>\r\n	<dt>\r\n		&nbsp;</dt>\r\n	<dd>\r\n		This line in the input requests a report. This is the only input line for which output is expected. Your program will display columns, with suitable headings, showing item-name, the buying price, the selling price, the number of units in the inventory, and the value of the units in the inventory (that is, the product of the number of units in the inventory and the buying price). The lines in the report should be sorted in alphabetical order on item name.. Following the last item the total value of all units in the inventory should be displayed. Then finally, a line should appear showing the total profit since the last report was issued. Profit is defined as total sales, less the cost of the items sold, less the cost of items written off (by the <code><strong>delete</strong></code> activity). The sample output shown illustrates the desired format for the report. All numbers in the report must naturally be exact.</dd>\r\n</dl>\r\n', '1993 North Central Region problem set', '<br />\r\n', '<br />\r\n', 'new Shade01 0.50 3.79\r\nnew Towel01 1.47 6.98\r\nnew Shade02 0.63 4.29\r\nnew BluBlock 1.00 4.98\r\nbuy BluBlock 100\r\nsell BluBlock 2\r\nbuy Towel01 500\r\nbuy Shade01 100\r\nbuy Shade02 100\r\nsell Towel01 1\r\nsell Towel01 1\r\nsell BluBlock 2\r\nreport\r\ndelete Shade01\r\nsell BluBlock 5\r\nnew Shade03 0.51 1.98\r\nbuy Shade03 250\r\nsell Towel01 5\r\nsell Shade03 4\r\nsell Shade02 10\r\nreport\r\n*\r\n', '                  INVENTORY REPORT\r\nItem Name     Buy At      Sell At      On Hand        Value\r\n---------     ------      -------      -------        -----\r\nBluBlock        1.00         4.98           96        96.00\r\nShade01         0.50         3.79          100        50.00\r\nShade02         0.63         4.29          100        63.00\r\nTowel01         1.47         6.98          498       732.06\r\n------------------------\r\nTotal value of inventory                             941.06\r\nProfit since last report                              26.94\r\n\r\n                  INVENTORY REPORT\r\nItem Name     Buy At      Sell At      On Hand        Value\r\n---------     ------      -------      -------        -----\r\nBluBlock        1.00         4.98           91        91.00\r\nShade02         0.63         4.29           90        56.70\r\nShade03         0.51         1.98          246       125.46\r\nTowel01         1.47         6.98          493       724.71\r\n------------------------\r\nTotal value of inventory                             997.87\r\nProfit since last report                              39.93\r\n', '', 0, 0, '2010-08-09 10:44:52', '2010-08-09 10:44:52'),
(140, 1, 'The Tower of Babylon', 1000, 33554432, 0000000000, 0000000000, '<p>\r\n	Perhaps you have heard of the legend of the Tower of Babylon. Nowadays many details of this tale have been forgotten. So now, in line with the educational nature of this contest, we will tell you the whole story:<br />\r\n	The babylonians had <i>n</i> types of blocks, and an unlimited supply of blocks of each type. Each type-<i>i</i> block was a rectangular solid with linear dimensions (<i>x<sub>i</sub>, y<sub>i</sub>, z<sub>i</sub></i>). A block could be reoriented so that any two of its three dimensions determined the dimensions of the base and the other dimension was the height.<br />\r\n	They wanted to construct the tallest tower possible by stacking blocks. The problem was that, in building a tower, one block could only be placed on top of another block as long as the two base dimensions of the upper block were both strictly smaller than the corresponding base dimensions of the lower block. This meant, for example, that blocks oriented to have equal-sized bases couldn&#39;t be stacked.</p>\r\n<p>\r\n	Your job is to write a program that determines the height of the tallest tower the babylonians can build with a given set of blocks.</p>\r\n', 'University of Ulm Local Contest 1996', '<p>\r\n	The input file will contain one or more test cases. The first line of each test case contains an integer <i>n</i>,representing the number of different blocks in the following data set. The maximum value for <i>n</i> is 30.Each of the next <i>n</i> lines contains three integers representing the values <i>x<sub>i</sub></i>, <i>y<sub>i</sub></i> and <i>z<sub>i</sub></i>.Input is terminated by a value of zero (0) for <i>n</i>.</p>\r\n', '<p>\r\n	For each test case, print one line containing the case number (they are numbered sequentially starting from 1) and the height of the tallest possible tower in the format &quot;Case <i>case</i>: maximum height = <i>height</i>&quot;</p>\r\n', '1\r\n10 20 30\r\n2\r\n6 8 10\r\n5 5 5\r\n7\r\n1 1 1\r\n2 2 2\r\n3 3 3\r\n4 4 4\r\n5 5 5\r\n6 6 6\r\n7 7 7\r\n5\r\n31 41 59\r\n26 53 58\r\n97 93 23\r\n84 62 64\r\n33 83 27\r\n0\r\n', 'Case 1: maximum height = 40\r\nCase 2: maximum height = 21\r\nCase 3: maximum height = 28\r\nCase 4: maximum height = 342\r\n', '', 0, 0, '2010-08-10 08:35:53', '2010-11-17 10:37:55'),
(141, 1, 'Humble Numbers', 1000, 33554432, 0000000000, 0000000000, '<p>\r\n	A number whose only prime factors are 2,3,5 or 7 is called a <i>humble</i> number. The sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 14, 15, 16, 18, 20, 21, 24, 25, 27, ... shows the first 20 humble numbers.</p>\r\n<p>\r\n	Write a program to find and print the <i>n</i>th element in this sequence.</p>\r\n', 'University of Ulm Local Contest 1996', '<p>\r\n	The input consists of one or more test cases. Each test case consists of one integer <i>n</i> with <i>1 &lt;= n &lt;= 5842</i>. Input is terminated by a value of zero (0) for <i>n</i>.</p>\r\n', '<p>\r\n	For each test case, print one line saying &quot;The <i>n</i>th humble number is <i>number</i>.&quot;. Depending on the value of <i>n</i>, the correct suffix &quot;st&quot;, &quot;nd&quot;, &quot;rd&quot;, or &quot;th&quot; for the ordinal number <i>n</i>th has to be used like it is shown in the sample output.</p>\r\n', '1\r\n2\r\n3\r\n4\r\n11\r\n12\r\n13\r\n21\r\n22\r\n23\r\n100\r\n1000\r\n5842\r\n', 'The 1st humble number is 1.\r\nThe 2nd humble number is 2.\r\nThe 3rd humble number is 3.\r\nThe 4th humble number is 4.\r\nThe 11th humble number is 12.\r\nThe 12th humble number is 14.\r\nThe 13th humble number is 15.\r\nThe 21st humble number is 28.\r\nThe 22nd humble number is 30.\r\nThe 23rd humble number is 32.\r\nThe 100th humble number is 450.\r\nThe 1000th humble number is 385875.\r\nThe 5842nd humble number is 2000000000.\r\n', '', 0, 0, '2010-08-10 08:38:22', '2010-08-10 08:38:22'),
(142, 1, 'Lotto', 1000, 33554432, 0000000000, 0000000000, '<p>\r\n	In the German Lotto you have to select 6 numbers from the set {1,2,...,49}. A popular strategy to play Lotto - although it doesn&#39;t increase your chance of winning - is to select a subset S containing <i>k</i> (<i>k</i>&gt;6) of these 49 numbers, and then play several games with choosing numbers only from S. For example, for <i>k</i>=8 and S = {1,2,3,5,8,13,21,34} there are 28 possible games: [1,2,3,5,8,13], [1,2,3,5,8,21], [1,2,3,5,8,34], [1,2,3,5,13,21], ... [3,5,8,13,21,34].</p>\r\n<p>\r\n	Your job is to write a program that reads in the number <i>k</i> and the set S and then prints all possible games choosing numbers only from S.</p>\r\n', 'University of Ulm Local Contest 1996', '<p>\r\n	The input file will contain one or more test cases. Each test case consists of one line containing several integers separated from each other by spaces. The first integer on the line will be the number <i>k</i> (6 &lt; <i>k</i> &lt; 13). Then <i>k</i> integers, specifying the set S, will follow in ascending order. Input will be terminated by a value of zero (0) for <i>k</i>.</p>\r\n', '<p>\r\n	For each test case, print all possible games, each game on one line. The numbers of each game have to be sorted in ascending order and separated from each other by exactly one space. The games themselves have to be sorted lexicographically, that means sorted by the lowest number first, then by the second lowest and so on, as demonstrated in the sample output below. The test cases have to be separated from each other by exactly one blank line. Do not put a blank line after the last test case.</p>\r\n', '7 1 2 3 4 5 6 7\r\n8 1 2 3 5 8 13 21 34\r\n0\r\n', '1 2 3 4 5 6\r\n1 2 3 4 5 7\r\n1 2 3 4 6 7\r\n1 2 3 5 6 7\r\n1 2 4 5 6 7\r\n1 3 4 5 6 7\r\n2 3 4 5 6 7\r\n\r\n1 2 3 5 8 13\r\n1 2 3 5 8 21\r\n1 2 3 5 8 34\r\n1 2 3 5 13 21\r\n1 2 3 5 13 34\r\n1 2 3 5 21 34\r\n1 2 3 8 13 21\r\n1 2 3 8 13 34\r\n1 2 3 8 21 34\r\n1 2 3 13 21 34\r\n1 2 5 8 13 21\r\n1 2 5 8 13 34\r\n1 2 5 8 21 34\r\n1 2 5 13 21 34\r\n1 2 8 13 21 34\r\n1 3 5 8 13 21\r\n1 3 5 8 13 34\r\n1 3 5 8 21 34\r\n1 3 5 13 21 34\r\n1 3 8 13 21 34\r\n1 5 8 13 21 34\r\n2 3 5 8 13 21\r\n2 3 5 8 13 34\r\n2 3 5 8 21 34\r\n2 3 5 13 21 34\r\n2 3 8 13 21 34\r\n2 5 8 13 21 34\r\n3 5 8 13 21 34\r\n', '', 0, 0, '2010-08-10 09:03:36', '2010-11-17 20:16:16'),
(143, 1, 'Matrix Chain Multiplication', 1000, 33554432, 0000000000, 0000000000, '<p>\r\n	Suppose you have to evaluate an expression like A*B*C*D*E where A,B,C,D and E are matrices.<br />\r\n	Since matrix multiplication is associative, the order in which multiplications are performed is arbitrary. However, the number of elementary multiplications needed strongly depends on the evaluation order you choose.<br />\r\n	For example, let A be a 50*10 matrix, B a 10*20 matrix and C a 20*5 matrix.<br />\r\n	There are two different strategies to compute A*B*C, namely (A*B)*C and A*(B*C).<br />\r\n	The first one takes 15000 elementary multiplications, but the second one only 3500.</p>\r\n<p>\r\n	Your job is to write a program that determines the number of elementary multiplications needed for a given evaluation strategy.</p>\r\n', 'University of Ulm Local Contest 1996', '<p>\r\n	Input consists of two parts: a list of matrices and a list of expressions.<br />\r\n	The first line of the input file contains one integer <i>n</i> (1 &lt;= <i>n</i> &lt;= 26), representing the number of matrices in the first part. The next <i>n</i> lines each contain one capital letter, specifying the name of the matrix, and two integers, specifying the number of rows and columns of the matrix.<br />\r\n	The second part of the input file strictly adheres to the following syntax (given in EBNF):</p>\r\n<p>\r\n	&nbsp;</p>\r\n<pre>\r\nSecondPart = Line { Line } &lt;EOF&gt;\r\nLine       = Expression &lt;CR&gt;\r\nExpression = Matrix | &quot;(&quot; Expression Expression &quot;)&quot;\r\nMatrix     = &quot;A&quot; | &quot;B&quot; | &quot;C&quot; | ... | &quot;X&quot; | &quot;Y&quot; | &quot;Z&quot;\r\n</pre>', '<p>\r\n	For each expression found in the second part of the input file, print one line containing the word &quot;error&quot; if evaluation of the expression leads to an error due to non-matching matrices. Otherwise print one line containing the number of elementary multiplications needed to evaluate the expression in the way specified by the parentheses.</p>\r\n', '9\r\nA 50 10\r\nB 10 20\r\nC 20 5\r\nD 30 35\r\nE 35 15\r\nF 15 5\r\nG 5 10\r\nH 10 20\r\nI 20 25\r\nA\r\nB\r\nC\r\n(AA)\r\n(AB)\r\n(AC)\r\n(A(BC))\r\n((AB)C)\r\n(((((DE)F)G)H)I)\r\n(D(E(F(G(HI)))))\r\n((D(EF))((GH)I))\r\n', '0\r\n0\r\n0\r\nerror\r\n10000\r\nerror\r\n3500\r\n15000\r\n40500\r\n47500\r\n15125\r\n', '<br />\r\n', 0, 0, '2010-08-10 09:22:45', '2010-11-06 21:44:26'),
(144, 1, 'Eeny Meeny Moo', 1000, 33554432, 0000000000, 0000000000, '<p>\r\n	Surely you have made the experience that when too many people use the Internet simultaneously, the net becomes very, very slow.<br />\r\n	To put an end to this problem, the University of Ulm has developed a contingency scheme for times of peak load to cut off net access for some cities of the country in a systematic, totally fair manner. Germany&#39;s cities were enumerated randomly from 1 to <i>n</i>. Freiburg was number 1, Ulm was number 2, Karlsruhe was number 3, and so on in a purely random order.<br />\r\n	Then a number <i>m</i> would be picked at random, and Internet access would first be cut off in city 1 (clearly the fairest starting point) and then in every <i>m</i>th city after that, wrapping around to 1 after <i>n</i>, and ignoring cities already cut off. For example, if <i>n</i>=17 and <i>m</i>=5, net access would be cut off to the cities in the order [1,6,11,16,5,12,2,9,17,10,4,15,14,3,8,13,7]. The problem is that it is clearly fairest to cut off Ulm last (after all, this is where the best programmers come from), so for a given <i>n</i>, the random number <i>m</i> needs to be carefully chosen so that city 2 is the last city selected.</p>\r\n<p>\r\n	Your job is to write a program that will read in a number of cities <i>n</i> and then determine the smallest integer <i>m</i> that will ensure that Ulm can surf the net while the rest of the country is cut off.</p>\r\n', 'University of Ulm Local Contest 1996', '<p>\r\n	The input file will contain one or more lines, each line containing one integer <i>n</i> with 3 &lt;= <i>n</i> &lt; 150, representing the number of cities in the country.<br />\r\n	Input is terminated by a value of zero (0) for <i>n</i>.</p>\r\n', '<p>\r\n	For each line of the input, print one line containing the integer <i>m</i> fulfilling the requirement specified above.</p>\r\n', '3\r\n4\r\n5\r\n6\r\n7\r\n8\r\n9\r\n10\r\n11\r\n12\r\n0\r\n', '2\r\n5\r\n2\r\n4\r\n3\r\n11\r\n2\r\n3\r\n8\r\n16\r\n', '', 0, 0, '2010-08-10 09:25:27', '2010-08-10 09:25:27'),
(146, 1, 'T和Y的计划', 1000, 33554432, 0000000000, 0000000000, 'ACM星球的程序艺术学院的T和Y相恋了。Y快要毕业了，为了前途，Y也许要去别的星球发展他的事业。于是，T和Y开始计划以后如何见面。T有个好主意，她跟Y约定在距离ACM星球和Future星球连线的中点最短的Heart星球见面，你能帮他们找出来浪漫的Heart星球吗？', 'ZJCM CXY', '<pre>\r\n<span class="di" id="clean">首行为一个数N,表示有N个星球。\r\n接下来N行，每行包括三个小数X,Y,Z，表示一个星球的坐标。\r\n第N+2行包括三个小数X,Y,Z，表示ACM星球的坐标。\r\n第N+3行包括三个小数X,Y,Z，表示Future星球的坐标。\r\nN&lt;=5000,1&lt;=X,Y,Z&lt;=99999</span></pre>', '<pre>\r\n<span class="di" id="clean">Heart星球的坐标。（保留3位小数）</span></pre>', '5\r\n1062.961900 47382.348900 49636.324000\r\n21829.052500 75418.119200 6862.009300\r\n24339.931000 6028.722000 27365.733500\r\n20111.459200 22797.250400 42073.367900\r\n29601.644400 39841.340000 55461.667800\r\n21829.052500 75418.119200 6862.009300\r\n20111.459200 22797.250400 42073.367900\r\n', '21829.053 75418.119 6862.009', '', 0, 0, '2010-08-17 05:01:14', '2010-08-17 05:01:14'),
(147, 1, '骨牌铺方格', 1000, 33554432, 0000000000, 0000000000, '<pre>\r\n<span class="di" id="clean">在1&times;n的一个长方形方格中，用1&times;1、1&times;2、1&times;3的骨牌铺满方格，输入n ，输出铺放方案的总数。\r\n例如n=3时，为1&times; 3方格，骨牌的铺放方案有四种，如下图：\r\n<img alt="" src="http://acm.zj.cn/upload/2009/12/fhl-01134558.jpg" />\r\n</span></pre>\r\n', 'ZJCM FHL', '<pre>\r\n<span class="di" id="clean">输入数据由多行组成，每行包含一个整数n，表示该测试实例的长方形方格的规格是1&times;n (0&lt;n&lt;=30)。当n=0时，表示输入结束，该行不做处理。</span></pre>\r\n', '<pre>\r\n<span class="di" id="clean">对于每个测试实例，请输出铺放方案的总数，每个实例的输出占一行。</span></pre>\r\n', '1\r\n2\r\n3\r\n0\r\n', '1\r\n2\r\n4\r\n', '', 0, 0, '2010-08-17 05:04:37', '2010-11-16 22:18:31'),
(148, 1, 'Max Area ', 1000, 33554432, 0000000000, 0000000000, '<pre>\r\n<span class="di" id="clean">又是这道题，请不要惊讶，也许你已经见过了，那就请你再来做一遍吧。这可是wolf最骄傲的题目哦。\r\n在笛卡尔坐标系正半轴（x&gt;=0,y&gt;=0）上有n个点，给出了这些点的横坐标和纵坐标，但麻烦的是这些点的坐标没有配对好，你的任务就是将这n个点的横坐标和纵坐标配对好，使得这n个点与x轴围成的面积最大。</span></pre>\r\n', 'ZJCM WL', '<pre>\r\n<span class="di" id="clean">在数据的第一行有一个正整数m,表示有m组测试实例。接下来有m行，每行表示一组测试实例。每行的第一个数n，表示给出了n个点，接着给出了n个x坐标和y坐标。（给出的x轴的数据不会重复，y轴数据也不会重复）（m&lt;5000,1&lt;n&lt;50）\r\n如：\r\n2\r\n4 x1 x2 x3 x4 y1 y2 y3 y4\r\n5 x1 x2 x3 x4 x5 y1 y2 y3 y4 y5</span></pre>\r\n<p>\r\n	<span class="b">&nbsp;</span></p>\r\n', '<pre>\r\n<span class="di" id="clean">输出所计算的最大面积，结果保留两位小数，每组数据占一行。</span></pre>\r\n', '2\r\n4 0 1 3 5 1 2 3 4\r\n6 14 0 5 4 6 8 1 5 6 2 4 3\r\n', '15.00\r\n59.00\r\n', '', 0, 0, '2010-08-17 05:07:59', '2010-08-17 05:09:54'),
(149, 1, 'MC part deux', 1000, 33554432, 0000000000, 0000000000, '<p>The Dean has determined that mathies have outgrown the building that has served them so well for many years. Luckily for him, the PM has decided to stimulate the economy by funding a new math building. To maximize the stimulating effect, the construction process is outsourced to a software engineering consultant who employs agile methodologies. The building will be built first, and designed later. The Dean has some concerns about this innovative process. After all, it would be very embarrassing if the walls of the new math building failed to line up at right angles!</p>\r\n<p>The Dean sneaks out one night with a tape measure to survey the last remaining grassy area on campus, where the new building will go. He drives stakes into the ground, then measures the distances between them. Afterwards, he retreats into his office to construct a map from his measurements. He notices that the first three stakes form a right-angled triangle with arms of length one metre and hypotenuse of length sqrt(2) metres. And that\\''s not all. The Dean plots these first three stakes on a piece of graph paper at coordinates (0,0), (0,1), and (1,0). After plotting some of the other stakes, it turns out that all of the stakes happen to be precisely at lattice points (i.e. points with integer coordinates) on the graph paper. Still, plotting all of the many stakes is tedious, so he asks his co-op student (i.e. you) to help out.</p>', 'http://plg1.cs.uwaterloo.ca/~acm00/090927/A.html', '<p>Input consists of a number of test cases. The first line of each test case contains two integers <i>n</i> and <i>m</i>, each at least 1 and no larger than 1000. The integer <i>n</i> is the number of lines that follow, and <i>m</i> is the number of stakes. The stakes are numbered from 1 to <i>m</i>. All of the stakes are at distinct locations. The x and y coordinates of each stake are no less than -1000000 and no greater than 1000000. Each of the following lines contains exactly six integers <i>a</i>, <i>b</i>, <i>c</i>, <i>x</i>, <i>y</i>, <i>z</i>. The integers <i>a</i>, <i>b</i>, and <i>c</i> are the numbers of three stakes. The three stakes are always listed in counter-clockwise order. That is, to move from stake <i>a</i> to stake <i>b</i> and then to stake <i>c</i>, one must turn left at stake <i>b</i>. The number <i>x</i> is the square of the distance from stake <i>a</i> to stake <i>b</i>. The number <i>y</i> is the square of the distance from stake <i>b</i> to stake <i>c</i>. The number <i>z</i> is the square of the distance from stake <i>c</i> to stake <i>a</i>. Every stake will appear in at least one line of the input. For every pair of stakes <i>a</i>, <i>b</i>, there is a subset of the triangles in the input that forms a sequence <i>T<sub>1</sub></i>, <i>T<sub>2</sub></i>, ..., <i>T<sub>n</sub></i> such that two of the vertices of <i>T<sub>i</sub></i> are also vertices of <i>T<sub>i+1</sub></i> for all 0&lt;<i>i</i>&lt;<i>n</i>, <i>a</i> is a vertex of <i>T<sub>1</sub></i>, and <i>b</i> is a vertex of <i>T<sub>n</sub></i>. The last line of input is <tt>0 0</tt>. These zeros are not values of <i>n</i> and <i>m</i>, and should not be processed as such.</p>', '<p>Output consists of exactly <i>m</i> lines for each test case. The <i>m</i> lines describe the stakes 1 to <i>m</i> in sequence. Each line contains two integers, giving the <i>x</i> and <i>y</i> coordinates of the stake. The first three lines of output for each test case are always:</p>\r\n<pre>\r\n0 0\r\n0 1\r\n1 0\r\n</pre>', '1 3\r\n1 3 2 1 2 1\r\n0 0', '0 0\r\n0 1\r\n1 0\r\n', '', 0, 0, '2010-08-18 20:18:05', '2010-08-18 20:18:05'),
(150, 1, 'Moveable maze', 1000, 33554432, 0000000000, 0000000000, '<p>After solving a difficult programming problem, you decide to take a break and play a puzzle game. After playing the game for a while, you decide to write a program to solve it for you.</p>\r\n<p>The game is played on a grid with <i>R</i> rows and <i>C</i> columns. Each square of the grid contains a black dot in the centre and black lines in the direction of some, none, or all of its north, east, south, and west neighbouring squares. Your objective in this game is to move your playing piece from the centre of the square in the <i>i<sub>1</sub></i><sup>th</sup> row and the <i>j<sub>1</sub></i><sup>th</sup> column, where it begins, to the centre of the square in the the <i>i<sub>2</sub></i><sup>th</sup> row and the <i>j<sub>2</sub></i><sup>th</sup> column.</p>\r\n<p>You wish to do this in the least number of turns possible, where a turn consists of the following two parts. First in each turn, you may opt to select any grid square and rotate it 90 degrees clockwise or counterclockwise. Second in each turn, you may opt to move your piece from the centre of its current grid square to the centre of a neighbouring grid square, provided your piece does not leave the black markings. In other words, you may move from a square A to a neighbouring square B if A has a black line in the direction of B and B has a black line in the direction of A. Note that either part of a turn may be omitted.</p>', '', '<p>Input consists of a number of test cases. The first line of each test case contains the two integers <i>R</i> and <i>C</i>, separated by spaces, with 1 &lt;= <i>R</i>, <i>C</i> &lt;= 20.</p>\r\n<p>The next line contains the integers <i>i<sub>1</sub></i>, <i>j<sub>1</sub></i>, <i>i<sub>2</sub></i>, <i>j<sub>2</sub></i>, separated by spaces, with 1 &lt;= <i>i<sub>1</sub></i>, <i>i<sub>2</sub></i> &lt;= <i>R</i> and 1 &lt;= <i>j<sub>1</sub></i>, <i>j<sub>2</sub></i> &lt;= <i>C</i>.</p>\r\n<p>The following <i>R</i> lines of input each contain one row of the grid, from north to south. Each of these lines contains exactly <i>C</i> strings of letters, separated by spaces, that correspond to squares of the grid, from west to east. Their format is as follows:</p>\r\n<ul>\r\n    <li>If the string is the single character <tt>x</tt>, then the square does not contain a line to any of its neighbours.</li>\r\n    <li>Otherwise, the string contains some of the characters <tt>N</tt>, <tt>E</tt>, <tt>S</tt>, <tt>W</tt>, which indicate that a black line extends from this square\\''s centre in the direction of its north, east, south, or west neighbour, respectively. No character will appear in the string more than once.</li>\r\n</ul>\r\n<p>It is guaranteed that it is possible to move your playing piece from  (<i>i<sub>1</sub></i>, <i>j<sub>1</sub></i>) to (<i>i<sub>2</sub></i>, <i>j<sub>2</sub></i>).</p>\r\n<p>Input is terminated by a line containing <tt>0 0</tt>. These zeros are not a test case and should not be processed.</p>\r\n<p>&nbsp;</p>\r\n<pre>\r\n4 2\r\n1 1 4 1\r\nE SW\r\nx EW\r\nNW ES\r\nN x\r\n0 0\r\n</pre>\r\n<p>A diagram of the input:</p>\r\n<p><br />\r\n<img src="http://plg1.cs.uwaterloo.ca/~acm00/090927/Bexample.png" alt="" /></p>', '<p>Output consists of exactly one line for each test case. The lines contains an integer: the minimum number of turns to move your playing piece from (<i>i<sub>1</sub></i>, <i>j<sub>1</sub></i>) to (<i>i<sub>2</sub></i>, <i>j<sub>2</sub></i>).</p>', '4 2\r\n1 1 4 1\r\nE SW\r\nx EW\r\nNW ES\r\nN x\r\n0 0\r\n', '5\r\n', 'An example optimal solution is:\r\n\r\n   1. Rotate (2,2) clockwise. Step to (1,2).\r\n\r\n   2. Rotate (3,2) counterclockwise. Step to (2,2).\r\n\r\n   3. Rotate (3,2) counterclockwise. Step to (3,2).\r\n\r\n   4. Rotate (3,1) clockwise. Step to (3,1).\r\n\r\n   5. Rotate (3,1) clockwise. Step to (4,1). ', 0, 0, '2010-08-18 20:19:28', '2010-08-18 20:19:28'),
(151, 1, 'Pick up sticks', 1000, 33554432, 0000000000, 0000000000, '<p>Pick up sticks is a fascinating game. A collection of coloured sticks are dumped in a tangled heap on the table. Players take turns trying to pick up a single stick at a time without moving any of the other sticks. It is very difficult to pick up a stick if there is another stick lying on top of it. The players therefore try to pick up the sticks in an order such that they never have to pick up a stick from underneath another stick.</p>\r\n<img align="right" width="411" height="330" src="http://plg1.cs.uwaterloo.ca/%7Eacm00/090927/C.png" alt="" />', '', '<p>The input consists of several test cases. The first line of each test case contains two integers <i>n</i> and <i>m</i> each at least one and no greater than one million. The integer <i>n</i> is the number of sticks, and  <i>m</i> is the number of lines that follow. The sticks are numbered from 1 to <i>n</i>. Each of the following lines contains a pair of integers <i>a</i>, <i>b</i>, indicating that there is a point where stick <i>a</i> lies on top of stick <i>b</i>. The last line of input is <tt>0 0</tt>. These zeros are not values of <i>n</i> and <i>m</i>, and should not be processed as such.</p>', '<p>For each test case, output <i>n</i> lines of integers, listing the sticks in the order in which they could be picked up without ever picking up a stick with another stick on top of it. If there are multiple such correct orders, any one will do. If there is no such correct order, output a single line containing the word <tt>IMPOSSIBLE</tt>.</p>', '3 2\r\n1 2\r\n2 3\r\n0 0\r\n', '1\r\n2\r\n3\r\n', '', 0, 0, '2010-08-18 20:19:58', '2010-08-18 20:19:58'),
(152, 1, 'Digits', 1000, 33554432, 0000000000, 0000000000, '<p><img align="right" width="270" height="164" alt="" src="http://plg1.cs.uwaterloo.ca/%7Eacm00/090927/D.png" /></p>\r\n<p>A googol written out in decimal has 101 digits. A googolplex has one plus a googol digits. That''s a lot of digits!</p>\r\n<p>Given any number <i>x<sub>0</sub></i>, define a sequence using the following recurrence:</p>\r\n<p>&nbsp;</p>\r\n<center>     <i>x<sub>i+1</sub></i> = the number of digits in the decimal representation of <i>x<sub>i</sub></i> </center>\r\n<p>Your task is to determine the smallest positive <i>i</i> such that <i>x<sub>i</sub></i> = <i>x<sub>i-1</sub></i>.</p>', 'http://plg1.cs.uwaterloo.ca/~acm00/090927/D.html', '<p>Input consists of several lines. Each line contains a value of <i>x<sub>0</sub></i>. Every value of <i>x<sub>0</sub></i> is non-negative and has no more than one million digits. The last line of input contains the word <tt>END</tt>.</p>', '<p>For each value of <i>x<sub>0</sub></i> given in the input, output one line containing the smallest positive <i>i</i> such that <i>x<sub>i</sub></i> = <i>x<sub>i-1</sub></i>.</p>', '42\r\nEND\r\n', '3\r\n', '', 0, 0, '2010-08-18 20:20:05', '2010-08-18 20:20:05'),
(153, 1, 'Rotate to root', 1000, 33554432, 0000000000, 0000000000, '<p>\r\n	Rotate-to-root is a heuristic for balancing binary search trees. In this problem, the contents of the tree will be ignored, and you will be asked about the effect the heuristic has on the structure of the tree.</p>\r\n<p>\r\n	A binary tree is either empty or consists of a node with a left child and a right child, where each of the children are also binary trees. No node has more than one parent, and there are no cycles. In any non-empty tree, there is exactly one node without a parent, which is called the root of the tree.</p>\r\n<p>\r\n	The rotate-to-root heuristic takes effect when a node in the tree, say X, is accessed. While X is not the root of the tree, the following procedure is executed:</p>\r\n<ul>\r\n	<li>\r\n		If X is the left child of its parent, a right tree rotation is performed. Let P be the parent of X, let A be X&#39;s left child, let B be X&#39;s right child, and let C be the right child of P. Then, P is replaced in the tree by X, so P&#39;s parent (if any) becomes X&#39;s parent; X&#39;s right child becomes P&#39;s left child (which replaces X); and P replaces X&#39;s right child. Diagram:<br />\r\n		<img alt="" height="180" src="http://plg1.cs.uwaterloo.ca/%7Eacm00/090927/Erightrot.png" width="419" /></li>\r\n	<li>\r\n		If X is the right child of its parent, a left tree rotation is performed. Let P be the parent of X, let A be the left child of P, let be B be X&#39;s left child, and let C be X&#39;s right child. Then, P is replaced in the tree by X, so P&#39;s parent (if any) becomes X&#39;s parent; X&#39;s left child becomes P&#39;s right child (which replaces X); and P replaces X&#39;s left child. Diagram:<br />\r\n		<img alt="" height="180" src="http://plg1.cs.uwaterloo.ca/%7Eacm00/090927/Eleftrot.png" width="422" /></li>\r\n</ul>\r\n<p>\r\n	Tree rotations preserve the order of the nodes in the tree, which is why they are useful, but that is not important for this problem.</p>\r\n<p>\r\n	The height of a binary tree is the longest length of a path from its root to the bottom of the tree. More formally, the height of the empty tree is 0, and the height of a non-empty tree that has a root node X with children A and B is 1 + max{height(A), height(B)}.</p>\r\n<p>\r\n	Given a binary tree, you must determine, for each node X, what the height of the tree would be after X is rotated to root.</p>\r\n', '', '<p>\r\n	Input consists of a number of test cases. The first line of each test case contains the integer <i>N</i>, the number of nodes in the binary tree, where 1 &lt;= <i>N</i> &lt;= 10<sup>5</sup>.</p>\r\n<p>\r\n	The following <i>N</i> lines of input each contain two integers. The <i>i</i><sup>th</sup> pair of these integers is <i>l<sub>i</sub></i> and <i>r<sub>i</sub></i>, the left and right children of node <i>i</i>. If <i>l<sub>i</sub></i> = 0, then the left child of node <i>i</i> is the empty tree, and if <i>r<sub>i</sub></i> = 0, then the right child of node <i>i</i> is the empty tree. Otherwise, 1 &lt;= <i>l</i>, <i>r</i> &lt;= N.</p>\r\n<p>\r\n	It is guaranteed that the input will describe a binary tree.</p>\r\n<p>\r\n	The last test case is followed by a line containing the integer <tt>0</tt>. This final line is not a test case and should not be processed.</p>\r\n', '<p>\r\n	Output consists of <i>N</i> lines for each test case, where the <i>i</i><sup>th</sup> line contains an integer giving the height of the tree after node <i>i</i> is rotated to root.</p>\r\n', '4\r\n2 3\r\n4 0\r\n0 0\r\n0 0\r\n0\r\n', '3\r\n3\r\n4\r\n3', '<br />\r\n', 0, 0, '2010-08-18 20:20:07', '2010-11-20 21:35:38'),
(154, 1, 'Tic Tac Toe', 1000, 134217728, 0000000000, 0000000000, '<p>\r\n	<img align="right" alt="" src="http://plg1.cs.uwaterloo.ca/%7Eacm00/090613/A.png" /></p>\r\n<p>\r\n	The game of Tic Tac Toe is played on an</p>\r\n<p>\r\n	<i>n</i></p>\r\n<p>\r\n	-by-</p>\r\n<p>\r\n	<i>n</i></p>\r\n<p>\r\n	grid (where</p>\r\n<p>\r\n	<i>n</i></p>\r\n<p>\r\n	is usually but not necessarily three). Two players alternate placing symbols on squares of the grid. One player places Xes and the other player places Os. The player placing Xes always goes first. When the grid contains a vertical, horizontal, or diagonal sequence of at least</p>\r\n<p>\r\n	<i>m</i></p>\r\n<p>\r\n	consecutive squares all containing the same symbol, the game ends and the winner is the player who placed the last symbol. When all the squares of the grid are filled, if neither player has won, the game ends in a draw.</p>\r\n<p>\r\n	Your task is to analyze the state of a Tic Tac Toe board, and determine whether the game is still in progress, or if it has completed, who won, or if the game ended in a draw. You should also detect erroneous states of the Tic Tac Toe board that could never occur during an actual game.</p>\r\n', 'http://plg1.cs.uwaterloo.ca/~acm00/090613/A.html', '<p>\r\n	The first line of input contains the two integers <i>n</i> and <i>m</i>, separated by spaces, with 1 &lt;= <i>m</i> &lt;= <i>n</i> &lt;= 2000. The following <i>n</i> lines of input each contain one row of the Tic Tac Toe board. Each of these lines contains exactly <i>n</i> characters, and each of these characters is either an <tt>X</tt>, an <tt>O</tt>, or a period (<tt>.</tt>), indicating an empty square.</p>\r\n', '<p>\r\n	Output a single line containing the appropriate string <tt>X WINS</tt>, <tt>O WINS</tt>, or <tt>DRAW</tt> if the game is over, the string <tt>IN PROGRESS</tt> if the game has not yet finished, or <tt>ERROR</tt> if the state of the board could never occur during a game.</p>\r\n', '3 3\r\n..X\r\nOOX\r\n..X\r\n', 'X WINS\r\n', '', 0, 0, '2010-08-18 20:47:29', '2010-08-18 12:51:51'),
(155, 1, 'Fire!', 1000, 33554432, 0000000000, 0000000000, '<p><img align="right" alt="" src="http://plg1.cs.uwaterloo.ca/%7Eacm00/090613/B.png" /></p>\r\n<p>Joe works in a maze. Unfortunately, portions of the maze have caught on fire, and the owner of the maze neglected to create a fire escape plan. Help Joe escape the maze.</p>\r\n<p>Given Joe''s location in the maze and which squares of the maze are on fire, you must determine whether Joe can exit the maze before the fire reaches him, and how fast he can do it.</p>\r\n<p>Joe and the fire each move one square per minute, vertically or horizontally (not diagonally). The fire spreads all four directions from each square that is on fire. Joe may exit the maze from any square that borders the edge of the maze. Neither Joe nor the fire may enter a square that is occupied by a wall.</p>', 'http://plg1.cs.uwaterloo.ca/~acm00/090613/B.html', '<p>The first line of input contains the two integers <i>R</i> and <i>C</i>, separated by spaces, with 1 &lt;= <i>R</i>,<i>C</i> &lt;= 1000. The following <i>R</i> lines of input each contain one row of the maze. Each of these lines contains exactly <i>C</i> characters, and each of these characters is one of:</p>\r\n<ul>\r\n    <li><tt>#</tt>, a wall</li>\r\n    <li><tt>.</tt>, a passable square</li>\r\n    <li><tt>J</tt>, Joe''s initial position in the maze, which is a passable square</li>\r\n    <li><tt>F</tt>, a square that is on fire</li>\r\n</ul>\r\n<p>There will be exactly one <tt>J</tt> in the input.</p>\r\n<h3>Sample Input</h3>\r\n<h5>I</h5>\r\n<pre>\r\n4 4\r\n####\r\n#JF#\r\n#..#\r\n#..#\r\n</pre>\r\n<h5>II</h5>\r\n<pre>\r\n3 3\r\n###\r\n#J.\r\n#.F\r\n</pre>', '<p>Output a single line containing <tt>IMPOSSIBLE</tt> if Joe cannot exit the maze before the fire reaches him, or an integer giving the earliest time Joe can safely exit the maze, in minutes.</p>\r\n<h5>I</h5>\r\n<pre>\r\n3\r\n</pre>\r\n<h5>II</h5>\r\n<pre>\r\nIMPOSSIBLE\r\n</pre>', '4 4\r\n####\r\n#JF#\r\n#..#\r\n#..#\r\n', '3\r\n\r\n', '', 0, 0, '2010-08-18 20:47:30', '2010-08-18 20:47:30'),
(156, 1, 'Nice Prefixes', 1000, 33554432, 0000000000, 0000000000, '<p>Consider strings formed from characters from an alphabet of size <i>K</i>. For example, if <i>K = 4</i>, our alphabet might be <i>{a,b,c,d}</i>, and an example string is <i>bbcac</i>.</p>\r\n<p>For a string <i>S</i>, define <i>count(S, k)</i> to be the number of occurrences of the symbol <i>k</i> in <i>S</i>. For example, <i>count(bbcac, b) = 2</i> and <i>count(bbcac, a) = 1</i>.</p>\r\n<p>A prefix of a string <i>S</i> is any string obtained from <i>S</i> by deleting some (possibly none) of the trailing characters of <i>S</i>. For example, the prefixes of <i>acb</i> are the empty string, <i>a</i>, <i>ac</i>, and <i>acb</i>.</p>\r\n<p>A string <i>S</i> has &quot;nice prefixes&quot; if for every prefix <i>P</i> of <i>S</i> and for every two characters <i>k1</i> and <i>k2</i> in the alphabet, <i>|count(P, k1) - count(P, k2)| &lt;= 2</i>. For example, <i>bbcac</i> has nice prefixes, but <i>abbbc</i> does not because <i>count(abbb, b) = 3</i> and <i>count(abbb, c) = 0</i>.</p>\r\n<p>Count the number of strings of length <i>L</i> on an alphabet of size <i>K</i> that have nice prefixes. This number can be large, so print its remainder when divided by 1000000007.</p>', 'http://plg1.cs.uwaterloo.ca/~acm00/090613/C.html', '<p>The input is a single line containing the two integers <i>L</i> and <i>K</i>, separated by spaces, with 1 &lt;= <i>L</i> &lt;= 10<sup>18</sup> and 1 &lt;= <i>K</i> &lt;= 50.</p>', '<p>Output a single line containing the number of strings of length <i>L</i> on an alphabet of size <i>K</i> that have nice prefixes, modulo 1000000007.</p>', '4 2\r\n', '12\r\n', '', 0, 0, '2010-08-18 20:47:31', '2010-08-18 20:47:31');
INSERT INTO `tbl_problems` (`id`, `user_id`, `title`, `time_limit`, `memory_limit`, `submission_no`, `accepted_no`, `description`, `source`, `input`, `output`, `input_sample`, `output_sample`, `hint`, `flag`, `visibility`, `created`, `modified`) VALUES
(157, 1, 'Convex Hull', 1000, 33554432, 0000000000, 0000000000, '<p>\r\n	<img align="right" alt="" src="http://plg1.cs.uwaterloo.ca/%7Eacm00/090613/D.png" /></p>\r\n<p>\r\n	Finding the convex hull of a set of points is an important problem that is often part of a larger problem. There are many algorithms for finding the convex hull. Since problems involving the convex hull sometimes appear in the ACM World Finals, it is a good idea for contestants to know some of these algorithms.</p>\r\n<p>\r\n	Finding the convex hull of a set of points in the plane can be divided into two sub-tasks. First, given a set of points, find a subset of those points that, when joined with line segments, form a convex polygon that encloses all of the original points. Second, output the points of the convex hull in order, walking counter-clockwise around the polygon. In this problem, the first sub-task has already been done for you, and your program should complete the second sub-task. That is, given the points that are known to lie on the convex hull, output them in order walking counter-clockwise around the hull.</p>\r\n', 'http://plg1.cs.uwaterloo.ca/~acm00/090613/D.html', '<p>\r\n	The first line of input contains a single integer 3 &lt;= <i>n</i> &lt;= 100000, the number of points. The following <i>n</i> lines of input each describe a point. Each of these lines contains two integers and either a <tt>Y</tt> or an <tt>N</tt>, separated by spaces. The two integers specify the x- and y-coordinates of the point. A <tt>Y</tt> indicates that the point is on the convex hull of all the points, and a <tt>N</tt> indicates that it is not. The x- and y-coordinates of each point will be no less than -1000000000 and no greater than 1000000000. No point will appear more than once in the input. The points in the input will never all lie on a line.</p>\r\n', '<p>\r\n	First, output a line containing a single integer <i>m</i>, the number of points on the convex hull. Next output <i>m</i> lines, each describing a point on the convex hull, in counter-clockwise order around the hull. Each of these lines should contain the x-coordinate of the point, followed by a space, followed by the y-coordinate of the point. Start with the point on the hull whose x-coordinate is minimal. If there are multiple such points, start with the one whose y-coordinate is minimal.</p>\r\n', '5\r\n1 1 Y\r\n1 -1 Y\r\n0 0 N\r\n-1 -1 Y\r\n-1 1 Y\r\n', '4\r\n-1 -1\r\n1 -1\r\n1 1\r\n-1 1\r\n', '', 0, 0, '2010-08-18 20:47:31', '2010-11-23 19:16:33'),
(158, 1, 'Slalom', 1000, 33554432, 0000000000, 0000000000, '<img align="right" src="http://plg1.cs.uwaterloo.ca/%7Eacm00/090613/E.png" alt="" />\r\n<p>You are competing in a ski slalom, and you need to select the best skis for the race. The format of the race is that there are</p>\r\n<i>N</i>\r\n<p>pairs of left and right gates, where each right gate is</p>\r\n<i>W</i>\r\n<p>metres to the right of its corresponding left gate, and you may neither pass to the left of the left gate nor to the right of the right gate. The</p>\r\n<i>i</i><sup>th</sup>\r\n<p>pair of gates occurs at distance</p>\r\n<i>y<sub>i</sub></i>\r\n<p>down the hill, with the horizontal position of the</p>\r\n<i>i</i><sup>th</sup>\r\n<p>left gate given by</p>\r\n<i>x<sub>i</sub></i>\r\n<p>. Each gate is further down the hill than the previous gate (i.e.</p>\r\n<i>y<sub>i</sub></i>\r\n<p>&lt;</p>\r\n<i>y<sub>i+1</sub></i>\r\n<p>for all</p>\r\n<i>i</i>\r\n<p>).</p>\r\n<p>You may select from <i>S</i> pairs of skis, where the <i>j</i><sup>th</sup> pair has speed <i>s<sub>j</sub></i>. Your movement is governed by the following rule: if you select a pair of skis with speed <i>s<sub>j</sub></i>, you move with a constant downward velocity of <i>s<sub>j</sub></i> metres per second. Additionally, at any time you may move at a horizontal speed of at most <i>v<sub>h</sub></i> metres per second.</p>\r\n<p>You may start and finish at any two horizontal positions. Determine which pair of skis will allow you to get through the race course, passing through all the gates, in the shortest amount of time.</p>', 'http://plg1.cs.uwaterloo.ca/~acm00/090613/E.html', '<p>The first line of input contains the three integers <i>W</i>, <i>v<sub>h</sub></i>, and <i>N</i>, separated by spaces, with 1 &lt;= <i>W</i> &lt;= 10<sup>8</sup>, 1 &lt;= <i>v<sub>h</sub></i> &lt;= 10<sup>6</sup>, and 1 &lt;= <i>N</i> &lt;= 10<sup>5</sup>.</p>\r\n<p>The following <i>N</i> lines of input each contain two integers <i>x<sub>i</sub></i> and <i>y<sub>i</sub></i>, the horizontal and vertical positions respectively of the <i>i</i><sup>th</sup> left gate, with 1 &lt;= <i>x<sub>i</sub></i>, <i>y<sub>i</sub></i> &lt;= 10<sup>8</sup>.</p>\r\n<p>The next line of input contains an integer <i>S</i>, the number of skis, with 1 &lt;= <i>S</i> &lt;= 10<sup>6</sup>.</p>\r\n<p>The following <i>S</i> lines of input each contain one integer <i>s<sub>j</sub></i>, the speed of the <i>j</i><sup>th</sup> pair of skis, with 1 &lt;= <i>s<sub>j</sub></i> &lt;= 10<sup>6</sup>.</p>\r\n<h5>I</h5>\r\n<pre>\r\n3 2 3\r\n1 1\r\n5 2\r\n1 3\r\n3\r\n3\r\n2\r\n1\r\n</pre>\r\n<h5>II</h5>\r\n<pre>\r\n3 2 3\r\n1 1\r\n5 2\r\n1 3\r\n1\r\n3\r\n</pre>', '<p>If it is impossible to complete the race with any pair of skis, print the line <tt>IMPOSSIBLE</tt>. Otherwise, print the vertical speed <i>s<sub>j</sub></i> of the pair of skis that allows you to get through the race course in the shortest time.</p>\r\n<h5>I</h5>\r\n<pre>\r\n2\r\n</pre>\r\n<h5>II</h5>\r\n<pre>\r\nIMPOSSIBLE\r\n</pre>', '3 2 3\r\n1 1\r\n5 2\r\n1 3\r\n3\r\n3\r\n2\r\n1\r\n', '2\r\n', '', 0, 0, '2010-08-18 20:47:31', '2010-08-18 20:47:31'),
(159, 1, 'Laurel Creek', 1000, 33554432, 0000000000, 0000000000, '<p>Laurel Creek is a perilous river that divides the campus into two halves and contains dangerous inhabitants such as geese and beavers. Your task in this problem is to find a way to cross the river without getting wet.</p>\r\n<p>To do so, you will take advantage of several tree stumps in the middle of the river. A tree stump provides a safe place for you to stand as you ponder your next move. To get from one stump to another, you walk along logs that connect the stumps.</p>\r\n<p>In cases where no log connects to the stump you wish to reach, all is not lost. You may pick up any log adjacent to the stump on which you are standing and put it down somewhere else so that it leads to the stump you wish to reach. In order for a log to be considered adjacent to a stump, it must be oriented in the appropriate direction; for example the log in <tt>S-S</tt> is adjacent to the two stumps, but the log in <tt>S|S</tt> is not considered adjacent to the two stumps.</p>\r\n<p>Each tree stump is located at a point on a square grid. Two stumps are designated as the beginning and end point of the crossing. Any two stumps lying in the same row or column of the grid may be connected by a log. At any point in time, you may perform one of the following legal moves:</p>\r\n<ul>\r\n    <li>Traverse a log adjacent to the tree stump you are standing on     to the tree stump at the opposite end of the log.</li>\r\n    <li>Pick up a log adjacent to the tree stump you are standing on.     You may not hold more than one log at a time.</li>\r\n    <li>Put down the log that you are holding so that it connects     the stump you are standing on to some other stump. The log must     be of precisely the right length to reach the other stump.     The log must rest in the water: you may not use a log to connect     two stumps if there is a third stump directly between them,     or if the log would cross some other log already in the water.</li>\r\n</ul>', 'http://plg1.cs.uwaterloo.ca/~acm00/080927/A.html', '<p>The first line of input contains one integer specifying the number of test cases to follow. Each test case begins with a line containing two integers 1 &lt;= <i>r</i> &lt;= 15 and 1 &lt;= <i>c</i> &lt;= 15 specifying the number of rows and columns in the grid. Each of the next <i>r</i> lines of input contains <i>c</i> characters with the following meaning. The character <tt>S</tt> denotes a stump. The characters <tt>B</tt> and <tt>E</tt> denote the beginning and end stumps of the crossing, respectively.  A consecutive sequence of <tt>-</tt> or <tt>|</tt> characters in a line denotes a single log whose length is proportional to the number of symbols. The character <tt>.</tt> denotes an empty grid point containing only water. There will never be more than fifteen stumps in the river.</p>', '<p>For each test case, output a line containing a single integer, the minimum number of moves in which the end stump can be reached from the initial configuration. If it is not possible to reach the end stump from the initial configuration, output a line containing the integer 0.</p>\r\n<h3>&nbsp;</h3>', '1\r\n7 11\r\n....S......\r\n....|......\r\nB---S......\r\n...........\r\n...........\r\n...........\r\n....S.S...E\r\n', '10\r\n', '', 0, 0, '2010-08-18 21:00:22', '2010-08-18 21:00:22'),
(160, 1, 'Rocket Stages', 10000, 33554432, 0000000000, 0000000000, '<p>Many rockets are made up of several stages to increase efficiency. When the fuel in one stage burns up, the stage can be discarded, reducing the weight of the remaining rocket. The first stage needs a strong engine capable of lifting the whole rocket, while later stages can have smaller engines.</p>\r\n<p>In this problem, you will determine which stages to put together to maximize the upward velocity of the rocket when all the fuel has burned.</p>\r\n<p>For each stage, you will be given:</p>\r\n<ul>\r\n    <li>the mass <i>S</i> of the stage, in kilograms, when it is empty (without fuel),</li>\r\n    <li>the mass <i>L</i> of the fuel, in kilograms, in the stage,</li>\r\n    <li>the thrust <i>T</i>, in newtons, provided by the engine in the stage, and</li>\r\n    <li>the fuel consumption <i>C</i>, in kilograms per second, of the stage.</li>\r\n</ul>\r\n<p>Assume that the rocket points straight upward for the duration of the flight. Two forces act on the rocket: the force of the engine, which is <i>T</i> newtons upwards, and the force of gravity, which is 9.8 <i>M</i> newtons downwards, where <i>M</i> is the total mass of the rocket in kilograms, including fuel. The acceleration of the rocket is <i>F</i> divided by <i>M</i> metres per second per second upwards, where <i>F</i> is the total net force acting on the rocket in newtons, and <i>M</i> is the total mass of the rocket in kilograms, including fuel. As soon as a stage finishes burning, it is immediately discarded and the next stage starts to burn. The final velocity of the rocket is the integral of the net acceleration (due to gravity and the engine) over time.</p>\r\n<p>Due to safety regulations, the net acceleration of the rocket is never allowed to be downwards, until the rocket runs out of fuel.</p>\r\n<p>Also due to safety regulations, the total mass of the rocket cannot exceed 10000 kilograms.</p>\r\n<p>The rocket must have at least one stage.</p>\r\n<p>&nbsp;</p>\r\n<h3>&nbsp;</h3>', 'http://plg1.cs.uwaterloo.ca/~acm00/080927/B.html', '<p>The first line of input contains one integer specifying the number of test cases to follow. Each test case begins with a line containing an integer <i>N</i>, the number of rocket stages in the current test case. There will be no more than 1000 stages. This line is followed by <i>N</i> lines, one for each stage. Each of these lines contains the four integers <i>S</i>, <i>L</i>, <i>T</i>, <i>C</i> that describe a stage, as explained above. Each of these integers can be represented by a 32-bit unsigned binary number. The order of the stages as listed must be preserved but some stages (including, possibly, the first stage) may be left out of the rocket.  The stage listed first is at the top of the rocket (and will burn last). For every test case in the input, it is always possible to construct at least one rocket satisfying all the requirements of the problem statement.</p>\r\n<h3>&nbsp;</h3>', '<p>For each test case, output a line containing a single integer, the maximum possible speed in metres per second of the rocket when it has finished burning, rounded to the nearest metre per second.</p>', '1\r\n1\r\n9999 1 1000000 1', '90\r\n', '', 0, 0, '2010-08-18 21:00:23', '2010-08-18 21:00:23'),
(161, 1, 'Virtual Friends', 10000, 33554432, 0000000000, 0000000000, '<p>These days, you can do all sorts of things online. For example, you can use various websites to make virtual friends. For some people, growing their social network (their friends, their friends'' friends, their friends'' friends'' friends, and so on), has become an addictive hobby. Just as some people collect stamps, other people collect virtual friends.</p>\r\n<p>Your task is to observe the interactions on such a website and keep track of the size of each person''s network.</p>\r\n<p>Assume that every friendship is mutual. If Fred is Barney''s friend, then Barney is also Fred''s friend.</p>', 'http://plg1.cs.uwaterloo.ca/~acm00/080927/C.html', '<p>The first line of input contains one integer specifying the number of test cases to follow. Each test case begins with a line containing an integer <i>F</i>, the number of friendships formed, which is no more than 100 000. Each of the  following <i>F</i> lines contains the names of two people  who have just become friends, separated by a space. A name is a string of 1 to 20 letters (uppercase or lowercase).</p>', '<pre>\r\nWhenever a friendship is formed, print a line containing\r\none integer, the number of people in the social\r\nnetwork of the two people who have just become friends.\r\n\r\n\r\n\r\n</pre>', '1\r\n3\r\nFred Barney\r\nBarney Betty\r\nBetty Wilma\r\n', '2\r\n3\r\n4\r\n', '', 0, 0, '2010-08-18 21:00:23', '2010-08-18 21:00:23'),
(162, 1, 'Dominos', 1000, 33554432, 0000000000, 0000000000, '<p>Dominos are lots of fun. Children like to stand the tiles on their side in long lines. When one domino falls, it knocks down the next one, which knocks down the one after that, all the way down the line. However, sometimes a domino fails to knock the next one down. In that case, we have to knock it down by hand to get the dominos falling again.</p>\r\n<p>Your task is to determine, given the layout of some domino tiles, the minimum number of dominos that must be knocked down by hand in order for all of the dominos to fall.</p>', 'http://plg1.cs.uwaterloo.ca/~acm00/080927/D.html', '<p>The first line of input contains one integer specifying the number of test cases to follow. Each test case begins with a line containing two integers, each no larger than 100 000. The first integer <i>n</i> is the number of domino tiles and the second integer <i>m</i> is the number of lines to follow in the test case. The domino tiles are numbered from 1 to <i>n</i>. Each of the following lines contains two integers <i>x</i> and <i>y</i> indicating that if domino number <i>x</i> falls, it will cause domino number <i>y</i> to fall as well.</p>', '<p>For each test case, output a line containing one integer, the minimum number of dominos that must be knocked over by hand in order for all the dominos to fall.</p>\r\n<h3>&nbsp;</h3>', '1\r\n3 2\r\n1 2\r\n2 3\r\n', '1\r\n', '', 0, 0, '2010-08-18 21:00:24', '2010-08-18 21:00:24'),
(163, 1, 'Logo', 1000, 33554432, 0000000000, 0000000000, '<p>\r\n	Logo is a programming language built around a turtle. Commands in the language cause the turtle to move. The turtle has a pen attached to it. As the turtle moves, it draw lines on the page. The turtle can be programmed to draw interesting pictures.</p>\r\n<p>\r\n	We are interested in making the turtle draw a picture, then return to the point that it started from. For example, we could give the turtle the following program:</p>\r\n<p>\r\n	<tt>fd 100 lt 120 fd 100 lt 120 fd 100</tt></p>\r\n<p>\r\n	The command <tt>fd</tt> causes the turtle to move forward by the specified number of units. The command <tt>lt</tt> causes the turtle to turn left by the specified number of degrees. Thus the above commands cause the turtle to draw an equilateral triangle with sides 100 units long. Notice that after executing the commands, the turtle ends up in the same place as it started. The turtle understands two additional commands. The command <tt>bk</tt> causes the turtle to move backward by the specified number of units. The command <tt>rt</tt> causes the turtle to turn right by the specified number of degrees.</p>\r\n<p>\r\n	After executing many commands, the turtle can get lost, far away from its starting position. Your task is to determine the straight-line distance from the turtle&#39;s position at the end of its journey back to the position that it started from.</p>\r\n', 'http://plg1.cs.uwaterloo.ca/~acm00/080927/E.html', '<p>\r\n	The first line of input contains one integer specifying the number of test cases to follow. Each test case starts with a line containing one integer, the number of commands to follow. The commands follow, one on each line. Each test case will contain no more than 1000 commands.</p>\r\n', '<p>\r\n	For each test case, output a line containing a single integer, the distance rounded to the nearest unit.</p>\r\n', '1\r\n5\r\nfd 100\r\nlt 120\r\nfd 100\r\nlt 120\r\nfd 100\r\n', '0\r\n', '', 0, 0, '2010-08-18 21:00:24', '2010-11-17 20:30:18'),
(164, 1, 'Exchange Rates', 1000, 33554432, 0000000000, 0000000000, '<p><a href="http://plg1.cs.uwaterloo.ca/~acm00/070923/million.jpg"><img src="http://plg1.cs.uwaterloo.ca/~acm00/070923/million.jpg" alt="" /></a></p>\r\n<p>Now that the Loonie is hovering about par with the Greenback, you have decided to use your $1000 entrance scholarship to engage in currency speculation.  So you gaze into a crystal ball which  predicts the closing exchange rate between Canadian and U.S. dollars for each of the next several days. On any given day, you can switch all of your money from Canadian to U.S. dollars, or vice versa, at the prevailing exchange rate, less a 3% commission, less any fraction of a cent.</p>\r\n<p>Assuming your crystal ball is correct, what''s the maximum amount of money you can have, in Canadian dollars, when you''re done?</p>\r\n<p>&nbsp;</p>', '', '<p>The input contains a number of test cases, followed by a line containing 0.  Each test case begins with <i>0 &lt;d &le; 365</i>, the number of days that your crystal ball can predict.  <i>d</i> lines follow, giving the price of a U.S. dollar in Canadian dollars, as a real number.</p>', '<p>For each test case, output a line giving the maximum amount of money, in Canadian dollars and cents, that it is possible to have at the end of the last prediction, assuming you may exchange money on any subset of the predicted days, in order.</p>', '3\r\n1.0500\r\n0.9300\r\n0.9900\r\n2\r\n1.0500\r\n1.1000\r\n0\r\n', '1001.60\r\n1000.00\r\n', '', 0, 0, '2010-08-18 22:06:38', '2010-08-18 22:06:38'),
(165, 1, 'Conformity', 10000, 33554432, 0000000000, 0000000000, '<p>Frosh commencing their studies at Waterloo have diverse interests, as evidenced by their desire to take various combinations of courses from among those available.</p>\r\n<p>University administrators are uncomfortable with this situation, and therefore wish to offer a <i>conformity prize</i> to frosh who choose one of the most popular combinations of courses.  How many frosh will win the prize?</p>\r\n<p>The input consists of several test cases followed by a line containing 0.  Each test case begins with an integer <i>1 &le; n &le; 10000</i>, the number of frosh.  For each frosh, a line follows containing the course numbers of five distinct courses selected by the frosh.  Each course number is an integer between 100 and 499.</p>\r\n<p>The <i>popularity</i> of a combination is the number of frosh selecting exactly the same combination of courses.  A combination of courses is considered <i>most popular</i> if no other combination has higher popularity.  For each line of input, you should output a single line giving the total number of students taking some combination of courses that is most popular. <a href="http://plg1.cs.uwaterloo.ca/~acm00/070923/0907einstein.jpg"><img alt="" src="http://plg1.cs.uwaterloo.ca/~acm00/070923/0907einstein.jpg" /></a></p>', '', '', '', '3\r\n100 101 102 103 488\r\n100 200 300 101 102\r\n103 102 101 488 100\r\n3\r\n200 202 204 206 208\r\n123 234 345 456 321\r\n100 200 300 400 444\r\n0\r\n', '2\r\n3\r\n', '', 0, 0, '2010-08-18 22:06:40', '2010-08-18 22:06:40'),
(166, 1, 'Pseudoprime numbers', 1000, 33554432, 0000000000, 0000000000, '<p><img src="http://plg1.cs.uwaterloo.ca/~acm00/070923/fermat.jpg" style="width: 596px; height: 386px;" alt="" /></p>\r\n<p>&nbsp;</p>\r\n<p>Fermat''s theorem states that for any prime number <i>p</i> and for any integer <i>a &gt; 1</i>, <i>a<sup>p</sup> == a (mod p)</i>. That is, if we raise <i>a</i> to the <i>p</i>th power and divide by <i>p</i>, the remainder is <i>a</i>.  Some (but not very many) non-prime values of <i>p</i>, known as <i>base-a pseudoprimes</i>, have this property for some <i>a</i>.  (And some, known as Carmichael Numbers, are base-a pseudoprimes for all <i>a</i>.)</p>\r\n<p>Given <i>2 &lt; p &le; 1,000,000,000</i> and <i>1 &lt; a &lt; p</i>, determine whether or not <i>p</i> is a <i>base-a pseudoprime</i>.</p>\r\n<p>Input contains several test cases followed by a line containing &quot;0 0&quot;.  Each test case consists of a line containing <i>p</i> and <i>a</i>.  For each test case, output &quot;yes&quot; if p is a base-a pseudoprime; otherwise output &quot;no&quot;.</p>', '', '', '', '3 2\r\n10 3\r\n341 2\r\n341 3\r\n1105 2\r\n1105 3\r\n0 0\r\n', 'no\r\nno\r\nyes\r\nno\r\nyes\r\nyes\r\n', '', 0, 0, '2010-08-18 22:06:40', '2010-08-18 22:06:40'),
(167, 1, 'Carpool', 1000, 33554432, 0000000000, 0000000000, '<p><img src="http://plg1.cs.uwaterloo.ca/~acm00/070923/carpool.jpg" alt="" /></p>\r\n<p>A group of friends has just completed their CS assignments, and because  of the nice weather, they decide to go to Joe''s house for a BBQ.  Unfortunately, after all that coding, they are too tired to walk.  Fortunately, between them they have enough cars to take everyone.</p>\r\n<p>Joe remembers that he needs to stop off at the supermarket along the way to buy some burgers and pop.</p>\r\n<p>Jenn proposes that they stop at her house to get a frisbee.</p>\r\n<p>Jim decides that he doesn''t like burgers, and wants to grab a pizza along the way.</p>\r\n<p>After having spent so long in the computer lab, Jerry''s eyes have become very sensitive to sunlight, so he needs to stop at his house for his sunglasses.</p>\r\n<p>And so it goes: each person needs to run a little errand along the way. At this rate, the friends worry that it will be dark by the time they get to Joe''s house. They launch into a heated discussion to about who should go in which car to minimize the time needed for everyone to reach Joe''s house. The discussion itself, of course, wastes precious time that could be better spent at the BBQ.</p>\r\n<p>To help the group, you will write a program to settle the discussion by computing an optimal assignment of people to cars. The overall travel time is the maximum of the travel times of each car. An optimal assignment is one that minimizes the overall travel time.</p>\r\n<p>Your program will be provided with a representation of the roads in the city, in the form of distances between major landmarks. Assume that every car always travels at 60 kilometres per hour (one kilometre per minute). Each stop (at a supermarket, someone''s house, etc.) takes five minutes.</p>\r\n<p>Although the friends have many cars between them, to be nice to the  environment, they decide to take no more cars than necessary. Each car can take at most five people.</p>', '', '<p>The first line of input contains two integers n and m, 1 &le; n &le; 15, 1 &le; m &le; 1000, the number of people in the group and the number of roads in the city. The places that must be visited along the way are numbered 1 through n. The campus is numbered 0, and Joe''s house is numbered n+1. An additional m lines follow, each containing three integers describing a stretch of road. The first two integers are in the range 0 to n+1 inclusive, and describe the two places connected by the stretch of road. The third integer specifies the length of the stretch of road, in kilometres. A road may be taken in both directions. There is a sequence of roads connecting every place in the city to every other place.</p>', '<p>Output a single integer, giving the number of minutes required for everyone to reach Joe''s house using an optimal assignment of people to cars.</p>', '1 2\r\n0 1 15\r\n1 2 10\r\n', '30\r\n', '', 0, 0, '2010-08-18 22:06:40', '2010-08-18 22:06:40'),
(168, 1, 'Trainsorting', 1000, 33554432, 0000000000, 0000000000, '<p>Erin is an engineer. She drives trains. She also arranges the cars within each train. She prefers to put the cars in decreasing order of weight, with the heaviest car at the front of the train.</p>\r\n<p>Unfortunately, sorting train cars is not easy. One cannot simply pick up a car and place it somewhere else. It is impractical to insert a car within an existing train. A car may only be added to the beginning and end of the train.</p>\r\n<p>Cars arrive at the train station in a predetermined order. When each car arrives, Erin can add it to the beginning or end of her train, or refuse to add it at all. The resulting train should be as long as possible, but the cars within it must be ordered by weight.</p>\r\n<p>Given the weights of the cars in the order in which they arrive, what is the longest train that Erin can make?</p>', 'http://plg1.cs.uwaterloo.ca/~acm00/080615/A.html', '<p>The first line contains an integer 0 &lt;= n &lt;= 2000, the number of cars. Each of the following n lines contains a non-negative integer giving the weight of a car. No two cars have the same weight.</p>', '<p>Output a single integer giving the number of cars in the longest train that can be made with the given restrictions.</p>', '3\r\n1\r\n2\r\n3\r\n', '3', '', 0, 0, '2010-08-18 22:09:06', '2010-08-18 22:09:06'),
(169, 1, 'Classified', 10000, 33554432, 0000000000, 0000000000, '<p>Classification levels like Secret and Top Secret are well-known features of military documents. Less well known are <em>integrity levels</em>, which correspond to <em>how reliable</em> information is.</p>\r\n<p>In the <b>Dynamic Biba integrity model</b>, every user and every document is assigned an integrity level. If a user writes to a document that has a higher integrity level than the user does, the document&rsquo;s integrity level goes down. Similarly, if a user reads a document that has a lower integrity level than the user does, the user&rsquo;s integrity level goes down.</p>\r\n<p>Your job is to keep track of the integrity levels of a number of users and documents. Complicating the matter is the fact that integrity levels aren&rsquo;t simply numbers; a document might contain very trusworthy information about operations in Afganistan, while at the same time containing less trustworthy information about operations in Iraq.</p>\r\n<p>Integrity levels are speficied by arbitrary labels, along with rules of the form <i>A</i> &rarr; <i>B</i>, indicating that integrity level <i>A</i> is at most as trustworthy as integrity level <i>B</i>. The rules satisfy a number of conditions:</p>\r\n<ul class="itemize">\r\n    <li class="li-itemize">For any label <i>A</i>, <i>A</i> &rarr; <i>A</i> is always true, and need not be specified.</li>\r\n    <li class="li-itemize">If <i>A</i> and <i>B</i> are two different labels, then it can never be the case that both <i>A</i> &rarr; <i>B</i> and <i>B</i> &rarr; <i>A</i> are true. However, it <em>can</em> be the case that neither <i>A</i> &rarr; <i>B</i> nor <i>B</i> &rarr; <i>A</i> are true.</li>\r\n    <li class="li-itemize">For any labels <i>A</i>, <i>B</i>, and <i>C</i>, if it is the case that <i>A</i> &rarr; <i>B</i> and <i>B</i> &rarr; <i>C</i> are both true, you can conclude (without it being explicitly specified) that <i>A</i> &rarr; <i>C</i> is true.</li>\r\n    <li class="li-itemize">For any two labels <i>A</i> and <i>B</i>, there is a label <i>G</i> = <i>glb</i>(<i>A</i>,<i>B</i>) called the <em>greatest lower bound</em> of <i>A</i> and <i>B</i> such that <i>G</i> &rarr; <i>A</i> and <i>G</i> &rarr; <i>B</i> are both true. Further, for any label <i>L</i> such that <i>L</i> &rarr; <i>A</i> and <i>L</i> &rarr; <i>B</i> are both true, it is also the case that <i>L</i> &rarr; <i>G</i> is true.</li>\r\n</ul>\r\n<p>You will be given as input the labels and rules defining the integrity levels, as well as the initial integrity level of a number of users and a number of documents. The format will be as follows:</p>\r\n<ul class="itemize">\r\n    <li class="li-itemize">The first line of the input will contain five integers separated by spaces. These integers are the number of integrity levels ℓ, the number of rules <i>r</i>, the number of users <i>u</i>, the number of documents <i>d</i>, and the number of actions <i>a</i>, in that order. None of these five integers will be greater than 10000. The integrity levels are numbered from 1 to ℓ; the users from 1 to <i>u</i>, and the documents from 1 to <i>d</i>.</li>\r\n    <li class="li-itemize">The next <i>r</i> lines specify the rules. Each line will consist of two integers between 1 and ℓ, separated by a space. The line &ldquo;<tt><i>x</i></tt><tt> </tt><tt><i>y</i></tt>&rdquo; indicates that integrity level <i>x</i> is at most as trustworthy as integrity level <i>y</i> (i.e. <i>x</i> &rarr; <i>y</i>)</li>\r\n    <li class="li-itemize">The next <i>u</i> lines specify the initial integrity levels for user number 1, 2, &hellip;, <i>u</i>. Each line will be an integrity level number, from 1 to ℓ.</li>\r\n    <li class="li-itemize">The next <i>d</i> lines specify the initial integrity levels for document number 1, 2, &hellip;, <i>d</i>. Each line will be an integrity level number, from 1 to ℓ.</li>\r\n    <li class="li-itemize">The next <i>a</i> lines specify the actions; each action will be of one of the following two forms (here, <em>user</em> is an integer between 1 and <i>u</i>, and <em>document</em> is an integer between 1 and <i>d</i>):\r\n    <ul class="itemize">\r\n        <li class="li-itemize"><tt><em>user</em></tt><tt> reads </tt><tt><em>document</em></tt>: The given user is reading the given document. The integrity level for the user should be changed to the <i>glb</i> of the old integrity level for the user and the integrity level of the document. Output the new integrity level for the user on a line by itself.</li>\r\n        <li class="li-itemize"><tt><em>user</em></tt><tt> writes </tt><tt><em>document</em></tt>: The given user is writing to the given document. The integrity level for the document should be changed to the <i>glb</i> of the integrity level for the user and the old integrity level of the document. Output the new integrity level for the document on a line by itself.</li>\r\n    </ul>\r\n    </li>\r\n</ul>', 'http://plg1.cs.uwaterloo.ca/~acm00/080615/B.html', '<p>Please Input Input Here</p>', '<p>Please Input Output Here</p>', '9 11 2 3 5\r\n6 9\r\n2 6\r\n9 4\r\n7 5\r\n3 8\r\n7 2\r\n5 3\r\n8 4\r\n5 1\r\n6 1\r\n1 8\r\n4\r\n2\r\n5\r\n9\r\n8\r\n1 reads 3\r\n1 writes 2\r\n2 reads 2\r\n1 reads 1\r\n2 writes 1\r\n', '8\r\n6\r\n2\r\n5\r\n7\r\n', '', 0, 0, '2010-08-18 22:09:06', '2010-08-18 22:09:06'),
(170, 1, 'Hot Spot', 10000, 33554432, 0000000000, 0000000000, '<p>Hot Spot is a single player game played on a 4 by 4 game board. The purpose of the game is to move a red robot from its current location on the board to the top left corner. The game board may also contain green and blue robots. Each square of the game board can be occupied by no more than one robot at any time.</p>\r\n<p>A robot may move in one of two ways:</p>\r\n<ol>\r\n    <li>If two robots are adjacent horizontally or vertically (but not diagonally), one of them may jump over the other to the immediately adjacent square, provided that square is empty. For example, if robot a is immediately to the left of robot b, robot a may jump to the square immediately to the right of robot b.</li>\r\n    <li>If three robots are adjacent in a line (again not diagonally), one of them may jump over the other two, provided the destination square is empty. For example, if robot b is immediately to the right of robot a and robot c is immediately to the right of robot b, robot a may jump to the square immediately to the right of robot c.</li>\r\n</ol>\r\n<p>Every jump only changes the positions of the existing robots; robots are never removed from or added to the game board.</p>\r\n<p>A blue robot is never allowed to be adjacent horizontally or vertically to another blue robot or to the red robot.</p>\r\n<p>Given the initial configuration of the game board, determine the minimum number of jumps required to move the red robot into the top left corner.</p>', 'http://plg1.cs.uwaterloo.ca/~acm00/080615/C.html', '<p>The input specifies the initial position of the board using four lines, each containing four characters. Each character may be either R, indicating the red robot, B, indicating a blue robot, G, indicating a green robot, or a period (.), indicating an empty square.</p>', '<p>Output a single line containing a single integer, the minimum number of jumps required for the red robot to reach the top left square of the game board.</p>\r\n<h3>&nbsp;</h3>', '.GR.\r\n....\r\n....\r\n....\r\n', '1', '', 0, 0, '2010-08-18 22:09:06', '2010-08-18 22:09:06'),
(171, 1, 'Snakes and Ladders', 1000, 33554432, 0000000000, 0000000000, '<p>Snakes and Ladders is a board game played on a 10 by 10 grid. The squares of the grid are numbered 1 to 100. Each player has a token which is placed on the square numbered 1 at the beginning of the game. Players take turns rolling a die which provides a random number between 1 and 6. After rolling, the player advances his or her token the number of squares shown on the die. If this would put the token past the square numbered 100, the token is advanced to 100. After advancing, if the token is on a square containing the bottom of a ladder, the token must be moved to the square containing the top of the ladder. Similarly, if the token is on a square containing the mouth of a snake, the token must be moved to the square containing the tail of the snake. No square contains more than one endpoint of any snake or ladder. The token numbered 100 does not contain the mouth of a snake or the bottom of a ladder. A player wins when his or her token reached the square numbered 100. At that point, the game ends.</p>\r\n<p>Given the configuration of the snakes and ladders on a game board and a sequence of die rolls, you are to determine the positions of all the tokens on the game board. The sequence of die rolls need not be complete (i.e. it need not lead to any player winning). The sequence of die rolls may also continue after the game is over; in this case, the die rolls after the end of the game should be ignored.</p>', 'http://plg1.cs.uwaterloo.ca/~acm00/080615/D.html', '<p>The first line contains three positive integers: the number a of players, the number b of snakes or ladders, and the number c of die rolls. There will be no more than 1000000 players and no more than 1000000 die rolls. Each of the next b lines contains two integers specifying a snake or ladder. The first integer indicates the square containing the mouth of the snake or the bottom of the ladder. The second integer indicates the square containing the tail of the snake or the top of the ladder. The following c lines each contain one integer giving number rolled on the die.</p>', '<p>For each player, output a single line containing a string of the form <tt>Position of player N is P.</tt>, where <tt>N</tt> is replaced with the number of the player and <tt>P</tt> is replaced with the final position of the player.</p>\r\n<h3>&nbsp;</h3>', '3 1 3\r\n4 20\r\n3\r\n4\r\n5\r\n', 'Position of player 1 is 20.\r\nPosition of player 2 is 5.\r\nPosition of player 3 is 6.\r\n', '', 0, 0, '2010-08-18 22:09:06', '2010-08-18 22:09:06'),
(172, 1, 'Balance', 1000, 33554432, 0000000000, 0000000000, '<p>A sailboat has many forces acting on it. This allows it to sail in many different directions, even if the wind is not blowing in the desired direction. In order for the boat to be easily controlled, however, certain forces must be balanced.</p>\r\n<p>Suppose the wind is blowing from the north and the boat is facing west. Above the water, the blowing wind hits the sails, and because of the way that they are angled, pushes the boat to the southwest. The keel extends deep below the water. The water resistance on the keel creates a counterforce pushing the boat northward. Ideally, the northward force  on the keel will counteract the southward component of the force on the sails, so that the boat will move to the west.</p>\r\n<p>A problem can arise if the centre of the sails (called the Centre of Effort, or CE) is not directly above the centre of the keel (called the Centre of Lateral Resistance, or CLR). In general, the boat can pivot about the centre of the keel. If the sails are too far forward of the keel, the wind will push the bow (the front) of the boat southwards, and the boat will turn towards the south. If the sails are too far aft of (behind) the keel, the wind will push the stern (the back) southwards, and the boat will turn towards the north. Ideally, the sails and keel are balanced so that the boat sails in a straight line.</p>\r\n<p>In this problem, you will examine a side view of the boat to determine whether the CE is above the CLR. The CE is defined as the centroid of the part of the boat above the waterline. The CLR is defined as the centroid of the part of the boat below the waterline. The centroid of a polygon is the unique point such that any line passing through it divides the polygon into two halves of equal area.</p>', 'http://plg1.cs.uwaterloo.ca/~acm00/080615/E.html', '<p>The first line of input will contain a single integer n specifying the number of points along the outline of the side view of the boat. The following n lines will each contain two integers: the x and y coordinate of a point along the outline. The points will be given in order along the outline. The x axis (i.e. the line y = 0) represents the waterline. Assume that the boat faces in the direction of increasing x coordinates.</p>', '<p>If the CE is forward of the CLR, print the line:</p>\r\n<p><tt>CE is forward of CLR by N units.</tt></p>\r\n<p>If the CE is aft of (behind) the CLR, print the line:</p>\r\n<p><tt>CE is aft of CLR by N units.</tt></p>\r\n<p>In both cases, replace the <tt>N</tt> with the difference in the x coordinates of the CE and CLR to two decimal places. If the x coordinates of the CE and CLR are equal, print the line:</p>\r\n<p><tt>Balanced.</tt></p>', '7\r\n0 1\r\n2 3\r\n4 1\r\n4 -3\r\n2 -3\r\n2 -1\r\n0 -1\r\n', 'CE is aft of CLR by 0.50 units.\r\n', '', 0, 0, '2010-08-18 22:09:06', '2010-08-18 22:09:06'),
(173, 1, 'Open Source', 1000, 33554432, 0000000000, 0000000000, '<p>At an open-source fair held at a major university, leaders of open-source projects put sign-up sheets on the wall, with the project name at the top in capital letters for identification.</p>\r\n<p>Students then signed up for projects using their userids.  A userid is a string of lower-case letters and numbers starting with a letter.</p>\r\n<p>The organizer then took all the sheets off the wall and typed in the information.</p>\r\n<p>Your job is to summarize the number of students who have signed up for each project. Some students were overly enthusiastic and put their name down several times for the same project. That''s okay, but they should only count once. Students were asked to commit to a single project, so any student who has signed up for more than one project should not count for any project.</p>\r\n<p>There are at most 10,000 students at the university, and at most 100 projects were advertised.</p>\r\n<p>Input Specification:</p>\r\n<p>The input contains several test cases, each one ending with a line that starts with the digit 1. The last test case is followed by a line starting with the digit 0.</p>\r\n<p>Each test case consists of one or more project sheets. A project sheet consists of a line containing the project name in capital letters, followed by the userids of students, one per line.</p>\r\n<p>Output Specification:</p>\r\n<p>For each test case, output a summary of each project sheet. The summary is one line with the name of the project followed by the number of students who signed up. These lines should be printed in decreasing order of number of signups. If two or more projects have the same number of signups, they should be listed in alphabetical order.</p>', 'http://plg1.cs.uwaterloo.ca/~acm00/070714/A.html', '<p>Please Input Input Here</p>', '<p>Please Input Output Here</p>', 'UBQTS TXT\r\ntthumb\r\nLIVESPACE BLOGJAM\r\nphilton\r\naeinstein\r\nYOUBOOK\r\nj97lee\r\nsswxyzy\r\nj97lee\r\naeinstein\r\nSKINUX\r\n1\r\n0\r\n', 'YOUBOOK 2\r\nLIVESPACE BLOGJAM 1\r\nUBQTS TXT 1\r\nSKINUX 0\r\n', '', 0, 0, '2010-08-18 22:11:07', '2010-08-18 22:11:07'),
(174, 1, 'Antimonotonicity', 20000, 134217728, 0000000000, 0000000000, '<p>\r\n	I have a sequence Fred of length n comprised of integers between 1 and n inclusive. The elements of Fred are pairwise distinct. I want to find a subsequence Mary of Fred that is as long as possible and has the property that:</p>\r\n<p>\r\n	Mary[0] &gt; Mary[1] &lt; Mary[2] &gt; Mary[3] &lt; ...</p>\r\n<p>\r\n	<img alt="" src="/joj/userfiles/admin/0/174elephant.jpg" style="width: 339px; height: 140px;" /></p>\r\n', 'http://plg1.cs.uwaterloo.ca/~acm00/070714/B.html', '<p>\r\n	The first line of input will contain a single integer T expressed in decimal with no leading zeroes. T will be at most 50. T test cases will follow.</p>\r\n<p>\r\n	Each test case is contained on a single line. A line describing a test case is formatted as follows:</p>\r\n<p>\r\n	n Fred[0] Fred[1] Fred[2] ... Fred[n-1].</p>\r\n<p>\r\n	where n and each element of Fred is an integer expressed in decimal with no leading zeroes. No line will have leading or trailing whitespace, and two adjacent integers on the same line will be separated by a single space. n will be at most 30000.</p>\r\n', '<p>\r\n	For each test case, output a single integer followed by a newline --- the length of the longest subsequence Mary of Fred with the desired properties.</p>\r\n', '4\r\n5 1 2 3 4 5\r\n5 5 4 3 2 1\r\n5 5 1 4 2 3\r\n5 2 4 1 3 5\r\n', '1\r\n2\r\n5\r\n3\r\n', '<br />\r\n', 0, 0, '2010-08-18 22:11:07', '2010-11-18 16:20:56'),
(175, 1, 'Humidex', 1000, 33554432, 0000000000, 0000000000, '<b>Adapted from Wikipedia, the free encyclopedia</b>\r\n<p>The humidex is a measurement used by Canadian meteorologists to reflect the combined effect of heat and humidity. It differs from the heat index used in the United States in using dew point rather than relative humidity.</p>\r\n<p>When the temperature is 30 C (86 F) and the dew point is 15 C (59 F), the humidex is 34 (note that humidex is a dimensionless number, but that the number indicates an approximate temperature in C). If the temperature remains 30 C and the dew point rises to 25 C (77 F), the humidex rises to 42.3.</p>\r\n<p>The humidex tends to be higher than the U.S. heat index at equal temperature and relative humidity.</p>\r\n<p>The current formula for determining the humidex was developed by J.M. Masterton and F.A. Richardson of Canada''s Atmospheric Environment Service in 1979.</p>\r\n<p>According to the Meteorological Service of Canada, a humidex of at least 40 causes &quot;great discomfort&quot; and above 45 is &quot;dangerous.&quot; When the humidex hits 54, heat stroke is imminent.</p>\r\n<p>The record humidex in Canada occurred on June 20, 1953, when Windsor, Ontario hit 52.1. (The residents of Windsor would not have known this at the time, since the humidex had yet to be invented.) More recently, the humidex reached 50 on July 14, 1995 in both Windsor and Toronto.</p>\r\n<p>The humidex formula is as follows:</p>\r\n<pre>\r\n    humidex = temperature + h\r\n    h = (0.5555)*(e - 10.0)\r\n    e = 6.11 * exp [5417.7530 * ((1/273.16) - (1/(dewpoint+273.16)))]\r\n</pre>\r\n<p>where exp(x) is 2.718281828 raised to the exponent x.</p>\r\n<p>While humidex is just a number, radio announcers often announce it as if it were the temperature, e.g. &quot;It''s 47 degrees out there ... [pause] .. with the humidex,&quot;. Sometimes weather reports give the temperature and dewpoint, or the temperature and humidex, but rarely do they report all three measurements. Write a program that, given any two of the measurements, will calculate the third.</p>\r\n<p>You may assume that for all inputs, the temperature, dewpoint, and humidex are all between -100 C and 100 C.</p>', 'http://plg1.cs.uwaterloo.ca/~acm00/070714/C.html', '<p>Input will consist of a number of lines. Each line except the last will consist of four items separated by spaces: a letter, a number, a second letter, and a second number. Each letter specifies the meaning of the number that follows it, and will be either T, indicating temperature, D, indicating dewpoint, or H, indicating humidex. The last line of input will consist of the single letter E.</p>', '<p>For each line of input except the last, produce one line of output. Each line of output should have the form:</p>\r\n<pre>\r\nT number D number H number\r\n</pre>\r\n<p>where the three numbers are replaced with the temperature, dewpoint, and humidex. Each value should be expressed rounded to the nearest tenth of a degree, with exactly one digit after the decimal point. All temperatures are in degrees celsius.</p>', 'T 30 D 15\r\nT 30.0 D 25.0\r\nE\r\n', 'T 30.0 D 15.0 H 34.0\r\nT 30.0 D 25.0 H 42.3\r\n', '', 0, 0, '2010-08-18 22:11:08', '2010-08-18 22:11:08'),
(176, 1, 'Tour de France', 1000, 33554432, 0000000000, 0000000000, '<p>A racing bicycle is driven by a chain connecting two sprockets. Sprockets are grouped into two clusters:  the front cluster  (typically consisting of 2 or 3 sprockets) and the rear cluster (typically consisting of between 5 and 10 sprockets).  At any time the chain connects one of the front sprockets to one of the rear sprockets.  The drive ratio -- the ratio of the angular velocity of the pedals to that of the wheels -- is n:m where n is the number of teeth on the rear sprocket and m is the number of teeth on the front sprocket. Two drive ratios  d<sub>1</sub>&lt;d<sub>2</sub> are adjacent if there is no other drive ratio  d<sub>1</sub>&lt;d<sub>3</sub>&lt;d<sub>2</sub>. The <i>spread</i> between a pair of drive ratios d<sub>1</sub>&lt;d<sub>2</sub> is their quotient:  d<sub>2</sub>/d<sub>1</sub>. You are to compute the maximum spread between two adjacent drive ratios achieved by a particular pair of front and rear clusters.</p>\r\n<p>Input consists of several test cases, followed by a line containing 0. Each test case is specified by the following input:</p>\r\n<ul>\r\n    <li>f:  the number of sprockets in the front cluster;</li>\r\n    <li>r:  the number of sprockets in the rear cluster;</li>\r\n    <li>f integers, each giving the number of teeth on one of the gears in the front cluster;</li>\r\n    <li>r integers, each giving the number of teeth on one of the gears in the rear cluster.</li>\r\n</ul>\r\n<p>You may assume that no cluster has more than 10 sprockets and that no gear has fewer than 10 or more than 100 teeth.</p>\r\n<p>For each test case, output the maximum spread rounded to two decimal places.</p>', 'http://plg1.cs.uwaterloo.ca/~acm00/070714/D.html', '<p>Please Input Input Here</p>', '<p>Please Input Output Here</p>', '2 4\r\n40 50\r\n12 14 16 19\r\n0\r\n', '1.19\r\n', '', 0, 0, '2010-08-18 22:11:08', '2010-08-18 22:11:08'),
(177, 1, 'Texas Trip', 1000, 33554432, 0000000000, 0000000000, '<p>After a day trip with his friend Dick, Harry noticed a strange pattern of tiny holes in the door of his SUV.  The local American Tire store sells fiberglass patching material only in square sheets. What is the smallest patch that Harry needs to fix his door?</p>\r\n<p>Assume that the holes are points on the integer lattice in the plane.  Your job is to find the area of the smallest square that will cover all the holes.</p>', 'http://plg1.cs.uwaterloo.ca/~acm00/070714/E.html', '<p>The first line of input contains a single integer T expressed in decimal  with no leading zeroes, denoting the number of test cases to follow.  The  subsequent lines of input describe the test cases.</p>\r\n<p>Each test case begins with a single line, containing a single integer n  expressed in decimal with no leading zeroes, the number of points to  follow; each of the following n lines contains two integers x and y, both  expressed in decimal with no leading zeroes, giving the coordinates of one  of your points.</p>\r\n<p>You are guaranteed that T &lt;= 30 and that no data set contains more than 30  points.  All points in each data set will be no more than 500 units away  from (0,0).</p>\r\n<h3>&nbsp;</h3>', '<p>Print, on a single line with two decimal places of precision, the area of  the smallest square containing all of your points.  An answer will be  accepted if it lies within 0.1 of the correct answer.</p>\r\n<h3>&nbsp;</h3>', '2\r\n4\r\n-1 -1\r\n1 -1\r\n1 1\r\n-1 1\r\n4\r\n10 1\r\n10 -1\r\n-10 1\r\n-10 -1\r\n', '4.00\r\n242.00\r\n', '', 0, 0, '2010-08-18 22:11:08', '2010-08-18 22:11:08');
INSERT INTO `tbl_problems` (`id`, `user_id`, `title`, `time_limit`, `memory_limit`, `submission_no`, `accepted_no`, `description`, `source`, `input`, `output`, `input_sample`, `output_sample`, `hint`, `flag`, `visibility`, `created`, `modified`) VALUES
(178, 1, 'Semi-prime H-numbers', 1000, 33554432, 0000000000, 0000000000, '<img align="right" vspace="20" hspace="20" src="http://plg1.cs.uwaterloo.ca/%7Eacm00/060930/hilbert.jpg" alt="" />\r\n<p>This problem is based on an exercise of David Hilbert, who pedagogically suggested that one study the theory of</p>\r\n<em>4n+1</em>\r\n<p>numbers. Here, we do only a bit of that.</p>\r\n<p>An <b>H</b>-number is a positive number which is one more than a multiple of four: 1, 5, 9, 13, 17, 21,... are the <b>H</b>-numbers. For this problem we pretend that these are the <em>only</em> numbers. The <b>H</b>-numbers are closed under multiplication.</p>\r\n<p>As with regular integers, we partition the <b>H</b>-numbers into units, <b>H</b>-primes, and <b>H</b>-composites. 1 is the only unit. An <b>H</b>-number <b>h</b> is <b>H</b>-prime if it is not the unit,  and is the product of two <b>H</b>-numbers in only one way: 1 &times; <b>h</b>. The rest of the numbers are <b>H</b>-composite.</p>\r\n<p>For examples, the first few <b>H</b>-composites are: 5 &times; 5 = 25, 5 &times; 9 = 45, 5 &times; 13 = 65, 9 &times; 9 = 81, 5 &times; 17 = 85.</p>\r\n<p>Your task is to count the number of <b>H</b>-semi-primes. An <b>H</b>-semi-prime is an <b>H</b>-number which is the product of exactly two <b>H</b>-primes. The two <b>H</b>-primes may be equal or different. In the example above, all five numbers are <b>H</b>-semi-primes. 125 = 5 &times; 5 &times; 5 is not an <b>H</b>-semi-prime, because it''s the product of three <b>H</b>-primes.</p>\r\n<p>Each line of input contains an <b>H</b>-number &le; 1,000,001. The last line of input contains 0 and this line should not be processed.</p>\r\n<p>For each inputted <b>H</b>-number <b>h</b>, print a line stating <b>h</b> and the number of <b>H</b>-semi-primes between 1 and <b>h</b> inclusive, separated by one space in the format shown in the sample.</p>', '', '<p>Please Input Input Here</p>', '<p>Please Input Output Here</p>', '21 \r\n85\r\n789\r\n0\r\n', '21 0\r\n85 5\r\n789 62\r\n', '', 0, 0, '2010-08-18 22:37:37', '2010-08-18 22:37:37'),
(179, 1, 'Rectilinear polygon', 1000, 33554432, 0000000000, 0000000000, '<img align="right" vspace="20" hspace="20" src="http://plg1.cs.uwaterloo.ca/%7Eacm00/060930/rp.jpg" alt="" />\r\n<p>Given is</p>\r\n<it>n</it>\r\n<p>points with integer coordinates in the plane.  Is it is possible to construct a simple, that is non-intersecting, rectilinear polygon with the given points as vertices?  In a rectilinear polygon there are at least 4 vertices and every edge is either horizontal or vertical;  each vertex is an endpoint of exactly one horizontal edge and one vertical edge.  There are no holes in a polygon.</p>\r\n<p>The first line of input is an integer giving the number of cases that follow.  The input of each case starts with an integer 4 &le; <it>n</it> &le; 100000 giving the number of points for this test case. It is followed by <it>n</it> pairs of integers specifying the <it>x</it> and <it>y</it> coordinates of the points for this case.</p>\r\n<p>The output should contain one line for each case on input.  Each line should contain one integer number giving the length of the rectilinear  polygon passing throught the given points when it exists; otherwise, it should contain <tt>-1</tt>.</p>', 'http://plg1.cs.uwaterloo.ca/~acm00/060930/B.html', '<p>Please Input Input Here</p>', '<p>Please Input Output Here</p>', '1\r\n8\r\n1 2\r\n1 0\r\n2 1\r\n2 2\r\n3 2\r\n3 1\r\n4 0\r\n4 2\r\n', '12', '', 0, 0, '2010-08-18 22:37:37', '2010-08-18 22:37:37'),
(180, 1, 'Life Forms', 10000, 33554432, 0000000000, 0000000000, '<p>You may have wondered why most extraterrestrial life forms resemble humans, differing by superficial traits such as height, colour, wrinkles, ears, eyebrows and the like.  A few bear no human resemblance; these typically have geometric or amorphous shapes like cubes, oil slicks or clouds of dust.</p>\r\n<p>The answer is given in the 146th episode of <i>Star Trek - The Next Generation</i>, titled <i>The Chase</i>.  It turns out that in the vast majority of the quadrant''s life forms ended up with a large fragment of common DNA.</p>\r\n<p>Given the DNA sequences of several life forms represented as strings of letters, you are to find the longest substring that is shared by more than half of them.</p>\r\n<p>Standard input contains several test cases.  Each test case begins with 1 &le; n &le; 100, the number of life forms.  <i>n</i> lines follow; each contains a string of lower case letters representing the DNA sequence of a life form.  Each DNA sequence contains at least one and not more than 1000 letters.  A line containing 0 follows the last test case.</p>\r\n<p>For each test case, output the longest string or strings shared by more than half of the life forms.  If there are many, output all of them in alphabetical order.  If there is no solution with at least one letter, output &quot;?&quot;.  Leave an empty line between test cases.</p>', '', '<p>Please Input Input Here</p>', '<p>Please Input Output Here</p>', '3\r\nabcdefg\r\nbcdefgh\r\ncdefghi\r\n3\r\nxxx\r\nyyy\r\nzzz\r\n0\r\n', 'bcdefg\r\ncdefgh\r\n\r\n?\r\n', '', 0, 0, '2010-08-18 22:37:37', '2010-08-18 22:37:37'),
(181, 1, 'Tautology', 1000, 33554432, 0000000000, 0000000000, '<p>WFF ''N PROOF is a logic game played with dice.  Each die has six faces representing some subset of the possible symbols K, A, N, C, E, p, q, r, s, t. A Well-formed formula (WFF) is any string of these symbols obeying the following rules:</p>\r\n<ul>\r\n    <li>p, q, r, s, and t are WFFs</li>\r\n    <li>if <i>w</i> is a WFF, N<i>w</i> is a WFF</li>\r\n    <li>if <i>w</i> and <i>x</i> are WFFs, K<i>wx</i>, A<i>wx</i>, C<i>wx</i>, and E<i>wx</i> are WFFs.</li>\r\n</ul>\r\n<p>The meaning of a WFF is defined as follows:</p>\r\n<ul>\r\n    <li>p, q, r, s, and t are logical variables that may take on the value 0 (false) or  1 (true).</li>\r\n    <li>K, A, N, C, E mean <i>and, or, not, implies,</i> and <i>equals</i> as defined in the truth table below.</li>\r\n</ul>\r\n<center>\r\n<table border="1" bgcolor="#ccffff" width="80%" cols="1">\r\n    <tbody>\r\n        <tr>\r\n            <td><center><b><font color="#000099"><font size="+1">Definitions of K, A, N, C, and E</font></font></b></center></td>\r\n        </tr>\r\n    </tbody>\r\n</table>\r\n<table border="1" bgcolor="#ccffff" width="80%" cols="6">\r\n    <tbody>\r\n        <tr>\r\n            <td>&nbsp;&nbsp;&nbsp;&nbsp; <b><font face="Courier New,Courier"><font size="+1"><i>w</i>&nbsp; <i>x</i></font></font></b></td>\r\n            <td><b><font face="Courier New,Courier"><font size="+1">&nbsp; K<i>wx</i></font></font></b></td>\r\n            <td><b><font face="Courier New,Courier"><font size="+1">&nbsp; A<i>wx</i></font></font></b></td>\r\n            <td><b><font face="Courier New,Courier"><font size="+1">&nbsp;&nbsp; N<i>w</i></font></font></b></td>\r\n            <td><b><font face="Courier New,Courier"><font size="+1">&nbsp; C<i>wx</i></font></font></b></td>\r\n            <td><b><font face="Courier New,Courier"><font size="+1">&nbsp; E<i>wx</i></font></font></b></td>\r\n        </tr>\r\n        <tr>\r\n            <td><b><font face="Courier New,Courier"><font size="+1">&nbsp; 1&nbsp; 1</font></font></b></td>\r\n            <td><b><font face="Courier New,Courier"><font size="+1">&nbsp; 1</font></font></b></td>\r\n            <td><b><font face="Courier New,Courier"><font size="+1">&nbsp; 1</font></font></b></td>\r\n            <td><b><font face="Courier New,Courier"><font size="+1">&nbsp;&nbsp; 0</font></font></b></td>\r\n            <td><b><font face="Courier New,Courier"><font size="+1">&nbsp; 1</font></font></b></td>\r\n            <td><b><font face="Courier New,Courier"><font size="+1">&nbsp; 1</font></font></b></td>\r\n        </tr>\r\n        <tr>\r\n            <td><b><font face="Courier New,Courier"><font size="+1">&nbsp; 1&nbsp; 0</font></font></b></td>\r\n            <td><b><font face="Courier New,Courier"><font size="+1">&nbsp; 0</font></font></b></td>\r\n            <td><b><font face="Courier New,Courier"><font size="+1">&nbsp; 1</font></font></b></td>\r\n            <td><b><font face="Courier New,Courier"><font size="+1">&nbsp;&nbsp; 0</font></font></b></td>\r\n            <td><b><font face="Courier New,Courier"><font size="+1">&nbsp; 0</font></font></b></td>\r\n            <td><b><font face="Courier New,Courier"><font size="+1">&nbsp; 0</font></font></b></td>\r\n        </tr>\r\n        <tr>\r\n            <td><b><font face="Courier New,Courier"><font size="+1">&nbsp; 0&nbsp; 1</font></font></b></td>\r\n            <td><b><font face="Courier New,Courier"><font size="+1">&nbsp; 0</font></font></b></td>\r\n            <td><b><font face="Courier New,Courier"><font size="+1">&nbsp; 1</font></font></b></td>\r\n            <td><b><font face="Courier New,Courier"><font size="+1">&nbsp;&nbsp; 1</font></font></b></td>\r\n            <td><b><font face="Courier New,Courier"><font size="+1">&nbsp; 1</font></font></b></td>\r\n            <td><b><font face="Courier New,Courier"><font size="+1">&nbsp; 0</font></font></b></td>\r\n        </tr>\r\n        <tr>\r\n            <td><b><font face="Courier New,Courier"><font size="+1">&nbsp; 0&nbsp; 0</font></font></b></td>\r\n            <td><b><font face="Courier New,Courier"><font size="+1">&nbsp; 0</font></font></b></td>\r\n            <td><b><font face="Courier New,Courier"><font size="+1">&nbsp; 0</font></font></b></td>\r\n            <td><b><font face="Courier New,Courier"><font size="+1">&nbsp;&nbsp; 1</font></font></b></td>\r\n            <td><b><font face="Courier New,Courier"><font size="+1">&nbsp; 1</font></font></b></td>\r\n            <td><b><font face="Courier New,Courier"><font size="+1">&nbsp; 1</font></font></b></td>\r\n        </tr>\r\n    </tbody>\r\n</table>\r\n</center>\r\n<p>A <i>tautology</i> is a WFF that has value 1 (true) regardless of the values of its variables.  For example, <i>ApNp</i> is a tautology because it is true regardless of the value of <i>p</i>.  On the other hand, <i>ApNq</i> is not, because it has the value 0 for <i>p=0, q=1</i>.</p>\r\n<p>You must determine whether or not a WFF is a tautology.</p>\r\n<p>Input consists of several test cases.  Each test case is a single line containing a WFF with no more than 100 symbols.  A line containing 0 follows the last case.  For each test case, output a line containing <i>tautology</i> or <i>not</i> as appropriate.</p>', 'http://plg1.cs.uwaterloo.ca/~acm00/060930/D.html', '<p>Please Input Input Here</p>', '<p>Please Input Output Here</p>', 'ApNp\r\nApNq\r\n0\r\n', 'tautology\r\nnot\r\n', '', 0, 0, '2010-08-18 22:37:37', '2010-08-18 22:37:37'),
(182, 1, 'Mall Mania', 1000, 134217728, 0000000000, 0000000000, '<p>\r\n	Waterloo has two giant shopping malls, each enclosing several city blocks. Kim and Pat like to shop and to walk within the malls but they don&#39;t like walking between the malls because such walking does not contribute directly to the task at hand: shopping. They would therefore like to know the minimum crossing distance between the malls.</p>\r\n<p>\r\n	Each city block is a unit square delimited by streets and avenues. Streets run east-west and avenues run north-south. Both are identified by consecutive integers between 0 and 2000. (Lower numbered avenues are west of higher numbered avenues and lower numbered streets are south of higher numbered streets.) Streets and avenues are narrow so their thickness may be assumed to be 0.</p>\r\n<p>\r\n	Each mall is a contiguous set of complete city blocks. By contiguous we mean that any two blocks are connected by some sequence of blocks such that consecutive pairs of blocks in the sequence share a side. The malls do not intersect and do not surround any empty blocks; that is, the blocks not in any mall are themselves contiguous.</p>\r\n<p>\r\n	Standard input contains several test cases. Each test case contains the description of the two malls. Each mall&#39;s description consists of an integer <i>p&nbsp;&ge;&nbsp;4</i>, the perimeter of the mall, followed by one or more lines containing <i>p</i> pairs <i>(a,s)</i> giving the coordinates of the avenue-street intersections contained in the perimeter, in clockwise order. A line containing 0 follows the last test case.</p>\r\n<p>\r\n	For each case, output a single integer <i>d</i> -- the minimum walking distance between the malls, assuming that Kim and Pat always walk along streets and avenues.</p>\r\n', 'http://plg1.cs.uwaterloo.ca/~acm00/060924/B.html', '<br />\r\n', '<br />\r\n', '4\r\n0 0 0 1 1 1 1 0\r\n6\r\n4 3 4 2 3 2\r\n2 2 2 3\r\n3 3\r\n0\r\n', '2\r\n', '', 0, 0, '2010-08-18 22:41:32', '2010-08-18 14:42:28'),
(183, 1, 'Moonshine', 10000, 33554432, 0000000000, 0000000000, '<p>Granny is preparing moonshine whiskey for an upcoming family reunion.  Because her family is large, she needs to make several batches of whiskey, which she collects in a large metal cream can.  After making, and sampling, several batches Granny  stumbles and knocks the can on its side.  Fortunately, the lid is tightly fixed so no whiskey is lost.</p>\r\n<p>Our question to you is this:  assuming that the depth of whiskey in the can was <i>k</i> cm with the can sitting upright, what is its depth with the can lying horizontal?  The can itself is made of two cylinders:  the body with height <i>h<sub>b</sub></i> and diameter <i>d<sub>b</sub></i>, and the neck with  height <i>h<sub>n</sub></i> and diameter <i>d<sub>n</sub></i>.  The neck and body are joined by a tapered conic shoulder such that the overall height of the can is <i>h</i>.  The bottom and lid of the can are disks of diameter <i>d<sub>b</sub></i> and <i>d<sub>n</sub></i> respectively.</p>\r\n<p>Input consists of several test cases.  Each test case consists of a line containing real numbers <i>k h<sub>b</sub> d<sub>b</sub> h<sub>n</sub> d<sub>n</sub></i> and <i>h.</i>  You may assume that <i>100&nbsp;&ge;&nbsp;h&nbsp;&ge;&nbsp;h<sub>b</sub>&nbsp;+&nbsp;h<sub>n</sub></i> and that <i>100&nbsp;&ge;&nbsp;d<sub>b</sub>&nbsp;&ge;&nbsp;d<sub>n</sub></i>.   A line containing 0 0 0 0 0 0 follows the last test case.</p>\r\n<p>For each test case, output a line containing <i>s</i> the depth with the can lying horizontally, rounded to two decimal places.</p>\r\n<center><img alt="" src="http://plg1.cs.uwaterloo.ca/%7Eacm00/060924/jug.jpg" /></center>', 'http://plg1.cs.uwaterloo.ca/~acm00/060924/C.html', '', '', '5.625 10.0 10.0 5.0 5.0 15.0\r\n0 0 0 0 0 0\r\n', '5.00\r\n', '', 0, 0, '2010-08-18 22:41:33', '2010-08-18 22:41:33'),
(184, 1, 'Cousins', 1000, 33554432, 0000000000, 0000000000, '<p>Two strings</p>\r\n<i>a</i>\r\n<p>and</p>\r\n<i>b</i>\r\n<p>are defined to be</p>\r\n<i>first cousins</i>\r\n<p>if they can be made equal by removing no more than half the characters from each. For example &quot;abcdef&quot; and &quot;axcyd&quot; are first cousins because we can remove 3 of the 6 characters (b,e,f) from the first string and 2 of the 5 characters in the second string (x,y) resulting in &quot;acd&quot;.  Two strings</p>\r\n<i>c</i>\r\n<p>and</p>\r\n<i>d</i>\r\n<p>are said to be n+1</p>\r\n<i>st cousins</i>\r\n<p>if there exists a string</p>\r\n<i>e</i>\r\n<p>that is a first cousin of</p>\r\n<i>c</i>\r\n<p>and is an n</p>\r\n<i>th</i>\r\n<p>cousin of</p>\r\n<i>d</i>\r\n<p>.</p>\r\n<p>Given two strings <i>x</i> and <i>y</i>, determine the smallest <i>n&nbsp;&ge;&nbsp;1</i> such that <i>x</i> is an n<i>th</i> cousin of <i>y</i>.</p>\r\n<p>Input consists of several test cases.  Each test case consists of two lines representing <i>x</i> and <i>y</i>.  <i>x</i> and <i>y</i>  each consist of at least 1 and at most 100 lower case letters.   Two lines containing 0 follow the last test case. For each test case, output a line containing <i>n</i> or  <b>not related</b> if <i>x</i> and <i>y</i> are not n<i>th</i> cousins for any <i>n</i>.</p>', 'http://plg1.cs.uwaterloo.ca/~acm00/060924/E.html', '', '', 'a\r\nb\r\nabb\r\nbaa\r\nabcdef\r\naxcyd\r\n0\r\n0\r\n', '2\r\n2\r\n1', '', 0, 0, '2010-08-18 22:41:33', '2010-08-18 22:41:33'),
(185, 1, 'Gangs', 1000, 33554432, 0000000000, 0000000000, '<p>The downtown core of Inner City is laid out as a grid, with numbered streets running north-south from 1st Street in the west to 20th Street in the east, and numbered avenues running east-west from 1st Avenue in the north to 20th Avenue in the south. The area is controlled by two gangs, the Blips and the Cruds. The boundary between their territory is the Green Line, running diagonally from the intersection of 1st Street and 1st Avenue to the intersection of 20th Street and 20th Avenue. The Blips control the area to the southwest of the Green Line, and the Cruds the area to the northeast.</p>\n<p>To prove their virility, the Blips go on &quot;runs&quot; through Crud territory, starting at 1st Avenue and 1st Street and ending at a point on the Green Line that varies from night to night. A run may return to the Green Line in between but never crosses it. A run uses avenues only in the east direction and streets only in the south direction. Thus a run can be described by a string of E''s and S''s of length 2N-2; such a run ends at Nth Street and Nth Avenue.</p>\n<p>The Blips judge the runs made on a given night (all of which have the same length) by how &quot;OG&quot; they are. A run R1 is more OG than a run R2 if and only if:</p>\n<ul>\n    <li>R2 returns to the Green Line for the first time at an earlier point   than when R1 returns to the Green Line, or</li>\n    <li>R1 and R2 return to the Green Line at the same point, but the   portion of R1 to that point (ignoring the initial E and final S) is   more OG than the portion of R2 to that point (also ignoring the   initial E and final S), or</li>\n    <li>R1 and R2 return to the Green Line at the same point and are   identical to that point, but the rest of R1 is more OG than the rest   of R2.</li>\n</ul>\n<p>Examples corresponding to these three cases:</p>\n<ul>\n    <li>EESS is more OG than ESES.</li>\n    <li>EEESSS is more OG than EESESS</li>\n    <li>EESSEESS is more OG than EESSESES.</li>\n</ul>\n<p>If all the runs of a given length are ordered according to how OG they are, then the rank of a run is its position in the resulting list. EESS has rank 1 and ESES has rank 2.</p>\n<p>Your task is to write a program to help the Blips plan and judge their nightly activities. The input to the program is a series of instances followed by 0 0. An instance consists of a line containing a positive integer N, representing the terminus of that night''s run (Nth Street and Nth Avenue), followed by positive integer M. The output corresponding to each instance is the run of length 2N-2  of rank M, or ERROR if there are fewer than M runs of length 2N-2.</p>', 'http://plg1.cs.uwaterloo.ca/~acm00/070929/A.html', '', '', '3 1\n3 2\n3 3\n0 0\n', 'EESS\nESES\nERROR\n', '', 0, 0, '2010-08-18 22:44:02', '2010-08-18 22:44:02'),
(186, 1, 'Smeech', 1000, 33554432, 0000000000, 0000000000, '<p>Professor Octastichs has invented a new programming language, Smeech.  An expression in Smeech may be a positive or negative integer, or may be of the form <tt>    (<i>p</i> <i>e<sub>1</sub></i> <i>e<sub>2</sub></i>) </tt> where <i>p</i> is a real number between 0 and 1 (inclusive) and <i>e<sub>1</sub></i> and <i>e<sub>2</sub></i> are Smeech expressions. The value represented by a Smeech expression is as follows:</p>\n<ul>\n    <li>An integer represents itself</li>\n    <li>With probability <i>p</i>, <tt>(<i>p</i> <i>e<sub>1</sub></i> <i>e<sub>2</sub></i>)</tt> represents <i>x+y</i> where <i>x</i> is the value of <i>e<sub>1</sub></i> and <i>y</i> is the value of <i>e<sub>2</sub></i>; otherwise it represents <i>x-y</i>.</li>\n</ul>\n<p>Given a Smeech expression, what is its expected value?</p>\n<p>Input consists of several Smeech expressions, one per line, followed by a line containing ().  For each expression, output its expected value to two decimal places.</p>', 'http://plg1.cs.uwaterloo.ca/~acm00/070929/B.html', '<p>Please Input Input Here</p>', '<p>Please Input Output Here</p>', '7\n(.5 3 9)\n()\n', '7.00\n3.00\n', '', 0, 0, '2010-08-18 22:44:02', '2010-08-18 22:44:02'),
(187, 1, 'The Dragon of Loowater', 1000, 33554432, 0000000000, 0000000000, '<p>Once upon a time, in the Kingdom of Loowater, a minor nuisance turned into a major problem. <img align="right" src="http://plg1.cs.uwaterloo.ca/~acm00/070929/Canadagoose_bw.GIF" alt="" /></p>\n<p>The shores of Rellau Creek in central Loowater had always been a prime breeding ground for geese. Due to the lack of predators, the geese population was out of control. The people of Loowater mostly kept clear of the geese. Occasionally, a goose would attack one of the people, and perhaps bite off a finger or two, but in general, the people tolerated the geese as a minor nuisance.</p>\n<p>One day, a freak mutation occurred, and one of the geese spawned a multi-headed fire-breathing dragon. When the dragon grew up, he threatened to burn the Kingdom of Loowater to a crisp. Loowater had a major problem. The king was alarmed, and called on his knights to slay the dragon and save the kingdom.</p>\n<p>The knights explained: &quot;To slay the dragon, we must chop off all its heads. Each knight can chop off one of the dragon''s heads. The heads of the dragon are of different sizes. In order to chop off a head, a knight must be at least as tall as the diameter of the head. The knights'' union demands that for chopping off a head, a knight must be paid a wage equal to one gold coin for each centimetre of the knight''s height.&quot;</p>\n<p>Would there be enough knights to defeat the dragon? The king called on his advisors to help him decide how many and which knights to hire. After having lost a lot of money building Mir Park, the king wanted to minimize the expense of slaying the dragon. As one of the advisors, your job was to help the king. You took it very seriously: if you failed, you and the whole kingdom would be burnt to a crisp!</p>', 'http://plg1.cs.uwaterloo.ca/~acm00/070929/C.html', '<p>The input contains several test cases. The first line of each test case contains two integers between 1 and 20000 inclusive, indicating the number <i>n</i> of heads that the dragon has, and the number <i>m</i> of knights in the kingdom. The next <i>n</i> lines each contain an integer, and give the diameters of the dragon''s heads, in centimetres. The following <i>m</i> lines each contain an integer, and specify the heights of the knights of Loowater, also in centimetres.</p>\n<p>The last test case is followed by a line containing:</p>\n<pre>\n0 0\n</pre>', '<p>For each test case, output a line containing the minimum number of gold coins that the king needs to pay to slay the dragon. If it is not possible for the knights of Loowater to slay the dragon, output the line:</p>\n<pre>\nLoowater is doomed!\n</pre>', '2 3\n5\n4\n7\n8\n4\n2 1\n5\n5\n10\n0 0\n', '11\nLoowater is doomed!\n', '', 0, 0, '2010-08-18 22:44:02', '2010-08-18 22:44:02'),
(188, 1, 'Ferry Loading IV', 10000, 134217728, 0000000000, 0000000000, '<p>Before bridges were common, ferries were used to transport cars across rivers. River ferries, unlike their larger cousins, run on a guide line and are powered by the river''s current. Cars drive onto the ferry from one end, the ferry crosses the river, and the cars exit from the other end of the ferry.</p>\r\n<p>There is an <i>l</i>-meter-long ferry that crosses the river. A car may arrive at either river bank to be transported by the ferry to the opposite bank.  The ferry travels continuously back and forth between the banks so long as it is carrying a car or there is at least one car waiting at either bank.  Whenever the ferry arrives at one of the banks, it unloads its cargo and loads up cars that are waiting to cross as long as they fit on its deck.  The cars are loaded in the order of their arrival; ferry''s deck accommodates only one lane of cars. The ferry is initially on the left bank where it broke and it took quite some time to fix it.  In the meantime, lines of cars formed on both banks that await to cross the river.</p>\r\n<p>The first line of input contains <i>c</i>, the number of test cases. Each test case begins with <i>l, m</i>. <i>m</i> lines follow describing the cars that arrive in this order to be transported.  Each line gives the length of a car (in centimeters), and the bank at which the car arrives (&quot;left&quot; or &quot;right&quot;).</p>\r\n<p>For each test case, output one line giving the number of times the ferry has to cross the river in order to serve all waiting cars.</p>', 'http://plg1.cs.uwaterloo.ca/~acm00/060527/A.html', '', '', '4\r\n20 4\r\n380 left\r\n720 left\r\n1340 right\r\n1040 left\r\n15 4 \r\n380 left\r\n720 left\r\n1340 right\r\n1040 left\r\n15 4 \r\n380 left\r\n720 left\r\n1340 left\r\n1040 left\r\n15 4 \r\n380 right\r\n720 right\r\n1340 right\r\n1040 right\r\n', '3\r\n3\r\n5\r\n6\r\n', '', 0, 0, '2010-08-18 23:03:11', '2010-08-18 23:03:11'),
(189, 1, 'Card Hands', 1000, 268435456, 0000000000, 0000000000, '<p>Jim is writing a program for statistically analyzing card games. He needs to store many different card hands in memory efficiently.  Each card has one of four <i>suits</i> and one of thirteen  <i>values</i>. In his implementation, each hand is stored as a linked list of cards in a canonical order:  the cards are first ordered by suit: all the clubs come first,  followed by all the diamonds, then all the hearts, and finally the spades. Within each suit, the cards are ordered by value: A, 2, 3, 4, 5, 6, 7, 8, 9, 10, J, Q, K. Each hand contains at most one of any given card.</p>\r\n<p>The card hands are using lots of memory. Jim therefore decides to try a more efficient representation. Whenever any two lists share a common tail, they can be updated to share one copy of the tail, and the other copy can be discarded. This process can be repeated until no two lists share a common tail.</p>\r\n<p>Your job is to tell Jim how many linked list nodes he needs to store all the card hands.</p>', 'http://plg1.cs.uwaterloo.ca/~acm00/060527/B.html', '<p>The input contains several test cases followed by a line containing 0. The first line of each case contains the number of card hands. Each subsequent line describes a card hand. It starts with a number indicating the number of cards in the hand. The cards follow, separated by spaces, in the canonical order defined above. For each card, the value is given first, followed by the suit (C, D, H, or S). There are at most 100,000 cards in all hands.</p>', '<p>For each test case, output a line containing the number of linked list  nodes needed to store all the lists.</p>', '3\r\n3 7D AH 5S\r\n4 9C 3D 4D 5S\r\n2 AH 5S\r\n0\r\n', '6', '', 0, 0, '2010-08-18 23:03:13', '2010-08-18 23:03:13'),
(190, 1, 'Eventually periodic sequence', 1000, 134217728, 0000000000, 0000000000, '<img align="right" vspace="10" hspace="10" src="http://plg1.cs.uwaterloo.ca/%7Eacm00/060527/period.jpg" alt="" />\r\n<p>Given is a function</p>\r\n<em>f: 0..N --&gt; 0..N</em>\r\n<p>for a non-negative</p>\r\n<em>N</em>\r\n<p>and a non-negative integer</p>\r\n<em>n</em>\r\n<p>&le;</p>\r\n<em>N</em>\r\n<p>.  One can construct an infinite sequence</p>\r\n<em>F = f<sup>&nbsp;1</sup>(n), f<sup>&nbsp;2</sup>(n), ... f<sup>&nbsp;k</sup>(n) ... </em>\r\n<p>, where</p>\r\n<em>f<sup>&nbsp;k</sup>(n)</em>\r\n<p>is defined recursively as follows:</p>\r\n<em>f<sup>&nbsp;1</sup>(n) = f(n)</em>\r\n<p>and</p>\r\n<em>f<sup>&nbsp;k+1</sup>(n)</em>\r\n<p>=</p>\r\n<em>f(f<sup>&nbsp;k</sup>(n))</em>\r\n<p>.</p>\r\n<p>It is easy to see that each such sequence <em>F</em> is eventually periodic, that is periodic from some point onwards, e.g 1, 2, 7, 5, 4, 6, 5, 4, 6, 5, 4, 6 ... . Given non-negative integer <em>N &le; 11000000 </em>, <em>n &le; N</em> and <em>f</em>, you are to compute the period of sequence <em>F</em>.</p>\r\n<p>Each line of input contains <em>N</em>, <em>n</em> and the a description of <em>f</em> in postfix notation, also known as Reverse Polish Notation (RPN).  The operands are either unsigned integer constants or <em>N</em> or the variable <em>x</em>.  Only binary operands are allowed: + (addition), * (multiplication) and % (modulo, i.e. remainder of integer division). Operands and operators are separated by whitespace.  The operand % occurs exactly once in a function and it is the last (rightmost, or topmost if you wish) operator and its second operand is always <em>N</em> whose value is read from input. The following function:</p>\r\n<pre>\r\n \r\n            2 x * 7 + N % \r\n</pre>\r\n<p>is the RPN rendition of the more familiar infix</p>\r\n<tt>(2*x+7)%N</tt>\r\n<p>.  All input lines are shorter than 100 characters. The last line of input has</p>\r\n<em>N</em>\r\n<p>equal 0 and should not be processed.</p>\r\n<p>For each line of input, output one line with one integer number, the period of <em>F</em> corresponding to the data given in the input line.</p>', 'http://plg1.cs.uwaterloo.ca/~acm00/060527/C.html', '', '', '10 1 x N %\r\n11 1 x x 1 + * N %\r\n1728 1 x x 1 + * x 2 + * N %\r\n1728 1 x x 1 + x 2 + * * N %\r\n100003 1 x x 123 + * x 12345 + * N %\r\n0 0 0 N %\r\n', '1\r\n3\r\n6\r\n6\r\n369\r\n', '', 0, 0, '2010-08-18 23:03:13', '2010-08-18 23:03:13'),
(191, 1, 'Point of view in Flatland', 5000, 134217728, 0000000000, 0000000000, '<p><img align="right" vspace="20" hspace="20" alt="" src="http://plg1.cs.uwaterloo.ca/%7Eacm00/060527/flat-world.jpg" /></p>\r\n<p>Everything is flat in Flatland.  The planets are round but they are flat, that is, they are discs in a plane.</p>\r\n<p>The centers of three planets in Flatland are given and their radii. Find the point in Flatland from which all three planets are visible at the same angle, that is, they appear to have the same size measured as angular diameter.  Let''s call such a point an <em> isoobservation</em> point.  There can be at most two such points and we are interested in finding the one that gives the largest angular diameter of the planets.</p>\r\n<p>Input consists of several cases, each case is presented at a single line.  Each line has nine numbers, three for each disc.  Each triple has <b>x</b> and <b>y</b> coordinates of the disc center and the radius <b>r</b> of that disc.  The input is terminated by a line  with nine zeros and this line should not be processed.</p>\r\n<p>For each case of input, print the <b>x</b> and <b>y</b> coordinates of the isoobservation point as described above in the format shown in the sample; but if there is no such point, print&nbsp;&nbsp; <tt>No solution</tt></p>\r\n<p>To simplify the problem you may assume that:</p>\r\n<ul>\r\n    <li>The discs centers are not all collinear.</li>\r\n    <li>The discs are totally disjoint.</li>\r\n    <li>The discs are transparent and non-refractive. That is, a disc is   visible and has the same apparent shape and size, whether or not   there''s another disc in front of it.</li>\r\n    <li>The input data are such that the existence or non-existence of such   a point is computable, even with slight rounding error. But use   double-precision, eh?</li>\r\n</ul>', 'http://plg1.cs.uwaterloo.ca/~acm00/060527/D.html', '', '', '10 10 1 30 30 1 50 10 1\r\n0 30 1.0 30 0 1.0 40 40 1.0\r\n10 30 1.0 31 0 1.0 42 43 1.0\r\n10 42 1 62.8 62.8 1 52.5 -25.3 1\r\n10 42 1.1 62.8 62.8 1.2 52.5 25.3 25\r\n0 0 0 0 0 0 0 0 0\r\n', '30.00 10.00\r\n23.00 23.00\r\n31.58 22.76\r\n49.27 19.73\r\nNo solution', '', 0, 0, '2010-08-18 23:03:13', '2010-08-18 23:03:13'),
(192, 1, 'How many 0', 10000, 134217728, 0000000000, 0000000000, '<p>A Benedict monk No. 16 writes down the decimal representations of all natural numbers between and including</p>\r\n<p><b>m and</b> <b>n , m<b>&le;</b>  n</b></p>\r\n<p>. How many 0''s will he write down?</p>\r\n<p>Input consists of a sequence of lines.  Each line contains two unsigned 32-bit integers <b>m</b> and <b>n</b>, <b>m</b> &le; <b>n</b>.  The last line of input has the value of <b>m</b> negative and this line should not be processed.</p>\r\n<p>For each line of input print one line of output with one integer number giving the number of 0''s written down by the monk.</p>\r\n<h3>&nbsp;<img align="right" vspace="10" hspace="10" src="http://plg1.cs.uwaterloo.ca/%7Eacm00/060527/zeros.jpg" alt="" /></h3>', 'http://plg1.cs.uwaterloo.ca/~acm00/060527/E.html', '', '', '10 11\r\n100 200\r\n0 500\r\n1234567890 2345678901\r\n0 4294967295\r\n-1 -1\r\n', '1\r\n22\r\n92\r\n987654304\r\n3825876150\r\n', '', 0, 0, '2010-08-18 23:03:13', '2010-08-18 23:03:13'),
(193, 1, 'Educational journey', 1000, 134217728, 0000000000, 0000000000, '<p>The University of Calgary team qualified for the 28th ACM International Collegiate Programming Contest World Finals in Prague, Czech Republic.  Just by using the initials of team members they got a very cunning team name: <b>ACM</b> (<b>A</b>lecs, <b>C</b>elly and <b>M</b>onny).  In order to prepare for the contest, they have decided to travel to Edmonton to learn the tricks of trade from <b>D</b>ilbert, Alberta-wide famous top-coder.</p>\r\n<p>Due to a horrible miscommunication which is as welcome as a plague among such teams, <b>A</b>, <b>C</b> and <b>M</b> drive from Calgary to Edmonton in separate cars.  To make things worse, there was also a miscommunication with <b>D</b>, who being always so helpful, decides to go to Calgary in order to save the team a trip to the far, freezing North.  All this happens on the same day and each car travels at a constant (but not necessarily the same) speed on the famous Alberta #2.</p>\r\n<p><b>A</b> passed <b>C</b> and <b>M</b> at time <em>t1</em> and <em>t2</em>, respectively, and met D at time <em>t3</em>. <b>D</b> met <b>C</b> and <b>M</b> at times <em>t4</em> and <em>t5</em>, respectively.  The question is: at what time time did <b>C</b> pass <b>M</b>?</p>\r\n<p>The input is a sequence of lines, each containing times <em>t1</em>, <em>t2</em>, <em>t3</em>, <em>t4</em> and <em>t5</em>, separated by white space. All times are distinct and given in increasing order. Each time is given in the hh:mm:ss format on the 24-hour clock. A line containing -1 terminates the input.</p>\r\n<p>For each line of input produce one line of output giving the time when  <b>C</b> passed <b>M</b> in the same format as input, rounding the seconds in the standard way.</p>\r\n<p>&nbsp;</p>\r\n<h3>&nbsp;</h3>', '', '', '', '10:00:00 11:00:00 12:00:00 13:00:00 14:00:00\r\n10:20:00 10:58:00 14:32:00 14:59:00 16:00:00\r\n10:20:00 12:58:00 14:32:00 14:59:00 16:00:00\r\n08:00:00 09:00:00 10:00:00 12:00:00 14:00:00\r\n-1\r\n', '12:00:00\r\n11:16:54\r\n13:37:32\r\n10:40:00\r\n', '', 0, 0, '2010-08-18 23:16:51', '2010-08-18 23:16:51'),
(194, 1, 'Go', 1000, 134217728, 0000000000, 0000000000, '<p>Go is played on a square board with an odd number of vertical and horizontal lines.  The usual board sizes are 9x9, 13x13 and 19x19.  But we''ll assume the size in <i>n</i>x<i>n</i> for 3 &le; n &le; 19.</p>\r\n<p>Black and White alternately play stones on the  intersection between two lines.  Black starts.  At any time one player may pass - not play a stone - but if both players pass the game ends.  We''ll denote playing a stone by P(x,y) where P is either B (for Black) or W (for White) and (1-n)/2 &le; x,y &le; (n-1)/2 gives the grid position of the stone to be played. The centre intersection of the board has coordinates (0,0).</p>\r\n<p>The rules of Go are reasonably straightforward, but the nuances of strategy make it an extremely challenging game. You are to use the following rules.</p>\r\n<ul>\r\n    <li>Black plays first.</li>\r\n    <li>Black and White alternate; at each turn a player may place a stone or may pass.  The game ends when Black and White pass consecutively.</li>\r\n    <li>A stone may be played only on an unoccupied intersection.</li>\r\n    <li>If one player P places a stone so that his or her stones (along with the edge of the board) completely surround a connected area occupied by stones belonging to the other player, Q, Q''s stones are said to be captured and removed from the board.  More precisely, two intersections are connected if they are horizontally or vertically (but not diagonally) adjacent.  Stones in an area are completely surrounded if no stone is connected with a vacant intersection.</li>\r\n    <li>If P places a stone that causes Q''s stones to be captured, P''s stone is not captured.</li>\r\n    <li>A connected area surrounded by P''s stones which contains none of Q''s stones is said to be <i>owned</i> by P.</li>\r\n    <li>The score for player P is the number of vacant intersections owned by P in the final board configuration plus the number of Q''s stones captured by P at any time during the game.</li>\r\n</ul>\r\n<p>The input consists of several test cases.  Each test case begins with a line containing</p>\r\n<i>n</i>\r\n<p>- the size of the board - and</p>\r\n<i>m</i>\r\n<p>- the number of stones placed in the game.</p>\r\n<i>m</i>\r\n<p>lines follow, each giving a placement in the format above. Note that</p>\r\n<i>m</i>\r\n<p>counts only stone placements - passes may result in two consecutive placements by the same player. You may assume that each move is legal.  A line containing 0 0 follows the last test case.</p>\r\n<p>For each test case, output a line with two numbers:  Black''s score followed by White''s score.</p>', '', '', '', '7 6\r\nB(-2,-2)\r\nW(2,2)\r\nB(-2,-3)\r\nW(2,3)\r\nB(-3,-2)\r\nW(3,2)\r\n7 6\r\nB(-2,-3)\r\nW(-3,-3)\r\nB(-2,-2)\r\nW(3,2)\r\nB(-3,-2)\r\nW(2,3)\r\n0 0\r\n', '1 1\r\n2 1\r\n', '', 0, 0, '2010-08-18 23:16:51', '2010-08-18 23:16:51'),
(195, 1, 'Medals', 1000, 134217728, 0000000000, 0000000000, '<p>At the Olympic Games, countries are ranked according to the number of medals 		their athletes won. However, there is more than one possible way of ranking 		countries by their medals. In Europe, for example, countries are first ranked 		by the number of gold medals their athletes won. Ties are broken by looking 		at silver medals, and then at bronze medals. In Canada, however, because 		Canadian athletes do not win very many gold medals, countries are ranked by 		the overall number of medals won, giving the same weight to gold, silver, and 		bronze medals. 		<br />\r\n<br />\r\nIn general, a ranking scheme can be thought of as a vector of positive weights. 		This vector is multiplied with the vector of medals won by each country, and 		the scalar product of the two vectors defines the score of the respective country, 		which is then used to produce the ranking. In this general scheme, the European 		ranking technique corresponds to the weight vector <i>(10<sup>20</sup>, 10<sup>10</sup>, 1)</i>, 		whereas the Canadian method corresponds to the vector <i>(1, 1, 1)</i>. 		<br />\r\n<br />\r\nIn this problem, you will only need to consider weight vectors of the form 		<i>(1/n<sup>j</sup>, 1/n<sup>k</sup>, 1/n<sup>l</sup>)</i>, where <i>n</i> is the 		total number of medals won by all athletes in the Olympic Games, and 		<i>j</i>, <i>k</i>, and <i>l</i> are integers. 		<br />\r\n<br />\r\nGiven a list of countries and the number of gold, silver, and bronze medals won by each 		country, print the line</p>\r\n<blockquote> 			<tt>Canada wins!</tt> 		</blockquote>\r\n<p>if there is a weight vector of the above form such that Canada ranks first according to 		the ranking scheme defined by that vector. Print the line</p>\r\n<blockquote> 			<tt>Canada cannot win.</tt> 		</blockquote>\r\n<p>if no such vector exists.</p>\r\n<br />\r\n<br />\r\n<p>The input contains multiple test cases. Each test case starts with an integer</p>\r\n<i>c</i>\r\n<p>, 		the number of countries to follow. Each of the following</p>\r\n<i>c</i>\r\n<p>lines contains the name 		of a country and three integers</p>\r\n<i>g</i>\r\n<p>,</p>\r\n<i>s</i>\r\n<p>, and</p>\r\n<i>b</i>\r\n<p>&ndash; the number of 		gold, silver, and bronze medals won by the country. The last test case has</p>\r\n<i>c = 0</i>\r\n<p>and must not be processed. It is guaranteed that each test case contains at most 20 		different countries and that the total number of medals smaller than 100. Country names 		do not contain whitespace characters.</p>', '', '', '', '2\r\nCanada 3 2 1\r\nUSA 1 2 3\r\n2\r\nUSA 2 2 2\r\nCanada 1 1 1\r\n0', 'Canada wins!\r\nCanada cannot win.', '', 0, 0, '2010-08-18 23:16:51', '2010-08-18 23:16:51'),
(196, 1, 'Flipping colors', 1000, 134217728, 0000000000, 0000000000, '<p>A rectangle with sides parallel to the x-y axes and its left-lower corner at (0,&nbsp;0) is being painted.  The rectangle may be thought of as a flat-screen display with almost infinite resolution; initially the entire rectangle is black.  Two numbers are given 0 &lt; <b>h</b>, <b>v</b> &lt; 1 and then</p>\r\n<ul>\r\n    <li>A vertical line is drawn dividing the horizontal sides of the rectangle in proportion <b>h</b>:1-<b>h</b> from the left.</li>\r\n    <li>A horizontal line is drawn dividing the vertical sides of the rectangles in proportion <b>v</b>:1-<b>v</b> from the bottom up.</li>\r\n    <li>These two lines divide the rectangle into four smaller rectangles.</li>\r\n    <li>The upper left and the lower right sub-rectangles remain intact.</li>\r\n    <li>The color of the other two rectangles is flipped (from black to white or from white to black) and now each of them is subject to the operation just performed on the bigger rectangle.</li>\r\n    <li>This process continues (in principle) forever.</li>\r\n</ul>\r\n<p>Given a point in the original rectangle but not on the boundary of any rectangle that turns up in the process of painting, determine the color of the point.</p>\r\n<p>Input contains multiple cases.  The first line of each case  contains 4 numbers, the length of the rectangle <b>H</b>, the height of the rectangle <b>V</b> and then the numbers <b>h</b> and <b>v</b>.  The next line contains one integer number <b>n</b>, the number of points to consider. The following <b>n</b> lines contain two numbers each, the <b>x</b> and the <b>y</b> coordinate of a point.</p>\r\n<p>Organize your output as shown in the sample.  For each point from input print the color of the point.</p>', '', '', '', '81 32 0.333333333333 0.5\r\n6\r\n16 30\r\n16 25\r\n16 12.0001\r\n16 11.9999\r\n16 7.987654321\r\n16 7.0123456789\r\n10 10 0.123456789 0.987654321\r\n2\r\n0.432 0.9876\r\n9.432 0.9876\r\n0 0 0 0\r\n', 'Case 1:\r\nblack\r\nblack\r\nwhite\r\nblack\r\nwhite\r\nwhite\r\nCase 2:\r\nwhite\r\nblack\r\n', '', 0, 0, '2010-08-18 23:16:51', '2010-08-18 23:16:51'),
(197, 1, 'Crabbles', 1000, 134217728, 0000000000, 0000000000, '<p>Jennifer is practicing for a Crabbles tournament. She pulls out a handful of Crabbles tiles out of a bag, and tries to form the word with the highest possible score. Each tile contains a letter (used to form the word) and a number (its score value). She can use each tile at most once in her word, and she is not required to use every tile. The word that she forms must appear in her dictionary. Her score is the sum of the values of the tiles used in the word.</p>\r\n<p>Note that in Crabbles, different tiles with the same letter may have different score values.</p>\r\n<p>To check her work, Jennifer would like a program to tell her the maximum score possible for the set of tiles. Your task is to write this program.</p>', '', '<p>The first line contains an integer 1 &le; N &le; 100,000 indicating the number of words in the dictionary. N lines follow, with one dictionary word on each line. Each dictionary word consists of only lowercase letters. The following line contains an integer 1 &le; M &le; 1000 indicating the number of Crabbles hands Jennifer wants to play. M hands follow. Each hand begins with a line containing an integer 1 &le; P &le; 10 indicating the number of tiles in the hand. This is followed by P lines, one for each tile. Each of these lines consists of a lowercase letter (the letter on the tile), a space, and an integer 0 &le; V &le; 10 (the value of the tile).</p>', '<p>For each hand in the input, output a line containing the maximum score possible with that hand.</p>', '2\r\nabcd\r\nhgfe\r\n1\r\n10\r\na 1\r\nb 2\r\nc 3\r\nd 4\r\ne 5\r\nf 6\r\ng 7\r\nh 8\r\ni 9\r\nj 10\r\n', '26\r\n', '', 0, 0, '2010-08-18 23:16:51', '2010-08-18 23:16:51'),
(198, 1, 'War on Weather', 1000, 134217728, 0000000000, 0000000000, '<p>After an unprovoked hurricane attack on the south shore, Glorious Warrior has declared war on weather.  The first salvo in this campaign will be a coordinated pre-emptive attack on as many tropical depressions as possible.  GW reckons that the attack will neutralize the tropical depressions before they become storms, and dissuade  others from forming.</p>\r\n<p>GW has at his disposal <i>k</i> space-to-earth killer satellites at various locations in space.  <i>m</i>  tropical depressions are known to exist at various locations on the earth''s surface.  Each satellite can attack any number of targets on the earth provided there is <i>line of sight</i> between the satellite and each target.  How many different targets can be hit?</p>\r\n<p>The input consists of several test cases.  Each case begins with a line containing integers <i>0 &lt; k, m &le; 100</i> as defined above.  <i>k</i> lines follow, each giving <i>x,y,z</i> - the location in space of a satellite at the scheduled time of attack.  <i>m</i> lines then  follow,  each giving <i>x,y,z</i> - the location of a target tropical depression. Assume the earth is a sphere centred at (0,0,0) with circumference 40,000 km.  All targets will be on the surface of the earth (within 10<sup>-9</sup> km) and all satellites will be at least 50 km above the surface. A line containing 0 0 follows the last test case.</p>\r\n<p>For each test case, output a line giving the total number of targets that can be hit.  If a particular target falls within 10<sup>-8</sup> km of the boundary between being within line-of-sight and not, it may be counted either way.  (That is, you need not consider  rounding error so long as it does not exceed 10<sup>-8</sup> km.)</p>\r\n<p>&nbsp;</p>\r\n<img src=http://plg1.cs.uwaterloo.ca/~acm00/050924/laser.jpg>', '', '', '', '3 2\r\n-10.82404031 -1594.10929753 -6239.77925152\r\n692.58497298 -5291.64700245 4116.92402298\r\n3006.49210582 2844.61925179 5274.03201053\r\n2151.03635167 2255.29684503 5551.13972186\r\n-1000.08700886 -4770.25497971 4095.48127333\r\n3 4\r\n0 0 6466.197723676\r\n0 6466.197723676 0\r\n6466.197723676 0 0\r\n6366.197723676 0 0\r\n6365.197723676 112.833485488 0\r\n0 0 6366.197723676\r\n0 -6366.197723676 0\r\n0 0\r\n', '2\r\n3\r\n', '', 0, 0, '2010-08-18 23:18:12', '2010-08-18 23:18:12'),
(199, 1, 'Factstone Benchmark', 1000, 134217728, 0000000000, 0000000000, '<p>Amtel has announced that it will release a 128-bit computer chip by  2010, a 256-bit computer by 2020, and so on, continuing its strategy of doubling the word-size every ten years.  (Amtel released a 64-bit computer in 2000, a 32-bit computer in 1990, a 16-bit computer in 1980, an 8-bit computer in 1970, and a 4-bit computer, its first, in 1960.)</p>\r\n<p>Amtel will use a new benchmark - the <i>Factstone</i> - to advertise the vastly improved capacity of its new chips.  The <i>Factstone</i>  rating is defined to be the largest integer <i>n</i> such that <i>n!</i> can be represented as an unsigned integer in a computer word.</p>\r\n<p>Given a year <i>1960 &le; y &le; 2160</i>, what will be the  <i>Factstone</i> rating of Amtel''s most recently released chip?</p>\r\n<p>There are several test cases.  For each test case, there is one line of input containing <i>y</i>.  A line containing 0 follows the last test case.  For each test case, output a line giving the Factstone rating.</p>\r\n<p>&nbsp;</p>\r\n<img src=http://plg1.cs.uwaterloo.ca/~acm00/050924/benchmark.jpg>', '', '', '', '1960\r\n1981\r\n0\r\n', '3\r\n8\r\n', '', 0, 0, '2010-08-18 23:18:12', '2010-08-18 23:18:12');
INSERT INTO `tbl_problems` (`id`, `user_id`, `title`, `time_limit`, `memory_limit`, `submission_no`, `accepted_no`, `description`, `source`, `input`, `output`, `input_sample`, `output_sample`, `hint`, `flag`, `visibility`, `created`, `modified`) VALUES
(200, 1, 'A Walk Through the Forest', 1000, 134217728, 0000000000, 0000000000, '<p>\r\n	<img src="http://plg1.cs.uwaterloo.ca/~acm00/050924/red-wood-forest.jpg" /></p>\r\n<p>\r\n	Jimmy experiences a lot of stress at work these days, especially since his accident made working difficult. To relax after a hard day, he likes to walk home. To make things even nicer, his office is on one side of a forest, and his house is on the other. A nice walk through the forest, seeing the birds and chipmunks is quite enjoyable.</p>\r\n<p>\r\n	The forest is beautiful, and Jimmy wants to take a different route everyday. He also wants to get home before dark, so he always takes a path to make progress towards his house. He considers taking a path from <i>A</i> to <i>B</i> to be progress if there exists a route from <i>B</i> to his home that is shorter than any possible route from <i>A</i>. Calculate how many different routes through the forest Jimmy might take.</p>\r\n', '', '<p>\r\n	Input contains several test cases followed by a line containing 0. Jimmy has numbered each intersection or joining of paths starting with 1. His office is numbered 1, and his house is numbered 2. The first line of each test case gives the number of intersections <em>N</em>, 1 &lt; <em>N</em> &le; 1000, and the number of paths <em>M</em>. The following <em>M</em> lines each contain a pair of intersections <em>a</em>&nbsp;<em>b</em> and an integer distance <em>1 &le; d &le; 1000000</em> indicating a path of length <em>d</em> between intersection <em>a</em> and a different intersection <em>b</em>. Jimmy may walk a path any direction he chooses. There is at most one path between any pair of intersections.</p>\r\n', '<p>\r\n	For each test case, output a single integer indicating the number of different routes through the forest. You may assume that this number does not exceed 2147483647.</p>\r\n', '5 6\r\n1 3 2\r\n1 4 2\r\n3 4 3\r\n1 5 12\r\n4 2 34\r\n5 2 24\r\n7 8\r\n1 3 1\r\n1 4 1\r\n3 7 1\r\n7 4 1\r\n7 5 1\r\n6 7 1\r\n5 2 1\r\n6 2 1\r\n0\r\n', '2\r\n4\r\n', '', 0, 0, '2010-08-18 23:18:12', '2010-11-17 20:14:39'),
(201, 1, 'Tri Tiling', 1000, 134217728, 0000000000, 0000000000, '<img src=http://plg1.cs.uwaterloo.ca/~acm00/050924/domino.jpg>\r\n<p>In how many ways can you tile a 3x<em>n</em> rectangle with 2x1  dominoes?</p>\r\n<p>Here is a sample tiling of a 3x12 rectangle.</p>\r\n<p>&nbsp;</p>\r\n<center> <img src="http://plg1.cs.uwaterloo.ca/%7Eacm00/050924/D.gif" alt="" /> </center>\r\n<p>Input consists of several test cases followed by a line containing <i>-1</i>. Each test case is a line containing an integer <em>0 &le; n &le; 30</em>.   For each test case, output one integer number giving the number of possible tilings.</p>', '', '', '', '2\r\n8\r\n12\r\n-1\r\n', '3\r\n153\r\n2131\r\n', '', 0, 0, '2010-08-18 23:18:13', '2010-08-18 23:18:13'),
(202, 1, 'Prerequisites?', 1000, 134217728, 0000000000, 0000000000, '<p>Freddie the frosh has chosen to take <i>k</i> courses. To meet the degree requirements, he must take courses from each of several categories.  Can you assure Freddie that he will graduate, based on his course selection?</p>\r\n<p>Input consists of several test cases.  For each case, the first line of input contains <i>1 &le; k &le; 100</i>, the number of courses Freddie has chosen, and <i>0 &le; m &le; 100</i>, the number of categories.  One or more lines follow containing <i>k</i>  4-digit integers follow; each is the number of a course selected by Freddie.  Each category is represented by a line containing <i>1 &le; c &le; 100</i>, the number of courses in the category, <i>0 &le; r &le; c</i>, the minimum number of courses from the category that must be taken, and the <i>c</i> course numbers in  the category. Each course number is a 4-digit integer.  The same course may fulfil several category requirements.  Freddie''s selections, and the course numbers in any particular category, are distinct.  A line containing 0 follows the last test case.</p>\r\n<p>For each test case, output a line containing &quot;yes&quot; if Freddie''s course selection meets the degree requirements; otherwise output &quot;no.&quot;</p>\r\n<p>&nbsp;</p>\r\n<img src=http://plg1.cs.uwaterloo.ca/~acm00/050924/pre.gif>', '', '', '', '3 2\r\n0123 9876 2222\r\n2 1 8888 2222\r\n3 2 9876 2222 7654 \r\n3 2\r\n0123 9876 2222\r\n2 2 8888 2222\r\n3 2 7654 9876 2222\r\n0\r\n', 'yes\r\nno\r\n', '', 0, 0, '2010-08-18 23:18:13', '2010-08-18 23:18:13'),
(203, 1, 'So you want to be a 2n-aire', 1000, 134217728, 0000000000, 0000000000, '<h2>So you want to be a 2<sup>n</sup>-aire<img align="right" src="http://plg1.cs.uwaterloo.ca/~acm00/050917/abregis.gif" alt="" /></h2>\r\n<p>The player starts with a prize of $1, and is asked a sequence of <em>n</em> questions. For each question, he may</p>\r\n<ul>\r\n    <li>quit and keep his prize.</li>\r\n    <li>answer the question.     If wrong, he quits with nothing.     If correct, the prize is doubled, and he continues with the next     question.</li>\r\n</ul>\r\n<p>After the last question, he quits with his prize. The player wants to maximize his expected prize.</p>\r\n<p>Once each question is asked, the player is able to assess the probability <i>p</i> that he will be able to answer it. For each question, we assume that <i>p</i> is a random variable uniformly distributed over the range <em>t .. 1</em>.</p>\r\n<p>Input is a number of lines, each with two numbers: an integer <em>1 &le; n &le; 30</em>, and a real <em>0 &le; t &le; 1</em>. Input is terminated by a line containing <tt>0 0</tt>.  This line should not be processed.</p>\r\n<p>For each input <em>n</em> and <em>t</em>, print the player''s expected prize, if he plays the best strategy.  Output should be rounded to  three fractional digits.</p>', '', '<p>Please Input Input Here</p>', '<p>Please Input Output Here</p>', '1 0.5\r\n1 0.3\r\n2 0.6\r\n24 0.25\r\n0 0\r\n', '1.500\r\n1.357\r\n2.560\r\n230.138\r\n', '', 0, 0, '2010-08-18 23:20:10', '2010-08-18 23:20:10'),
(204, 1, 'Ferry Loading III', 1000, 134217728, 0000000000, 0000000000, '<p>Before bridges were common, ferries were used to transport cars across rivers. River ferries, unlike their larger cousins, run on a guide line and are powered by the river''s current. Cars drive onto the ferry from one end, the ferry crosses the river, and the cars exit from the other end of the ferry. <img align="right" src="http://plg1.cs.uwaterloo.ca/~acm00/050917/800px-Small_Mannum_Ferry.jpg" style="width: 214px; height: 142px;" alt="" /></p>\r\n<p>There is a ferry across the river that can take <em>n</em> cars across the river in <em>t</em> minutes and return in <em>t</em> minutes.   A car may arrive at either river bank to be transported by the ferry to the opposite bank.  The ferry travels continuously back and forth between the banks so long it is carrying a car or there is at  least one car waiting at either bank.  Whenever the ferry arrives at one of the banks, it unloads its cargo and loads up to <em>n</em> cars that are waiting to cross. If there are more than <em>n</em>, those that have been waiting the longest are loaded.  If there are no cars waiting on either bank, the ferry waits until one arrives, loads it (if it arrives on the same bank of the ferry), and crosses the river. At what time does each car reach the other side of the river?</p>\r\n<p>The first line of input contains <i>c</i>, the number of test cases. Each test case begins with <i>n, t, m</i>. <i>m</i> lines follow, each giving the arrival time for a car (in minutes since the beginning of the day), and the  bank at which the car arrives (&quot;left&quot; or &quot;right&quot;). For each test case, output one line per car, in the same order as the input, giving the time at which that car is unloaded at the opposite bank. Output an empty line between cases.</p>\r\n<p>You may assume that 0 &lt; n, t, m &le; 10000.  The arrival times for each test case are strictly increasing.  The ferry is initially on the left bank. Loading and unloading time may be considered to be 0.</p>', '', '<p>Please Input Input Here</p>', '<p>Please Input Output Here</p>', '2\r\n2 10 10\r\n0 left\r\n10 left\r\n20 left\r\n30 left\r\n40 left\r\n50 left\r\n60 left\r\n70 left\r\n80 left\r\n90 left\r\n2 10 3\r\n10 right\r\n25 left\r\n40 left\r\n', '10\r\n30\r\n30\r\n50\r\n50\r\n70\r\n70\r\n90\r\n90\r\n110\r\n\r\n30\r\n40\r\n60\r\n', '', 0, 0, '2010-08-18 23:20:10', '2010-08-18 23:20:10'),
(205, 1, 'Pick-up sticks', 1000, 134217728, 0000000000, 0000000000, '<p>Stan has <em>n</em> sticks of various length.  He throws them one at a time on the floor in a random way.  After finishing throwing, Stan tries to find the top sticks, that is these sticks such that there is no stick on top of them.  Stan has noticed that the last thrown stick is always on top but he wants to know all the sticks that are on top. Stan sticks are very, very thin such that their thickness can be neglected. <img align="right" src="http://plg1.cs.uwaterloo.ca/~acm00/050917/pickup.jpg" style="width: 127px; height: 210px;" alt="" /></p>\r\n<p>Input consists of a number of cases.  The data for each case start with <em>1 &le; n &le; 100000</em>, the number of sticks for this case.  The following <em>n</em> lines contain four numbers each, these numbers are the planar coordinates of the endpoints of one stick. The sticks are listed in the order in which Stan has thrown them.   You may assume that there are no more than 1000 top sticks.  The input is ended by the case with <em>n=0</em>. This case should not be processed.</p>\r\n<p>For each input case, print one line of output listing the top sticks in the format given in the sample.  The top sticks should be listed in order in which they were thrown.</p>\r\n<p>The picture to the right below illustrates the first case from input.</p>\r\n<p><img align="middle" src="http://plg1.cs.uwaterloo.ca/~acm00/050917/C.jpg" alt="" /></p>', '', '<p>Please Input Input Here</p>', '<p>Please Input Output Here</p>', '5\r\n1 1 4 2\r\n2 3 3 1\r\n1 -2.0 8 4\r\n1 4 8 2\r\n3 3 6 -2.0\r\n3\r\n0 0 1 1\r\n1 0 2 1\r\n2 0 3 1\r\n0\r\n\r\n', 'Top sticks: 2, 4, 5.\r\nTop sticks: 1, 2, 3.\r\n', '', 0, 0, '2010-08-18 23:20:10', '2010-08-18 23:20:10'),
(206, 1, 'Rock-Paper-Scissors Tournament', 1000, 134217728, 0000000000, 0000000000, '<p>Rock-Paper-Scissors is game for two players, A and B, who each choose, independently of the other, one of <i>rock, paper,</i> or <i>scissors</i>.  A player chosing <i>paper</i> wins over a player chosing <i>rock</i>; a player chosing <i>scissors</i> wins over a player chosing <i>paper</i>; a player chosing <i>rock</i> wins over a player chosing <i>scissors</i>.  A player chosing the same thing as the other player neither wins nor loses.</p>\r\n<p>A tournament has been organized in which each of <i>n</i> players plays <i>k</i> rock-scissors-paper games with each of the other players - <i>k*n*(n-1)/2</i> games in total. Your job is to compute the <i>win average</i> for each player, defined as <i>w / (w + l)</i> where <i>w</i> is the number of games won, and <i>l</i> is the number of games lost, by the player.</p>\r\n<p>Input consists of several test cases. The first line of input for each case contains <i>1 &le; n &le; 100</i> <i>1 &le; k &le; 100</i> as defined above.  For each game, a line follows containing p<sub>1</sub>, m<sub>1</sub>, p<sub>2</sub>, m<sub>2</sub>. 1 &le; p<sub>1</sub> &le; <i>n</i> and 1 &le; p<sub>2</sub> &le; <i>n</i> are distinct integers identifying two players; m<sub>1</sub> and m<sub>2</sub> are their respective moves (&quot;rock&quot;, &quot;scissors&quot;, or &quot;paper&quot;).  A line containing 0 follows the last test case.</p>\r\n<p>Output one line each for player 1, player 2, and so on, through player <i>n</i>, giving the player''s win average rounded to three decimal places.  If the win average is undefined, output &quot;-&quot;.  Output an empty line between cases. <img align="right" src="http://plg1.cs.uwaterloo.ca/~acm00/050917/ChampsBanner.jpg" style="width: 309px; height: 109px;" alt="" /></p>', '', '<p>Please Input Input Here</p>', '<p>Please Input Output Here</p>', '2 4\r\n1 rock 2 paper\r\n1 scissors 2 paper\r\n1 rock 2 rock\r\n2 rock 1 scissors\r\n2 1\r\n1 rock 2 paper\r\n0\r\n', '0.333\r\n0.667\r\n\r\n0.000\r\n1.000\r\n', '', 0, 0, '2010-08-18 23:20:10', '2010-08-18 23:20:10'),
(207, 1, 'Structural Equivalence', 5000, 134217728, 0000000000, 0000000000, '<p>\r\n	In programming language design circles, there has been much debate about the merits of &quot;structural equivalence&quot; vs. &quot;name equivalence&quot; for type matching. Pascal purports to have &quot;name equivalence&quot;, but it doesn&#39;t; C purports to have structural equivalence, but it doesn&#39;t. Algol 68, the <i>Latin</i> of programming languages, has pure structural equivalence. <img align="right" alt="" src="http://plg1.cs.uwaterloo.ca/~acm00/050917/dolls.jpg" style="width: 139px; height: 102px;" /></p>\r\n<p>\r\n	A simplified syntax for an Algol 68 type definition is as follows:</p>\r\n<pre>\r\n<i>type_def</i> -&gt; type <i>T</i> = <i>type_expr</i>\r\n   <i>type_expr</i> -&gt; <i>T</i> | int | real | char | struct ( <i>field_defs</i> )\r\n   <i>field_defs</i> -&gt; T | <i>field_defs</i> T\r\n</pre>\r\n<p>\r\n	In this syntax, <i>T</i> is a programmer-defined type name (in this problem, for simplicity, a single upper case letter). Plain text symbols appear literally in the input, and zero or more spaces may appear where there are spaces in the syntax.</p>\r\n<p>\r\n	Algol 68 type equivalence say that two types are equivalent if they are the same primitive type or they are both structures containing equivalent types in the same order.</p>\r\n<p>\r\n	Input consists of several test cases. Each test case is a sequence of Algol 68 definitions, as described above, one per line. A line containing &quot;-&quot; separates test cases. A line containing &quot;--&quot; follows the last test case. The output for each case will consist of several lines; each line should contain a list of type names, all of which represent equivalent types. Each type name should appear on exactly one line of output, and the number of output lines should be minimized. The names in each list should be in alphabetical order; the lines of output should also be in alphabetical order. Output an empty line between test cases.</p>\r\n', '', '<p>\r\n	Please Input Input Here</p>\r\n', '<p>\r\n	Please Input Output Here</p>\r\n', 'type A = int\r\ntype B = A\r\ntype C = int\r\ntype X = struct(A B)\r\ntype Y = struct(B A)\r\ntype Z = struct(A Z)\r\ntype S = struct(A S)\r\ntype W = struct(B R)\r\ntype R = struct(C W)\r\n--\r\n', 'A B C\r\nR S W Z\r\nX Y\r\n', '<br />\r\n', 0, 0, '2010-08-18 23:20:11', '2010-08-20 08:17:49'),
(208, 1, 'Brownie Points I', 1000, 134217728, 0000000000, 0000000000, '<img align="right" vspace="20" hspace="20" src="http://plg1.cs.uwaterloo.ca/%7Eacm00/050611/A.jpg" alt="" />\r\n<p>Stan and Ollie play the game of Odd Brownie Points.  Some brownie points are located in the plane, at integer coordinates. Stan plays first and places a vertical line in the plane.  The line must go through a brownie point and may cross many (with the same x-coordinate).  Then Ollie places a horizontal line that must cross a brownie point already crossed by the vertical line.</p>\r\n<p>Those lines divide the plane into four quadrants. The quadrant containing points with arbitrarily large positive coordinates is the top-right quadrant.</p>\r\n<p>The players score according to the number of brownie points in the quadrants. If a brownie point is crossed by a line, it doesn''t count. Stan gets a point for each (uncrossed) brownie point in the top-right and bottom-left quadrants. Ollie gets a point for each (uncrossed) brownie point in the top-left and bottom-right quadrants.</p>\r\n<p>Your task is to compute the scores of Stan and Ollie given the point through which they draw their lines.</p>\r\n<p>Input contains a number of test cases.  The data of each test case appear on a sequence of input lines.  The first line of each test case contains a positive odd integer 1&nbsp;&lt;&nbsp;<em>n</em>&nbsp;&lt;&nbsp;200000 which is the number of brownie points.  Each of the following <em>n</em> lines contains two integers, the horizontal (<em>x</em>) and vertical (<em>y</em>) coordinates of a brownie point.  No two brownie points occupy the same place.  The input ends with a line containing 0 (instead of the <em>n</em> of a test).</p>\r\n<p>For each test case of input, print a line with two numbers separated by a single space.  The first number is Stan''s score, the second is  the score of Ollie when their lines cross the point whose coordinates are given at the center of the input sequence of points for this case.</p>\r\n<h3>&nbsp;</h3>', '', '', '', '11\r\n3 2\r\n3 3\r\n3 4\r\n3 6\r\n2 -2\r\n1 -3\r\n0 0\r\n-3 -3\r\n-3 -2\r\n-3 -4\r\n3 -7\r\n0\r\n', '6 3\r\n', '', 0, 0, '2010-08-18 23:20:48', '2010-08-18 23:20:48'),
(209, 1, 'Magic Bitstrings ', 1000, 134217728, 0000000000, 0000000000, '<p>A bitstring, whose length is one less than a prime, might be <b>magic</b>.  <tt>1001</tt> is one such string.  In order to see the <b>magic</b> in the string let us append a non-bit <tt>x</tt> to it, regard the new <em>thingy</em> as a cyclic string, and make this square matrix of bits</p>\r\n<p>&nbsp;</p>\r\n<center>\r\n<table border="1" cellspacing="0" cellpadding="3">\r\n    <tbody>\r\n        <tr height="30">\r\n            <td align="center" width="100">each bit</td>\r\n            <td>&nbsp;&nbsp;<tt>1001</tt>&nbsp;&nbsp;</td>\r\n        </tr>\r\n        <tr height="30">\r\n            <td align="center" width="100">every 2<sup>nd</sup> bit</td>\r\n            <td>&nbsp;&nbsp;<tt>0110</tt>&nbsp;&nbsp;</td>\r\n        </tr>\r\n        <tr height="30">\r\n            <td align="center" width="100">every 3<sup>rd</sup> bit</td>\r\n            <td>&nbsp;&nbsp;<tt>0110</tt>&nbsp;&nbsp;</td>\r\n        </tr>\r\n        <tr height="30">\r\n            <td align="center" width="100">every 4<sup>th</sup> bit</td>\r\n            <td>&nbsp;&nbsp;<tt>1001</tt>&nbsp;&nbsp;</td>\r\n        </tr>\r\n    </tbody>\r\n</table>\r\n</center>\r\n<p>This matrix has the same number of rows as the length of the original bitstring.  The <em>m</em>-th row of the matrix has every <em>m</em>-th bit of the original string starting with the <em>m</em>-th bit.  Because the enlarged <em>thingy</em> has prime length, the appended <tt>x</tt> never gets used.</p>\r\n<p>If each row of the matrix is either the original bitstring or its complement, the original bitstring is <b>magic</b>.</p>\r\n<p>Each line of input (except last) contains a prime number <em>p</em>&nbsp;&le;&nbsp;100000.  The last line contains 0 and this line should not be processed.  For each prime number from the input produce one line of output containing the lexicographically smallest, non-constant <b>magic</b> bitstring of length <em>p-1</em>, if such a string exists, otherwise output <tt>Impossible</tt>.</p>', '', '', '', '5\r\n3\r\n17\r\n47\r\n2\r\n79\r\n0\r\n', '0110\r\n01\r\n0010111001110100\r\n0000100001101010001101100100111010100111101111\r\nImpossible\r\n001001100001011010000001001111001110101010100011000011011111101001011110011011\r\n', '', 0, 0, '2010-08-18 23:20:48', '2010-08-18 23:20:48'),
(210, 1, 'Cutting a polygon', 1000, 134217728, 0000000000, 0000000000, '<p>\r\n	Given is a simple but not necessarily convex polygon. Given is also a line in the plane. If the polygon is cut along the line then we may get several smaller polygons. Your task is to find the length of the cut, that is the total length of the segments in the intersection of the line and the polygon.</p>\r\n<p>\r\n	<img align="center" alt="" hspace="100" src="http://plg1.cs.uwaterloo.ca/%7Eacm00/050611/C.jpg" vspace="20" /></p>\r\n<p>\r\n	The picture above illustrates the first cutting line for the polygon from the sample.</p>\r\n', '', '<p>\r\n	Input consists of a number of cases. The data of each case appears on a number of input lines, the first of which contains two non negative integers&nbsp;<em>n</em>&nbsp;and&nbsp;<em>m&nbsp;</em>giving the number of the vertices of the polygon and the number of cutting lines to consider, 3&nbsp;&le;&nbsp;<em>n</em>&nbsp;&le;&nbsp;1000. The following&nbsp;<em>n</em>&nbsp;lines contain coordinates of the vertices of the polygon; each line contains the&nbsp;<em>x</em>&nbsp;and&nbsp;<em>y</em>&nbsp;coordinates of a vertex. The vertices are given either in clockwise or counterclockwise order.</p>\r\n<p>\r\n	Each of the following&nbsp;<em>m</em>&nbsp;lines of input contains four numbers; these are&nbsp;<em>x</em>&nbsp;and&nbsp;<em>y</em>&nbsp;coordinates of the two points defining the cutting line. If a vertex of the polygon is closer than 10e<sup>-8</sup>&nbsp;to the cutting line then we consider that the vertex lies on the cutting line.Input is terminated by a line with&nbsp;<em>n</em>&nbsp;and&nbsp;<em>m</em>&nbsp;equal to 0.</p>\r\n', '<p>\r\n	For each cutting line, print the total length of the segments in the intersection of the line and the polygon defined for this test case, with 3 digits after the decimal point. Note: the perimiter of a polygon belongs the polygon.</p>\r\n', '9 5\r\n0 0\r\n0 2\r\n1 1\r\n2 2\r\n3 1\r\n4 2\r\n5 1\r\n6 2\r\n6 0\r\n-1 2 7.5 1\r\n0 1 6 1\r\n0 1.5 6 1.5\r\n0 2 6 1\r\n0 0 0 2\r\n0 0\r\n', '2.798\r\n6.000\r\n3.000\r\n2.954\r\n2.000\r\n', '', 0, 0, '2010-08-18 23:20:48', '2010-11-22 21:26:41'),
(211, 1, 'Bungee Jumping', 1000, 134217728, 0000000000, 0000000000, '<p><img align="right" vspace="20" hspace="20" alt="" src="http://plg1.cs.uwaterloo.ca/%7Eacm00/050611/D.jpg" /></p>\r\n<p>Once again, James Bond is fleeing from some evil people who want to see 		him dead. Fortunately, he has left a 		bungee rope on a nearby highway bridge which he can use to escape from his 		enemies. His plan is to attach one end of the rope to the bridge, the other end of  		the rope to his body and jump off the 		bridge. At the moment he reaches the ground, he will cut the rope, jump 		into his car and be gone.</p>\r\n<p>&nbsp;</p>\r\n<p>Unfortunately, he had not had enough time to calculate whether the bungee 		rope has the right length, so it is not clear at all what is going to 		happen when he jumps off the bridge. There are three possible scenarios:</p>\r\n<ul>\r\n    <li style="margin: 5px;">The rope is too short 				(or too strong), and James Bond will 				never reach the ground.</li>\r\n    <li style="margin: 5px;">The rope is too long 				(or too weak), and James Bond will be 				going too fast when he touches the 				ground. Even for a special agent, this 				can be very dangerous.  You may assume 				that if he collides at a speed of more 				than 10 m/s, he will not survive the 				impact.</li>\r\n    <li style="margin: 5px;">The rope''s length and 				strength are good. James Bond touches 				the ground at a comfortable speed and 				can escape.</li>\r\n</ul>\r\n<p>As his employer, you would like to know whether James Bond survives 		or whether you should place a job ad for the soon-to-be vacant position 		in the local newspaper. Your physicists claim that:</p>\r\n<ul>\r\n    <li style="margin: 5px;">The force with which 				James is pulled towards the earth is 				<blockquote> 					<i>9.81 * w,</i> 				</blockquote>  				where <i>w</i> is his weight in 				kilograms and 9.81 is the Earth 				acceleration in meters over squared 				seconds.</li>\r\n    <li style="margin: 5px;">Mr. Bond falls freely 				until the rope tautens.  Then the 				force with which the bungee rope pulls 				him back into the sky depends on the 				current length of the rope and is 				<blockquote> 					<i>k * &Delta;l</i>, 				</blockquote>  				where <i>&Delta;l</i> is the 				difference between the rope''s current 				length and its nominal, unexpanded 				length, and <i>k</i> is a 				rope-specific constant.</li>\r\n</ul>\r\n<p>Given the rope''s strength</p>\r\n<p><i>k</i></p>\r\n<p>, the nominal length 		of the rope</p>\r\n<p><i>l</i></p>\r\n<p>in meters, the height of the 		bridge</p>\r\n<p><i>s</i></p>\r\n<p>in meters, and James Bond''s body 		weight</p>\r\n<p><i>w</i></p>\r\n<p>, you have to determine what is going 		to happen to our hero. For all your calculations, you 		may assume that James Bond is a point at the end of 		the rope and the rope has no mass. You may further 		assume that</p>\r\n<p><i>k</i></p>\r\n<p>,</p>\r\n<p><i>l</i></p>\r\n<p>,</p>\r\n<p><i>s</i></p>\r\n<p>, and</p>\r\n<p><i>w</i></p>\r\n<p>are non-negative and that</p>\r\n<p><i>s &lt; 200</i></p>\r\n<p>.</p>\r\n<p>The input contains several test cases, one test case per line. Each test 		case consists of four floating-point numbers (<i>k</i>, <i>l</i>, <i>s</i>, 		and <i>w</i>) that describe the situation. Depending on what is going to 		happen, your program must print &quot;<tt>Stuck in the air.</tt>&quot;, 		&quot;<tt>Killed by the impact.</tt>&quot;, or 		&quot;<tt>James Bond survives.</tt>&quot;. 		Input is terminated by a line containing four 0s, this line 		should not be processed.</p>', '', '', '', '350 20 30 75\r\n375 20 30 75\r\n400 20 30 75\r\n425 20 30 75\r\n450 20 30 75\r\n400 20 30 50\r\n400 20 30 80\r\n400 20 30 85\r\n0 0 0 0\r\n', 'Killed by the impact.\r\nJames Bond survives.\r\nJames Bond survives.\r\nJames Bond survives.\r\nStuck in the air.\r\nStuck in the air.\r\nJames Bond survives.\r\nKilled by the impact.\r\n', '', 0, 0, '2010-08-18 23:20:48', '2010-08-18 23:20:48'),
(212, 1, 'Brownie Points II', 10000, 134217728, 0000000000, 0000000000, '<p><img align="right" vspace="20" hspace="20" alt="" src="http://plg1.cs.uwaterloo.ca/%7Eacm00/050611/E.jpg" /></p>\r\n<p>Stan and Ollie play the game of Odd Brownie Points.  Some brownie points are located in the plane, at integer coordinates. Stan plays first and places a vertical line in the plane.  The line must go through a brownie point and may cross many (with the same x-coordinate).  Then Ollie places a horizontal line that must cross a brownie point already crossed by the vertical line.</p>\r\n<p>Those lines divide the plane into four quadrants. The quadrant containing points with arbitrarily large positive coordinates is the top-right quadrant.</p>\r\n<p>The players score according to the number of brownie points in the quadrants. If a brownie point is crossed by a line, it doesn''t count. Stan gets a point for each (uncrossed) brownie point in the top-right and bottom-left quadrants. Ollie gets a point for each (uncrossed) brownie point in the top-left and bottom-right quadrants.</p>\r\n<p>Stan and Ollie each try to maximize his own score. When Stan plays, he considers the responses, and chooses a line which maximizes his smallest-possible score.</p>\r\n<p>Input contains a number of test cases.  The data of each test case appear on a sequence of input lines.  The first line of each test case contains a positive odd integer 1&nbsp;&lt;&nbsp;<em>n</em>&nbsp;&lt;&nbsp;200000 which is the number of brownie points.  Each of the following <em>n</em> lines contains two integers, the horizontal (<em>x</em>) and vertical (<em>y</em>) coordinates of a brownie point.  No two brownie points occupy the same place.  The input ends with a line containing 0 (instead of the <em>n</em> of a test).</p>\r\n<p>For each input test, print a line of output in the format shown below. The first number is the largest score which Stan can assure for himself.  The remaining numbers are the possible (high) scores of Ollie, in increasing order.</p>', '', '', '', '11\r\n3 2\r\n3 3\r\n3 4\r\n3 6\r\n2 -2\r\n1 -3\r\n0 0\r\n-3 -3\r\n-3 -2\r\n-3 -4\r\n3 -7\r\n0\r\n', 'Stan: 7; Ollie: 2 3;\r\n', '', 0, 0, '2010-08-18 23:20:48', '2010-08-18 23:20:48'),
(213, 1, 'Great Circle', 1000, 134217728, 0000000000, 0000000000, '<img src=http://plg1.cs.uwaterloo.ca/~acm00/050205/circle.gif align=right>\r\n<p>Airplanes fly close to the Great Circle Route between two cities. The Great Circle Route is the shortest arc concentric with the earth that joins the two cities; that is, the shortest distance between the two cities following the surface of the earth.</p>\r\n<p>Given the latitude and longitude of two cities, find the most northerly latitude reached on the Great Circle Route between the cities.  Print &quot;undefined&quot; if there is no unique answer.</p>\r\n<p>The first line of input contains N, the number of test cases.  N lines follow, one for each case, containing the latitude and longitude of the two cities, in degrees, minutes, and direction.  [A minute is 1/60 degree; Points on the equator have latitude denoted 0,0N (not 0,0S); points on the poles have longitude denoted 0,0W; points with 180 degrees longitude are denoted 180,0W  (not 180,0E).]</p>\r\n<p>For each case your program should produce one line of output giving the most northerly latitude reached, in the given format. Round your answer to the nearest minute.</p>', '', '', '', '3\r\n50,13N 45,10W 75,0N 44,50E\r\n50,13N 90,10W 75,0N 89,50E\r\n10,0N 129,30E 10,0S 50,30W\r\n', '75,41N\r\n90,0N\r\nundefined\r\n', '', 0, 0, '2010-08-18 23:27:09', '2010-08-18 23:27:09'),
(214, 1, 'Ultra-QuickSort', 1000, 134217728, 0000000000, 0000000000, '<img align=right src=http://plg1.cs.uwaterloo.ca/~acm00/050205/bubble.jpg>\r\n<p>In this problem, you have to analyze a particular sorting algorithm. 		The algorithm processes a sequence of <i>n</i> distinct integers by swapping 		two adjacent sequence elements until the sequence is sorted in ascending order. 		For the input sequence</p>\r\n<blockquote> 			<tt>9 1 0 5 4</tt>&nbsp;, 		</blockquote>\r\n<p>Ultra-QuickSort produces the output</p>\r\n<blockquote> 			<tt>0 1 4 5 9</tt>&nbsp;. 		</blockquote>\r\n<p>Your task is to determine how many swap operations Ultra-QuickSort needs to 		perform in order to sort a given input sequence.</p>\r\n<p>The input contains several test cases. Every test case begins with a line 		that contains a single integer <i>n &lt; 500,000</i> -- the length of the input sequence. 		Each of the the following <i>n</i> lines contains a single integer 		<i>0 &le; a[i] &le; 999,999,999</i>, the <i>i</i>-th input sequence element. Input is terminated 		by a sequence of length <i>n = 0</i>. This sequence must not be processed.</p>\r\n<p>For every input sequence, your program prints a single line containing an 		integer number <i>op</i>, the minimum number of swap operations necessary 		to sort the given input sequence.</p>', '', '', '', '5\r\n9\r\n1\r\n0\r\n5\r\n4\r\n3\r\n1\r\n2\r\n3\r\n0', '6\r\n0', '', 0, 0, '2010-08-18 23:27:09', '2010-08-18 23:27:09'),
(215, 1, 'Up the Ante', 1000, 134217728, 0000000000, 0000000000, '<img src=http://plg1.cs.uwaterloo.ca/~acm00/050205/crown.jpg align=right>\r\n<p>Every summer, Stan and Ollie attend the Ex together.  Stan likes to play <i>Crown &amp; Anchor</i>, a gambling game in which one bets on one of:  <i>Crown, Anchor, Club, Diamond, Heart, Spade.</i> A wheel is spun and stops in a position marked by three of the above symbols (not necessarily distinct).  If Stan has bet on one of the three symbols indicated, he receives his bet back plus <i>n</i> times his bet, where <i>n</i> is the number of times that his symbol appears.</p>\r\n<p>Every year, Stan loses money and Ollie ridicules him for it.  This year, Stan has made a side bet with Ollie:  that he can make money playing Crown &amp; Anchor.  Ollie is not stupid and realizes that Stan might be lucky and win the first few rounds,  so he insists that, to win the bet, Stan must be ahead after at  least <i>k</i> rounds.  Also, so that the issue may be resolved  before the Ex closes, to win Stan must show a profit within at most  <i>m</i> rounds.</p>\r\n<p>Stan has a trick up his sleeve.  He has recently learned of the <i>Monte Carlo</i> strategy for betting.  The idea is that he first places the minimum bet.  If he wins, he collects his winnings and once again places the minimum bet.  If he loses, he doubles his bet so that if he wins the next round, he will win enough to recoup his previous losses and make a profit.  This doubling continues until he wins.  Whenever he wins, he pockets the profit and  starts over with the minimum bet.</p>\r\n<p>Stan thinks this is a great strategy but the establishment thought of it first and implemented a <i>house limit</i> - the maximum bet that Stan can place in any given round.  (Even without a house limit there''s a de facto <i>Stan limit</i> - the amount of money he has with him.  But we''ll assume he has enough money that this limit  isn''t an issue.)  Stan modifies his strategy so that if doubling his bet would exceed the house limit, he starts over at the minimum bet, hoping to recover his loss.</p>\r\n<p>Stan wins the bet if, following this strategy, his net winnings are positive at any time after playing <i>k</i> and before playing the  <i>m+1st</i> round.  What''s the probability that Stan will win the bet?</p>\r\n<p>The first line of input contains <i>n</i>, the number of test cases. Each test case is represented by a line containing integers  <i>k</i>, <i>m</i>, and <i>l</i>, the minimum number of rounds, the maximum number of rounds, and the house limit.  <i>0 &lt; k &lt; m &le; 30</i>; <i>2 &le; l &le; 1000</i>. The minimum bet is 1.</p>\r\n<p>For each test case, print the probability that Stan will win the bet, rounded to 4 decimal places.</p>\r\n<p>The design of the wheel can be seen in the illustration.  It has 28 possible stopping positions, only 14 different combinations of symbols, each of which appears twice.  The 14 combinations include: 6 that contain three identical symbols; 6 that contain two identical symbols, and 2 that contain three distinct symbols.  The patterns are designed so that each symbol appears once, twice, and three times in an equal number of wheel positions.</p>', '', '', '', '1\r\n3 4 10\r\n', '0.5835\r\n', '', 0, 0, '2010-08-18 23:27:10', '2010-08-18 23:27:10'),
(216, 1, 'Beat the Spread!', 1000, 134217728, 0000000000, 0000000000, '<p>Superbowl Sunday is nearly here.  In order to pass the time waiting for the half-time commercials and wardrobe malfunctions, the local hackers have organized a betting pool on the game.  Members place their bets on the sum of the two final scores, or on the absolute difference between the  two scores.</p>\r\n<p>Given the winning numbers for each type of bet, can you deduce the final scores?</p>\r\n<p>The first line of input contains <i>n</i>, the number of test cases. <i>n</i> lines follow, each representing a test case.  Each test case gives <i>s</i> and <i>d</i>, non-negative integers representing the sum and (absolute) difference between the two final scores.  For each test case, output a line giving  the two final scores, largest first.  If there are no such scores, output a line containing &quot;impossible&quot;.  Recall that football scores are always non-negative integers.</p>\r\n<img src=http://plg1.cs.uwaterloo.ca/~acm00/050205/football.jpg align=right>', '', '', '', '2\r\n40 20\r\n20 40\r\n', '30 10\r\nimpossible\r\n', '', 0, 0, '2010-08-18 23:27:10', '2010-08-18 23:27:10'),
(217, 1, 'Traditional BINGO', 1000, 134217728, 0000000000, 0000000000, '<p>Traditional BINGO is played in person in a large hall. Players meet at the hall, pay a fee to get in, then the games begin. A night of BINGO consists of many BINGO games played continuously, one after another.</p>\r\n<p>A single BINGO game proceeds like this: Each player has a number of BINGO cards (players can usually play any number of cards). Each BINGO card has 5 rows and 5 columns thus providing 25 spaces.</p>\r\n<p>The columns are labeled from left to right with the letters: ''B'', ''I'', ''N'', ''G'', ''O''. With one exception (the center space is &quot;free&quot;) the spaces in the card are assigned values as follows:</p>\r\n<ul>\r\n    <li>Each space in the ''B'' column contains a number from 1 - 15.</li>\r\n    <li>Each space in the ''I'' column contains a number from 16 - 30.</li>\r\n    <li>Each space in the ''N'' column contains a number from 31 - 45.</li>\r\n    <li>Each space in the ''G'' column contains a number from 46 - 60.</li>\r\n    <li>Each space in the ''O'' column contains a number from 61 - 75.</li>\r\n</ul>\r\n<p>Furthermore, a number can appear only once on a single card.</p>\r\n<p>Here''s a sample BINGO card:</p>\r\n<p>\r\n<table border="1" cellpadding="5">\r\n    <tbody>\r\n        <tr align="center">\r\n            <td><font size="5">B</font></td>\r\n            <td><font size="5">I</font></td>\r\n            <td><font size="5">N</font></td>\r\n            <td><font size="5">G</font></td>\r\n            <td><font size="5">O</font></td>\r\n        </tr>\r\n        <tr align="center">\r\n            <td>10</td>\r\n            <td>17</td>\r\n            <td>39</td>\r\n            <td>49</td>\r\n            <td>64</td>\r\n        </tr>\r\n        <tr align="center">\r\n            <td>12</td>\r\n            <td>21</td>\r\n            <td>36</td>\r\n            <td>55</td>\r\n            <td>62</td>\r\n        </tr>\r\n        <tr align="center">\r\n            <td>14</td>\r\n            <td>25</td>\r\n            <td><font size="1">FREE<br />\r\n            SPACE</font></td>\r\n            <td>52</td>\r\n            <td>70</td>\r\n        </tr>\r\n        <tr align="center">\r\n            <td>7</td>\r\n            <td>19</td>\r\n            <td>32</td>\r\n            <td>56</td>\r\n            <td>68</td>\r\n        </tr>\r\n        <tr align="center">\r\n            <td>5</td>\r\n            <td>24</td>\r\n            <td>34</td>\r\n            <td>54</td>\r\n            <td>71</td>\r\n        </tr>\r\n    </tbody>\r\n</table>\r\n</p>\r\n<p>The number of unique BINGO cards is very large and can be calculated with this equation:</p>\r\n<pre>\r\n// the B, I, G, and O columns * the N column\r\n(15 * 14 * 13 * 12 * 11) ^ 4 * (15 * 14 * 13 * 12)\r\n</pre>\r\n<p>While perhaps interesting to a statistician, the number of possible BINGO cards has nothing to do with player''s</p>\r\n<a href="http://plg1.cs.uwaterloo.ca/%7Eacm00/050205/E.html#CHANCES">chances of winning</a>\r\n<p>.</p>\r\n<p>You will note that there are 75 possible BINGO numbers:</p>\r\n<blockquote>\r\n<pre>\r\nB1, B2, B3, ... B15, I16, I17, I18, ... I30, N31, N32, ... O74, O75.\r\n</pre>\r\n</blockquote>\r\n<p>Each of these numbers is represented by a ball in a large rotating bin. Each ball is painted with its unique BINGO number. An announcer spins the bin, reaches in a selects a ball, and a announces it to the room. The players check all of their cards to see if that number appears on their card. If it is, they mark it.  A player may mark the centre FREE SPACE at any time.</p>\r\n<p>When a player has a BINGO (5 marks in a row, column, or diagonal), he or she calls out BINGO. The game pauses while the card is verified. If indeed a winner, the game stops and a new game begins. If the card wasn''t a winner, the game proceeds where it left off. Each BINGO game proceeds until someone wins (there''s always a winner).</p>\r\n<p>The first line of input contains <i>n</i>, the number of BINGO games that you will analyze.  <i>n</i> game descriptions follow.  Each game description specifies a card to be played followed by a sequence of BINGO numbers.  You are to determine, when the holder of the card will win the game, assuming the player has just this one card and there are no other players.</p>\r\n<p>Each card description consists of five lines, giving the numbers on the card row by row.  All but the 3rd row contain 5 numbers; the 3rd contains 4 because of the free space.  One or more lines follow that represent some ordering of all 75 bingo numbers.  All bingo numbers are simply integers between 1 and 75 - the one-letter prefix is redundant.  For each game, ouput the line &quot;BINGO after <i>n</i> numbers announced&quot; as appropriate. <a name="CHANCES">\r\n<h4>Chances of Winning</h4>\r\n</a></p>\r\n<p>Every BINGO game has a winning card, so a player''s chances of winning depend on the number of cards in the game and how many cards s/he is playing. For example, if a player has 12 cards in a game with 1200 cards,  the chances of winning for that player is 1 in 100.</p>', '', '', '', '1\r\n10 17 39 49 64\r\n12 21 36 55 62\r\n14 25 52 70\r\n7 19 32 56 68\r\n5 24 34 54 71\r\n1 2 3 4 5 6 7 8 9 10\r\n11 12 13 14 15 16 17 18 19 20\r\n21 22 23 24 25 26 27 28 29 30\r\n31 32 33 34 35 36 37 38 39 40\r\n41 42 43 44 45 46 47 48 49 50\r\n51 52 53 54 55 56 57 58 59 60\r\n61 62 63 64 65 66 67 68 69 70\r\n71 72 73 74 75\r\n', 'BINGO after 14 numbers announced\r\n', '', 0, 0, '2010-08-18 23:27:10', '2010-08-18 23:27:10'),
(218, 1, 'Practice', 1000, 134217728, 0000000000, 0000000000, '<p>How much does winning ACM depend on practice?</p>\n<p>We assume that <i>p</i>, the probability that a given team will win a given contest, is related  to <i>n</i>, the number of practice problems solved by the team prior to the contest.  This relationship is  modelled by the <i>logistic</i> formula</p>\n<pre>\n   <i>log</i>(p/(1-p)) = <i>a</i> + <i>b</i> n ,\n</pre>\n<p>for some</p>\n<i>a</i>\n<p>and</p>\n<i>b</i>\n<p>.  Your job is to find</p>\n<i>a</i>\n<p>and</p>\n<i>b</i>\n<p>such that the formula most accurately reflects a set of observed results.</p>\n<p>Each observation consists of <i>n</i>  and <i>w</i>.  <i>n</i> is the number of practice problems solved by some team prior to a contest, and <i>w</i> is 1 if the team wins the contest, 0 if it does not.</p>\n<p>Given <i>a</i>, <i>b</i>, and <i>n</i> the formula above may be used to compute <i>p</i>, the  estimated probability that <i>w</i> = 1. The <i>likelihood</i> of a particular observation is <i>p</i> if <i>w</i> = 1 and <i>1-p</i> if <i>w</i> = 0; The likelihood of a set of observations is the product of the likelihoods of the individual observations.</p>\n<p>You are to compute the <i>maximum likelihood estimate</i> for  <i>a</i> and <i>b</i>.  That is, the values of <i>a</i> and <i>b</i> for which the likelihood of a given set of observations is maximized.</p>\n<p>The input contains several test cases followed by a line contatining 0. Each test case begins with 1 &lt; <i>k</i> &le; 100, the number  of observations that follow.  Each observation consists of integers 0 &le; <i>n</i> &le; 100 and 0 &le; w &le; 1. The input will contain at least two distinct values of <i>n</i> and of <i>w</i>. For each test case, output a single line containing <i>a</i> and <i>b</i>, rounded to four digits to the right of the decimal.</p>', '', '', '', '20\n0 0\n0 0\n0 0\n0 0\n1 0\n1 0\n1 0\n1 1\n2 0\n2 0\n2 1\n2 1\n3 0\n3 1\n3 1\n3 1\n4 1\n4 1\n4 1\n4 1\n0\n', '-3.1748 1.5874\n', '', 0, 0, '2010-08-18 23:28:26', '2010-08-18 23:28:26'),
(219, 1, 'Treequivalence', 1000, 134217728, 0000000000, 0000000000, '<h2>Treequivalence</h2>\n<p>The following grammar describes a textual notation for a tree  with (not necessarily unique) vertex labels:</p>\n<pre>\n   <i>tree</i> ::= <i>label</i>\n   <i>tree</i> ::= <i>label</i> ( <i>subtrees</i> )\n   <i>subtrees</i> ::= <i>tree</i>\n   <i>subtrees</i> ::= <i>subtrees</i> , <i>tree</i>\n   <i>label</i> ::= A | B | C | ... | Z\n</pre>\n<p>That is, the representation of a tree consists of a label  (which is an uppercase letter) or a label followed by a bracketed ordered list of trees separated by commas.</p>\n<p>In order to draw such a tree on paper, we must write each label on the page, such that the labels for the subtrees of a vertex are positioned counter-clockwise about the  vertex.  The labels must be positioned such that  non-intersecting line segments connect each vertex to each of its subtrees.  That is to say, we draw the normal planar representation of the tree, preserving the order of subtrees.  Beyond these constraints, the position, shape, and size of the representation is arbitrary.</p>\n<p>For example, a possible graphical representation for A(B(C,D),E) is  <img align="center" src="http://plg1.cs.uwaterloo.ca/%7Eacm00/040925/tree.gif" alt="" /> .</p>\n<p>Given the textual representation for two trees, you are to determine whether or not they are equivalent.  That is, do they share a common paper representation?</p>\n<p>The first line of input contains <i>t</i>, the number of test cases.  Each test case consists of two lines, each specifying a tree in the notation described above.  Each line will contain at most 200 characters, and no white space. For each test case, output a line containing &quot;same&quot; or &quot;different&quot; as appropriate.</p>', '', '<p>Please Input Input Here</p>', '<p>Please Input Output Here</p>', '2\nA(B(C,D),E)\nE(A,B(C,D))\nA(B(C,D),E)\nE(A(B(C,D)))\n', 'different\nsame\n', '', 0, 0, '2010-08-18 23:28:26', '2010-08-18 23:28:26'),
(220, 1, 'Antiarithmetic?', 1000, 134217728, 0000000000, 0000000000, '<p>A permutation of <em>n</em> is a bijective function of the initial <em>n</em> natural numbers: 0, 1, ... <em>n</em>-1.  A permutation <em>p</em> is called antiarithmetic if there is no subsequence of it forming an arithmetic progression of length bigger than 2, i.e. there are no three indices 0&nbsp;&le;&nbsp;<em>i</em>&nbsp;&lt;&nbsp;<em>j</em>&nbsp;&lt;&nbsp;<em>k</em>&nbsp;&lt;&nbsp;<em>n</em> such that (<em>p<sub>i</sub></em>&nbsp;,&nbsp;<em>p<sub>j</sub></em>&nbsp;,&nbsp;<em>p<sub>k</sub></em>) forms an arithmetic progression.</p>\n<p>&nbsp;</p>\n<p>For example, the sequence (2, 0, 1, 4, 3) is an antiarithmetic permutation of 5.  The sequence (0, 5, 4, 3, 1, 2) is not an antiarithmetic permutation as its first, fifth and sixth term (0, 1, 2) form an arithmetic progression; and so do its second, forth and fifth term (5, 3, 1).</p>\n<p>Your task is to check whether a given permutation of <em>n</em> is antiarithmetic.</p>\n<p>There are several test cases, followed by a line containing 0. Each test case is a line of the input file containing a natural number 3&nbsp;&le;&nbsp;<em>n</em>&nbsp;&le;&nbsp;10000 followed by a colon and then followed by <em>n</em> distinct numbers separated by whitespace. All <em>n</em> numbers are natural numbers smaller than <em>n</em>.</p>\n<p>For each test case output one line with <tt>yes</tt> or <tt>no</tt> stating whether the permutation is antiarithmetic or not.</p>', '', '<p>Please Input Input Here</p>', '<p>Please Input Output Here</p>', '3: 0 2 1 \n5: 2 0 1 3 4\n6: 2 4 3 5 0 1\n0\n', 'yes\nno\nyes\n', '', 0, 0, '2010-08-18 23:28:27', '2010-08-18 23:28:27'),
(221, 1, 'Test', 1000, 134217728, 0000000000, 0000000000, '<p>A vocational preference test, unlike an aptitude test, seeks to identify careers that the candidate might find satisfying. Based on the answers to a slew of seemingly inane multiple-choice questions like the one below, the test determines  which occupations suit the candidate''s personality.</p><img align=right src=http://plg1.cs.uwaterloo.ca/~acm00/040925/rfive1.gif >\n<pre>\n   Which would you rather spend an afternoon doing?\n\n   (a) feeding chickens\n   (b) driving a race car\n   (c) watching The Simpsons on TV\n   (d) suntanning\n   (e) building a dog house\n</pre>\n<p>Each question asks the candidate to express a preference from among  five activities, selected from a common larger set.  That is, activities like</p>\n<i>feeding chickens</i>\n<p>or</p>\n<i>suntanning</i>\n<p>are likely to appear in several different questions.</p>\n<p>If a candidate answers A in a question containing A, B, C, D, E as alternatives, this choice indicates a preference for A over each of B, C, D, E.  Also, if one answer indicates a preference for X over Y and one or more other answers indicate a preference for Y over Z, the combined set of answers indicates a preference for X over Z.</p>\n<p>The candidate may provide contradictory answers; that is, the answers may indicate a preference for X over Y and also for Y over X.  These contradictions indicate inconsistency, a personalitiy attribute that may suggest a career in politics or used auto sales.</p>\n<p>Given a set of answers to a vocational preference test, you are to partition the activities into the minimal number of sets such that, for each pair within a given set, the answers indicate a contradictory preference.</p>\n<p>The input contains several test cases followed by a line containing 0.  Each case begins with <i>n</i>, the number of questions in the test.  <i>n</i> lines follow, each containing the names of five distinct activities, followed by the candidate''s answer - one of the five alternatives.  Each activity is named by a single upper case letter.</p>\n<p>For each test case, output the sets, one per line.  Output the elements of each set in alphabetical order, and output the sets in alphabetical order by their least element.  The sets should together contain exactly the set of activities that appear in the input.  Leave an empty line between test cases.</p>', '', '<p>Please Input Input Here</p>', '<p>Please Input Output Here</p>', '4\nA B C D E C\nF C H I J J\nK B H I F I\nK C E B J K\n0\n', 'A\nB\nC\nD\nE\nF\nH\nI J K\n', '', 0, 0, '2010-08-18 23:28:27', '2010-08-18 23:28:27');
INSERT INTO `tbl_problems` (`id`, `user_id`, `title`, `time_limit`, `memory_limit`, `submission_no`, `accepted_no`, `description`, `source`, `input`, `output`, `input_sample`, `output_sample`, `hint`, `flag`, `visibility`, `created`, `modified`) VALUES
(222, 1, 'Ants', 1000, 134217728, 0000000000, 0000000000, '<p>An army of ants walk on a horizontal pole of length <em>l</em> cm, each with a constant speed of 1 cm/s.  When a walking ant reaches an end of the pole, it immediatelly falls off it.  When two ants meet they turn back and start walking in opposite directions.  We know the original positions of ants on the pole, unfortunately, we do not know the directions in which the ants are walking.  Your task is to compute the earliest and the latest possible times needed for all ants to fall off the pole.</p>\r\n<p>The first line of input contains one integer giving the number of cases that follow.  The data for each case start with two integer numbers: the length of the pole (in cm) and <em>n</em>, the number of ants residing on the pole. These two numbers are followed by <em>n</em> integers giving the position of each ant on the pole as the distance measured from the left end of the pole, in no particular order.  All input integers are not bigger than 1000000 and they are separated by whitespace.</p>\r\n<p>For each case of input, output two numbers separated by a single space.  The first number is the earliest possible time when all ants fall off the pole (if the directions of their walks are chosen appropriately) and the second number is the latest possible such time.</p><img algin=right src=http://plg1.cs.uwaterloo.ca/~acm00/040919/tna.jpg>', '', '<p>Please Input Input Here</p>', '<p>Please Input Output Here</p>', '2\r\n10 3\r\n2 6 7\r\n214 7\r\n11 12 7 13 176 23 191\r\n', '4 8\r\n38 207\r\n', '', 0, 0, '2010-08-18 23:29:46', '2010-08-18 23:29:46'),
(223, 1, ' Evil Straw Warts Live', 1000, 134217728, 0000000000, 0000000000, '<p>\r\n	A palindrome is a string of symbols that is equal to itself when reversed. Given an input string, not necessarily a palindrome, compute the number of swaps necessary to transform the string into a palindrome. By <i>swap</i> we mean reversing the order of two adjacent symbols. For example, the string &quot;mamad&quot; may be transformed into the palindrome &quot;madam&quot; with 3 swaps:</p>\r\n<ul>\r\n	<li>\r\n		swap &quot;ad&quot; to yield &quot;mamda&quot;</li>\r\n	<li>\r\n		swap &quot;md&quot; to yield &quot;madma&quot;</li>\r\n	<li>\r\n		swap &quot;ma&quot; to yield &quot;madam&quot;</li>\r\n</ul>\r\n<p>\r\n	The first line of input gives <i>n</i>, the number of test cases. For each test case, one line of input follows, containing a string of up to 100 lowercase letters. Output consists of one line per test case. This line will contain the number of swaps, or &quot;Impossible&quot; if it is not possible to transform the input to a palindrome.</p>\r\n', '', '<p>\r\n	Please Input Input Here</p>\r\n', '<p>\r\n	Please Input Output Here</p>\r\n', '3\r\nmamad\r\nasflkj\r\naabb\r\n', '3\r\nImpossible\r\n2\r\n', '', 0, 0, '2010-08-18 23:29:46', '2010-10-27 14:15:45'),
(224, 1, 'Mint', 1000, 134217728, 0000000000, 0000000000, '<p>\r\n	The Royal Canadian Mint has commissioned a new series of designer coffee tables, with legs that are constructed from stacks of coins. Each table has four legs, each of which uses a different type of coin. For example, one leg might be a stack of quarters, another nickels, another loonies, and another twonies. Each leg must be exactly the same length.</p>\r\n<p>\r\n	Many coins are available for these tables, including foreign and special commemorative coins. Given an inventory of available coins and a desired table height, compute the lengths nearest to the desired height for which four legs of equal length may be constructed using a different coin for each leg.</p>', 'http://plg1.cs.uwaterloo.ca/~acm00/040919/E.html', '<p>\r\n	Input consists of several test cases. Each case begins with two integers: 4 &le;&nbsp;<i>n</i>&nbsp;&le; 50 giving the number of types of coins available, and 1 &le;&nbsp;<i>t</i>&nbsp;&le; 10 giving the number of tables to be designed.&nbsp;<i>n</i>&nbsp;lines follow; each gives the thickness of a coin in hundredths of millimetres.&nbsp;<i>t</i>&nbsp;lines follow; each gives the height of a table to be designed (also in hundredths of millimetres). A line containing 0 0 follows the last test case.</p>\r\n', '<p>\r\n	For each table, output a line with two integers: the greatest leg length not exceeding the desired length, and the smallest leg length not less than the desired length</p>\r\n', '4 2\r\n50\r\n100\r\n200\r\n400\r\n1000\r\n2000\r\n0 0\r\n', '800 1200\r\n2000 2000\r\n', '', 0, 0, '2010-08-18 23:29:46', '2010-11-22 21:45:21'),
(225, 1, 'Expanding Rods', 1000, 134217728, 0000000000, 0000000000, '<img align="right" vspace="20" hspace="20" src="http://plg1.cs.uwaterloo.ca/%7Eacm00/040612/rods.jpg" alt="" />\r\n<p>When a thin rod of length</p>\r\n<em>L</em>\r\n<p>is heated</p>\r\n<em>n</em>\r\n<p>degrees, it expands to a new length</p>\r\n<em>L''=(1+n*C)*L</em>\r\n<p>, where</p>\r\n<em>C</em>\r\n<p>is the coefficient of heat expansion.</p>\r\n<p>When a thin rod is mounted on two solid walls  and then heated, it expands and takes the shape of a circular segment, the original rod being the chord of the segment.</p>\r\n<p>Your task is to compute the distance by which the center of the rod is displaced.</p>\r\n<p>The input contains multiple lines.  Each line of input contains three non-negative numbers: the initial lenth of the rod in millimeters, the  temperature change in degrees and the coefficient of heat expansion of the material.  Input data guarantee that no rod expands by more than one half of its original length.  The last line of input contains three negative numbers and it should not be processed.</p>\r\n<p>For each line of input, output one line with the displacement of the center of the rod in millimeters with 3 digits of precision.</p>', '', '', '', '1000 100 0.0001\r\n15000 10 0.00006\r\n10 0 0.001\r\n-1 -1 -1\r\n', '61.329\r\n225.020\r\n0.000\r\n', '', 0, 0, '2010-08-19 00:02:16', '2010-08-19 00:02:16'),
(226, 1, 'Three powers', 1000, 134217728, 0000000000, 0000000000, '<img align="right" vspace="0" hspace="10" src="http://plg1.cs.uwaterloo.ca/%7Eacm00/040612/3powers.jpg" alt="" />\r\n<p>Consider the set of all non-negative integer powers of 3.</p>\r\n<p>&nbsp;</p>\r\n<center> <em>S</em> = { 1, 3, 9, 27, 81, ... } </center>\r\n<p>Consider the sequence of all subsets of <em>S</em> ordered by the value of the sum of their elements.  The question is simple: find the set at the <em>n</em>-th position in the sequence and print it in increasing order of its elements.</p>\r\n<p>Each line of input contains a number <em>n</em>, which is a positive integer with no more than 19 digits.  The last line of input contains 0 and it should not be processed.</p>\r\n<p>For each line of input, output a single line displaying the <em>n</em>-th set as described above, in the format used in the sample output.</p>\r\n<h3>&nbsp;</h3>', '', '', '', '1\r\n7\r\n14\r\n783\r\n1125900981634049\r\n0\r\n', '{ }\r\n{ 3, 9 }\r\n{ 1, 9, 27 }\r\n{ 3, 9, 27, 6561, 19683 }\r\n{ 59049, 3486784401, 205891132094649, 717897987691852588770249 }\r\n', '', 0, 0, '2010-08-19 00:02:17', '2010-08-19 00:02:17'),
(227, 1, 'Work Reduction', 1000, 134217728, 0000000000, 0000000000, '<img align="right" width="250" src="http://plg1.cs.uwaterloo.ca/%7Eacm00/040612/work.gif" alt="" />\r\n<p>Paperwork is beginning to pile up on your desk, and tensions at the workplace are starting to mount.  Your boss has threatened to fire you if you don''t make any progress by the end of the day.  You currently have</p>\r\n<b>N</b>\r\n<p>units of paperwork on your desk, and your boss demands that you have exactly</p>\r\n<b>M</b>\r\n<p>units of paperwork left by the end of the day.</p>\r\n<p>The only hope for you now is to hire help.  There are various agencies which offer paperwork reduction plans:</p>\r\n<p>For <b>$A</b> they will reduce your paperwork by one unit.<br />\r\nFor <b>$B</b> they will reduce your entire paperwork by half (rounding down when necessary).</p>\r\n<p>Note that work can never be reduced to less than 0.</p>\r\n<p>Your task now is to produce a sorted table of agency names and their respective minimum costs to solve your workload problem.</p>\r\n<p>The first line of input consists of a single positive integer representing the number of cases to follow.  Each case begins with three positive integers separated by spaces: <b>N</b> - your starting workload, <b>M</b> - your target workload, and <b>L</b> - the number of work reduction agencies available to you, (1 &lt;= M &lt;= N &lt;= 100000, 1 &lt;= L &lt;= 100).  The next <b>L</b> lines have the format &quot;[<em>agency name</em>]<b>:A</b>,<b>B</b>&quot;, where <b>A</b> and <b>B</b> are the rates as described above for the given agency. (0 &lt;= A,B &lt;= 10000) The length of the agency name will be between 1 and 16, and will consist only of capital letters.  Agency names will be unique.</p>\r\n<p>For each test case, print &quot;Case X&quot;, with X being the case number, on a single line, followed by the table of agency names and their respective minimum costs, sorted in non-decreasing order of minimum costs.  Sort job agencies with identical minimum costs in alphabetical order by agency name.  For each line of the table, print out the agency name, followed by a space, followed by the minimum required cost for that agency to solve your problem.</p>', '', '', '', '2\r\n100 5 3\r\nA:1,10\r\nB:2,5\r\nC:3,1\r\n1123 1122 5\r\nB:50,300\r\nA:1,1000\r\nC:10,10\r\nD:1,50\r\nE:0,0\r\n', 'Case 1\r\nC 7\r\nB 22\r\nA 37\r\nCase 2\r\nE 0\r\nA 1\r\nD 1\r\nC 10\r\nB 50\r\n', '', 0, 0, '2010-08-19 00:02:17', '2010-08-19 00:02:17'),
(228, 1, 'Grid Speed', 10000, 134217728, 0000000000, 0000000000, '<p>Consider a grid in which north-south streets, separated by gaps of 10 miles each, are elevated above east-west streets laid out in a similar fashion (see illustration for the case of a 6 by 6 grid).  All streets are two-way. Entrance and exit ramps connect the streets at every intersection.  Because there are no traffic lights, switching from a north-south street to an east-west street, and vice versa, takes essentially no time.  The grid has very little traffic, but the local police patrol so carefully for speeding that there are virtually no speeders.</p>\r\n<p><img align="center" vspace="20" hspace="20" alt="" src="http://plg1.cs.uwaterloo.ca/%7Eacm00/040612/gridspeed.gif" /></p>\r\n<p>The speed limits follow an unusual pattern.  The speed limits are separately posted for each street and are the same for the entire street in both directions.  In the illustration above, let us label the intersections using their column and row numbers: the southwestern corner of the grid is (1,&nbsp;1), the southeastern corner is (6,&nbsp;1), and so on.  Part of your task is to determine the shortest time in which we can get from (1,&nbsp;1) to (6,&nbsp;3) while obeying speed limits.</p>\r\n<p>However, after the Kyoto disagreement, just being fast is not good enough, one also has to be fuel efficient.  Fuel consumption of a car is given in miles-per-gallon (mpg) and depends on speed of the car. Speed of a car is given in miles-per-hour (mph) and, in this digital age, the speed of a car is always a positive integer multiple of 5. The formula relating mpg to mph is a very simple one: a car travelling at <em>v</em> mph makes 80-0.03*<em>v</em><sup>2</sup> mpg. In a given grid of streets we would like to travel from intersection (<em>x<sub>s</sub></em>, <em>y<sub>s</sub></em>) to intersection (<em>x<sub>t</sub></em>, <em>y<sub>t</sub></em>).  You are to determine the fastest and the most fuel efficient way of making the trip such that:</p>\r\n<ul>\r\n    <li>the car does not change speed between intersections,</li>\r\n    <li>the car obeys all speed limits,</li>\r\n    <li>the car travels the shortest possible distance between the start and finish,     and</li>\r\n    <li>the car arrives at the destination in the given time interval.</li>\r\n</ul>', '', '<p>The first line of input contains an integer <em>t</em>, the number of scenarios to be processed.  The data for each scenario occupy 5 lines. The first line contains an integer <em>n</em>&lt;=10 which is the number of horizontal and vertical streets.  The second line contains an integer which is the grid unit size in miles, smaller than 100. The third and fourth lines contain <em>n</em> integers each, specifying the speed limits on the horizontal and vertical streets, respectively. The largest speed limit is 50.  The last line of data for a scenario contains 6 integers.  The first four are <em>x<sub>s</sub></em>, <em>y<sub>s</sub></em>, <em>x<sub>t</sub></em>, and <em>y<sub>t</sub></em>.  The last two integers give the shortest and the longest allowed time to travel in minutes, inclusive, both not bigger than 1000.</p>', '<p>For each scenario, output two or three lines in the format given in the sample output.  If the travel is possible then, on the second line of output, report the earliest possible arrival time (but within the imposed limits) and fuel consumed (least possible for this travel time) and, on the third line, report the earliest arrival time (but within the imposed limits) that consumes the minimum amount of fuel. The time is to be reported in minutes (integer), rounded up.</p>', '3\r\n8\r\n20\r\n10 20 30 40 50 50 50 50\r\n50 50 50 50 50 50 40 50\r\n2 3 7 8 300 320\r\n8\r\n2\r\n10 20 20 30 10 20 10 10 \r\n10 20 20 30 10 20 10 20 \r\n6 8 2 4 10 39\r\n10\r\n10\r\n30 20 20 10 10 20 10 10 20 20\r\n40 20 10 20 10 20 20 10 10 20\r\n1 1 10 10 100 500\r\n', 'Scenario 1:\r\nThe earliest  arrival: 300 minutes, fuel 6.25 gallons\r\nThe economical travel: 318 minutes, fuel 5.60 gallons\r\nScenario 2:\r\nIMPOSSIBLE\r\nScenario 3:\r\nThe earliest  arrival: 405 minutes, fuel 4.14 gallons\r\nThe economical travel: 498 minutes, fuel 2.76 gallons\r\n', '', 0, 0, '2010-08-19 00:02:17', '2010-08-19 00:02:17'),
(229, 1, 'Marbles on a tree', 1000, 134217728, 0000000000, 0000000000, '<img align="right" vspace="20" hspace="20" src="http://plg1.cs.uwaterloo.ca/%7Eacm00/040612/marbles.jpg" alt="" />  <em>n</em>\r\n<p>boxes are placed on the vertices of a rooted tree, which are numbered from 1 to</p>\r\n<em>n</em>\r\n<p>, 1&nbsp;&le;&nbsp;</p>\r\n<em>n</em>\r\n<p>&nbsp;&le;&nbsp;10000.  Each box is either empty or contains a number of marbles; the total number of marbles is</p>\r\n<em>n</em>\r\n<p>.</p>\r\n<p>The task is to move the marbles such that each box contains exactly one marble.  This is to be accomplished be a sequence of moves; each move consists of moving one marble to a box at an adjacent vertex. What is the minimum number of moves required to achieve the goal?</p>\r\n<p>The input contains a number of cases.  Each case starts with the number <em>n</em> followed by <em>n</em> lines.  Each line contains at least three numbers which are: <em>v</em> the number of a vertex, followed by the number of marbles originally placed at vertex <em>v</em> followed by a number <em>d</em> which is the number of children of <em>v</em>, followed by <em>d</em> numbers giving the identities of the children of <em>v</em>.</p>\r\n<p>The input is terminated by a case where <em>n</em>&nbsp;=&nbsp;0 and this case should not be processed.</p>\r\n<p>For each case in the input, output the smallest number of moves of marbles resulting in one marble at each vertex of the tree.</p>', '', '', '', '9\r\n1 2 3 2 3 4\r\n2 1 0\r\n3 0 2 5 6\r\n4 1 3 7 8 9\r\n5 3 0\r\n6 0 0\r\n7 0 0\r\n8 2 0\r\n9 0 0\r\n9\r\n1 0 3 2 3 4\r\n2 0 0\r\n3 0 2 5 6\r\n4 9 3 7 8 9\r\n5 0 0\r\n6 0 0\r\n7 0 0\r\n8 0 0\r\n9 0 0\r\n9\r\n1 0 3 2 3 4\r\n2 9 0\r\n3 0 2 5 6\r\n4 0 3 7 8 9\r\n5 0 0\r\n6 0 0\r\n7 0 0\r\n8 0 0\r\n9 0 0\r\n0\r\n', '7\r\n14\r\n20\r\n', '', 0, 0, '2010-08-19 00:02:17', '2010-08-19 00:02:17'),
(230, 1, 'Advanced Causal Measurements (ACM) ', 1000, 134217728, 0000000000, 0000000000, '<p>Causality is a very important concept in theoretical physics.  The basic elements in a discussion of causality are <em>events</em>.  An event <em>e</em> is described by its time of occurrence <em>t</em>, and its location, <b><em>x</em></b>, and we write <em>e</em> = (<em>t</em>,<b><em>x</em></b>).  For our concerns, all events happen in the one dimensional geometric space and thus locations are given by a single real number <em>x</em> as a coordinate on <em>x</em>-axis. Usually, theoretical physicists like to define the speed of light to be 1, so that time and space have the same units (actual physical units frighten and confuse theorists).</p>\r\n<p>One event <em>e<sub>1</sub></em> = (<em>t<sub>1</sub></em>,<em>x<sub>1</sub></em>) is a <em>possible cause</em> for a second event <em>e<sub>2</sub></em> = (<em>t<sub>2</sub></em>,<em>x<sub>2</sub></em>) if a signal emitted at <em>e<sub>1</sub></em> could arrive at <em>e<sub>2</sub></em>.  Signals can''t travel faster than the speed of light, so this condition can be stated as:</p>\r\n<center> <em>e<sub>1</sub></em> is a <em>possible cause</em> for <em>e<sub>2</sub></em> <spacer size="10" type="horizontal"></spacer><b>iff</b><spacer size="10" type="horizontal"></spacer> <em>t<sub>2</sub></em> &gt;= <em>t<sub>1</sub></em>+|<em>x<sub>2</sub></em>-<em>x<sub>1</sub></em>| </center>\r\n<p>Thus an event at (-1,1) could cause events at (0,0), (1,2), and (1,3), for example, but could not have caused events at (1,4) or (-2,1). Note that one event can cause several others.</p>\r\n<p><img align="right" vspace="20" hspace="20" src="http://plg1.cs.uwaterloo.ca/%7Eacm00/040131/causes.jpg" alt="" /> Recently, scientists have observed several unusual events in the geometrically one dimensional universe, and using current theories, they know how many causes were responsible for these observations, but they know nothing about the time and space coordinates of the causes. You asked to write a program to determine the latest time at which the earliest cause could have occurred (i.e. the time such that at least one cause must have occurred on or before this time).  Somewhat surprisingly, all the observed events have both space and time coordinates expressed by integer numbers in the range  -1000000&nbsp;&le;&nbsp;<em>t</em>,&nbsp;<em>x</em>&nbsp;&le;&nbsp;1000000.</p>\r\n<p>The figure on the right illustrates the first case from input: the earliest single event as a possible cause of all four events.</p>\r\n<p>The first line of input is the number of cases which follow.  Each case begins with a line containing the number <em>n</em> of events and the number <em>m</em> of causes, 1&nbsp;&le;&nbsp;<em>n,&nbsp;m</em>&nbsp;&le;&nbsp;100000.  Next follows <em>n</em> lines containing the <em>t</em> and <em>x</em> coordinates for each event.</p>\r\n<p>Output consists of a single line for each case in the format as in the sample output, giving the latest time at which the earliest cause could have occurred, this will be an integer as our time units are not divisible.</p>', 'http://plg1.cs.uwaterloo.ca/~acm00/040131/B.html', '', '', '4\r\n4 1\r\n1 -1\r\n1 3\r\n1 4\r\n2 6\r\n4 2\r\n1 -1\r\n1 3\r\n1 4\r\n2 6\r\n4 3\r\n1 -1\r\n1 3\r\n1 4\r\n2 6\r\n4 4\r\n1 -1\r\n1 3\r\n1 4\r\n2 6\r\n', 'Case 1: -2\r\nCase 2: 0\r\nCase 3: 0\r\nCase 4: 1\r\n', '', 0, 0, '2010-08-19 00:04:28', '2010-08-19 00:04:28'),
(231, 1, 'A flea on a chessboard', 1000, 134217728, 0000000000, 0000000000, '<p>\r\n	An infinite chessboard is obtained by extending a finite chessboard to the right and up infinitely. Each square of the chessboard is either black or white with the side of <em>S</em> milimiters, 0&nbsp;&lt;&nbsp;<em>S</em>&nbsp;&lt;=&nbsp;1000. The leftmost bottom square of the chessboard is black. A flea is positioned on the chessboard at the point (<em>x</em>,&nbsp;<em>y</em>) (given in milimeters) and makes jumps by jumping <em>dx</em> milimeters to the right and <em>dy</em> milimiters up, 0&nbsp;&lt;&nbsp;<em>dx</em>,&nbsp;<em>dy</em>, that is, a flea at position (<em>x</em>,&nbsp;<em>y</em>) after one jump lands at position (<em>x+dx</em>,&nbsp;<em>y+dy</em>).</p>\r\n<p>\r\n	Given the starting position of the flea on the board your task is to find out after how many jumps the flea will reach a white square. If the flea lands on a boundary between two squares then it does not count as landing on the white square. Note that it is possible that the flea never reaches a white square.</p>\r\n', 'http://plg1.cs.uwaterloo.ca/~acm00/040131/C.html', '<p>\r\n	Each test case consists of one line of input containing five non-negative numbers separated by white space and giving integers <em>S</em>, <em>x</em>, <em>y</em>, <em>dx</em>, and <em>dy</em>. An input line containing five zeroes follows the last test case. For test case print one line of output in the format shown in the sample.</p>\r\n', '', '10 2 3 3 2\r\n100 49 73 214 38\r\n25 0 0 5 25\r\n407 1270 1323 1 1\r\n18 72 6 18 6\r\n407 1270 1170 100 114\r\n0 0 0 0 0\r\n', 'After 3 jumps the flea lands at (11, 9).\r\nAfter 1 jumps the flea lands at (263, 111).\r\nThe flea cannot escape from black squares.\r\nAfter 306 jumps the flea lands at (1576, 1629).\r\nThe flea cannot escape from black squares.\r\nAfter 0 jumps the flea lands at (1270, 1170).\r\n', '', 0, 0, '2010-08-19 00:04:29', '2010-11-18 16:04:50'),
(232, 1, ' Perfect Pth Powers', 1000, 134217728, 0000000000, 0000000000, '<p>\r\n	We say that <i>x</i> is a perfect square if, for some integer <i>b</i>, <i>x = b<sup>2</sup></i>. Similarly, <i>x</i> is a perfect cube if, for some integer <i>b</i>, <i>x = b<sup>3</sup></i>. More generally, <i>x</i> is a perfect p<i>th</i> power if, for some integer <i>b</i>, <i>x = b<sup>p</sup></i>. Given an integer <i>x</i> you are to determine the largest <i>p</i> such that <i>x</i> is a perfect p<i>th</i> power.</p>\r\n<p>\r\n	Each test case is given by a line of input containing <i>x</i>. The value of <i>x</i> will have magnitude at least 2 and be within the range of a (32-bit) <i>int</i> in C, C++, and Java. A line containing 0 follows the last test case.</p>\r\n<p>\r\n	For each test case, output a line giving the largest integer <i>p</i> such that <i>x</i> is a perfect p<i>th</i> power.</p>\r\n', 'http://plg1.cs.uwaterloo.ca/~acm00/040131/E.html', '', '', '17\r\n1073741824\r\n25\r\n0\r\n', '1\r\n30\r\n2\r\n', '', 0, 0, '2010-08-19 00:04:29', '2010-11-17 13:43:19'),
(233, 1, 'Calories from Fat', 1000, 134217728, 0000000000, 0000000000, '<p>Fat contains about 9 Calories/g of food energy.  Protein, sugar, and starch contain about 4 Calories/g, while alcohol contains about 7 Calories/g.   Although many people consume more than 50% of their total Calories as fat, most dieticians recommend that this proportion should be 30% or less.  For example, in the <i>Nutrition Facts</i> label to the right, we see that 3g of fat is 5% of the recommended daily intake based on a 2,000 calorie diet.  A quick calculation reveals that the recommended daily intake of fat is therefore 60g; that is, 540 Calories or 27% Calories from fat.</p>\r\n<p>Others recommend radically different amounts of fat.  Dean Ornish, for example, suggests that less than 10% of total caloric intake should be fat.  On the other hand, Robert Atkins recommends the elimination of all carbohydrate with no restriction on fat.  It has been estimated that the average Atkins dieter consumes 61% of Calories from fat.</p>\r\n<p>From a record of food eaten in one day, you are to compute the percent  Calories from fat.  The record consists of one line of input per food item, giving the quantity of fat, protein, sugar, starch and alcohol in each. Each quantity is an integer followed by a unit, which  will be one of: g (grams), C (Calories), or % (percent Calories).  Percentages will be between 0 and 99.   At least one of the ingredients will be given as a non-zero quantity of grams or Calories (not percent Calories).</p>\r\n<p>Input will consist of several test cases.  Each test case will have one or more lines as described above.  Each test case will be terminated by a line containing ''-''.  An additional line containing ''-'' will follow the last test case.</p>\r\n<p>For each test case, print percent Calories from fat, rounded to the  nearest integer.</p>', '', '', '', '3g 10g 10% 0g 0g\r\n55% 100C 0% 0g 30g\r\n-\r\n25g 0g 0g 0g 0g\r\n-\r\n1g 15% 20% 30% 1C\r\n-\r\n-\r\n', '53%\r\n100%\r\n32%\r\n', '', 0, 0, '2010-08-19 00:05:23', '2010-08-19 00:05:23'),
(234, 1, 'Dead Fraction', 1000, 134217728, 0000000000, 0000000000, '<p>Mike is frantically scrambling to finish his thesis at the last minute.  He needs to assemble all his research notes into vaguely coherent form in the next 3 days.  Unfortunately, he notices that he had been extremely sloppy in his calculations.  Whenever he needed to perform arithmetic, he just plugged  it into a calculator and scribbled down as much of the answer as he felt was relevant.  Whenever a repeating fraction was displayed, Mike simply reccorded the first few digits followed by &quot;...&quot;.  For instance, instead of &quot;1/3&quot; he might have written down &quot;0.3333...&quot;. Unfortunately, his results require exact fractions!  He doesn''t have time to redo every calculation, so he needs you to write a program (and FAST!) to automatically deduce the original fractions.</p>\r\n<p>To make this tenable, he assumes that the original fraction is always the simplest one that produces the given sequence of digits; by <i>simplest</i>, he means the the one with smallest denominator.  Also, he assumes that he did not neglect to write down important digits; no digit from the repeating portion of the decimal expansion was left unrecorded (even if this repeating portion was all zeroes).</p>\r\n<p>There are several test cases.  For each test case there is one line of input of the form &quot;0.<i>dddd</i>...&quot; where <i>dddd</i> is a string of 1 to 9 digits, not all zero. A line containing 0 follows the last case.  For each case, output the original  fraction.</p>\r\n<p><!--with least possible denominator such that\r\n0.<i>dddd</i> is a prefix of its infinite decimal expansion and such that\r\n<i>dddd</i> contains the entire repeating part. --></p>\r\n<p>Note that an exact decimal fraction has two repeating expansions (e.g.  1/5 = 0.2000... = 0.19999...).</p>', '', '', '', '0.2...\r\n0.20...\r\n0.474612399...\r\n0', '2/9\r\n1/5\r\n1186531/2500000\r\n', '', 0, 0, '2010-08-19 00:05:23', '2010-08-19 00:05:23'),
(235, 1, 'Biometrics', 1000, 134217728, 0000000000, 0000000000, '<p>Recently, the term Biometrics been used to refer to the emerging field of technology devoted to identification of individuals using biological traits, such as those based on retinal or iris scanning, fingerprints, or face recognition.</p>\r\n<br />\r\n<br />\r\n<p>A simple biometric system translates a human image into a polygon by considering certain features (eyes, nose, ears, etc.) to be vertices and connecting them with line segments. The polygon has distinct vertices but may be degenerate in that the line segments could intersect. Because these polygons are generally created from remote images, there is some uncertainty as to their scale and rotation. Your job is to determine whether or not two polygons are similar; that is, can they be made equal by repositioning, rotating and magnifying them?</p>\r\n<br />\r\n<br />\r\n<p>Input consists of several test cases. Each test case consists of three lines containing:</p>\r\n<br />\r\n<br />\r\n<p>&nbsp;&nbsp;&nbsp; * f, the number of features</p>\r\n<br />\r\n<p>&nbsp;&nbsp;&nbsp; * f coordinate pairs giving the vertices of the first polygon</p>\r\n<br />\r\n<p>&nbsp;&nbsp;&nbsp; * f coordinate pairs giving the vertices of the second polygon</p>\r\n<br />\r\n<br />\r\n<p>The vertices for both polygons correspond to the same set of features in the same order; for example, right ear tip, chin cleft, right eye, nose, left eye, left ear tip, space between front teeth. Each polygon has f distinct vertices; each vertex is given as an x and y coordinate pair. There are at least three and no more than ten features. Coordinates are integers between -1000 and 1000. A line containing 0 follows the last test case.</p>\r\n<br />\r\n<br />\r\n<p>For each case, output a line &quot;similar&quot; or &quot;dissimilar&quot; as appropriate. The two polygons are similar if, after some combination of translation, rotation, and scaling (but not reflection) both vertices corresponding to each feature are in the same position.</p>\r\n<br />', '', '', '', '4\r\n0 0 0 1 1 1 1 0\r\n0 1 1 0 0 -1 -1 0\r\n3\r\n0 0 10 0 10 10\r\n0 0 -10 0 -10 10\r\n3\r\n0 0 10 10 20 20\r\n0 0 11 11 22 22\r\n3\r\n0 0 10 10 20 20\r\n0 0 11 11 20 20\r\n0\r\n', 'similar\r\ndissimilar\r\nsimilar\r\ndissimilar\r\n', '', 0, 0, '2010-08-19 00:05:23', '2010-08-19 00:05:23'),
(236, 1, 'XYZZY', 1000, 134217728, 0000000000, 0000000000, '<hr />\r\n<pre>\r\nADVENT: /ad磛ent/, n.\r\n</pre>\r\n<i>    The prototypical computer adventure game, first designed by Will Crowther    on the PDP-10 in the mid-1970s as an attempt at computer-refereed fantasy    gaming, and expanded into a puzzle-oriented game by Don Woods at Stanford    in 1976. (Woods had been one of the authors of INTERCAL.) Now better    known as Adventure or Colossal Cave Adventure, but the TOPS-10 operating    system permitted only six-letter filenames in uppercase. See also vadding,    Zork, and Infocom. </i> <hr />\r\n<p>It has recently been discovered how to run open-source software on the Y-Crate gaming device.  A number of enterprising designers have developed <i>Advent</i>-style games for deployment on the Y-Crate.  Your job is to test a number of these designs to see which are winnable.</p>\r\n<p>Each game consists of a set of up to 100 rooms.  One of the rooms is the <i>start</i> and one of the rooms is the <i>finish</i>. Each room has an <i>energy value</i> between -100 and +100. One-way doorways interconnect pairs of rooms.</p>\r\n<p>The player begins in the start room with 100 <i>energy points</i>.  She may pass through any doorway that connects the room she is in to another room, thus entering the other room.  The energy value of this room is added to the player''s energy.  This process continues until she wins by entering the finish room or dies by running out of energy (or quits in frustration).   During her adventure the player may enter the same room several times, receiving its energy each time.</p>\r\n<p>The input consists of several test cases.  Each test case begins with <i>n</i>, the number of rooms.  The rooms are numbered from 1 (the start  room) to <i>n</i> (the finish room).  Input for the <i>n</i> rooms follows.   The input for each room consists of one or more lines containing:</p>\r\n<ul>\r\n    <li>the energy value for room <i>i</i></li>\r\n    <li>the number of doorways leaving room <i>i</i></li>\r\n    <li>a list of the rooms that are reachable by the doorways leaving room <i>i</i></li>\r\n</ul>\r\n<p>The start and finish rooms will always have enery level 0.   <!-- Given enough energy, it is possible to get from any room to the finish.  --> A line containing -1 follows the last test case.</p>\r\n<p>In one line for each case, output &quot;winnable&quot; if it is possible for the player to win, otherwise output &quot;hopeless&quot;.</p>', '', '', '', '5\r\n0 1 2\r\n-60 1 3\r\n-60 1 4\r\n20 1 5\r\n0 0\r\n5\r\n0 1 2\r\n20 1 3\r\n-60 1 4\r\n-60 1 5\r\n0 0\r\n5\r\n0 1 2\r\n21 1 3\r\n-60 1 4\r\n-60 1 5\r\n0 0\r\n5\r\n0 1 2\r\n20 2 1 3\r\n-60 1 4\r\n-60 1 5\r\n0 0\r\n-1\r\n', 'hopeless\r\nhopeless\r\nwinnable\r\nwinnable\r\n', '', 0, 0, '2010-08-19 00:05:23', '2010-08-19 00:05:23'),
(237, 1, ' Combination Lock', 1000, 134217728, 0000000000, 0000000000, '<p>Now that you''re back to school for another term, you need to remember how to work the combination lock on your locker.  A common design is that of the Master Brand, shown at right.  The lock has a dial with 40 calibration marks numbered 0 to 39.  A combination consists of 3 of these numbers; for example:  15-25-8.  To open the lock, the following steps are taken:</p>\r\n<ul>\r\n    <li>turn the dial clockwise 2 full turns</li>\r\n    <li>stop at the first number of the combination</li>\r\n    <li>turn the dial counter-clockwise 1 full turn</li>\r\n    <li>continue turning counter-clockwise until the 2nd number is reached</li>\r\n    <li>turn the dial clockwise again until the 3rd number is reached</li>\r\n    <li>pull the shank and the lock will open.</li>\r\n</ul>\r\n<p>Given the initial position of the dial and the combination for the lock, how many degrees is the dial rotated in total (clockwise plus counter-clockwise) in opening the lock?</p>\r\n<p>Input consists of several test cases.  For each case there is a line of input containing 4 numbers between 0 and 39.  The first number is the position of the dial.  The next three numbers are the combination.   Consecutive numbers in the combination will be distinct.  A line  containing 0 0 0 0 follows the last case.</p>\r\n<p>For each case, print a line with a single integer:  the number of  degrees that the dial must be turned to open the lock.</p>', '', '', '', '0 30 0 30\r\n5 35 5 35\r\n0 20 0 20\r\n7 27 7 27\r\n0 10 0 10\r\n9 19 9 19\r\n0 0 0 0\r\n', '1350\r\n1350\r\n1620\r\n1620\r\n1890\r\n1890\r\n', '', 0, 0, '2010-08-19 00:08:06', '2010-08-19 00:08:06'),
(238, 1, 'Basic remains ', 1000, 134217728, 0000000000, 0000000000, '<p>Given a base b and two non-negative base b integers p and m, compute p mod m and print the result as a base b integer. p mod m is defined as the smallest non-negative integer k such that p = a*m + k for some integer a.</p>\r\n<br />\r\n<br />\r\n<p>Input consists of a number of cases. Each case is represented by a line containing three unsigned integers. The first, b, is a decimal number between 2 and 10. The second, p, contains up to 1000 digits between 0 and b-1. The third, m, contains up to 9 digits between 0 and b-1. The last case is followed by a line containing 0.</p>\r\n<br />\r\n<br />\r\n<p>For each test case, print a line giving p mod m as a base-b integer.</p>\r\n<br />', '', '', '', '2 1100 101\r\n10 123456789123456789123456789 1000\r\n0\r\n', '10\r\n789\r\n', '', 0, 0, '2010-08-19 00:08:06', '2010-08-19 00:08:06'),
(239, 1, 'Genealogical Research', 1000, 134217728, 0000000000, 0000000000, '<p>These days, everyone seems to be exploring their ancestry.  This effort is supported by family history software, now marketed by a number of vendors.  Unfortunately this software is expensive and runs only on the McDoze X operating system.  You are to write an open-source equivalent.</p>\r\n<p>Your program accepts a series of commands, one per line.  The commands are described by the following syntax:</p>\r\n<pre>\r\n   <i>command</i> ::= <i>birth</i>\r\n           ::= <i>death</i>\r\n           ::= <i>ancestors</i>\r\n           ::= <i>descendants</i> \r\n           ::= QUIT\r\n   \r\n   <i>birth</i> ::= BIRTH <i>child</i>: <i>date</i>: <i>mother</i>: <i>father</i>\r\n\r\n   <i>death</i> ::= DEATH <i>person</i>: <i>date</i>\r\n\r\n   <i>ancestors</i> ::= ANCESTORS <i>person</i>\r\n\r\n   <i>descendants</i> ::= DESCENDANTS <i>person</i>\r\n   \r\n   <i>child</i> ::= <i>name</i>\r\n\r\n   <i>mother</i> ::= <i>name</i>\r\n\r\n   <i>father</i> ::= <i>name</i>\r\n\r\n   <i>person</i> ::= <i>name</i>\r\n\r\n   <i>date</i> ::= <i>name</i>\r\n\r\n   <i>name</i> ::= <i>&lt;&lt;any sequence of characters not beginning or ending<br />                       with a space or containing a colon&gt;&gt;</i>\r\n</pre>\r\n<p>Spaces in the input are ignored except where they appear within</p>\r\n<i>name</i>\r\n<p>. The BIRTH and DEATH commands record the birth and death of an individual. You may assume that each individual has a unique name.  The ANCESTORS and DESCENDANTS commands are queries:  they print a family tree or a reverse family tree for the named person, using the BIRTH and DEATH information entered by previous commands.  The QUIT command indicates the end of input.</p>\r\n<p>The BIRTH, DEATH, and QUIT commands have no output.  For each ANCESTORS (DESCENDANTS) command, print the following information:</p>\r\n<ul>\r\n    <li>1. Print a line containing &quot;ANCESTORS of&quot; (&quot;DESCENDANTS of&quot;) followed by the person''s name</li>\r\n    <li>2. Indented 2 spaces from the previous line, print the person''s first parent (child) in alphabetical order, followed by the parent''s (child''s) birth date, followed by a space, followed by a hyphen, and, if the parent (child) has died, another space and the date of death.  If there is no birth record for the parent (child), print the name alone.</li>\r\n    <li>3. Print the ancestry (descendant) information for the parent (child), indented another 2 spaces, using these same steps (i.e. steps 2-4).</li>\r\n    <li>4. Repeat steps 2-4 for the remaining parent (children).  Indentation should be the same as for the previous parent (child).</li>\r\n</ul>\r\n<p>Leave an empty line between the output sequences for successive commands.</p>\r\n<p>You may assume that no input line exceeds 100 characters, and that there are not more than 250 lines of input.  You may assume that DEATH, ANCESTORS, and DESCENDANTS commands refer to a name for which a BIRTH command has previously been given.  QUIT appears only as the last line of input.</p>', '', '', '', 'BIRTH John Doe : January 7, 1599 : Jane Doe : Adam Doe\r\nBIRTH Mary Worth : May 18, 1666 : Jane Doe : Adam Doe\r\nBIRTH Casper Ghost : Jan 2, 1959 : Mary Worth : John Doe\r\nDEATH Mary Worth : Jan 3, 1959\r\nANCESTORS Casper Ghost\r\nDESCENDANTS John Doe\r\nQUIT\r\n', 'ANCESTORS of Casper Ghost\r\n  John Doe January 7, 1599 -\r\n    Adam Doe\r\n    Jane Doe\r\n  Mary Worth May 18, 1666 - Jan 3, 1959\r\n    Adam Doe\r\n    Jane Doe\r\n\r\nDESCENDANTS of John Doe\r\n  Casper Ghost Jan 2, 1959 -\r\n', '', 0, 0, '2010-08-19 00:08:06', '2010-08-19 00:08:06'),
(240, 1, 'Treasure Map', 1000, 134217728, 0000000000, 0000000000, '<p>You have come into possession of a pirate map that gives a series of  steps to get from your landing place on a desert isle to</p>\r\n<i>the spot  marked <b>X</b></i>\r\n<p>where the treasure is located.  Each step consists  of a compass heading and a number of paces.</p>\r\n<p>After spending most of your savings chartering a boat, you arrive at the island and, with the help of your portable GPS receiver, duly execute  the instructions on the map.  Alas, no treasure!  On your return home you are astonished to learn that the pirates had no knowledge of GPS and used a magnetic compass to create the map. The pirates were unaware that their compass pointed to <i>magnetic north</i> rather than true north.  The relative angle between magnetic north and true north varies depending where you are on the planet, but you are able to determine that on this particular desert isle, magnetic north is <i>d</i> degrees from true north.  How close were you to <i>the spot marked <b>X</b></i> at any moment while following the map?</p>\r\n<p>There are several test cases.  Each test case begins with <i>n &lt;= 1000</i>, the number of steps in the map.  <i>n</i> lines follow;  each consists of  one of the 32 named compass points shown at right followed by a number  of paces.  The last line is a number giving the angle between magnetic north and true north, in degrees.  A positive number indicates that magnetic north is to the east of true north; a negative indicates that it is to the west.  The magnitude of this angle will not exceed 90 degrees. A line containing 0 follows the input for the last case.</p>\r\n<p>For each test case, output a single number, rounded to two decimal places,  giving the least distance (in paces) that separated you from the treasure at any point while you were following the map.</p>\r\n<p><i>Note:</i> We use combinations of the letters <b>N,E,S,W,b</b> to abbreviate the names of the compass points.  For example, <b>NEbE</b> stands for <i>north-east by east</i>.  The 32 points are equally spaced about the compass.  Clockwise, they are: <b> N NbE NNE NEbN NE NEbE ENE EbN E EbS ESE SEbE SE SEbS SSE SbE S SbW SSW SWbS SW SWbW WSW WbS W WbN WNW NWbW NW NWbN NNW NbW.</b></p>', '', '', '', '2\r\nNbE 10\r\nEbS 10\r\n90.00\r\n2\r\nNbE 10\r\nEbS 10\r\n-90.00\r\n0\r\n', '14.14\r\n10.00\r\n', '', 0, 0, '2010-08-19 00:08:06', '2010-08-19 00:08:06'),
(241, 1, ' Intellectual Property', 1000, 134217728, 0000000000, 0000000000, '<p>TDP Inc. has decided to sue JCN Inc. for copyright infringement.  To this end, TDP wishes to find</p>\r\n<i>infringing segments</i>\r\n<p>within JCN''s code base, to show to selected media representatives.  Since TDP has fired all its technical staff, it is looking to hire a consultant to be paid on a contingency basis should the lawsuit be successful. To demonstrate your qualifications for this position, you are  to solve the problem on a number of test cases.</p>\r\n<p>Each test case begins with a positive integer <i>k</i>, the number of infringing segments to be found.  Following this line are two code bases.  The first code base is preceded by the line &quot;BEGIN TDP CODEBASE&quot; and contains a number of lines followed by the line &quot;END TDP CODEBASE&quot;.  The second code base is preceded by &quot;BEGIN JCN CODEBASE&quot; and followed by &quot;END JCN CODEBASE&quot;.  The line &quot;END TDP CODEBASE&quot; does not appear in the first code base and the line &quot;END JCN CODEBASE&quot; does not appear in the second. A line containing 0 follows the last test case.</p>\r\n<p>For each test case you should output: (1) a line containing &quot;CASE <i>n</i>&quot; where <i>n</i> is the number of the test case; (2) up to <i>k</i> infringing segments.  Each segment should be printed exactly as it appears in the JCN code base (including newlines and whitespace) and should be preceded by a line containing  &quot;INFRINGING SEGMENT <i>m</i> LENGTH <i>l</i> POSITION <i>p</i>&quot; where  <i>m</i> is the number of the segment within the test case,  <i>l</i> is the length of the segment (in characters) and <i>p</i> is the position of the segment (in characters from the start of the JCN codebase).  Output an empty line between test cases.</p>\r\n<p>A code base is simply a string of characters. An infringing segment is a non-empty contiguous sequence of characters in the JCN code base that is textually identical to some contiguous sequence   of characters in the TDP code base, and is not contained in a larger infringing segment.  You should consider all characters in the code base, including spaces and the <i>newline</i> character at the end of each line.</p>\r\n<p>If there are <i>k</i> or fewer common segments, print them all in decreasing order by length; if several segments have the same length, print them in the order they occur in JCN''s code base. If there are more than <i>k</i> segments, print the first <i>k</i>  according to the given order.</p>\r\n<p>You may assume that no code base contains more than 50,000 characters.</p>', '', '', '', '6\r\nBEGIN TDP CODEBASE\r\nthe quick brown fox\r\njumps over the lazy dog.\r\nso there!\r\nEND TDP CODEBASE\r\nBEGIN JCN CODEBASE\r\nnow is the time for all\r\ngood men to come to the aid\r\nof the party.\r\nso there!\r\nEND JCN CODEBASE\r\n100\r\nBEGIN TDP CODEBASE\r\nxyzzy\r\nEND TDP CODEBASE\r\nBEGIN JCN CODEBASE\r\nxyzzabczzyy\r\nEND JCN CODEBASE\r\n0\r\n', 'CASE 1\r\nINFRINGING SEGMENT 1 LENGTH 12 POSITION 64\r\n.\r\nso there!\r\n\r\nINFRINGING SEGMENT 2 LENGTH 5 POSITION 6\r\n the \r\nINFRINGING SEGMENT 3 LENGTH 5 POSITION 42\r\no the\r\nINFRINGING SEGMENT 4 LENGTH 5 POSITION 43\r\n the \r\nINFRINGING SEGMENT 5 LENGTH 5 POSITION 54\r\n the \r\nINFRINGING SEGMENT 6 LENGTH 3 POSITION 15\r\n fo\r\n\r\nCASE 2\r\nINFRINGING SEGMENT 1 LENGTH 4 POSITION 0\r\nxyzz\r\nINFRINGING SEGMENT 2 LENGTH 3 POSITION 7\r\nzzy\r\nINFRINGING SEGMENT 3 LENGTH 2 POSITION 10\r\ny\r\n', '', 0, 0, '2010-08-19 00:09:28', '2010-08-19 00:09:28');
INSERT INTO `tbl_problems` (`id`, `user_id`, `title`, `time_limit`, `memory_limit`, `submission_no`, `accepted_no`, `description`, `source`, `input`, `output`, `input_sample`, `output_sample`, `hint`, `flag`, `visibility`, `created`, `modified`) VALUES
(242, 1, 'Persistent Numbers', 1000, 134217728, 0000000000, 0000000000, '<table align="right" frame="void" width="300" vspace="20" hspace="20" rules="none" ncellpadding="3">\r\n    <tbody>\r\n        <tr bgcolor="#ffff00">\r\n            <td></td>\r\n            <td><small><b>1</b></small></td>\r\n            <td><small><b>2</b></small></td>\r\n            <td><small><b>3</b></small></td>\r\n            <td><small><b>4</b></small></td>\r\n            <td><small><b>5</b></small></td>\r\n            <td><small><b>6</b></small></td>\r\n            <td><small><b>7</b></small></td>\r\n            <td><small><b>8</b></small></td>\r\n            <td><small><b>9</b></small></td>\r\n        </tr>\r\n        <tr>\r\n            <td bgcolor="#ffff00"><small><b>1</b></small></td>\r\n            <td><small>&nbsp;1  </small></td>\r\n            <td><small>&nbsp;2 </small></td>\r\n            <td><small>&nbsp;3 </small></td>\r\n            <td><small>&nbsp;4 </small></td>\r\n            <td><small>&nbsp;5 </small></td>\r\n            <td><small>&nbsp;6 </small></td>\r\n            <td><small>&nbsp;7 </small></td>\r\n            <td><small>&nbsp;8 </small></td>\r\n            <td><small>&nbsp;9  </small></td>\r\n        </tr>\r\n        <tr>\r\n            <td bgcolor="#ffff00"><small><b>2 </b></small></td>\r\n            <td><small>&nbsp;2  </small></td>\r\n            <td><small>&nbsp;4 </small></td>\r\n            <td><small>&nbsp;6 </small></td>\r\n            <td><small>&nbsp;8 </small></td>\r\n            <td><small>10</small></td>\r\n            <td><small>12</small></td>\r\n            <td><small>14</small></td>\r\n            <td><small>16</small></td>\r\n            <td><small>18 </small></td>\r\n        </tr>\r\n        <tr>\r\n            <td bgcolor="#ffff00"><small><b>3 </b></small></td>\r\n            <td><small>&nbsp;3  </small></td>\r\n            <td><small>&nbsp;6 </small></td>\r\n            <td><small>&nbsp;9 </small></td>\r\n            <td><small>12</small></td>\r\n            <td><small>15</small></td>\r\n            <td><small>18</small></td>\r\n            <td><small>21</small></td>\r\n            <td><small>24</small></td>\r\n            <td><small>27 </small></td>\r\n        </tr>\r\n        <tr>\r\n            <td bgcolor="#ffff00"><small><b>4 </b></small></td>\r\n            <td><small>&nbsp;4  </small></td>\r\n            <td><small>&nbsp;8 </small></td>\r\n            <td><small>12</small></td>\r\n            <td><small>16</small></td>\r\n            <td><small>20</small></td>\r\n            <td><small>24</small></td>\r\n            <td><small>28</small></td>\r\n            <td><small>32</small></td>\r\n            <td><small>36 </small></td>\r\n        </tr>\r\n        <tr>\r\n            <td bgcolor="#ffff00"><small><b>5 </b></small></td>\r\n            <td><small>&nbsp;5  </small></td>\r\n            <td><small>10</small></td>\r\n            <td><small>15</small></td>\r\n            <td><small>20</small></td>\r\n            <td><small>25</small></td>\r\n            <td><small>30</small></td>\r\n            <td><small>35</small></td>\r\n            <td><small>40</small></td>\r\n            <td><small>45 </small></td>\r\n        </tr>\r\n        <tr>\r\n            <td bgcolor="#ffff00"><small><b>6 </b></small></td>\r\n            <td><small>&nbsp;6  </small></td>\r\n            <td><small>12</small></td>\r\n            <td><small>18</small></td>\r\n            <td><small>24</small></td>\r\n            <td><small>30</small></td>\r\n            <td><small>36</small></td>\r\n            <td><small>42</small></td>\r\n            <td><small>48</small></td>\r\n            <td><small>54 </small></td>\r\n        </tr>\r\n        <tr>\r\n            <td bgcolor="#ffff00"><small><b>7 </b></small></td>\r\n            <td><small>&nbsp;7  </small></td>\r\n            <td><small>14</small></td>\r\n            <td><small>21</small></td>\r\n            <td><small>28</small></td>\r\n            <td><small>35</small></td>\r\n            <td><small>42</small></td>\r\n            <td><small>49</small></td>\r\n            <td><small>56</small></td>\r\n            <td><small>63 </small></td>\r\n        </tr>\r\n        <tr>\r\n            <td bgcolor="#ffff00"><small><b>8 </b></small></td>\r\n            <td><small>&nbsp;8  </small></td>\r\n            <td><small>16</small></td>\r\n            <td><small>24</small></td>\r\n            <td><small>32</small></td>\r\n            <td><small>40</small></td>\r\n            <td><small>48</small></td>\r\n            <td><small>56</small></td>\r\n            <td><small>64</small></td>\r\n            <td><small>72 </small></td>\r\n        </tr>\r\n        <tr>\r\n            <td bgcolor="#ffff00"><small><b>9 </b></small></td>\r\n            <td><small>&nbsp;9  </small></td>\r\n            <td><small>18</small></td>\r\n            <td><small>27</small></td>\r\n            <td><small>36</small></td>\r\n            <td><small>45</small></td>\r\n            <td><small>54</small></td>\r\n            <td><small>63</small></td>\r\n            <td><small>72</small></td>\r\n            <td><small>81 </small></td>\r\n        </tr>\r\n    </tbody>\r\n</table>\r\n<p>The multiplicative persistence of a number is defined by Neil Sloane (Neil J.A. Sloane in</p>\r\n<em> The Persistence of a Number </em>\r\n<p>published in Journal of Recreational Mathematics 6, 1973, pp. 97-98., 1973) as the number of steps to reach a one-digit number when repeatedly multiplying the digits. Example:</p>\r\n<center>\r\n<pre><b>679</b> -&gt; <b>378</b> -&gt; <b>168</b> -&gt; <b>48</b> -&gt; <b>32</b> -&gt; <b>6</b>.\r\n</pre>\r\n</center>\r\n<p>That is, the persistence of 679 is 5.  The persistence of a single digit number is 0.    At the time of this writing it is known that there are numbers with  the persistence of 11.  It is not known whether there are numbers with the persistence of 12 but it is known that if they exists then the smallest of them would have more than 3000 digits.</p>\r\n<p>The problem that you are to solve here is: what is the smallest number such that the first step of computing its persistence results in the given number?</p>\r\n<p>For each test case there is a single line of input containing a decimal  number with up to 1000 digits.  A line containing -1 follows the last test case. For each test case you are to output one line containing one integer number satisfying the condition stated above or a statement saying that there is no such number in the format shown below.</p>', '', '', '', '0\r\n1\r\n4\r\n7\r\n18\r\n49\r\n51\r\n768\r\n-1\r\n', '10\r\n11\r\n14\r\n17\r\n29\r\n77\r\nThere is no such number.\r\n2688\r\n', '', 0, 0, '2010-08-19 00:09:28', '2010-08-19 00:09:28'),
(243, 1, ' Major Scales', 1000, 134217728, 0000000000, 0000000000, '<p>In music, the range of audible frequencies is divided into octaves, where each octave spans frequencies within factor of 2 of one another. For example, the note called <i>middle C</i> corresponds to an  audio frequency of 263 Hz.  The octave below middle C spans the frequency range from 131.5 Hz to 263 Hz while the octave above middle C spans the range from 263 Hz to 526 Hz.</p>\r\n<p>An octave contains 13 <i>chromatic notes</i> whose frequencies differ by a common  ratio.  The separation between two adjacent  chromatic notes is called a <i>half-step</i> or <i>semi-tone</i>. Note that there are 12 semi-tones in an octave and therefore the frequency ratio represented by a semi-tone is 1.0593 (since 1.0593<sup>12</sup> = 2).  A <i>tone</i> is two semi-tones.</p>\r\n<p>While it might be convenient to use frequencies to describe musical notes, historical tradition demands that we name the notes of the chromatic scale, in order:  C, C#, D, D#, E, F, F#, G, G#, A, A#, B, C, and so on, repeating the same names for each new octave.</p>\r\n<p>Western music rarely uses all the notes in the chromatic scale. Instead, 8 of the 13 chromatic notes are commonly used a composition. The most common such set of 8 notes is the <i>major scale</i>.   The 8 notes of a major scale, in order, are separated by:   <i>tone, tone, semi-tone, tone, tone, tone, semi-tone</i>.  A major scale can begin with any of the chromatic notes; this note defines the <i>key</i> of the scale. Coincidentally, in the key of C, the major scale consists of the notes: C, D, E, F, G, A, B, C.  On the other hand, in the key of F, the major scale is:  F, G, A, A#, C, D, E, F.</p>\r\n<p>There are other scales, notably the <i>minor scale</i>, and music composed in a particular scale sometimes uses notes that are not within the scale, caled <i>accidentals</i>.  We shall concern ourselves only with music composed in a major scale with no accidentals.</p>\r\n<p>Your job is to read a sequence of notes and to identify all the keys that the music might have been composed in.  Your program need not have any musical ear:  report a particular key if and only if all the notes come from the major scale in that key.</p>\r\n<p>Input contains several test cases.  Each test case consists of a single line of input, containing a sequence of chromatic notes separated by white space.  No input line exceeds 1000 characters.  The last line of  input contains the word &quot;END&quot;.</p>\r\n<p>For each test case, output a line giving the possible keys, in the order given above.</p>', '', '', '', 'C C D F E G A A F G B\r\nA B C D E F G C#\r\nC C D F E G A A F G\r\nC C C C C\r\nEND\r\n', 'C\r\n\r\nC F\r\nC C# D# F G G# A#\r\n', '', 0, 0, '2010-08-19 00:09:28', '2010-08-19 00:09:28'),
(244, 1, 'Dumb Bones', 1000, 134217728, 0000000000, 0000000000, '<p>You are trying to set up a straight line of dominos, standing on end, to be pushed over later for your entertainment.  (Sure, it seems pointless to set something up only to knock it down again, but you have some strange hobbies) The tricky thing about setting dominos, however, is that if you make a mistake and knock one over as you place it, it will knock down any adjacent line of consecutive dominos on one side of it, partially ruining your work.</p>\r\n<p>For instance, if you''ve already placed dominos in the pattern DD__DxDDD_D, and you try placing a domino at position x, there is a chance it will fall and knock over the domino to the left or the three dominos to its right, forcing you to place them again.</p>\r\n<p>This human error is somewhat unavoidable, but you <i>can</i> make the odds somewhat more favourable by using a domino-placing technique that leads to dominos falling in one direction more often than in the other.</p>\r\n<p>Given the number of dominos you are trying to set up, and the probability that you''ll knock over any individual domino either to the left or to the right while placing it, determine the average number of dominos you''ll need to place before you finish.  Assume that you''re using an optimal placement strategy.</p>\r\n<p>Input will consist of up to 100 cases.  Each case consists of one line of input.  It will contain the number of dominos to place, n, 1 &lt;= n &lt;= 1000, followed by nonnegative values Pl and Pr, indicating the probability of any domino falling to the left or to the right when placed.  You may assume 0 &lt; Pl + Pr &lt;= 0.5.</p>\r\n<p>The last test case is followed by a line containing a single 0.</p>\r\n<p>For each case, output the expected number of dominos that will need to be placed before you finish, accurate to two digits after the decimal.</p>', '', '', '', '10 0.25 0.25\r\n10 0.1 0.4\r\n10 0.0 0.5\r\n0\r\n', '46.25\r\n37.28\r\n20.00\r\n', '', 0, 0, '2010-08-19 00:09:28', '2010-08-19 00:09:28'),
(245, 1, 'Guessing Game', 1000, 134217728, 0000000000, 0000000000, '<p>Stan and Ollie are playing a guessing game.  Stan thinks of a number between 1 and 10 and Ollie guesses what the number might be.  After each guess, Stan indicates whether Ollie''s guess is too high, too low, or right on.</p>\r\n<p>After playing several rounds, Ollie has become suspicious that Stan cheats; that is, that he changes the number between Ollie''s guesses.  To prepare his case against Stan, Ollie has recorded a transcript of several games. You are to determine whether or not each transcript proves that Stan is cheating.</p>\r\n<p>Standard input consists of several transcripts.  Each  transcript consists of a number of paired guesses and responses.  A guess is a line containing single integer between 1 and 10, and a response is a line containing &quot;too high&quot;, &quot;too low&quot;, or &quot;right on&quot;. Each game ends with &quot;right on&quot;.  A line containing 0 follows the last transcript.</p>\r\n<p>For each game, output a line &quot;Stan is dishonest&quot; if Stan''s responses are inconsistent with the final guess and  response.  Otherwise, print &quot;Stan may be honest&quot;.</p>', '', '', '', '10\r\ntoo high\r\n3\r\ntoo low\r\n4\r\ntoo high\r\n2\r\nright on\r\n5\r\ntoo low\r\n7\r\ntoo high\r\n6\r\nright on\r\n0\r\n', 'Stan is dishonest\r\nStan may be honest\r\n', '', 0, 0, '2010-08-19 00:09:28', '2010-08-19 00:09:28'),
(246, 1, 'Temple of Dune', 1000, 134217728, 0000000000, 0000000000, '<p>\r\n	The Archaeologists of the Current Millenium (ACM) now and then discover ancient artifacts located at the vertices of regular polygons. In general it is necessary to move one sand dune to uncover each artifact. After discovering three artifacts, the archaeologists wish to compute the minimum number of dunes that must be moved to uncover all of them.</p>\r\n', 'http://plg1.cs.uwaterloo.ca/~acm00/030125/A.html', '<p>\r\n	The first line of input contains a positive integer&nbsp;<i>n</i>, the number of test cases. Each test case consists of three pairs of real numbers giving the&nbsp;<i>x</i>&nbsp;and&nbsp;<i>y</i>&nbsp;coordinates of three vertices from a regular polygon.You may assume that each input case gives three distinct vertices of a regular polygon with at most 200 vertices.</p>', '<p>\r\n	For each line of input, output a single integer stating the fewest vertices that such a polygon might have.</p>\r\n', '4\r\n10.00000 0.00000 0.00000 -10.00000 -10.00000 0.00000\r\n22.23086 0.42320 -4.87328 11.92822 1.76914 27.57680\r\n156.71567 -13.63236 139.03195 -22.04236 137.96925 -11.70517\r\n129.400249 -44.695226 122.278798 -53.696996 44.828427 -83.507917\r\n', '4\r\n6\r\n23\r\n100\r\n', '', 0, 0, '2010-08-19 00:09:47', '2010-11-23 19:41:30'),
(247, 1, 'Ferry Loading II', 1000, 134217728, 0000000000, 0000000000, '<p>Before bridges were common, ferries were used to transport cars across rivers. River ferries, unlike their larger cousins, run on a guide line and are powered by the river''s current. Cars drive onto the ferry from one end, the ferry crosses the river, and the cars exit from the other end of the ferry.</p>\r\n<p>There is a ferry across the river that can take <em>n</em> cars across the river in <em>t</em> minutes and return in <em>t</em> minutes.   <i>m</i> cars arrive at the ferry terminal by a given schedule.  What is the  earliest time that all the cars can be transported across the river?   What is the minimum number of trips that the operator must make to deliver all cars by that time?</p>\r\n<p>The first line of input contains <i>c</i>, the number of test cases. Each test case begins with <i>n, t, m</i>. <i>m</i> lines follow, each giving the arrival time for a car (in minutes since the beginning of the day). The operator can run the ferry whenever he or she wishes, but can take only the cars that have arrived up to that time.  For each test case, output a single line with two integers: the time, in minutes since the beginning of the day, when the last car is delivered to the other side of the river, and the minimum number of trips made by the ferry to carry the cars within that time.</p>\r\n<p>You may assume that 0 &lt; n, t, m &lt; 1440.  The arrival times for each test case are in non-decreasing order.</p>', '', '', '', '2\r\n2 10 10\r\n0\r\n10\r\n20\r\n30\r\n40\r\n50\r\n60\r\n70\r\n80\r\n90\r\n2 10 3\r\n10\r\n30\r\n40\r\n', '100 5\r\n50 2\r\n', '', 0, 0, '2010-08-19 00:09:47', '2010-08-19 00:09:47'),
(248, 1, 'Catenyms', 1000, 134217728, 0000000000, 0000000000, '<div>\r\n	A catenym is a pair of words separated by a period such that the last letter of the first word is the same as the last letter of the second. For example, the following are catenyms:</div>\r\n<div>\r\n	dog.gopher<br />\r\n	gopher.rat<br />\r\n	rat.tiger<br />\r\n	aloha.aloha<br />\r\n	arachnid.dog</div>\r\n<div>\r\n	A compound catenym is a sequence of three or more words separated by periods such that each adjacent pair of words forms a catenym. For example,</div>\r\n<div>\r\n	aloha.aloha.arachnid.dog.gopher.rat.tiger</div>\r\n<div>\r\n	&nbsp;</div>\r\n<div>\r\n	Given a dictionary of lower case words, you are to find a compound catenym that contains each of the words exactly once. The first line of standard input contains&nbsp;<i>t&nbsp;</i>, the number of test cases. Each test case begins with 3 &lt;=&nbsp;<i>n&nbsp;</i>&lt;= 1000 - the number of words in the dictionary.&nbsp;<i>n&nbsp;</i>distinct dictionary words follow; each word is a string of between 1 and 20 lowercase letters on a line by itself. For each test case, output a line giving the lexicographically least compound catenym that contains each dictionary word exactly once. Output &quot;***&quot; if there is no solution.</div>\r\n', '', '', '', '2\r\n6\r\naloha\r\narachnid\r\ndog\r\ngopher\r\nrat\r\ntiger\r\n3\r\noak\r\nmaple\r\nelm\r\n', 'aloha.arachnid.dog.gopher.rat.tiger\r\n***\r\n', '', 0, 0, '2010-08-19 00:09:47', '2010-10-27 14:10:57'),
(249, 1, 'Basic', 1000, 134217728, 0000000000, 0000000000, '<p>\r\n	The programming language Ada has integer constants that look like this: 123, 8#123#, 16#abc#. These constants represent the integers 123, 83 (123 base 8) and 2739 (abc base 16). More precisely, an integer may be a decimal integer given as a sequence of one or more digits less than 10, or it may be an integer to some specific base, given as the base followed by a sequence of one or more digits less than the base enclosed by # symbols. Lower case letters from a through f are used as the digits representing 10 through 15. In Ada, the base, if specified, must be a sequence of decimal digits. For this problem, however, the base may be of any form described above so long as it represents an integer between 2 and 16 inclusive.</p>\r\n<p>\r\n	The first line of input contains a positive integer <i>n</i>. <i>n</i> lines follow. For each line of input, output a line &quot;yes&quot; if it is a valid integer constant according to the above rules; otherwise output a line containing &quot;no&quot;. Input lines contain no spaces and are between 1 and 80 characters in length.</p>\r\n', '', '', '', '5\r\n2#101#\r\n2#101##123#\r\n17#abc#\r\n16#123456789abcdef#\r\n16#123456789abcdef#123456789abcdef#\r\n', 'yes\r\nyes\r\nno\r\nyes\r\nno\r\n', '', 0, 0, '2010-08-19 00:09:47', '2010-11-18 16:17:37'),
(250, 1, 'Rock, Scissors, Paper', 1000, 134217728, 0000000000, 0000000000, '<p>Bart''s sister Lisa has created a new civilization on a two-dimensional grid. At the outset each grid location may be occupied by one of three life forms: <i>Rocks</i>, <i>Scissors</i>, or <i>Papers</i>.  Each day, differing life forms occupying horizontally or vertically adjacent grid locations wage war.   In each war, Rocks always defeat Scissors, Scissors always defeat Papers,  and Papers always defeat Rocks.  At the end of the day, the victor expands its  territory to include the loser''s grid position.  The loser vacates the position.</p>\r\n<p>Your job is to determine the territory occupied by each life form after <i>n</i> days. The first line of input contains <i>t</i>, the number of test cases.  Each test case begins with three integers not greater than 100: <i>r</i> and <i>c</i>, the number of rows and columns in the grid, and <i>n</i>.  The grid is represented by the <i>r</i> lines that follow,  each with <i>c</i> characters. Each character in the grid is R, S, or P, indicating that it is occupied by Rocks, Scissors, or Papers respectively.</p>\r\n<p>For each test case, print the grid as it appears at the end of the <i>n</i>th day. Leave an empty line between the output for successive test cases.</p>', '', '', '', '2\r\n3 3 1\r\nRRR\r\nRSR\r\nRRR\r\n3 4 2\r\nRSPR\r\nSPRS\r\nPRSP\r\n', 'RRR\r\nRRR\r\nRRR\r\n\r\nRRRS\r\nRRSP\r\nRSPR\r\n', '', 0, 0, '2010-08-19 00:09:47', '2010-08-19 00:09:47'),
(251, 1, 'Equations', 1000, 134217728, 0000000000, 0000000000, '<div>\r\n	Given 2 equations on the variables&nbsp;<i>x</i>&nbsp;and&nbsp;<i>y</i>, solve for&nbsp;<i>x</i>&nbsp;and&nbsp;<i>y</i>.\r\n	<p>\r\n		The first line of input contains N, the number of test cases. Each test case consists of two equations, each on a separate line. An empty line separates cases. An equation consists of two or more terms separated by addition, subtraction, or equality operators. A term is an integer, or a variable name (<i>x</i>&nbsp;or&nbsp;<i>y</i>) optionally preceded by a minus sign or an integer coefficient. There is exactly one equality operator. All operators are surrounded by spaces, and there are no spaces within terms. For each case, print two lines, giving the values of&nbsp;<i>x</i>&nbsp;and&nbsp;<i>y</i>&nbsp;as rationals in simplest terms. If&nbsp;<i>x</i>&nbsp;or&nbsp;<i>y</i>&nbsp;has no unique rational value such that both equations hold, print &quot;don&#39;t know&quot; for its value. Print an empty line between cases.</p>\r\n</div>\r\n', 'http://plg1.cs.uwaterloo.ca/~acm00/020928/A.html', '', '', '7\r\n2x + 3y = x\r\n5 = x + y + 3\r\n\r\n2x + 3y = 0\r\n10x = -15y\r\n\r\n2x + 3y = 0\r\n10x = -15y + 1\r\n\r\nx = 1\r\n3x = 6y\r\n\r\n2x = 3x + -x + y\r\nx + y = x + y\r\n\r\n2x = -3\r\n-2y = 3\r\n\r\n1 = 2\r\nx = 3\r\n', '3\r\n-1\r\n\r\ndon''t know\r\ndon''t know\r\n\r\ndon''t know\r\ndon''t know\r\n\r\n1\r\n1/2\r\n\r\ndon''t know\r\n0\r\n\r\n-3/2\r\n-3/2\r\n\r\ndon''t know\r\ndon''t know\r\n', '', 0, 0, '2010-08-19 00:27:17', '2010-10-11 13:16:12'),
(252, 1, 'Euclid''s Game', 1000, 134217728, 0000000000, 0000000000, '<p>Two players, Stan and Ollie, play, starting with two natural numbers. Stan, the first player, subtracts any positive multiple of the lesser of the two numbers from the greater of the two numbers, provided that the resulting number must be nonnegative. Then Ollie, the second player, does the same with the two resulting numbers, then Stan, etc., alternately, until one player is able to subtract a multiple of the lesser number from the greater to reach 0, and thereby wins. For example, the players may start with (25,7):</p>\r\n<pre>\r\n         25 7\r\n         11 7\r\n          4 7\r\n          4 3\r\n          1 3\r\n          1 0\r\n</pre>\r\n<p>an Stan wins.</p>\r\n<p>The input consists of a number of lines.  Each line contains two positive integers giving the starting two numbers of the game. Stan always starts.</p>\r\n<p>For each line of input, output one line saying either <tt>Stan wins</tt> or <tt>Ollie wins</tt> assuming that both of them play perfectly. The last line of input contains two zeroes and should not be processed.</p>', '', '', '', '34 12\r\n15 24\r\n0 0\r\n', 'Stan wins\r\nOllie wins\r\n', '', 0, 0, '2010-08-19 00:27:17', '2010-08-19 00:27:17'),
(253, 1, 'Arctic Network', 1000, 134217728, 0000000000, 0000000000, '<p>The Department of National Defence (DND) wishes to connect several northern outposts by a wireless network.  Two different communication technologies are to be used in establishing the network:  every outpost will have a  radio transceiver and some outposts will in addition have a satellite  channel.</p>\r\n<p>Any two outposts with a satellite channel can communicate via the satellite, regardless of their location.  Otherwise, two  outposts can communicate by radio only if the distance between them does not exceed D, which depends of the power of the transceivers.   Higher power yields higher D but costs more.   Due to purchasing and maintenance considerations, the transceivers at the outposts must be identical; that is, the value of D is the same for every pair of outposts.</p>\r\n<p>Your job is to determine the minimum D required for the transceivers.  There must be at least one communication path (direct or indirect) between every pair of outposts.</p>\r\n<p>The first line of input contains N, the number of test cases.  The first line of each test case contains 1 &lt;= S &lt;= 100, the number of satellite channels,  and S &lt; P &lt;= 500, the number of outposts.  P lines follow, giving the (x,y) coordinates of each outpost in km (coordinates are integers between 0 and 10,000).   For each case, output should consist of a single line giving the minimum D required to connect the network. Output should be specified to 2 decimal points.</p>', '', '', '', '1\r\n2 4\r\n0 100\r\n0 300\r\n0 600\r\n150 750\r\n', '212.13\r\n', '', 0, 0, '2010-08-19 00:27:17', '2010-08-19 00:27:17'),
(254, 1, 'Above Average', 1000, 134217728, 0000000000, 0000000000, '<p>It is said that 90% of frosh expect to be above average in their class.  You are to provide a reality check.</p>\r\n<p>The first line of standard input contains an integer C, the number of test cases.  C data sets follow.  Each data set begins with an integer, N, the number of people in the class (1 &lt;= N &lt;= 1000). N integers follow, separated by spaces or newlines, each giving the final grade (an integer between 0 and 100)  of a student in the class.  For each case you are to output a line giving the percentage of students whose grade is above average, rounded to 3 decimal places.</p>', '', '', '', '5\r\n5 50 50 70 80 100\r\n7 100 95 90 80 70 60 50\r\n3 70 90 80\r\n3 70 90 81\r\n9 100 99 98 97 96 95 94 93 91\r\n', '40.000%\r\n57.143%\r\n33.333%\r\n66.667%\r\n55.556%\r\n', '', 0, 0, '2010-08-19 00:27:17', '2010-08-19 00:27:17'),
(255, 1, 'Time Zones', 1000, 134217728, 0000000000, 0000000000, '<img align="right" src="http://plg1.cs.uwaterloo.ca/%7Eacm00/020928/time.gif" alt="" />\r\n<p>Prior to the late nineteenth century, time keeping was a purely local phenomenon. Each town would set their clocks to noon when the sun reached its zenith each day. A clockmaker or town clock would be the &quot;official&quot; time and the citizens would set their pocket watches and clocks to the time of the town - enterprising citizens would offer their services as mobile clock setters, carrying a watch with the accurate time to adjust the clocks in customer''s homes on a weekly basis. Travel between cities meant having to change one''s pocket watch upon arrival.</p>\r\n<p>However, once railroads began to operate and move people rapidly across great distances, time became much more critical. In the early years of the railroads, the schedules were very confusing because each stop was based on a different local time.  The standardization of time was essential to efficient operation of railroads.</p>\r\n<p>In 1878, Canadian Sir Sanford Fleming proposed the system of worldwide time zones that we use today. He recommended that the world be divided into twenty-four time zones, each spaced 15 degrees of longitude apart. Since the earth rotates once every 24 hours and there are 360 degrees of longitude, each hour the earth rotates one-twenty-fourth of a circle or 15� of longitude. Sir Fleming''s time zones were heralded as a brilliant solution to a chaotic problem worldwide.</p>\r\n<p>United States railroad companies began utilizing Fleming''s standard time zones on November 18, 1883. In 1884 an International Prime Meridian Conference was held in Washington D.C. to standardize time and select the Prime Meridian. The conference selected the longitude of Greenwich, England as zero degrees longitude and established the 24 time zones based on the Prime Meridian. Although the time zones had been established, not all countries switched immediately. Though most U.S. states began to adhere to the Pacific, Mountain, Central, and Eastern time zones by 1895, Congress didn''t make the use of these time zones mandatory until the Standard Time Act of 1918.</p>\r\n<p>Today, many countries operate on variations of the time zones proposed by Sir Fleming. All of China (which should span five time zones) uses a single time zone - eight hours ahead of Coordinated Universal Time (known by the abbreviation UTC - based on the time zone running through Greenwich at 0� longitude). Russia adheres to its designated time zones although the entire country is on permanent Daylight Saving Time and is an hour ahead of their actual zones. Australia uses three time zones - its central time zone is a half-hour ahead of its designated time zone. Several countries in the Middle East and South Asia also utilize half-hour time zones.</p>\r\n<p>Since time zones are based on segments of longitude and lines of longitude narrow at the poles, scientists working at the North and South Poles simply use UTC time. Otherwise, Antarctica would be divided into 24 very thin time zones!</p>\r\n<p>Time zones have recently been given standard capital-letter abbreviations as follows:</p>\r\n<pre>\r\nUTC Coordinated Universal Time\r\nGMT Greenwich Mean Time, defined as UTC\r\nBST British Summer Time, defined as UTC+1 hour\r\nIST Irish Summer Time, defined as UTC+1 hour\r\nWET Western Europe Time, defined as UTC\r\nWEST Western Europe Summer Time, defined as UTC+1 hour\r\nCET Central Europe Time, defined as UTC+1\r\nCEST Central Europe Summer Time, defined as UTC+2\r\nEET Eastern Europe Time, defined as UTC+2\r\nEEST Eastern Europe Summer Time, defined as UTC+3\r\nMSK Moscow Time, defined as UTC+3\r\nMSD Moscow Summer Time, defined as UTC+4\r\nAST Atlantic Standard Time, defined as UTC-4 hours\r\nADT Atlantic Daylight Time, defined as UTC-3 hours\r\nNST Newfoundland Standard Time, defined as UTC-3.5 hours\r\nNDT Newfoundland Daylight Time, defined as UTC-2.5 hours\r\nEST Eastern Standard Time, defined as UTC-5 hours\r\nEDT Eastern Daylight Saving Time, defined as UTC-4 hours\r\nCST Central Standard Time, defined as UTC-6 hours\r\nCDT Central Daylight Saving Time, defined as UTC-5 hours\r\nMST Mountain Standard Time, defined as UTC-7 hours\r\nMDT Mountain Daylight Saving Time, defined as UTC-6 hours\r\nPST Pacific Standard Time, defined as UTC-8 hours\r\nPDT Pacific Daylight Saving Time, defined as UTC-7 hours\r\nHST Hawaiian Standard Time, defined as UTC-10 hours\r\nAKST Alaska Standard Time, defined as UTC-9 hours\r\nAKDT Alaska Standard Daylight Saving Time, defined as UTC-8 hours\r\nAEST Australian Eastern Standard Time, defined as UTC+10 hours \r\nAEDT Australian Eastern Daylight Time, defined as UTC+11 hours \r\nACST Australian Central Standard Time, defined as UTC+9.5 hours \r\nACDT Australian Central Daylight Time, defined as UTC+10.5 hours \r\nAWST Australian Western Standard Time, defined as UTC+8 hours \r\n</pre>\r\n<p>Given the current time in one time zone, you are to compute what time it is in another time zone.  The first line of input contains N, the number of test cases. For each case a line is given with a time, and 2 time zone abbreviations.   Time is given in standard a.m./p.m. format with midnight denoted &quot;midnight&quot;  and noon denoted &quot;noon&quot; (12:00 a.m. and 12:00 p.m. are oxymorons). Assuming the given time is the current time in the first time zone, give the current time in the second time zone.</p>', '', '', '', '4\r\nnoon HST CEST \r\n11:29 a.m. EST GMT\r\n6:01 p.m. CST UTC\r\n12:40 p.m. ADT MSK\r\n', 'midnight\r\n4:29 p.m.\r\n12:01 a.m.\r\n6:40 p.m.\r\n', '', 0, 0, '2010-08-19 00:27:17', '2010-08-19 00:27:17'),
(256, 1, 'Equations', 1000, 134217728, 0000000000, 0000000000, '<p>Given 2 equations on the variables</p>\r\n<i>x</i>\r\n<p>and</p>\r\n<i>y</i>\r\n<p>, solve for</p>\r\n<i>x</i>\r\n<p>and</p>\r\n<i>y</i>\r\n<p>.</p>\r\n<p>The first line of input contains N, the number of test cases.  Each test case consists of two equations, each on a separate line.  An empty line separates cases.  An equation consists of two or more terms separated by addition,  subtraction, or equality operators.  A term is an integer, or a variable name (<i>x</i> or <i>y</i>) optionally preceded by a minus sign or an integer coefficient.  There is exactly one equality operator.  All operators are surrounded by spaces, and there are no spaces within terms.  For each case, print two lines, giving the values of <i>x</i> and <i>y</i> as rationals in simplest terms.  If <i>x</i> or <i>y</i> has no unique rational value such that both equations hold, print &quot;don''t know&quot; for its value.  Print an empty line between cases.</p>', 'http://plg1.cs.uwaterloo.ca/~acm00/020928/A.html', '', '', '7\r\n2x + 3y = x\r\n5 = x + y + 3\r\n\r\n2x + 3y = 0\r\n10x = -15y\r\n\r\n2x + 3y = 0\r\n10x = -15y + 1\r\n\r\nx = 1\r\n3x = 6y\r\n\r\n2x = 3x + -x + y\r\nx + y = x + y\r\n\r\n2x = -3\r\n-2y = 3\r\n\r\n1 = 2\r\nx = 3\r\n', '3\r\n-1\r\n\r\ndon''t know\r\ndon''t know\r\n\r\ndon''t know\r\ndon''t know\r\n\r\n1\r\n1/2\r\n\r\ndon''t know\r\n0\r\n\r\n-3/2\r\n-3/2\r\n\r\ndon''t know\r\ndon''t know\r\n', '', 0, 0, '2010-08-19 00:27:38', '2010-08-19 00:27:38'),
(257, 1, 'Euclid''s Game', 1000, 134217728, 0000000000, 0000000000, '<p>Two players, Stan and Ollie, play, starting with two natural numbers. Stan, the first player, subtracts any positive multiple of the lesser of the two numbers from the greater of the two numbers, provided that the resulting number must be nonnegative. Then Ollie, the second player, does the same with the two resulting numbers, then Stan, etc., alternately, until one player is able to subtract a multiple of the lesser number from the greater to reach 0, and thereby wins. For example, the players may start with (25,7):</p>\r\n<pre>\r\n         25 7\r\n         11 7\r\n          4 7\r\n          4 3\r\n          1 3\r\n          1 0\r\n</pre>\r\n<p>an Stan wins.</p>\r\n<p>The input consists of a number of lines.  Each line contains two positive integers giving the starting two numbers of the game. Stan always starts.</p>\r\n<p>For each line of input, output one line saying either <tt>Stan wins</tt> or <tt>Ollie wins</tt> assuming that both of them play perfectly. The last line of input contains two zeroes and should not be processed.</p>', '', '', '', '34 12\r\n15 24\r\n0 0\r\n', 'Stan wins\r\nOllie wins\r\n', '', 0, 0, '2010-08-19 00:27:38', '2010-08-19 00:27:38'),
(258, 1, 'Arctic Network', 1000, 134217728, 0000000000, 0000000000, '<p>The Department of National Defence (DND) wishes to connect several northern outposts by a wireless network.  Two different communication technologies are to be used in establishing the network:  every outpost will have a  radio transceiver and some outposts will in addition have a satellite  channel.</p>\r\n<p>Any two outposts with a satellite channel can communicate via the satellite, regardless of their location.  Otherwise, two  outposts can communicate by radio only if the distance between them does not exceed D, which depends of the power of the transceivers.   Higher power yields higher D but costs more.   Due to purchasing and maintenance considerations, the transceivers at the outposts must be identical; that is, the value of D is the same for every pair of outposts.</p>\r\n<p>Your job is to determine the minimum D required for the transceivers.  There must be at least one communication path (direct or indirect) between every pair of outposts.</p>\r\n<p>The first line of input contains N, the number of test cases.  The first line of each test case contains 1 &lt;= S &lt;= 100, the number of satellite channels,  and S &lt; P &lt;= 500, the number of outposts.  P lines follow, giving the (x,y) coordinates of each outpost in km (coordinates are integers between 0 and 10,000).   For each case, output should consist of a single line giving the minimum D required to connect the network. Output should be specified to 2 decimal points.</p>', '', '', '', '1\r\n2 4\r\n0 100\r\n0 300\r\n0 600\r\n150 750\r\n', '212.13\r\n', '', 0, 0, '2010-08-19 00:27:38', '2010-08-19 00:27:38'),
(259, 1, 'Above Average', 1000, 134217728, 0000000000, 0000000000, '<p>It is said that 90% of frosh expect to be above average in their class.  You are to provide a reality check.</p>\r\n<p>The first line of standard input contains an integer C, the number of test cases.  C data sets follow.  Each data set begins with an integer, N, the number of people in the class (1 &lt;= N &lt;= 1000). N integers follow, separated by spaces or newlines, each giving the final grade (an integer between 0 and 100)  of a student in the class.  For each case you are to output a line giving the percentage of students whose grade is above average, rounded to 3 decimal places.</p>', '', '', '', '5\r\n5 50 50 70 80 100\r\n7 100 95 90 80 70 60 50\r\n3 70 90 80\r\n3 70 90 81\r\n9 100 99 98 97 96 95 94 93 91\r\n', '40.000%\r\n57.143%\r\n33.333%\r\n66.667%\r\n55.556%\r\n', '', 0, 0, '2010-08-19 00:27:38', '2010-08-19 00:27:38'),
(260, 1, 'Time Zones', 1000, 134217728, 0000000000, 0000000000, '<img align="right" src="http://plg1.cs.uwaterloo.ca/%7Eacm00/020928/time.gif" alt="" />\r\n<p>Prior to the late nineteenth century, time keeping was a purely local phenomenon. Each town would set their clocks to noon when the sun reached its zenith each day. A clockmaker or town clock would be the &quot;official&quot; time and the citizens would set their pocket watches and clocks to the time of the town - enterprising citizens would offer their services as mobile clock setters, carrying a watch with the accurate time to adjust the clocks in customer''s homes on a weekly basis. Travel between cities meant having to change one''s pocket watch upon arrival.</p>\r\n<p>However, once railroads began to operate and move people rapidly across great distances, time became much more critical. In the early years of the railroads, the schedules were very confusing because each stop was based on a different local time.  The standardization of time was essential to efficient operation of railroads.</p>\r\n<p>In 1878, Canadian Sir Sanford Fleming proposed the system of worldwide time zones that we use today. He recommended that the world be divided into twenty-four time zones, each spaced 15 degrees of longitude apart. Since the earth rotates once every 24 hours and there are 360 degrees of longitude, each hour the earth rotates one-twenty-fourth of a circle or 15� of longitude. Sir Fleming''s time zones were heralded as a brilliant solution to a chaotic problem worldwide.</p>\r\n<p>United States railroad companies began utilizing Fleming''s standard time zones on November 18, 1883. In 1884 an International Prime Meridian Conference was held in Washington D.C. to standardize time and select the Prime Meridian. The conference selected the longitude of Greenwich, England as zero degrees longitude and established the 24 time zones based on the Prime Meridian. Although the time zones had been established, not all countries switched immediately. Though most U.S. states began to adhere to the Pacific, Mountain, Central, and Eastern time zones by 1895, Congress didn''t make the use of these time zones mandatory until the Standard Time Act of 1918.</p>\r\n<p>Today, many countries operate on variations of the time zones proposed by Sir Fleming. All of China (which should span five time zones) uses a single time zone - eight hours ahead of Coordinated Universal Time (known by the abbreviation UTC - based on the time zone running through Greenwich at 0� longitude). Russia adheres to its designated time zones although the entire country is on permanent Daylight Saving Time and is an hour ahead of their actual zones. Australia uses three time zones - its central time zone is a half-hour ahead of its designated time zone. Several countries in the Middle East and South Asia also utilize half-hour time zones.</p>\r\n<p>Since time zones are based on segments of longitude and lines of longitude narrow at the poles, scientists working at the North and South Poles simply use UTC time. Otherwise, Antarctica would be divided into 24 very thin time zones!</p>\r\n<p>Time zones have recently been given standard capital-letter abbreviations as follows:</p>\r\n<pre>\r\nUTC Coordinated Universal Time\r\nGMT Greenwich Mean Time, defined as UTC\r\nBST British Summer Time, defined as UTC+1 hour\r\nIST Irish Summer Time, defined as UTC+1 hour\r\nWET Western Europe Time, defined as UTC\r\nWEST Western Europe Summer Time, defined as UTC+1 hour\r\nCET Central Europe Time, defined as UTC+1\r\nCEST Central Europe Summer Time, defined as UTC+2\r\nEET Eastern Europe Time, defined as UTC+2\r\nEEST Eastern Europe Summer Time, defined as UTC+3\r\nMSK Moscow Time, defined as UTC+3\r\nMSD Moscow Summer Time, defined as UTC+4\r\nAST Atlantic Standard Time, defined as UTC-4 hours\r\nADT Atlantic Daylight Time, defined as UTC-3 hours\r\nNST Newfoundland Standard Time, defined as UTC-3.5 hours\r\nNDT Newfoundland Daylight Time, defined as UTC-2.5 hours\r\nEST Eastern Standard Time, defined as UTC-5 hours\r\nEDT Eastern Daylight Saving Time, defined as UTC-4 hours\r\nCST Central Standard Time, defined as UTC-6 hours\r\nCDT Central Daylight Saving Time, defined as UTC-5 hours\r\nMST Mountain Standard Time, defined as UTC-7 hours\r\nMDT Mountain Daylight Saving Time, defined as UTC-6 hours\r\nPST Pacific Standard Time, defined as UTC-8 hours\r\nPDT Pacific Daylight Saving Time, defined as UTC-7 hours\r\nHST Hawaiian Standard Time, defined as UTC-10 hours\r\nAKST Alaska Standard Time, defined as UTC-9 hours\r\nAKDT Alaska Standard Daylight Saving Time, defined as UTC-8 hours\r\nAEST Australian Eastern Standard Time, defined as UTC+10 hours \r\nAEDT Australian Eastern Daylight Time, defined as UTC+11 hours \r\nACST Australian Central Standard Time, defined as UTC+9.5 hours \r\nACDT Australian Central Daylight Time, defined as UTC+10.5 hours \r\nAWST Australian Western Standard Time, defined as UTC+8 hours \r\n</pre>\r\n<p>Given the current time in one time zone, you are to compute what time it is in another time zone.  The first line of input contains N, the number of test cases. For each case a line is given with a time, and 2 time zone abbreviations.   Time is given in standard a.m./p.m. format with midnight denoted &quot;midnight&quot;  and noon denoted &quot;noon&quot; (12:00 a.m. and 12:00 p.m. are oxymorons). Assuming the given time is the current time in the first time zone, give the current time in the second time zone.</p>', '', '', '', '4\r\nnoon HST CEST \r\n11:29 a.m. EST GMT\r\n6:01 p.m. CST UTC\r\n12:40 p.m. ADT MSK\r\n', 'midnight\r\n4:29 p.m.\r\n12:01 a.m.\r\n6:40 p.m.\r\n', '', 0, 0, '2010-08-19 00:27:38', '2010-08-19 00:27:38'),
(261, 1, 'Hay Points', 1000, 134217728, 0000000000, 0000000000, '<p>\r\n	<img align="right" alt="" src="http://plg1.cs.uwaterloo.ca/~acm00/020601/haystack.jpg" />Each employee of a bureaucracy has a <i>job description</i> - a few paragraphs that describe the responsibilities of the job. The employee&#39;s job description, combined with other factors, such as seniority, is used to determine his or her salary.</p>\r\n<p>\r\n	The <i>Hay Point</i> system frees the Human Resources department from having to make an intelligent judgement as to the value of the employee; the job description is merely scanned for words and phrases that indicate responsibility. In particular, job descriptions that indicate control over a large budget or management over a large number of people yield high Hay Point scores.</p>\r\n<p>\r\n	You are to implement a simplified Hay Point system. You will be given a Hay Point dictionary and a number of job descriptions. For each job description you are to compute the salary associated with the job, according to the system.</p>\r\n', 'http://plg1.cs.uwaterloo.ca/~acm00/020601/A.html', '<p>\r\n	The first line of input contains 2 positive integers:&nbsp;<i>m &lt;= 1000</i>, the number of words in the Hay Point dictionary, and&nbsp;<i>n &lt;= 100</i>, the number of job descriptions.&nbsp;<i>m&nbsp;</i>lines follow; each contains a word (a string of up to 16 lower-case letters) and a dollar value (a real number between 0 and 1,000,000). Following the dictionary are the&nbsp;<i>n</i>&nbsp;job descriptions. Each job description consists of one or more lines of text; for your convenience the text has been converted to lower case and has no characters other than letters, numbers, and spaces. Each job description is terminated by a line containing a period.</p>\r\n', '<p>\r\n	For each job description, output the corresponding salary computed as the sum of the Hay Point values for all words that appear in the description. Words that do not appear in the dictionary have a value of 0.</p>\r\n', '7 2\r\nadminister 100000\r\nspending 200000\r\nmanage 50000\r\nresponsibility 25000\r\nexpertise 100\r\nskill 50\r\nmoney 75000\r\nthe incumbent will administer the spending of kindergarden milk money\r\nand exercise responsibility for making change he or she will share\r\nresponsibility for the task of managing the money with the assistant\r\nwhose skill and expertise shall ensure the successful spending exercise\r\n.\r\nthis individual must have the skill to perform a heart transplant and\r\nexpertise in rocket science\r\n.\r\n', '700150\r\n150\r\n', '', 0, 0, '2010-08-19 00:28:15', '2010-11-21 20:26:52'),
(262, 1, 'Jogging Trails', 1000, 134217728, 0000000000, 0000000000, '<p>\r\n	Gord is training for a marathon. Behind his house is a park with a large network of jogging trails connecting water stations. Gord wants to find the shortest jogging route that travels along every trail at least once.</p>\r\n', 'http://plg1.cs.uwaterloo.ca/~acm00/020601/B.html', '<p>\r\n	Input consists of several test cases. The first line of input for each case contains two positive integers:&nbsp;<i>n &lt;= 15</i>, the number of water stations, and&nbsp;<i>m &lt; 1000</i>, the number of trails. For each trail, there is one subsequent line of input containing three positive integers: the first two, between 1 and&nbsp;<i>n</i>, indicating the water stations at the end points of the trail; the third indicates the length of the trail, in cubits. There may be more than one trail between any two stations; each different trail is given only once in the input; each trail can be travelled in either direction. It is possible to reach any trail from any other trail by visiting a sequence of water stations connected by trails. Gord&#39;s route may start at any water station, and must end at the same station. A single line containing 0 follows the last test case.</p>\r\n', '<p>\r\n	For each case, there should be one line of output giving the length of Gord&#39;s jogging route.</p>\r\n', '4 5\r\n1 2 3\r\n2 3 4\r\n3 4 5\r\n1 4 10\r\n1 3 12\r\n0\r\n', '41\r\n', '', 0, 0, '2010-08-19 00:28:15', '2010-11-22 08:59:54'),
(263, 1, 'Beavergnaw ', 1000, 134217728, 0000000000, 0000000000, '<p>\r\n	When chomping a tree the beaver cuts a very specific shape out of the tree trunk. What is left in the tree trunk looks like two frustums of a cone joined by a cylinder with the diameter the same as its height. A very curious beaver tries not to demolish a tree but rather sort out what should be the diameter of the cylinder joining the frustums such that he chomped out certain amount of wood. You are to help him to do the calculations.</p>\r\n<p>\r\n	<img align="right" alt="" hspace="10" src="http://plg1.cs.uwaterloo.ca/~acm00/020601/draw.jpg" vspace="10" /> <img align="left" alt="" hspace="10" src="http://plg1.cs.uwaterloo.ca/~acm00/020601/beaver5.gif" vspace="10" /> We will consider an idealized beaver chomping an idealized tree. Let us assume that the tree trunk is a cylinder of diameter <b>D</b> and that the beaver chomps on a segment of the trunk also of height <b>D</b>. What should be the diameter <b>d</b> of the inner cylinder such that the beaver chmped out <b>V</b> cubic units of wood?</p>\r\n<p>\r\n	Input contains multiple cases each presented on a separate line. Each line contains two integer numbers <b>D</b> and <b>V</b> separated by whitespace. <b>D</b> is the linear units and <b>V</b> is in cubic units. <b>V</b> will not exceed the maximum volume of wood that the beaver can chomp. A line with <b>D</b>=0 and <b>V</b>=0 follows the last case.</p>\r\n<p>\r\n	For each case, one line of output should be produced containing one number rounded to three fractional digits giving the value of <b>d</b> measured in linear units.</p>\r\n', 'http://plg1.cs.uwaterloo.ca/~acm00/020601/C.html', '', '', '10 250\r\n20 2500\r\n25 7000\r\n50 50000\r\n0 0\r\n', '8.054\r\n14.775\r\n13.115\r\n30.901\r\n', '', 0, 0, '2010-08-19 00:28:15', '2010-11-22 09:40:26');
INSERT INTO `tbl_problems` (`id`, `user_id`, `title`, `time_limit`, `memory_limit`, `submission_no`, `accepted_no`, `description`, `source`, `input`, `output`, `input_sample`, `output_sample`, `hint`, `flag`, `visibility`, `created`, `modified`) VALUES
(264, 1, 'Power Strings', 1000, 134217728, 0000000000, 0000000000, '<p>\r\n	Given two strings <i>a</i> and <i>b</i> we define <i>a*b</i> to be their concatenation. For example, if <i>a = &quot;abc&quot;</i> and <i>b = &quot;def&quot;</i> then <i>a*b = &quot;abcdef&quot;</i>. If we think of concatenation as multiplication, exponentiation by a non-negative integer is defined in the normal way: <i>a^0 = &quot;&quot;</i> (the empty string) and <i>a^(n+1) = a*(a^n)</i>.</p>\r\n<p>\r\n	Each test case is a line of input representing <i>s</i>, a string of printable characters. For each <i>s</i> you should print the largest <i>n</i> such that <i>s = a^n</i> for some string <i>a</i>. The length of <i>s</i> will be at least 1 and will not exceed 1 million characters. A line containing a period follows the last test case.</p>\r\n', 'http://plg1.cs.uwaterloo.ca/~acm00/020601/D.html', '', '', 'abcd\r\naaaa\r\nababab\r\n.\r\n', '1\r\n4\r\n3\r\n', '', 0, 0, '2010-08-19 00:28:15', '2010-11-22 10:57:54'),
(265, 1, 'Relatives', 1000, 134217728, 0000000000, 0000000000, '<p>\r\n	Given <i>n</i>, a positive integer, how many positive integers less than <i>n</i> are relatively prime to <i>n</i>? Two integers <i>a</i> and <i>b</i> are relatively prime if there are no integers&nbsp;<i>x &gt; 1, y &gt; 0, z &gt; 0</i> such that <i>a = xy</i> and <i>b = xz</i>.There are several test cases. For each test case, standard input contains a line with <i>n &lt;= 1,000,000,000</i>. A line containing 0 follows the last case.For each test case there should be single line of output answering the question posed above.</p>\r\n', 'http://plg1.cs.uwaterloo.ca/~acm00/020601/E.html', '', '', '7\r\n12\r\n0\r\n', '6\r\n4\r\n', '', 0, 0, '2010-08-19 00:28:16', '2010-11-22 13:43:09'),
(266, 1, 'Return of the Jedi', 1000, 134217728, 0000000000, 0000000000, '<p>\r\n	<img align="right" alt="" src="http://plg1.cs.uwaterloo.ca/~acm00/020126/jedi.jpg" /></p>\r\n<div>\r\n	Luke Skywalker races through the forest on a speeder bike, trying to outrun a patrol of Imperial scouts on Endor. A small moon near a new Death Star, Endor is covered by dense foliage and a thick forest of ancient towering trees. The speeder bike , which Luke stole from an Imperial scout, is an antigravity vehicle capable of speeds of 200 miles an hour. How quickly can Luke reach Princess Leia in the Ewok village?</div>\r\n<div>\r\n	The forest is a plane with T trees. Luke&#39;s position is specified by a pair of coordinates ( x<sub>luke</sub> , y<sub>luke</sub> ) within the plane. The Ewok village has coordinates ( x<sub>ewok</sub> , y<sub>ewok</sub> ). You are to find the shortest travel time from Luke&#39;s position to the Ewok village.</div>\r\n<div>\r\n	&nbsp;</div>\r\n<div>\r\n	&nbsp;</div>\r\n<p>\r\n	&nbsp;</p>', 'http://plg1.cs.uwaterloo.ca/~acm00/020126/A.html', '<p>\r\n	The first line of input contains T, x<sub>luke</sub>&nbsp;, y<sub>luke</sub>&nbsp;x<sub>ewok</sub>&nbsp;, y<sub>ewok</sub>&nbsp;. T lines follow; each gives the coordinates and diameter of a tree: x<sub>tree<sub>i</sub></sub>&nbsp;, y<sub>tree<sub>i</sub></sub>&nbsp;, d<sub>tree<sub>i</sub></sub>&nbsp;. T is an integer not exceeding 10; coordinates and diameters are real numbers in miles. Trees do not intersect or touch one another.</p>\r\n', '<p>\r\n	Output is a single real number, to two decimal places, giving the minimum travel time in seconds.</p>\r\n', '2 0.0 0.0 10.0 0.0\r\n4.0 0.0 1.0\r\n6.0 0.0 1.0\r\n', '181.13\r\n', '', 0, 0, '2010-08-19 00:29:22', '2010-11-22 20:46:10'),
(267, 1, 'Problem B:  Discrete Logging', 1000, 134217728, 0000000000, 0000000000, '<p><img align="right" src="http://plg1.cs.uwaterloo.ca/~acm00/020126/woodchop.jpg" alt="" /></p>\r\n<h2>Problem B:  Discrete Logging</h2>\r\n<p>Given a prime P, 2 &lt;= P &lt; 2<sup>31</sup>, an integer B, 2 &lt;= B &lt; P, and an integer N, 2 &lt;= N &lt; P, compute the discrete logarithm of N, base B, modulo P. That is, find an integer L such that</p>\r\n<pre>\r\n    B<sup>L</sup> == N (mod P)\r\n</pre>\r\n<p>Read several lines of input, each containing P,B,N separated by a space, and for each line print the logarithm on a separate line.  If there are several, print the smallest; if there is none, print &quot;no solution&quot;.</p>\r\n<p>The solution to this problem requires a well known result in number theory  that is probably expected of you for Putnam but not ACM competitions.  It is Fermat''s theorem  that states</p>\r\n<pre>\r\n   B<sup>(P-1)</sup> == 1 (mod P)\r\n</pre>\r\n<p>for any prime P and some other (fairly rare) numbers known as base-B pseudoprimes.  A rarer subset of the base-B pseudoprimes, known as Carmichael numbers, are pseudoprimes for every base between 2 and P-1. A corollary to Fermat''s theorem is that for any m</p>\r\n<pre>\r\n   B<sup>(-m)</sup> == B<sup>(P-1-m)</sup> (mod P) .\r\n</pre>', '', '', '', '5 2 1\r\n5 2 2\r\n5 2 3\r\n5 2 4\r\n5 3 1\r\n5 3 2\r\n5 3 3\r\n5 3 4\r\n5 4 1\r\n5 4 2\r\n5 4 3\r\n5 4 4\r\n12345701 2 1111111\r\n1111111121 65537 1111111111\r\n', '0\r\n1\r\n3\r\n2\r\n0\r\n3\r\n1\r\n2\r\n0\r\nno solution\r\nno solution\r\n1\r\n9584351\r\n462803587\r\n', '', 0, 0, '2010-08-19 00:29:22', '2010-08-19 00:29:22'),
(268, 1, 'Hardwood Species', 2000, 134217728, 0000000000, 0000000000, '<p>\r\n	<img align="right" alt="" src="http://plg1.cs.uwaterloo.ca/~acm00/020126/pitchpine.gif" /></p>\r\n<h2>\r\n	<span class="Apple-style-span" style="font-weight: normal; font-size: 12px; ">Hardwoods are the botanical group of trees that have broad leaves, produce a fruit or nut, and generally go dormant in the winter.</span></h2>\r\n<p>\r\n	America&#39;s temperate climates produce forests with hundreds of hardwood species -- trees that share certain biological characteristics. Although oak, maple and cherry all are types of hardwood trees, for example, they are different species. Together, all the hardwood species represent 40 percent of the trees in the United States.</p>\r\n<p>\r\n	On the other hand, softwoods, or conifers, from the Latin word meaning &quot;cone-bearing,&quot; have needles. Widely available US softwoods include cedar, fir, hemlock, pine, redwood, spruce and cypress. In a home, the softwoods are used primarily as structural lumber such as 2x4s and 2x6s, with some limited decorative applications.</p>\r\n<p>\r\n	Using satellite imaging technology, the Department of Natural Resources has compiled an inventory of every tree standing on a particular day. You are to compute the total fraction of the tree population represented by each species.</p>\r\n<p>\r\n	Input to your program consists of a list of the species of every tree observed by the satellite; one tree per line. No species name exceeds 30 characters. There are no more than 10,000 species and no more than 1,000,000 trees.</p>\r\n<p>\r\n	Print the name of each species represented in the population, in alphabetical order, followed by the percentage of the population it represents, to 4 decimal places.</p>\r\n', '', '<br />\r\n', '<br />\r\n', 'Red Alder\r\nAsh\r\nAspen\r\nBasswood\r\nAsh\r\nBeech\r\nYellow Birch\r\nAsh\r\nCherry\r\nCottonwood\r\nAsh\r\nCypress\r\nRed Elm\r\nGum\r\nHackberry\r\nWhite Oak\r\nHickory\r\nPecan\r\nHard Maple\r\nWhite Oak\r\nSoft Maple\r\nRed Oak\r\nRed Oak\r\nWhite Oak\r\nPoplan\r\nSassafras\r\nSycamore\r\nBlack Walnut\r\nWillow\r\n', 'Ash 13.7931\r\nAspen 3.4483\r\nBasswood 3.4483\r\nBeech 3.4483\r\nBlack Walnut 3.4483\r\nCherry 3.4483\r\nCottonwood 3.4483\r\nCypress 3.4483\r\nGum 3.4483\r\nHackberry 3.4483\r\nHard Maple 3.4483\r\nHickory 3.4483\r\nPecan 3.4483\r\nPoplan 3.4483\r\nRed Alder 3.4483\r\nRed Elm 3.4483\r\nRed Oak 6.8966\r\nSassafras 3.4483\r\nSoft Maple 3.4483\r\nSycamore 3.4483\r\nWhite Oak 10.3448\r\nWillow 3.4483\r\nYellow Birch 3.4483\r\n', '', 0, 0, '2010-08-19 00:29:22', '2011-01-25 19:35:17'),
(269, 1, 'Problem D:  Forests', 1000, 134217728, 0000000000, 0000000000, '<p><img align="right" src="http://plg1.cs.uwaterloo.ca/~acm00/020126/treefall.jpg" alt="" /></p>\r\n<h2>Problem D:  Forests</h2>\r\n<p>If a tree falls in the forest, and there''s nobody there to hear, does it make a sound?  This classic conundrum was coined by George Berkeley (1685-1753), the Bishop and influential Irish philosopher whose primary philosophical achievement is the advancement of what has come to be called <i>subjective idealism</i>.  He wrote a number of works, of which the most widely-read are <i>Treatise Concerning the Principles of Human Knowledge</i> (1710) and <i>Three Dialogues between Hylas and Philonous</i> (1713) (Philonous, the &quot;lover of the mind,&quot; representing Berkeley himself).</p>\r\n<p>A forest contains <i>T</i> trees numbered from 1 to <i>T</i> and <i>P</i>  people numbered from 1 to <i>P</i>.  Standard input consists of a line containing <i>T</i> and <i>P</i> followed by several lines,  containing a pair of integers <i>i</i> and <i>j</i>,  indicating that person <i>i</i> has heard tree <i>j</i> fall.   People may have different opinions as to which trees, according to Berkeley, have made a sound.  How many different opinions are  represented in the input?  Two people hold the same opinion only if they hear exactly the same set of trees. You may assume that <i>P &lt; 100</i> and <i>T &lt; 100</i>.</p>', '', '', '', '3 4\r\n1 2\r\n3 3\r\n1 3\r\n2 2\r\n3 2\r\n2 4\r\n', '2\r\n', '', 0, 0, '2010-08-19 00:29:25', '2010-08-19 00:29:25'),
(270, 1, 'Problem E:  A Star not a Tree?', 1000, 134217728, 0000000000, 0000000000, '<p><img align="right" src="http://plg1.cs.uwaterloo.ca/~acm00/020126/cables.jpg" alt="" /></p>\r\n<h2>Problem E:  A Star not a Tree?</h2>\r\n<p>Luke wants to upgrade his home computer network from 10mbs to 100mbs. His existing network uses 10base2 (coaxial) cables that allow you to connect any number of computers together in a linear arrangement. Luke is particulary proud that he solved a nasty NP-complete problem in order to minimize the total cable length.</p>\r\n<p>Unfortunately, Luke cannot use his existing cabling. The 100mbs system uses 100baseT (twisted pair) cables.  Each 100baseT cable connects only two devices:  either two network cards or a network card and a hub.  (A hub is an electronic device that  interconnects several cables.)  Luke has a choice:  He can buy 2N-2 network cards and connect his N computers together by inserting one or more cards into each computer and connecting them all together. Or he can buy N network cards and a hub and connect each of his N computers to the hub.  The first approach would require that Luke configure his operating system to forward network traffic.  However, with the installation of Winux 2007.2, Luke discovered that network forwarding no longer worked. He couldn''t figure out how to re-enable forwarding, and he had never heard of Prim or Kruskal, so he settled on the second approach:   N network cards and a hub.</p>\r\n<p>Luke lives in a loft and so is prepared to run the cables and place the  hub anywhere.  But he won''t move his computers.  He wants to minimize the total length of cable he must buy.</p>\r\n<p>The first line of input contains a positive integer N &lt;= 100, the number  of computers.  N lines follow; each gives the (x,y) coordinates (in mm.) of a computer within the room.  All coordinates are integers between  0 and 10,000.  Output consists of one number, the total length of the cable segments, rounded to the nearest mm.</p>', '', '', '', '4\r\n0 0\r\n0 10000\r\n10000 10000\r\n10000 0\r\n', '28284\r\n', '', 0, 0, '2010-08-19 00:29:25', '2010-08-19 00:29:25'),
(271, 1, 'Rooks', 2000, 134217728, 0000000000, 0000000000, '<p>\r\n	You have unexpectedly become the owner of a large chessboard, having fifteen squares to each side. Because you do not know how to play chess on such a large board, you find an alternative way to make use of it.</p>\r\n<p>\r\n	In chess, a rook attacks all squares that are in the same row or column of the chessboard as it is. For the purposes of this problem, we define a rook as also attacking the square on which it is already standing.</p>\r\n<p>\r\n	Given a set of chessboard squares, how many rooks are needed to attack all of them?</p>\r\n', '', '<p>\r\n	Input consists of a number of test cases. Each test case consists of fifteen lines each containing fifteen characters depicting the chess board. Each character is either a period (<tt>.</tt>) or a hash (<tt>#</tt>). Every chessboard square depicted by a hash must be attacked by a rook. After all the test cases, one more line of input appears. This line contains the word <tt>END</tt>.</p>\r\n', '<p>\r\n	Output consists of exactly one line for each test case. The line contains a single integer, the minimum number of rooks that must be placed on the chess board so that every square marked with a hash is attacked.</p>\r\n', '...............\r\n...............\r\n...............\r\n...............\r\n...............\r\n...............\r\n...............\r\n.......#.......\r\n...............\r\n...............\r\n...............\r\n...............\r\n...............\r\n...............\r\n...............\r\nEND\r\n', '1\r\n', '', 0, 0, '2010-08-19 00:31:58', '2010-08-18 16:32:23'),
(272, 1, 'Pipes', 1000, 134217728, 0000000000, 0000000000, '<p><img src="http://acm.zj.cn/upload/2010/3/B-22104525.jpg" alt="" /></p>\r\n<p>After writing a solver for the &quot;moveable maze&quot; game last week, you have grown tired of it. After all, you already know the optimal solution. To entertain yourself, you find another puzzle game called &quot;Pipes&quot;, and play that for a while. On one puzzle, you have not been able to find a solution by hand, and you think that there is no solution. You decide to write a program to tell you whether this is the case.</p>\r\n<p>The game is played on a grid with <i>R</i> rows and <i>C</i> columns. Each square of the grid contains a black dot in the centre and black lines in the direction of some, none, or all of its north, east, south, and west neighbouring squares, with the following restriction: if two opposite directions both have lines, then at least one of the other two directions has a line as well. In other words, it is forbidden for a square to consist of a straight line.</p>\r\n<p>The objective of the game is to rotate each square, as many times as you like, such that for each square, if it has a line going in a compass direction (that is, north, east, south, or west), then it has a neighbour in that compass direction and that neighbour has a line going in the opposite compass direction. In other words, each edge in the grid should either have a line on both sides or neither side.</p>\r\n<p>Your task is to determine whether a given grid has a solution.</p>\r\n<h3>&nbsp;</h3>', '', '<p>The input consists of several test cases.</p>\r\n<p>The first line of each test case contains the two integers <i>R</i> and <i>C</i>, separated by spaces, with 1 &lt;= <i>R</i>,<i>C</i> &lt;= 12.</p>\r\n<p>The following <i>R</i> lines of input each contain one row of the grid, from north to south. Each of these lines contains exactly <i>C</i> strings of letters, separated by spaces, that correspond to squares of the grid, from west to east. Their format is as follows:</p>\r\n<ul>\r\n    <li>If the string is the single character <i>x</i>, then the square      does not contain a line to any of its neighbours.</li>\r\n    <li>Otherwise, the string contains some of the characters <tt>N</tt>,      <tt>E</tt>, <tt>S</tt>, <tt>W</tt>, which indicate that a black      line extends from this square''s centre in the direction of its      north, east, south, or west neighbour, respectively. No character      will appear in the string more than once.</li>\r\n</ul>\r\n<p>Input is terminated by a line containing <tt>0 0</tt>. These zeros are not a test case and should not be processed.</p>', '<p>For each test case, output <tt>SOLVABLE</tt> if there is a solution to the puzzle, and <tt>UNSOLVABLE</tt> otherwise.</p>', '3 3\r\nNW NW x\r\nNES NESW W\r\nE W x\r\n2 2\r\nES x\r\nx N\r\n0 0\r\n', 'SOLVABLE\r\nUNSOLVABLE\r\n', '', 0, 0, '2010-08-19 00:31:58', '2010-08-19 00:31:58'),
(273, 1, 'Cantor', 10000, 134217728, 0000000000, 0000000000, '<p>&nbsp;</p>\r\n<p>The ternary expansion of a number is that number written in base 3. A number can have more than one ternary expansion. A ternary expansion is indicated with a subscript 3. For example, 1 = 1<sub>3</sub> = 0.222...<sub>3</sub>, and 0.875 = 0.212121...<sub>3</sub>.</p>\r\n<p>The Cantor set is defined as the real numbers between 0 and 1 inclusive that have a ternary expansion that does not contain a 1. If a number has more than one ternary expansion, it is enough for a single one to not contain a 1.</p>\r\n<p>For example, 0 = 0.000...<sub>3</sub> and 1 = 0.222...<sub>3</sub>, so they are in the Cantor set. But 0.875 = 0.212121...<sub>3</sub> and this is its only ternary expansion, so it is not in the Cantor set.</p>\r\n<p>Your task is to determine whether a given number is in the Cantor set.</p>\r\n<h3>&nbsp;</h3>\r\n<p>&nbsp;</p>\r\n<p><img src="http://acm.zj.cn/upload/2010/3/C-22105053.jpg" alt="" /></p>', '', '<p>The input consists of several test cases.</p>\r\n<p>Each test case consists of a single line containing a number <i>x</i> written in decimal notation, with 0 &lt;= <i>x</i> &lt;= 1, and having at most 6 digits after the decimal point.</p>\r\n<p>The last line of input is <tt>END</tt>. This is not a test case.</p>', '<p>For each test case, output <tt>MEMBER</tt> if <i>x</i> is in the Cantor set, and <tt>NON-MEMBER</tt> if <i>x</i> is not in the Cantor set.</p>', '0\r\n1\r\n0.875\r\nEND\r\n', 'MEMBER\r\nMEMBER\r\nNON-MEMBER\r\n', '', 0, 0, '2010-08-19 00:31:58', '2010-08-19 00:31:58'),
(274, 1, 'Meltdown', 1000, 134217728, 0000000000, 0000000000, '<p>A polygon is lowered at a constant speed of <i>v</i> metres per minute from the air into a liquid that dissolves it at a constant speed of <i>c</i> metres per minute from all sides. Given a point <i>(x,y)</i> inside the polygon that moves with the polygon, determine when the liquid reaches the point.</p>\r\n<p>The border between air and liquid always has y-coordinate 0, and the liquid only eats away from the sides of the polygon in 2 dimensions. The polygon does not rotate as it is lowered into the liquid, and at time 0, it is not touching the liquid.</p>\r\n<p>Unlike the polygon, which is flat (2-dimensional), the liquid exists in three dimensions. Therefore, the liquid seeps into cavities in the polygon. For example, if the polygon is &quot;cup-shaped&quot;, the liquid can get &quot;inside&quot; the cup, as in the diagram below.</p>\r\n<p><img src="http://plg1.cs.uwaterloo.ca/%7Eacm00/091003/Ddiag.png" alt="" /></p>', '', '<p>The input consists of several test cases.</p>\r\n<p>The first line of each test case contains the five integers <i>N</i>, <i>x</i>, <i>y</i>, <i>v</i>, and <i>c</i>, where  3 &lt;= <i>N</i> &lt;= 30, -100 &lt;= <i>x</i> &lt;= 100, 1 &lt;= <i>y</i> &lt;= 100, and 1 &lt;= <i>c</i> &lt; <i>v</i> &lt;= 10.</p>\r\n<p>The following <i>N</i> lines of the test case each contain one vertex of the polygon. The <i>i</i><sup>th</sup> line contains the two integers <i>x</i>, <i>y</i>, where -100 &lt;= <i>x</i> &lt;= 100, 1 &lt;= <i>y</i> &lt;= 100.</p>\r\n<p>The vertices of the polygon are given in counter-clockwise order. The border of the polygon does not intersect or touch itself, and the point <i>(x,y)</i> lies strictly inside the polygon&mdash;it does not lie on the border of the polygon.</p>\r\n<p>Input is terminated by a line containing <tt>0 0 0 0 0</tt>. These zeros are not a test case and should not be processed.</p>', '<p>For each test case, output the first time in minutes that the liquid reaches the specified point, rounded to four decimal places.</p>', '4 0 50 2 1\r\n-1 10\r\n1 10\r\n1 90\r\n-1 90\r\n0 0 0 0 0\r\n', '25.8660', '', 0, 0, '2010-08-19 00:31:58', '2010-08-19 00:31:58'),
(275, 1, 'sqrt log sin', 1000, 134217728, 0000000000, 0000000000, '<img align="right" src="http://plg1.cs.uwaterloo.ca/%7Eacm00/091003/E.png" alt="" />\r\n<p>An evil professor has just assigned you the following problem.</p>\r\n<p>A sequence is defined by the following recurrence:</p>\r\n<p><img align="center" src="http://plg1.cs.uwaterloo.ca/%7Eacm00/091003/Eeq.png" alt="" /></p>\r\n<p>Determine</p>\r\n<i>x<sub>1000000</sub></i>\r\n<p>.</p>', '', '<p>Input consists of a number of lines, each containing one integer, a value of <i>i</i>, no less than zero and no greater than one million. Input is followed by a single line containing the integer <i>-1</i>. This last line is not a value of <i>i</i> and should not be processed.</p>', '<p>For each value of <i>i</i> in the input (but not the final <tt>-1</tt>), output the corresponding value of <i>x<sub>i</sub></i> modulo 1000000.</p>', '0\r\n-1\r\n', '1\r\n', '', 0, 0, '2010-08-19 00:31:58', '2010-08-19 00:31:58'),
(276, 1, 'Problem A: Freckles', 1000, 134217728, 0000000000, 0000000000, '<p></p>\n<h2>Problem A: Freckles</h2>\n<p>In an episode of the Dick Van Dyke show, little Richie connects the freckles on his Dad''s back to form a picture of the Liberty Bell.  Alas, one of the freckles turns out to be a scar, so his Ripley''s engagement falls through.</p>\n<p>Consider Dick''s back to be a plane with freckles at various (x,y) locations. Your job is to tell Richie how to connect the dots so as to minimize the amount of ink used.  Richie connects the dots by drawing straight lines between pairs, possibly lifting the pen between lines. When Richie is done there must be a sequence of connected lines from any freckle to any other freckle.</p>\n<p>The first line contains 0 &lt; <i>n</i> &lt;= 100, the number of freckles on Dick''s back.  For each freckle, a line follows; each following line contains two real numbers indicating the (x,y) coordinates of the freckle.</p>\n<p>Your program prints a single real number to two decimal places:  the minimum total length of ink lines that can connect all the freckles.</p>', '', '', '', '3\n1.0 1.0\n2.0 2.0\n2.0 4.0\n', '3.41\n', '', 0, 0, '2010-08-19 00:35:22', '2010-08-19 00:35:22'),
(277, 1, 'Problem B: Language Cardinality', 1000, 134217728, 0000000000, 0000000000, '<p></p>\n<h2>Problem B: Language Cardinality</h2>\n<p>A (formal) language is a set of strings.  One way to define a particular langauge is using ordinary set notation.  Alternatively, some form of grammar may be more convenient for representing large sets.  The UW grammar in which we are interested has two parts:</p>\n<ul>\n    <li>An initial string</li>\n    <li>A set of replacement rules of the form <i>s<sub>1</sub></i> -&gt; <i>s<sub>2</sub></i> where <i>s<sub>1</sub></i> and <i>s<sub>2</sub></i> are strings</li>\n</ul>\n<p>The language defined by this grammar is the set of all strings that can be generated by repeatedly replacing  <i>s<sub>1</sub></i> by <i>s<sub>2</sub></i> within the initial string. For example, consider the grammar G consisting of the initial string</p>\n<p></p>\n<pre>\n&quot;AyB&quot;\n</pre>\n<p>and the replacement rules</p>\n<pre>\n{&quot;A&quot;-&gt;&quot;ab&quot;, &quot;Ay&quot;-&gt;&quot;cdy&quot;, &quot;B&quot;-&gt;&quot;w&quot;, &quot;B&quot;-&gt;&quot;x&quot;} .\n</pre>\n<p>G generates the language</p>\n<p></p>\n<pre>\nL = {&quot;AyB&quot;, &quot;Ayw&quot;, &quot;Ayx&quot;, &quot;abyB&quot;, &quot;abyw&quot;, &quot;abyx&quot;, &quot;cdyB&quot;, &quot;cdyw&quot;, &quot;cdyx&quot;}\n</pre>\n<p>Given a UW grammar G, compute how many different strings there are in the language generated by G.</p>\n<p>The first line of input contains the initial string. The second and subsequent lines contain the replacement rules, one per line, terminated by end-of-file.    There are at most 100 replacement rules.  Each input string contains between 0 and 10 upper and lower case  letters, and is enclosed in quotes.  There are no spaces in the input.</p>\n<p>Output consists of a single integer, the number of distinct strings in the language generated by G.  If there are more than 1000 distinct strings, print &quot;Too many.&quot; instead.</p>', '', '', '', '"AyB"\n"A"->"ab"\n"Ay"->"cdy"\n"B"->"w"\n"B"->"x"\n', '9\n', '', 0, 0, '2010-08-19 00:35:22', '2010-08-19 00:35:22'),
(278, 1, 'Problem C:  Primary Arithmetic', 1000, 134217728, 0000000000, 0000000000, '<p></p>\n<h2>Problem C:  Primary Arithmetic</h2>\n<p>Children are taught to add multi-digit numbers from right-to-left one digit at a time.  Many find the &quot;carry&quot; operation - in which a 1 is carried from one digit position to be added to the next - to be a significant challenge.  Your job is to count the number of  carry operations for each of a set of addition problems so that educators may assess their difficulty.</p>\n<p>Each line of input contains two unsigned integers less than 10 digits.   The last line of input contains 0 0.  For each line of input except the  last you should compute and print the number of carry operations that would result from adding the two numbers, in the format shown below.</p>', '', '', '', '123 456\n555 555\n123 594\n0 0\n', 'No carry operation.\n3 carry operations.\n1 carry operation.\n', '', 0, 0, '2010-08-19 00:35:22', '2010-08-19 00:35:22'),
(279, 1, 'Problem D:  Demerit Points', 1000, 134217728, 0000000000, 0000000000, '<p></p>\n<h2>Problem D:  Demerit Points</h2>\n<p>A province to our west, which shall remain nameless, but whose name does not start with A, B, or S, has a unique system for driver''s license demerit and merit points.  The system works (more or less) as follows.</p>\n<p>A new driver starts with no merit or demerit points.  When the driver is convicted of a driving offense, he or she is given between 2 and 15 demerit points, depending on the severity of the offense.</p>\n<p>A merit point is given, to a maximum of five, for each interval of two years in which a driver has no offenses and no demerit points. Each merit point cancels up to two demerit points.  If a subsequent offense occurs and the number of demerit points exceeds double the number of merit points, the number of demerit points is reduced by double the number of merit points, and the number of merit points is set to 0. If a subsequent offense occurs and the number of demerit points is less than or equal to double the number of merit points, the number of demerit points is reduced to 0, and the number of merit points is reduced by half the number of demerit points.  Any fractional merit points are discarded.</p>\n<p>Demerit points are reduced whenever a driver has one year free of any driving offense.  This reduction decreases the number of demerits by half or by 2, whichever is more.   Any fractional or negative demerit points are discarded.  This reduction takes place on each anniversary of the most recent offense until no points remain.</p>\n<p>If a new offense occurs on the same day as a demerit point reduction or merit point award, the reduction/award is done before the new demerit points are given.</p>\n<p>Your job is to read a set of information records for a driver, and to print the number of merit or demerit points at any given time.</p>\n<p>The first line of input contains the date of issue of the license (yyyymmdd) Subsequent lines contain information on offenses, in chronological order.  Each such line contains the offense date (yyyymmdd) and the number of points applied  (an integer between 2 and 15).   On the day the license is issued, and on every occasion that the number  of merit or demerit points changes, output a line giving the date and the number of points, in the format below. Output terminates when 5 merit points are accumulated following the last offense.</p>', '', '', '', '19820508\n19830606 2\n19830607 2\n19891212 15\n', '1982-05-08 No merit or demerit points.\n1983-06-06 2 demerit point(s).\n1983-06-07 4 demerit point(s).\n1984-06-07 2 demerit point(s).\n1985-06-07 No merit or demerit points.\n1987-06-07 1 merit point(s).\n1989-06-07 2 merit point(s).\n1989-12-12 11 demerit point(s).\n1990-12-12 5 demerit point(s).\n1991-12-12 2 demerit point(s).\n1992-12-12 No merit or demerit points.\n1994-12-12 1 merit point(s).\n1996-12-12 2 merit point(s).\n1998-12-12 3 merit point(s).\n2000-12-12 4 merit point(s).\n2002-12-12 5 merit point(s).\n', '', 0, 0, '2010-08-19 00:35:22', '2010-08-19 00:35:22'),
(280, 1, 'Problem E:  Edit Step Ladders', 10000, 134217728, 0000000000, 0000000000, '<p></p>\n<h2>Problem E:  Edit Step Ladders</h2>\n<p>An <i>edit step</i> is a transformation from one word <i>x</i> to another word <i>y</i> such that <i>x</i> and <i>y</i> are words in the dictionary, and <i>x</i> can be transformed to <i>y</i> by adding, deleting, or changing one letter. So the transformation from <i>dig</i> to <i>dog</i> or from <i>dog</i> to <i>do</i> are both edit steps.  An <i>edit step ladder</i> is a lexicographically ordered sequence of words  <i>w<sub>1</sub>, w<sub>2</sub>, ... w<sub>n</sub></i> such that the transformation from <i>w<sub>i</sub></i> to <i>w<sub>i+1</sub></i> is an edit step for all <i>i</i> from 1 to <i>n-1</i>.</p>\n<p>For a given dictionary, you are to compute the length of the longest edit step ladder.  The input to your program consists of the dictionary - a set of lower case words in lexicographic order - one per line.  No word exceeds 16 letters and there are no more than 25000 words in the dictionary. The output consists of a single integer, the number of words in the  longest edit step ladder.</p>', '', '', '', 'cat\ndig\ndog\nfig\nfin\nfine\nfog\nlog\nwine\n', '5\n', '', 0, 0, '2010-08-19 00:35:22', '2010-08-19 00:35:22'),
(281, 1, 'Problem C:  Jolly Jumpers', 1000, 134217728, 0000000000, 0000000000, '<p></p>\r\n<h2>Problem C:  Jolly Jumpers</h2>\r\n<p>A sequence of <i>n &gt; 0</i> integers is called a <i>jolly jumper</i> if the absolute values of the difference between successive elements take on all the values 1 through <i>n-1</i>.  For instance,</p>\r\n<p></p>\r\n<pre>\r\n1 4 2 3\r\n</pre>\r\n<p>is a jolly jumper, because the absolutes differences are 3, 2, and 1 respectively.  The definition implies that any sequence of a single integer is a jolly jumper.  You are to write a program to determine whether or not each of a number of sequences is a jolly jumper.</p>\r\n<p>Each line of input contains an integer <i>n</i> &lt; 3000 followed by <i>n</i> integers representing the sequence.  For each line of input, generate a line of output saying &quot;Jolly&quot; or &quot;Not jolly&quot;.</p>', '', '', '', '4 1 4 2 3\r\n5 1 4 2 -1 6\r\n', 'Jolly\r\nNot jolly\r\n', '', 0, 0, '2010-08-19 00:36:38', '2010-08-19 00:36:38'),
(282, 1, 'Problem D:  Tug of War', 10000, 134217728, 0000000000, 0000000000, '<p></p>\r\n<h2>Problem D:  Tug of War</h2>\r\n<p>A tug of war is to be arranged at the local office picnic.  For the tug of war, the picnickers must be divided into two teams.  Each person must be on one team or the other; the number of people on the two teams must not differ by more than 1; the total weight of the people on each team should be as nearly equal as possible.</p>\r\n<p>The first line of input contains <i>n</i> the number of people at the picnic.  <i>n</i> lines follow.  The first line gives the weight of person 1; the second the weight of person 2; and so on.  Each weight is an integer between 1 and 450.  There are at most 100 people at the picnic.</p>\r\n<p>Your output will be a single line containing 2 numbers:  the total weight of the people on one team, and the total weight of the people on the other team.  If these numbers differ, give the lesser first.</p>', '', '', '', '3\r\n100\r\n90\r\n200\r\n', '190 200\r\n', '', 0, 0, '2010-08-19 00:36:38', '2010-08-19 00:36:38'),
(283, 1, 'Problem E:  Interpreter', 1000, 134217728, 0000000000, 0000000000, '<p></p>\r\n<h2>Problem E:  Interpreter</h2>\r\n<p>A certain computer has 10 registers and 1000 words of RAM.  Each register or RAM location holds a 3-digit integer between 0 and 999.  Instructions are encoded as 3-digit integers and stored in RAM.   The encodings are as follows:</p>\r\n<ul>\r\n    <li>100 means <i>halt</i></li>\r\n    <li>2dn means <i>set register d to n (between 0 and 9)</i></li>\r\n    <li>3dn means <i>add n to register d</i></li>\r\n    <li>4dn means <i>multiply register d by n</i></li>\r\n    <li>5ds means <i>set register d to the value of register s</i></li>\r\n    <li>6ds means <i>add the value of register s to register d</i></li>\r\n    <li>7ds means <i>multiply register d by the value of register s</i></li>\r\n    <li>8da means <i>set register d to the value in RAM whose address is in register a</i></li>\r\n    <li>9sa means <i>set the value in RAM whose address is in register a to the value of register s</i></li>\r\n    <li>0ds means <i>goto the location in register d unless register s contains 0</i></li>\r\n</ul>\r\n<p>All registers initially contain 000.  The initial content of the RAM is read from standard input.  The first instruction to be executed is at RAM address 0.  All results are reduced modulo 1000.</p>\r\n<p>The input to your program consists of up to 1000 3-digit unsigned integers, representing the contents of consecutive RAM locations starting at 0. Unspecified RAM locations are initialized to 000.</p>\r\n<p>The output from your program is a single integer:  the number of  instructions executed up to and including the <i>halt</i> instruction. You may assume that the program does halt.</p>', '', '', '', '299\r\n492\r\n495\r\n399\r\n492\r\n495\r\n399\r\n283\r\n279\r\n689\r\n078\r\n100\r\n000\r\n000\r\n000\r\n', '16\r\n', '', 0, 0, '2010-08-19 00:36:38', '2010-08-19 00:36:38'),
(284, 1, 'Problem A:  Bridge', 1000, 134217728, 0000000000, 0000000000, '<p></p>\r\n<h2>Problem A:  Bridge</h2>\r\n<p><i>n</i> people wish to cross a bridge at night.  A group of at most two people may cross at any time, and each group must have a flashlight. Only one flashlight is available among the <i>n</i> people, so some sort of shuttle arrangement must be arranged in order to return the flashlight so that more people may cross.</p>\r\n<p>Each person has a different crossing speed; the speed of a group is determined by the speed of the slower member.  Your job is to determine a strategy that gets all <i>n</i> people across the bridge in the minimum time.</p>\r\n<p>The first line of input contains <i>n</i>, followed by <i>n</i> lines giving the crossing times for each of the people. There are not more than 1000 people and nobody takes more than 100 seconds  to cross the bridge.</p>\r\n<p>The first line of output must contain the total number of seconds required for all <i>n</i> people to cross the bridge.   The following lines give a strategy for achieving this time.  Each line contains either one or two integers, indicating which person or people form the next group to cross.  (Each person is indicated by the crossing time specified in the input.  Although many people may have the same crossing time the ambiguity is of no consequence.) Note that the crossings alternate directions, as it is necessary to return the flashlight so that more may cross.  If more than one strategy yields the minimal time, any one will do.</p>', '', '', '', '4\r\n1\r\n2\r\n5\r\n10\r\n', '17\r\n1 2\r\n1\r\n5 10\r\n2\r\n1 2\r\n', '', 0, 0, '2010-08-19 00:42:08', '2010-08-19 00:42:08'),
(285, 1, 'Problem B: Saskatchewan', 10000, 134217728, 0000000000, 0000000000, '<p></p>\r\n<h3>Problem B:  Saskatchewan</h3>\r\n<p>The province of Saskatchewan is surveyed in <i>sections</i>.   A section is a square mile of land.  Grid roads delimit sections; there is one north-south and one east-west road exactly every mile.  (Complications arise because of the curvature of the earth but you can disregard these and assume that the province is a plane.)  The provincial border is a polygon whose vertices correspond to the intersections of grid roads. However, the edges do not necessarily follow grid roads; some sections are cut by the border.  Your job is to compute how many sections are completely within a province like Saskatchewan.</p>\r\n<p>Standard input contains a series of no more than 100 coordinate pairs, one pair per line.  These coordinates give the vertices of the perimeter of the province; the border is formed by connecting them in order.  All coordinates are in the first quadrant; they range from 0 to 100,000.</p>\r\n<p>Your output should be a single integer:  the number of sections  (i.e. unit squares with corners at integer coordinates)  fully contained within the province.</p>\r\n<p></p>', '', '', '', '0 0\r\n0 100000\r\n99999 100000\r\n100000 0\r\n', '9999900000\r\n', '', 0, 0, '2010-08-19 00:42:09', '2010-08-19 00:42:09'),
(286, 1, ' Problem A - Y2K Accounting Bug', 2000, 134217728, 0000000000, 0000000000, '<p>\r\n	&nbsp;</p>\r\n<p>\r\n	&nbsp;</p>\r\n<h2>\r\n	Problem A - Y2K Accounting Bug</h2>\r\n<p>\r\n	Accounting for Computer Machinists (ACM) has sufferred from the Y2K bug and lost some vital data for preparing annual report for MS Inc.</p>\r\n<p>\r\n	All what they remember is that MS Inc. posted a surplus or a deficit each month of 1999 and each month when MS Inc. posted surplus, the amount of surplus was <em>s</em> and each month when MS Inc. posted deficit, the deficit was <em>d</em>. They do not remember which or how many months posted surplus or deficit. MS Inc., unlike other companies, posts their earnings for each consecutive 5 months during a year. ACM knows that each of these 8 postings reported a deficit but they do not know how much. The chief accountant is almost sure that MS Inc. was about to post surplus for the entire year of 1999. Almost but not quite.</p>\r\n<p>\r\n	Write a program, which decides whether MS Inc. suffered a deficit during 1999, or if a surplus for 1999 was possible, what is the maximum amount of surplus that they can post.</p>\r\n<p>\r\n	Input is a sequence of lines, each containing two positive integers <em>s</em> and <em>d</em>. For each line of input, output one line containing either a single integer giving the amount of surplus for the entire year, or output <tt>Deficit</tt> if it is impossible.</p>\r\n', '', '<br />\r\n', '<br />\r\n', '59 237\r\n375 743\r\n200000 849694\r\n2500000 8000000\r\n', '116\r\n28\r\n300612\r\nDeficit\r\n', '', 0, 0, '2010-08-19 01:28:06', '2010-08-18 17:34:20'),
(287, 1, 'Problem B - Airline Hub', 1000, 134217728, 0000000000, 0000000000, '<p></p>\r\n<h2>Problem B - Airline Hub</h2>\r\n<p>World Wide Flyer has landing rights at several airports throughout the world.  They wish to place their central hub at the airport that minimizes the maximum direct flying distance from the hub to any other  airport in the world.</p>\r\n<p>Input consists of a line containing n &lt;= 1000, the number of airports.  n lines follow, each giving the latitude (between -90 and +90 degrees) and longitude (between -180 and +180 degrees) of an airport.</p>\r\n<p>To two decimal places, give the latitude and longitude of the airport that best serves as a hub.  If there are several any one will do.</p>', '', '', '', '3\r\n3.2 -15.0\r\n20.1 -175\r\n-30.2 10\r\n', '3.20 -15.00\r\n', '', 0, 0, '2010-08-19 01:28:07', '2010-08-19 01:28:07'),
(288, 1, 'Problem C - Snakes', 1000, 134217728, 0000000000, 0000000000, '<p></p>\r\n<h2>Problem C - Snakes</h2>\r\n<p>Buffalo Bill wishes to cross a 1000x1000 square field.  A number of snakes are on the field at various positions, and each snake can  strike a particular distance in any direction.  Can Bill make the trip without being bitten?</p>\r\n<p>Assume that the southwest corner of the field is at (0,0) and the northwest corner at (0,1000).  The input consists of a line containing n &lt;= 1000, the number of snakes.  A line follows for each snake, containing three real numbers:  the (x,y) location of the snake and its strike distance.  The snake will bite anything that passes closer than this distance from its location.</p>\r\n<p>Bill must enter the field somewhere between the southwest and northwest corner and must leave somewhere between the southeast and northeast corners.</p>\r\n<p>If Bill can complete the trip, give coordinates at which he may enter and leave the field.  If Bill may enter and leave at several places, give the most northerly.  If there is no such pair of positions, print &quot;Bill will be bitten.&quot;</p>', '', '', '', '3\r\n500 500 499\r\n0 0 999\r\n1000 1000 200\r\n', 'Bill enters at (0.00, 1000.00) and leaves at (1000.00, 800.00).\r\n', '', 0, 0, '2010-08-19 01:28:08', '2010-08-19 01:28:08'),
(289, 1, 'Problem D - Snap', 1000, 134217728, 0000000000, 0000000000, '<p>\r\n	<em>Snap</em> is a 2-player card game. The deck of cards contains several of each type of card. Initially each player has one half of the deck, in some random sequence, face down in a pile, and plays them in sequence from top to bottom, placing each card face-up in another pile. When the face-down pile is exhausted, the face-up pile is turned over to become the face-down pile and play continues.</p>\r\n<p>\r\n	The two players play their cards concurrently and synchronously. That is, each places a card face up at exactly the same time. If two cards turned up at the same time are the same type, each player calls &quot;Snap!&quot; and the player who calls first takes the other&#39;s face-up pile and places it on top of his or her own.</p>\r\n<p>\r\n	Play proceeds until one player has all the cards. This player is the winner.</p>\r\n<p>\r\n	Your job is to simulate a game of snap to determine whether it will end within 1000 turns and, if so, to determine the winner.</p>\r\n<p>\r\n	Each type of card is denoted by a single letter or digit. The first line of input Jane&#39;s initial pile of cards, from top to bottom. The second line of input is John&#39;s initial pile. Jane and John start with the same number of cards; not more than 50 each.</p>\r\n<p>\r\n	During play, whenever it comes time to call &quot;Snap!&quot; the builtin function &quot;random&quot; is used to determine who calls first: if the expression</p>\r\n<pre>\r\nrand()/141%2           {in C or C++}\r\n\r\nrandom div 141 mod 2     {in Pascal; see note below}\r\n</pre>\r\n<p>\r\n	yields 0, Jane calls first; otherwise John calls first. Whenever Jane calls first, print &quot;Snap! for Jane: &quot; followed by Jane&#39;s face-up pile, from top to bottom. Whenever John calls first, print &quot;Snap! for John: &quot; followed by John&#39;s face-up pile. If the game ends, print &quot;John wins.&quot; or &quot;Jane wins.&quot;, whichever is appropriate. If the game does not end when each player has turned over 1000 cards, print &quot;Keeps going and going ...&quot;</p>\r\n', '', '', '<br />\r\n', 'ABCDA\r\nCBADC\r\n', 'Snap! for Jane: BCBA\r\nSnap! for Jane: DADCBCBA\r\nSnap! for Jane: CCBA\r\nJane wins.\r\n', '', 0, 0, '2010-08-19 01:28:08', '2010-10-28 13:55:19'),
(290, 1, 'Problem E - Steps', 1000, 134217728, 0000000000, 0000000000, '<p></p>\r\n<h2>Problem E - Steps</h2>\r\n<p>One steps through integer points of the straight line.  The length of         a step must be nonnegative and can be by one bigger than, equal to, or          by one smaller than the length of the previous step.</p>\r\n<p>What is the minimum number of steps in order to get from x to y?         The length of the first and the last step must be 1.</p>\r\n<p>Input consists of a line containing n, the number of test cases.  For each test case, a line follows with two integers:  0 &lt;= x &lt;= y &lt; 2^31. For each test case, print a line giving the minimum number of steps to get from x to y.</p>', '', '', '', '3\r\n45 48\r\n45 49\r\n45 50\r\n', '3\r\n3\r\n4\r\n', '', 0, 0, '2010-08-19 01:28:08', '2010-08-19 01:28:08'),
(291, 1, 'Problem A: Fire Station', 10000, 134217728, 0000000000, 0000000000, '<p></p>\r\n<p>\r\n<title></title>\r\n</p>\r\n<h2>Problem A: Fire Station</h2>\r\n<p>A city is served by a number of fire stations.  Some residents have complained that the distance from their houses to the nearest station is too far, so a new station is to be built.  You are to choose the location of the fire station so as to reduce the distance to the nearest station from the houses of the disgruntled residents.</p>\r\n<p>The city has up to 500 intersections, connected by road segments of various lengths.  No more than 20 road segments intersect at a given intersection.  The location of houses and firestations alike are considered to be at intersections (the travel distance from the intersection to the actual building can be discounted).  Furthermore, we assume that there is at least one house associated with every intersection.  There may be more than one firestation per intersection.</p>', '', '<p>The first line of input contains two positive integers:  <i>f</i>,the  number of existing fire stations (<i>f</i> &lt;= 100) and <i>i</i>, the number of  intersections  (<i>i</i> &lt;= 500).  The intersections are numbered from 1 to <i>i</i> consecutively.  <i>f</i> lines follow; each contains the intersection number at which an existing fire station is found.  A number of lines follow, each containing three positive integers:  the number of an intersection, the number of a different intersection, and the length of the road segment connecting the intersections.  All road segments are two-way (at least as far as fire engines are concerned), and there will exist a route between any pair of intersections.</p>', '<p>You are to output a single integer:  the lowest intersection number at  which a new fire station should be built so as to minimize the maximum distance from any intersection to the nearest fire station.</p>', '1 6\r\n2\r\n1 2 10\r\n2 3 10\r\n3 4 10\r\n4 5 10\r\n5 6 10\r\n6 1 10\r\n', '5\r\n', '', 0, 0, '2010-08-19 01:35:03', '2010-08-19 01:35:03'),
(292, 1, 'Problem B: Soundex', 1000, 134217728, 0000000000, 0000000000, '<p></p>\r\n<p>\r\n<title></title>\r\n</p>\r\n<h2>Problem B: Soundex</h2>\r\n<p>Soundex coding groups together words that appear to sound alike based on their spelling.  For example, &quot;can&quot; and &quot;khawn&quot;, &quot;con&quot; and &quot;gone&quot; would be equivalent under Soundex coding.</p>\r\n<p>Soundex coding involves translating each word into a series of digits in which each digit represents a letter:</p>\r\n<pre>\r\n      1 represents B, F, P, or V\r\n      2 represents C, G, J, K, Q, S, X,  or Z\r\n      3 represents D or T\r\n      4 represents L\r\n      5 represents M or N\r\n      6 represents R\r\n</pre>\r\n<p>The letters A, E, I, O, U, H, W, and Y are not represented in Soundex coding, and repeated letters with the same code digit are represented by a single instance of that digit.  Words with the same Soundex coding are considered equivalent.</p>\r\n<p>Each line of input contains a single word, all upper case, less than 20 letters long.  For each line of input, produce a line of output giving the Soundex code.</p>', '', '', '', 'KHAWN\r\nPFISTER\r\nBOBBY\r\n', '25\r\n1236\r\n11\r\n', '', 0, 0, '2010-08-19 01:35:03', '2010-08-19 01:35:03'),
(293, 1, 'Problem C: Ferry Loading', 1000, 134217728, 0000000000, 0000000000, '<p></p>\r\n<p>\r\n<title></title>\r\n</p>\r\n<h2>Problem C: Ferry Loading</h2>\r\n<p>Before bridges were common, ferries were used to transport cars across rivers.  River ferries, unlike their larger cousins, run on a guide line and are powered by the river''s current.  Two lanes of cars drive onto the ferry from one end, the ferry crosses the river, and the cars exit from the other end of the ferry.</p>\r\n<p>The cars waiting to board the ferry form a single queue, and the operator directs each car in turn to drive onto the port (left) or starboard (right) lane of the ferry so as to balance the load. Each car in the queue has a different length, which the operator estimates by inspecting the queue.  Based on this inspection, the operator decides which side of the ferry each car should board, and boards as many cars as possible from the queue, subject to the length limit of the ferry. Your job is to write a program that will tell the operator which car to load on which side so as to maximize the number of cars loaded.</p>', '', '<p>The first line of input contains a single integer between 1 and 100: the length of the ferry (in metres). For each car in the queue there is an additional line of input  specifying the length of the car (in cm, an integer between 100 and 3000  inclusive).   A final line of input contains the integer 0. The cars must be loaded in order, subject to the constraint that the total length of cars on either side does not exceed the length of the ferry. Subject to this constraint as many cars should be loaded as possible, starting with the first car in the queue and loading cars in order until no more can be loaded.</p>', '<p>The first line of outuput should give the number of cars that can be loaded onto the ferry. For each car that can be loaded onto the ferry, in the order the cars appear in the input, output a line containing &quot;port&quot; if the car is to be directed to the port side and &quot;starboard&quot; if the car is to be directed to the starboard side.  If several arrangements of the cars meet the criteria above, any one will do.</p>', '50\r\n2500\r\n3000\r\n1000\r\n1000\r\n1500\r\n700\r\n800\r\n0\r\n', '6\r\nport\r\nstarboard\r\nstarboard\r\nport\r\nport\r\nstarboard\r\n', '', 0, 0, '2010-08-19 01:35:03', '2010-08-19 01:35:03');
INSERT INTO `tbl_problems` (`id`, `user_id`, `title`, `time_limit`, `memory_limit`, `submission_no`, `accepted_no`, `description`, `source`, `input`, `output`, `input_sample`, `output_sample`, `hint`, `flag`, `visibility`, `created`, `modified`) VALUES
(294, 1, 'Problem D:  Dog & Gopher', 1000, 134217728, 0000000000, 0000000000, '<p></p>\r\n<p>\r\n<title></title>\r\n</p>\r\n<h2>Problem D:  Dog &amp; Gopher</h2>\r\n<p>A large field has a dog and a gopher.  The dog wants to eat the gopher, while the gopher wants to run to safety through one of several gopher holes dug in the surface of the field.</p>\r\n<p>Neither the dog nor the gopher is a math major; however, neither is entirely stupid. The gopher decides on a particular gopher hole and heads for that  hole in a straight line at a fixed speed.  The dog, which is very good at reading body language, anticipates which hole the gopher has chosen, and heads at double the speed of the gopher to the hole, where it intends to gobble up the gopher.  If the dog reaches the hole first, the gopher gets gobbled; otherwise, the gopher escapes.</p>\r\n<p>You have been retained by the gopher to select a hole through which it can escape, if such a hole exists.</p>\r\n<p>The first line of input contains four floating point numbers:  the  (x,y) coordinates of the gopher followed by the (x,y) coordinates of the dog.  Subsequent lines of input each contain two floating point numbers:  the (x,y) coordinates of a gopher hole.  All distances are in metres, to the nearest mm.</p>\r\n<p>Your output should consist of a single line.  If the gopher can escape the line should read &quot;The gopher can escape through the hole at (<i>x</i>,<i>y</i>).&quot;  identifying the appropriate hole to the nearest mm.   Otherwise the output line should read &quot;The gopher cannot escape.&quot;  If the gopher may escape through more than one hole, any one will do.  If the gopher and dog reach the hole at the same time either answer may be given. There are not more than 1000 gopher holes and all coordinates are between -10000 and +10000.</p>', '', '', '', '1.000 1.000 2.000 2.000\r\n1.500 1.500\r\n', 'The gopher cannot escape.\r\n', '<h3>Sample Input 2</h3>\r\n<pre>\r\n2.000 2.000 1.000 1.000\r\n1.500 1.500\r\n2.500 2.500\r\n</pre>\r\n<h3>Output for Sample Input 2</h3>\r\n<pre>\r\nThe gopher can escape through the hole at (2.500,2.500).\r\n</pre>', 0, 0, '2010-08-19 01:35:03', '2010-08-19 01:35:03'),
(295, 1, 'Problem E: Gas Station Numbers', 1000, 134217728, 0000000000, 0000000000, '<p></p>\r\n<p>\r\n<title></title>\r\n</p>\r\n<h2>Problem E: Gas Station Numbers</h2>\r\n<p>Many gas stations use plastic digits on an illuminated sign to indicate prices.  When there is an insufficient quantity of a particular digit, the attendant may substitute another one upside down.</p>\r\n<p>The digit &quot;6&quot; looks much like &quot;9&quot; upside down.  The digits &quot;0&quot;, &quot;1&quot;  and &quot;8&quot; look  like themselves.  The digit &quot;2&quot; looks a bit like a &quot;5&quot; upside down (well, at least enough so that gas stations use it).</p>\r\n<p>Due to rapidly increasing prices, a certain gas station has used all of its available digits to display the current price.  Fortunately, this shortage of digits need not prevent the attendant from raising  prices.  She can simply rearrange the digits, possibly reversing some of them as described above.</p>\r\n<p>Your job is to compute, given the current price of gas, the next highest price that can be displayed using exactly the same digits. The input consists of several lines, each containing between 2 and 30 digits (to account for future prices) and a decimal point immediately before the last digit. There are no useless leading zeroes; that is, there is a leading zero only if the price is less than 1. You are to compute the next highest price that can be displayed using the same digits and the same format rules.  An input line containing a decimal  point alone terminates the input.  If the price  cannot be raised,  print &quot;The price cannot be raised.&quot;</p>', '', '', '', '65.2\r\n76.7\r\n77.7\r\n.\r\n', '65.5\r\n77.6\r\nThe price cannot be raised.\r\n', '', 0, 0, '2010-08-19 01:35:03', '2010-08-19 01:35:03'),
(296, 1, 'Problem A - Billiard', 1000, 134217728, 0000000000, 0000000000, '<p></p>\r\n<p>\r\n<title></title>\r\n</p>\r\n<h2>Problem A - Billiard</h2>\r\n<p>In a billiard table with horizontal side <b>a</b> inches and vertical side <b>b</b> inches, a ball is launched from the middle of the table.  After <b>s</b> &gt; 0 seconds the ball returns to the point from which it was launched, after having made <b>m</b> bounces off the vertical sides and <b>n</b> bounces off the horizontal sides of the table.  Find the launching angle <b>A</b> (measured from the horizontal), which will be between 0 and 90 degrees inclusive, and the initial velocity of the ball.</p>\r\n<p>Assume that the collisions with a side are elastic (no energy loss), and thus the velocity component of the ball parallel to each side remains unchanged.  Also, assume the ball has a radius of zero.  Remember that, unlike pool tables, billiard tables have no pockets.</p>', '', '<p>Input consists of a sequence of lines, each containing five nonnegative integers separated by whitespace. The five numbers are: a, b, s, m, and n, respectively. All numbers are positive integers not greater than 10000. Input is terminated by a line containing five zeroes.</p>', 'For each input line except the last, output a line containing two real numbers (accurate to two decimal places) separated by a single space. The first number is the measure of the angle A in degrees and the second is the velocity of the ball measured in inches per second, according to the description above.', '100 100 1 1 1\r\n200 100 5 3 4\r\n201 132 48 1900 156\r\n0 0 0 0 0\r\n', '45.00 141.42\r\n33.69 144.22\r\n3.09 7967.81\r\n', '', 0, 0, '2010-08-19 01:35:39', '2010-08-19 01:35:39'),
(297, 1, 'Problem B - The Brick Stops Here', 1000, 134217728, 0000000000, 0000000000, '<p></p>\r\n<p>\r\n<title></title>\r\n</p>\r\n<h2>Problem B - The Brick Stops Here</h2>\r\n<p>You have been hired by several clients of a factory that manufactures brass bricks.  Brass is an alloy of copper and zinc; each brick weighs 1000 grams, and the copper content of a brick can range from 1 to 999 grams.  (Note that brass with less than 55% or more than 62% of copper is practically useless; however, this is irrelevant for this question)  The factory manufactures, through various processes, different types of brick, each of which has a different copper concentration and price.  It distributes a catalog of these types to its customers.</p>\r\n<p>Your clients desire to buy a certain number (<b>M</b>) of bricks, which for, uh, religious reasons must be of different types.  They will be melted together, and the resultant mixture must have a concentration of at least <b>CMin</b> and at most <b>CMax</b> grams of copper per kilogram.  Their goal is to pick the <b>M</b> types of brick so that the mixture has the correct concentration and the price of the collection is minimized.  You must figure out how to do this.  <b>M</b>, <b>CMin</b>, and <b>CMax</b> will vary depending on the client.</p>', '', '<p></p>\r\n<p><span class="Apple-style-span" style="font-family: ''AR PL UKai CN''; font-size: medium; ">The first part of input consists of a line containing a number</span><span class="Apple-style-span" style="font-family: ''AR PL UKai CN''; font-size: medium; ">&nbsp;</span><span class="Apple-style-span" style="font-family: ''AR PL UKai CN''; font-size: medium; "><b>N</b></span><span class="Apple-style-span" style="font-family: ''AR PL UKai CN''; font-size: medium; ">&nbsp;</span><span class="Apple-style-span" style="font-family: ''AR PL UKai CN''; font-size: medium; ">(1 &lt;=</span><span class="Apple-style-span" style="font-family: ''AR PL UKai CN''; font-size: medium; ">&nbsp;</span><span class="Apple-style-span" style="font-family: ''AR PL UKai CN''; font-size: medium; "><b>N</b></span><span class="Apple-style-span" style="font-family: ''AR PL UKai CN''; font-size: medium; ">&nbsp;</span><span class="Apple-style-span" style="font-family: ''AR PL UKai CN''; font-size: medium; ">&lt;= 200), the number of brick types, and then</span><span class="Apple-style-span" style="font-family: ''AR PL UKai CN''; font-size: medium; ">&nbsp;</span><span class="Apple-style-span" style="font-family: ''AR PL UKai CN''; font-size: medium; "><b>N</b></span><span class="Apple-style-span" style="font-family: ''AR PL UKai CN''; font-size: medium; ">lines containing the copper concentration (between 1 and 999) and price (in cents) of each brick type. No brick costs more than 10 dollars.</span></p>\r\n<p>\r\n<meta http-equiv="content-type" content="text/html; charset=utf-8" /></p>\r\n<p style="font-family: ''AR PL UKai CN''; font-size: medium; ">The second part consists of a line containing a number&nbsp;<b>C</b>&nbsp;(1 &lt;=&nbsp;<b>C</b>&nbsp;&lt;= 100), the number of clients you are serving, followed by<b>C</b>&nbsp;lines containing&nbsp;<b>M</b>&nbsp;(1 &lt;=&nbsp;<b>M</b>&nbsp;&lt;= 20),&nbsp;<b>CMin</b>&nbsp;(1 &lt;=&nbsp;<b>CMin</b>&nbsp;&lt;= 999), and&nbsp;<b>CMax</b>&nbsp;(1 &lt;=&nbsp;<b>CMax</b>&nbsp;&lt;= 999) for each client.</p>\r\n<p></p>\r\n<p></p>', '<p></p>\r\n<p><span class="Apple-style-span" style="font-family: ''AR PL UKai CN''; font-size: medium; ">Output consists of a line for each client containing the minimum possible price for which they can purchase bricks to meet their demands. If there is no way to match their specifications, output &quot;impossible&quot;.</span></p>\r\n<p>\r\n<meta http-equiv="content-type" content="text/html; charset=utf-8" /></p>\r\n<p></p>', '11\r\n550 300\r\n550 200\r\n700 340\r\n300 140\r\n600 780\r\n930 785\r\n730 280\r\n678 420\r\n999 900\r\n485 390\r\n888 800\r\n3\r\n2 500 620\r\n9 550 590\r\n9 610 620\r\n', '420\r\nimpossible\r\n3635\r\n', '', 0, 0, '2010-08-19 01:35:39', '2010-08-19 01:35:39'),
(298, 1, 'Problem C - Election', 1000, 134217728, 0000000000, 0000000000, '<p></p>\r\n<p>\r\n<title></title>\r\n</p>\r\n<h2>Problem C - Election</h2>\r\n<p>Canada has a multi-party system of government.  Each candidate is generally associated with a party, and the party whose candidates win the most ridings generally forms the government.  Some candidates run as independents, meaning they are not associated with any party. Your job is to count the votes for a particular riding and to determine the party with which the winning candidate is associated.</p>', '', '<p></p>\r\n<p><span class="Apple-style-span" style="font-family: ''AR PL UKai CN''; font-size: medium; ">The first line of input contains a positive integer</span><span class="Apple-style-span" style="font-family: ''AR PL UKai CN''; font-size: medium; ">&nbsp;</span><span class="Apple-style-span" style="font-family: ''AR PL UKai CN''; font-size: medium; "><b>n</b></span><span class="Apple-style-span" style="font-family: ''AR PL UKai CN''; font-size: medium; ">&nbsp;</span><span class="Apple-style-span" style="font-family: ''AR PL UKai CN''; font-size: medium; ">satisfying 2 &lt;=</span><span class="Apple-style-span" style="font-family: ''AR PL UKai CN''; font-size: medium; ">&nbsp;</span><span class="Apple-style-span" style="font-family: ''AR PL UKai CN''; font-size: medium; "><b>n</b></span><span class="Apple-style-span" style="font-family: ''AR PL UKai CN''; font-size: medium; ">&nbsp;</span><span class="Apple-style-span" style="font-family: ''AR PL UKai CN''; font-size: medium; ">&lt;= 20, the number of candidates in the riding.</span><span class="Apple-style-span" style="font-family: ''AR PL UKai CN''; font-size: medium; ">&nbsp;</span><span class="Apple-style-span" style="font-family: ''AR PL UKai CN''; font-size: medium; "><b>n</b></span><span class="Apple-style-span" style="font-family: ''AR PL UKai CN''; font-size: medium; ">pairs of lines follow: the first line in each pair is the name of the candidate, up to 80 characters; the second line is the name of the party, up to 80 characters, or the word &quot;independent&quot; if the candidate has no party. No candidate name is repeated and no party name is repeated in the input. No lines contain leading or trailing blanks.</span></p>\r\n<p>\r\n<meta http-equiv="content-type" content="text/html; charset=utf-8" /></p>\r\n<p></p>\r\n<p></p>', '<p></p>\r\n<p><span class="Apple-style-span" style="font-family: ''AR PL UKai CN''; font-size: medium; ">Output consists of a single line containing one of:</span></p>\r\n<p>\r\n<meta http-equiv="content-type" content="text/html; charset=utf-8" /></p>\r\n<ul style="font-family: ''AR PL UKai CN''; font-size: medium; ">\r\n    <li>The name of the party with whom the winning candidate is associated, if there is a winning candidate and that candidate is associated with a party.</li>\r\n    <li>The word &quot;independent&quot; if there is a winning candidate and that candidate is not associated with a party.</li>\r\n    <li>The word &quot;tie&quot; if there is no winner; that is, if no candidate receives more votes than every other candidate.</li>\r\n</ul>\r\n<p></p>\r\n<p></p>', '3\r\nMarilyn Manson\r\nRhinoceros\r\nJane Doe\r\nFamily Coalition\r\nJohn Smith\r\nindependent\r\n6\r\nJohn Smith\r\nMarilyn Manson\r\nMarilyn Manson\r\nJane Doe\r\nJohn Smith\r\nMarilyn Manson\r\n', 'Rhinoceros\r\n', '', 0, 0, '2010-08-19 01:35:39', '2010-08-19 01:35:39'),
(299, 1, 'Maze', 10000, 67108864, 0000000000, 0000000000, '<p>\r\n	You have been blindfolded and deposited someplace in a maze. You have no idea where you are. You do know, however, that the maze is laid out on a grid, and that each grid location is either blocked or free. In fact, you have memorized a map of the maze. Also, your magnetic personality allows you to always sense which direction is north.</p>\r\n<p>\r\n	In this maze, you have four possible moves: north, south, east, and west. Your task is to find the shortest sequence of moves that will guarantee your escape, regardless of your initial placement in the maze. You have &quot;escaped&quot; whenever you reach a square on an outside edge of the grid (and if you start there, then you&#39;ve already escaped). Further moves are irrelevant once you have escaped. If you try to walk into a wall, you will simply stay in the same spot.</p>\r\n<p>\r\n	You may assume that it is possible to escape from every unblocked position in the maze.</p>\r\n', 'http://plg1.cs.uwaterloo.ca/~acm00/990619/data/html/D.html', '<p>\r\n	<span class="Apple-style-span" style="font-family: ''AR PL UKai CN''; font-size: medium;">Input consists of a positive integer</span><span class="Apple-style-span" style="font-family: ''AR PL UKai CN''; font-size: medium;">&nbsp;</span><span class="Apple-style-span" style="font-family: ''AR PL UKai CN''; font-size: medium;"><b>n</b></span><span class="Apple-style-span" style="font-family: ''AR PL UKai CN''; font-size: medium;">&nbsp;</span><span class="Apple-style-span" style="font-family: ''AR PL UKai CN''; font-size: medium;">&lt;= 8, followed by</span><span class="Apple-style-span" style="font-family: ''AR PL UKai CN''; font-size: medium;">&nbsp;</span><span class="Apple-style-span" style="font-family: ''AR PL UKai CN''; font-size: medium;"><b>n</b></span><span class="Apple-style-span" style="font-family: ''AR PL UKai CN''; font-size: medium;">&nbsp;</span><span class="Apple-style-span" style="font-family: ''AR PL UKai CN''; font-size: medium;">lines giving the rows of an</span><span class="Apple-style-span" style="font-family: ''AR PL UKai CN''; font-size: medium;">&nbsp;</span><span class="Apple-style-span" style="font-family: ''AR PL UKai CN''; font-size: medium;"><b>n</b></span><span class="Apple-style-span" style="font-family: ''AR PL UKai CN''; font-size: medium;">&nbsp;</span><span class="Apple-style-span" style="font-family: ''AR PL UKai CN''; font-size: medium;">by</span><span class="Apple-style-span" style="font-family: ''AR PL UKai CN''; font-size: medium;">&nbsp;</span><span class="Apple-style-span" style="font-family: ''AR PL UKai CN''; font-size: medium;"><b>n</b></span><span class="Apple-style-span" style="font-family: ''AR PL UKai CN''; font-size: medium;">&nbsp;</span><span class="Apple-style-span" style="font-family: ''AR PL UKai CN''; font-size: medium;">grid. This grid describes the maze you are trapped in. Written on the screen, north is up. Blocked locations are denoted by the character &quot;O&quot; (that&#39;s an uppercase &quot;o&quot;), while unblocked locations are indicated by the character &quot;.&quot;.</span></p>', '<p>\r\n	<span class="Apple-style-span" style="font-family: ''AR PL UKai CN''; font-size: medium;">Output consists of a number of lines, each consisting of one of &quot;north&quot;, &quot;south&quot;, &quot;east&quot;, or &quot;west&quot;, indicating the shortest sequence of moves that guarantees escape for any possible unblocked starting position.</span></p>\r\n<p>\r\n	&nbsp;</p>', '4\r\nOO.O\r\n...O\r\nOO..\r\nO..O\r\n', 'east\r\nnorth\r\n', '<br />\r\n', 0, 0, '2010-08-19 01:35:39', '2010-12-05 14:44:11'),
(377, 1, 'You can Solve a Geometry Problem too', 1000, 33554432, 0000000000, 0000000000, '<div class="panel_content">\r\n	Many geometry（几何）problems were designed in the ACM/ICPC. And now, I also prepare a geometry problem for this final exam. According to the experience of many ACMers, geometry problems are always much trouble, but this problem is very easy, after all we are now attending an exam, not a contest :)<br />\r\n	Give you N (1&lt;=N&lt;=300) segments（线段）, please output the number of all intersections（交点）. You should count repeatedly if M (M&gt;2) segments intersect at the same point.<br />\r\n	<br />\r\n	Note:<br />\r\n	You can assume that two segments would not intersect at more than one point.</div>\r\n', 'hdu 1086', '<p>\r\n	Input contains multiple test cases. Each test case contains a integer N (1=N&lt;=100) in a line first, and then N lines follow. Each line describes one segment with four float values x1, y1, x2, y2 which are coordinates of the segment&rsquo;s ending.<br />\r\n	A test case starting with 0 terminates the input and this test case is not to be processed.</p>\r\n', '<p>\r\n	For each case, print the number of intersections, and one line one case.</p>\r\n', '2\r\n0.00 0.00 1.00 1.00\r\n0.00 1.00 1.00 0.00\r\n3\r\n0.00 0.00 1.00 1.00\r\n0.00 1.00 1.00 0.000\r\n0.00 0.00 1.00 0.00\r\n0\r\n', '1\r\n3\r\n', '<br />\r\n', 0, 0, '2010-11-10 21:54:45', '2010-11-11 07:56:05'),
(300, 1, 'Problem E - Boastin'' Red Socks', 1000, 134217728, 0000000000, 0000000000, '<p>\r\n	You have a drawer that is full of two kinds of socks: red and black. You know that there are at least 2 socks, and not more than 50000. However, you do not know how many there actually are, nor do you know how many are red, or how many are black. (Your mother does the laundry!)</p>\r\n<p>\r\n	You have noticed, though, that when you reach into the drawer each morning and choose two socks to wear (in pitch darkness, so you cannot distinguish red from black), the probability that you pick two red socks is exactly <b>p</b>/<b>q</b>, where 0 &lt; <b>q</b> and 0 &lt;= <b>p</b> &lt;= <b>q</b>.</p>\r\n<p>\r\n	From this, can you determine how many socks of each colour are in your drawer? There may be multiple solutions - if so, pick the solution with the fewest total number of socks.</p>\r\n', '', '<p>\r\n	<span class="Apple-style-span" style="font-family: ''AR PL UKai CN''; font-size: medium;">Input consists of multiple problems, each on a separate line. Each problem consists of the integers</span><span class="Apple-style-span" style="font-family: ''AR PL UKai CN''; font-size: medium;">&nbsp;</span><span class="Apple-style-span" style="font-family: ''AR PL UKai CN''; font-size: medium;"><b>p</b></span><span class="Apple-style-span" style="font-family: ''AR PL UKai CN''; font-size: medium;">&nbsp;</span><span class="Apple-style-span" style="font-family: ''AR PL UKai CN''; font-size: medium;">and</span><span class="Apple-style-span" style="font-family: ''AR PL UKai CN''; font-size: medium;">&nbsp;</span><span class="Apple-style-span" style="font-family: ''AR PL UKai CN''; font-size: medium;"><b>q</b></span><span class="Apple-style-span" style="font-family: ''AR PL UKai CN''; font-size: medium;">&nbsp;</span><span class="Apple-style-span" style="font-family: ''AR PL UKai CN''; font-size: medium;">separated by a single space. Note that</span><span class="Apple-style-span" style="font-family: ''AR PL UKai CN''; font-size: medium;">&nbsp;</span><span class="Apple-style-span" style="font-family: ''AR PL UKai CN''; font-size: medium;"><b>p</b></span><span class="Apple-style-span" style="font-family: ''AR PL UKai CN''; font-size: medium;">&nbsp;</span><span class="Apple-style-span" style="font-family: ''AR PL UKai CN''; font-size: medium;">and</span><span class="Apple-style-span" style="font-family: ''AR PL UKai CN''; font-size: medium;">&nbsp;</span><span class="Apple-style-span" style="font-family: ''AR PL UKai CN''; font-size: medium;"><b>q</b></span><span class="Apple-style-span" style="font-family: ''AR PL UKai CN''; font-size: medium;">&nbsp;</span><span class="Apple-style-span" style="font-family: ''AR PL UKai CN''; font-size: medium;">will both fit into an unsigned long integer.</span></p>\r\n<p>\r\n	<span class="Apple-style-span" style="font-family: ''AR PL UKai CN''; font-size: medium;">Input is terminated by a line consisting of two zeroes.</span></p>\r\n<p>\r\n	&nbsp;</p>\r\n<p>\r\n	&nbsp;</p>', '<p>\r\n	<span class="Apple-style-span" style="font-family: ''AR PL UKai CN''; font-size: medium;">For each problem, output a single line consisting of the number of red socks and the number of black socks in your drawer, separated by one space. If there is no solution to the problem, print &quot;impossible&quot;.</span></p>\r\n<p>\r\n	&nbsp;</p>', '1 2\r\n6 8\r\n12 2499550020\r\n56 789\r\n0 0\r\n', '3 1\r\n7 1\r\n4 49992\r\nimpossible\r\n', '<br />\r\n', 0, 0, '2010-08-19 01:35:39', '2010-11-06 10:49:30'),
(301, 1, ' Friend or Foe?', 1000, 134217728, 0000000000, 0000000000, '<p>Luke has a bit of trouble telling the difference between  star systems in the Rebel Alliance and those in the Empire. He has a list of the x,y,z coordinates of each system in the Empire and each in the Alliance, but at warp speed he simply has insufficient time to look up systems in his lists.</p>\r\n<p>After destroying the friendly planet Endor, Luke has had to admit he needs the help of his targeting computer.  His computer, being an early model, can only compute the truth value of the inequality</p>\r\n<pre>\r\n   ax + by + cz + d &gt; 0\r\n</pre>\r\n<p>Where x,y,z are the coordinates of the system, and a,b,c,d are real-valued coefficients.  You are to compute a,b,c,d so that the inequality holds for all systems in the Empire, and for no systems in the Alliance.</p>\r\n<p>Input consists of several test cases followed by -1 -1. Each test case first gives the number of Alliance systems, followed by a line for each system giving the integer coordinates <i>-100 &le; x,y,z &le; 100</i> of the system in 3-dimensional space.  The number of Empire systems, and the coordinates of each, follow.  The Empire and Alliance combined have at least one and no more than 200 systems. All systems have distinct coordinates.</p>\r\n<p>For each test case, output a single line containing a,b,c,d as real numbers separated by spaces.  Use enough precision to ensure that your solution is correct.  You may assume that a solution exists; if there is more than one solution, any one will do.</p>\r\n<h3><img alt="" src="http://plg1.cs.uwaterloo.ca/~acm00/070923/deathstar.jpg" /></h3>', '', '', '', '2\r\n-93 48 -92\r\n-62 12 -32\r\n8\r\n51 98 -61\r\n-3 72 81\r\n95 25 22\r\n89 43 -99\r\n100 -2 -96\r\n-18 45 -63\r\n36 -21 -8\r\n71 -24 42\r\n-1 -1\r\n', '83.000000 65.000000 -27.000000 -62.000000\r\n', '', 1, 0, '2010-08-20 00:30:15', '2010-08-20 00:30:15'),
(302, 1, 'Rinse', 1000, 134217728, 0000000000, 0000000000, '<p>\r\n	Granny&#39;s reunion was a smashing success. Next she is expecting a visit from Eliot Ness and in anticipation of his visit would like to remove as much whiskey from the cream can as possible prior to his visit.</p>\r\n<p>\r\n	Granny can upend the cream can, thus pouring its contents on the ground. But due to surface tension and the shape of the can a small amount of the content remains, even after the can is upended. Granny has a barrel full of rain water that she can use to rinse the can several times. Each rinse involves pouring some amount of water (perhaps none) into the cream can, mixing it thoroughly with the existing contents, and pouring it out. After each rinse an amount of liquid remains, some fraction of which is whiskey and the rest water.</p>\r\n<p>\r\n	Mr. Ness&#39; visit is imminent, affording Granny the time to do at most <i>k</i> rinses. You are to determine a rinsing strategy that Granny should employ to minimize the amount of residual whiskey in the cream can after the last rinse.</p>\r\n<p>\r\n	Standard input consists of several test cases. Each test case is represented by a line with five numbers:</p>\r\n<ul>\r\n	<li>\r\n		0 &lt; k &le; 100 -- an integer denoting the maximum number of rinses</li>\r\n	<li>\r\n		V<sub>b</sub> &gt; 0 -- a real number denoting the volume of available rain water in the barrel</li>\r\n	<li>\r\n		V<sub>w</sub> &gt; 0 -- a real number denoting the volume of whiskey in the cream can</li>\r\n	<li>\r\n		V<sub>r</sub> &gt; 0 -- a real number denoting the volume of liquid that cannot be poured out by upending the can (further liquid might be eliminated by evaporation, but there is insufficient time before Ness&#39; visit for any evaporation to take place)</li>\r\n	<li>\r\n		V<sub>c</sub> &gt; V<sub>w</sub>,V<sub>r</sub> -- a real number denoting the maximum capacity of the cream can.</li>\r\n</ul>\r\n<p>\r\n	A line containing 0 follows the last case. For each test case, output</p>\r\n<p>\r\n	<i>r</i></p>\r\n<p>\r\n	, the number of rinses that Granny should perform. On the same line, output</p>\r\n<p>\r\n	<i>r</i></p>\r\n<p>\r\n	real numbers, rounded to two decimal places, giving the amount of rain water to be used for each rinse, in order.</p>\r\n<p>\r\n	Note that the total amount of water used in all rinses must not exceed V<sub>b</sub>. The total amount of liquid in the cream can cannot exceed V<sub>c</sub> at any time. Assume that whiskey and water mix perfectly and that their volumes are additive; that is, <i>x</i> units of whiskey and <i>y</i> units of water combine to form <i>x+y</i> units of liquid.</p>\r\n', 'http://plg1.cs.uwaterloo.ca/~acm00/060930/rinse.html', '<p>\r\n	Please Input Input Here</p>\r\n', '<p>\r\n	Please Input Output Here</p>\r\n', '2 15.0 25.0 1.0 50.0\r\n0 \r\n', '2 0.00 15.00\r\n', '', 1, 0, '2010-08-20 00:31:52', '2010-11-18 16:10:22'),
(303, 1, 'The Trip, 2007', 1000, 134217728, 0000000000, 0000000000, '<p>\r\n	A number of students are members of a club that travels annually to exotic locations. Their destinations in the past have included Indianapolis, Phoenix, Nashville, Philadelphia, San Jose, Atlanta, Eindhoven, Orlando, Vancouver, Honolulu, Beverly Hills, Prague, Shanghai, and San Antonio. This spring they are hoping to make a similar trip but aren&#39;t quite sure where or when.</p>\r\n<p>\r\n	An issue with the trip is that their very generous sponsors always give them various knapsacks and other carrying bags that they must pack for their trip home. As the airline allows only so many pieces of luggage, they decide to pool their gifts and to pack one bag within another so as to minimize the total number of pieces they must carry.</p>\r\n<p>\r\n	The bags are all exactly the same shape and differ only in their linear dimension which is a positive integer not exceeding 1000000. A bag with smaller dimension will fit in one with larger dimension. You are to compute which bags to pack within which others so as to minimize the overall number of pieces of luggage (i.e. the number of outermost bags). While maintaining the minimal number of pieces you are also to minimize the total number of bags in any one piece that must be carried.</p>\r\n<p>\r\n	Standard input contains several test cases. Each test case consists of an integer <i>1 &le; n &le; 10000</i> giving the number of bags followed by <i>n</i> integers on one or more lines, each giving the dimension of a piece. A line containing 0 follows the last test case. For each test case your output should consist of <i>k</i>, the minimum number of pieces, followed by <i>k</i> lines, each giving the dimensions of the bags comprising one piece, separated by spaces. Each dimension in the input should appear exactly once in the output, and the bags in each piece must fit nested one within another. If there is more than one solution, any will do. Output an empty line between cases.</p>\r\n', '', '', '', '6\r\n1 1 2 2 2 3\r\n0\r\n', '3\r\n1 2\r\n1 2\r\n3 2', '', 1, 0, '2010-08-20 00:32:37', '2010-10-23 09:04:03'),
(304, 1, 'WFF ', 1000, 134217728, 0000000000, 0000000000, '<p>WFF ''N PROOF is a logic game played with dice.  Each die has six faces representing some subset of the possible symbols K, A, N, C, E, p, q, r, s, t. A Well-formed formula (WFF) is any string of these symbols obeying the following rules:</p>\r\n<ul>\r\n    <li>p, q, r, s, and t are WFFs</li>\r\n    <li>if <i>w</i> is a WFF, N<i>w</i> is a WFF</li>\r\n    <li>if <i>w</i> and <i>x</i> are WFFs, K<i>wx</i>, A<i>wx</i>, C<i>wx</i>, and E<i>wx</i> are WFFs.</li>\r\n</ul>\r\n<p>The meaning of a WFF is defined as follows:</p>\r\n<ul>\r\n    <li>p, q, r, s, and t are logical variables that may take on the value 0 (false) or  1 (true).</li>\r\n    <li>K, A, N, C, E mean <i>and, or, not, implies,</i> and <i>equals</i> as defined in the truth table below.</li>\r\n</ul>\r\n<center>\r\n<table border="1" bgcolor="#ccffff" width="80%" cols="1">\r\n    <tbody>\r\n        <tr>\r\n            <td><center><b><font color="#000099"><font size="+1">Definitions of K, A, N, C, and E</font></font></b></center></td>\r\n        </tr>\r\n    </tbody>\r\n</table>\r\n<table border="1" bgcolor="#ccffff" width="80%" cols="6">\r\n    <tbody>\r\n        <tr>\r\n            <td>&nbsp;&nbsp;&nbsp;&nbsp; <b><font face="Courier New,Courier"><font size="+1"><i>w</i>&nbsp; <i>x</i></font></font></b></td>\r\n            <td><b><font face="Courier New,Courier"><font size="+1">&nbsp; K<i>wx</i></font></font></b></td>\r\n            <td><b><font face="Courier New,Courier"><font size="+1">&nbsp; A<i>wx</i></font></font></b></td>\r\n            <td><b><font face="Courier New,Courier"><font size="+1">&nbsp;&nbsp; N<i>w</i></font></font></b></td>\r\n            <td><b><font face="Courier New,Courier"><font size="+1">&nbsp; C<i>wx</i></font></font></b></td>\r\n            <td><b><font face="Courier New,Courier"><font size="+1">&nbsp; E<i>wx</i></font></font></b></td>\r\n        </tr>\r\n        <tr>\r\n            <td><b><font face="Courier New,Courier"><font size="+1">&nbsp; 1&nbsp; 1</font></font></b></td>\r\n            <td><b><font face="Courier New,Courier"><font size="+1">&nbsp; 1</font></font></b></td>\r\n            <td><b><font face="Courier New,Courier"><font size="+1">&nbsp; 1</font></font></b></td>\r\n            <td><b><font face="Courier New,Courier"><font size="+1">&nbsp;&nbsp; 0</font></font></b></td>\r\n            <td><b><font face="Courier New,Courier"><font size="+1">&nbsp; 1</font></font></b></td>\r\n            <td><b><font face="Courier New,Courier"><font size="+1">&nbsp; 1</font></font></b></td>\r\n        </tr>\r\n        <tr>\r\n            <td><b><font face="Courier New,Courier"><font size="+1">&nbsp; 1&nbsp; 0</font></font></b></td>\r\n            <td><b><font face="Courier New,Courier"><font size="+1">&nbsp; 0</font></font></b></td>\r\n            <td><b><font face="Courier New,Courier"><font size="+1">&nbsp; 1</font></font></b></td>\r\n            <td><b><font face="Courier New,Courier"><font size="+1">&nbsp;&nbsp; 0</font></font></b></td>\r\n            <td><b><font face="Courier New,Courier"><font size="+1">&nbsp; 0</font></font></b></td>\r\n            <td><b><font face="Courier New,Courier"><font size="+1">&nbsp; 0</font></font></b></td>\r\n        </tr>\r\n        <tr>\r\n            <td><b><font face="Courier New,Courier"><font size="+1">&nbsp; 0&nbsp; 1</font></font></b></td>\r\n            <td><b><font face="Courier New,Courier"><font size="+1">&nbsp; 0</font></font></b></td>\r\n            <td><b><font face="Courier New,Courier"><font size="+1">&nbsp; 1</font></font></b></td>\r\n            <td><b><font face="Courier New,Courier"><font size="+1">&nbsp;&nbsp; 1</font></font></b></td>\r\n            <td><b><font face="Courier New,Courier"><font size="+1">&nbsp; 1</font></font></b></td>\r\n            <td><b><font face="Courier New,Courier"><font size="+1">&nbsp; 0</font></font></b></td>\r\n        </tr>\r\n        <tr>\r\n            <td><b><font face="Courier New,Courier"><font size="+1">&nbsp; 0&nbsp; 0</font></font></b></td>\r\n            <td><b><font face="Courier New,Courier"><font size="+1">&nbsp; 0</font></font></b></td>\r\n            <td><b><font face="Courier New,Courier"><font size="+1">&nbsp; 0</font></font></b></td>\r\n            <td><b><font face="Courier New,Courier"><font size="+1">&nbsp;&nbsp; 1</font></font></b></td>\r\n            <td><b><font face="Courier New,Courier"><font size="+1">&nbsp; 1</font></font></b></td>\r\n            <td><b><font face="Courier New,Courier"><font size="+1">&nbsp; 1</font></font></b></td>\r\n        </tr>\r\n    </tbody>\r\n</table>\r\n</center>\r\n<p>Given a collection of symbols resulting from throwing a set of dice, determine the longest WFF that can be formed from those symbols.</p>\r\n<p>Input consists of several test cases.  Each test case is a single line containing a string containing between 1 and 100 of the characters.  A line containing 0 follows the last case.  For each test case, output a line containing the longest WFF that can be formed using some subset of the letters in the string.  If there are several such WFFs, any one will do.  If no WFF can be constructed, output a line containing &quot;no WFF possible&quot; as shown below.</p>', 'http://plg1.cs.uwaterloo.ca/~acm00/060924/D.html', '', '', 'qKpNq\r\nKKN\r\n0\r\n', 'KqNq\r\nno WFF possible\r\n', '', 1, 0, '2010-08-20 00:32:37', '2010-08-20 00:32:37'),
(305, 1, 'Tournament', 1000, 134217728, 0000000000, 0000000000, '<p>Every September, the Kingdom of Loowater holds a jousting tournament. In each of a series of event, a pair of knights attempt to knock each other from their respective horses.  The winning knight is paired  with another, while the loser is elimnated.  This process continues until all but one knight is eliminated; this knight is declared champion.</p>\n<p>The tournament schedule is organized so that no knight needs  to compete in more than <i>e</i> events to be champion, for the minimum possible <i>e</i> given <i>k</i>,  the number of knights.  In order to construct the schedule, it may be necessary to identify several knights who compete in fewer than <i>e</i> events; these knights are said to be awarded a <i>bye</i> and are excluded from the first round of competition.</p>\n<p>The first round of competition involves pairing as many knights as possible among those who are not awarded a bye.  The competition is more interesting if the knights in each pair are as evenly matched in ability as possible.  You are to determine which knights should be awarded a bye so as to make the first round as interesting as possible.</p>\n<p>Standard input consists of several test cases followed by a line containing 0.  Each test case begins with an integer <i>1 &lt; k  &le; 2500 </i>, the number of knights.  <i>i</i> lines follow, each giving the name and ability of a knight.  The name is a string of lower case letters not longer than 20; the ability is a real number.</p>\n<p>The <i>mismatch</i> between knights with abilities <i>a</i> and <i>b</i> respectively is defined to be <i>(a-b)<sup>2</sup></i>. For each test case, output the names of the knights to be given a bye such that the sum of all mismatch values for pairs of knights competing in the first round is minimized.  If there are several solutions, any will do.  Output an empty line between test cases.</p>', 'http://plg1.cs.uwaterloo.ca/~acm00/070929/D.html', '<p>Please Input Input Here</p>', '<p>Please Input Output Here</p>', '3\ngallahad 10\nlancelot 11\nmccartney 2\n0\n', 'mccartney\n', '', 1, 0, '2010-08-20 00:33:01', '2010-08-20 00:33:01'),
(306, 1, 'Wedding', 1000, 134217728, 0000000000, 0000000000, '<p>Up to thirty couples will attend a wedding feast, at which they will be  seated on either side of a long table. The bride and groom sit at one  end, opposite each other, and the bride wears an elaborate headdress  that keeps her from seeing people on the same side as her. It is  considered bad luck to have a husband and wife seated on the same side  of the table. Additionally, there are several pairs of people conducting  adulterous relationships (both different-sex and same-sex relationships  are possible), and it is bad luck for the bride to see both members of  such a pair.  Your job is to arrange people at the table so as to avoid any bad luck.</p>\n<p>The input consists of a number of test cases, followed by a line  containing 0 0.  Each test case gives <i>n</i>, the number of couples, followed  by the number of adulterous pairs, followed by the pairs, in  the form &quot;4h 2w&quot; (husband from couple 4, wife from couple 2), or &quot;10w  4w&quot;, or &quot;3h 1h&quot;.  Couples are numbered from 0 to <i>n-1</i> with the bride and groom being 0w and 0h.  For each case, output a single line containing  a list of the people that should be seated on the same side as the  bride.  If there are several solutions, any one will do.  If there is no solution, output a line containing &quot;bad luck&quot;.</p>', 'http://plg1.cs.uwaterloo.ca/~acm00/070929/E.html', '<p>Please Input Input Here</p>', '<p>Please Input Output Here</p>', '10 6\n3h 7h\n5w 3w\n7h 6w\n8w 3w\n7h 3w\n2w 5h\n0 0\n', '1h 2h 3w 4h 5h 6h 7h 8h 9h', '', 1, 0, '2010-08-20 00:33:01', '2010-08-20 00:33:01'),
(307, 1, 'Help!', 1000, 134217728, 0000000000, 0000000000, '<p>MegaFirm Inc. has created a set of patterns to aid its telephone help-desk operators in responding to customers.  A pattern is a phrase consisting of words and placeholders.  A word is simply a  string of letters.  A placeholder is a word enclosed in angle  brackets (that is &lt; ... &gt;). A phrase <i>matches</i> a pattern if each placeholder in the pattern can be systematically replaced by a word so as to make the pattern and phrase equal.  By &quot;systematically replaced&quot; we mean that all placeholders enclosing the same word are replaced by the same word.</p>\n<p>For example, the phrase</p>\n<pre>\n   to be or not to be\n</pre>\n<p>matches the pattern</p>\n<pre>\n   &lt;foo&gt; be &lt;bar&gt; not &lt;foo&gt; &lt;baf&gt;\n</pre>\n<p>because we can replace &lt;foo&gt; by to, &lt;bar&gt; by or, and &lt;baf&gt; by be.</p>\n<p>Given two patterns, you are to find a phrase that matches both.</p>\n<p>The first line of input contains <i>n</i>, the number of test cases.  Each test case consists of two lines of input; each a pattern.  Patterns consist of lowercase words, and placeholders containing lowercase words.  No pattern exceeds 100 characters.  Words contain at most 16 characters.  A single space separates adjacent words and placeholders.</p>\n<p>For each test case, output a phrase that matches both patterns.  If several phrases match, any will do.  If no phrase matches, output a line containing &quot;-&quot; (a single minus sign).</p>', '', '', '', '3\nhow now brown <animal>\n<foo> now <color> cow\nwho are you\n<a> <b> <a>\n<a> b\nc <a>\n', 'how now brown cow\n-\nc b\n', '', 1, 0, '2010-08-20 00:36:56', '2010-08-20 00:36:56'),
(308, 1, 'Map', 1000, 134217728, 0000000000, 0000000000, '<p>\r\n	<img algin="right" src="http://plg1.cs.uwaterloo.ca/~acm00/040919/map.gif" /></p>\r\n<p>\r\n	A pirate&#39;s treasure map typically contains a series of instructions which, if followed, lead you from the landing place on a desert isle to <i>the spot marked X</i> where the treasure is buried. You are to construct such a series of instructions for a particular desert isle.</p>\r\n<p>\r\n	The island is a circle with radius <i>r</i> paces whose centre is at (0,0). Relative to the centre, the point (0,1) is north, (0,-1) is south, (1,0) is east, and (-1,0) is west. Also, (1,1) is northeast, (1,-1) is southeast, (-1,1) is northwest, and (-1,-1) is southwest.</p>\r\n<p>\r\n	The landing place, on the circumference, is specified by its coordinates. The spot marked X, on the surface of the island is also specified by its coordinates.</p>\r\n<p>\r\n	Each instruction in the sequence should have the form</p>\r\n<pre>\r\n<i>direction distance</i>\r\n</pre>\r\n<p>\r\n	where<i> direction</i> is one of { north, south, east, west, northeast, northwest, southeast, southwest } and<i> distance</i> is a non-negative real number indicating the number of paces to be travelled in the given direction. When executed as a sequence the instructions should lead from the landing place to the spot marked X without leaving the island. The total distance (that is, the sum of the distances in your sequence) should be minimized. From the possible sequences that minimize total distance, choose one with the minimum number of instructions.</p>\r\n<p>\r\n	Input will consist of a number of test cases, followed by a line containing -1. Each test case consists of a single line containing five real numbers: <i>r, x, y, X, Y</i>. <i>r</i> is the radius of the island; <i>x,y</i> are the coordinates of the landing place; <i>X,Y</i> are the coordinates of the spot marked X. The landing place and the spot marked X are distinct.</p>\r\n<p>\r\n	For each test case, output the sequence, one instruction per line. Distances should be accurate to ten places after the decimal, as shown. Output an empty line between test cases.</p>\r\n', '', '<p>\r\n	Please Input Input Here</p>\r\n', '<p>\r\n	Please Input Output Here</p>\r\n', '100.0 0.0 100.0 25.0 50.0\r\n-1\r\n', 'south 25.0000000000\r\nsoutheast 35.3553390593\r\n', '<br />\r\n', 1, 0, '2010-08-20 00:37:31', '2010-11-06 22:26:03'),
(309, 1, 'Cat', 1000, 134217728, 0000000000, 0000000000, '<p>\r\n	<img align="right" alt="" src="http://plg1.cs.uwaterloo.ca/~acm00/040919/cat250.jpg" /></p>\r\n<p>\r\n	In strong winds, sailboats tend to heel leeward (tilt away from the wind) like the one in the picture. Heeling is undesirable for at least two reasons. First, the effective sail area is reduced, as the effective height of the sail is multiplied by the cosine of the angle. Reduced sail area implies reduced speed. Second, the boat may heel to the point that its centre of gravity ceases to be above the hull, causing the boat to capsize.</p>\r\n<p>\r\n	To mitigate these problems, catamarans like the one shown split the hull into two pieces (the port and starboard hulls). This design increases the effective width of the boat. Increased width decreases the vertical mechanical advantage of the sail, thus reducing heeling. Increased width also increases the angle of heeling that can be tolerated before the boat capsizes.</p>\r\n<p>\r\n	Heeling can also be mitigated by having the crew sit or stand on, or even hike out beyond, the windward hull. If you look carefully at the picture you can see the two person crew hiking to windward.</p>\r\n<p>\r\n	At some wind velocity, even these measures are insufficient to keep the boat upright. A skipper&#39;s only choice (other than to capsize) is to let out the sail, which reduces its effective horizontal dimension much as heeling reduces its vertical dimension. As with heeling, this action causes loss of speed. If the boat heels sufficiently, it may not even be possible to let out the sail, as its outer corner may be obstructed by the surface of the water!</p>\r\n<p>\r\n	Reefing is a mechanism for reducing the sail&#39;s area. Roller reefing involves wrapping the sail around the boom (much like a window blind) so as to reduce its height. With sufficient reefing, the heeling can be controlled in almost any wind.</p>\r\n<p>\r\n	But reefing involves reduced speed, so our skipper has elected yet another approach. She has decided to beach the boat and pick up some rocks to use as ballast. Ballast is just dead weight added to hull, which tends to counteract heeling. It slows the boat a bit (as it rides lower in the water) but not nearly so much as reducing sail area.</p>\r\n<p>\r\n	Given <i>n</i> rocks, you are to compute how to divide them between the port and starboard hulls so that the weight of rocks in each hull is nearly equal.</p>\r\n', '', '<p>\r\n	Input contains several test cases. Each test case begins with 1 &lt;&nbsp;<i>n</i>&nbsp;&le; 100; the number of rocks to be added as ballast. Consider the rocks to be numbered 1 through&nbsp;<i>n</i>.&nbsp;<i>n</i>&nbsp;lines follow; the&nbsp;<i>i</i>th line gives the weight in kg of the&nbsp;<i>i</i>th rock - a positive real number not greater than 100. A line containing 0 follows the last test case.</p>\r\n', '<p>\r\n	&nbsp;</p>\r\n<p>\r\n	For each test case, output a single line giving the numbers of the rocks that should be loaded as ballast into the starboard hull. Assume that the other rocks will be loaded into the port hull. The total weight of ballast in the port hull should not differ from that in the starboard hull by more than 2%. If there are many solutions, any one will do. There will always be a solution; indeed, there will always be a solution that balances within 1%, but you aren&#39;t required to find it.</p>\r\n', '5\r\n10.0\r\n50.0\r\n90.0\r\n38.0\r\n7.1\r\n0\r\n', '3 5\r\n', '', 1, 0, '2010-08-20 00:37:31', '2010-11-18 16:14:47'),
(310, 1, ' Tango Tango Insurrection', 1000, 134217728, 0000000000, 0000000000, '<p><img align="left" alt="" src="http://plg1.cs.uwaterloo.ca/%7Eacm00/040131/ddr1.gif" /></p>\r\n<p>You are attempting to learn to play a simple arcade dancing game. The game has 4 arrows set into a pad: Up, Left, Down, Right.  While a song plays, you watch arrows rise on a screen, and when they hit the top, you have to hit the corresponding arrows on the pad.  There is no penalty for stepping on an arrow without need, but note that merely standing on an arrow does not activate it; you must actually tap it with your foot. Many sequences in the game are very fast-paced, and require proper footwork if you don''t want to tire yourself out.  Write a program to determine the easiest way to execute a certain sequence of arrows.</p>\r\n<p>We will work with a basic time unit of an eighth-note.  At any given time, your left foot and right foot will each be on distinct arrows. Only one foot may perform an action (changing arrows and/or tapping) during any time unit; jumping is not allowed.  Also, you must remain facing forward in order to see the screen.  This puts limitations on which feet you can use to hit which arrows.  Finally, hitting two arrows in a row with the same foot (&quot;double-tapping&quot;) is exhausting, because you can''t shift your weight onto that foot.  Ideally, you want to alternate feet all the way through a string of consecutive arrows.</p>\r\n<p>Performing an action with a foot costs 1 unit of energy if it did NOT perform an action in the previous time unit.  If it did, then it costs 3 units if it doesn''t change arrows, 5 units if it moves to an adjacent arrow, and 7 units if it moves directly across the pad (between Up and Down, or Left and Right).</p>\r\n<p>Under normal circumstances, you can''t put your left foot on Right, or your right foot on Left.  However, you CAN do a temporary &quot;crossover&quot;: if your left foot is on Up or Down, you can twist your hips and put your right foot on Left - but until your right foot moves away, you can''t move your left to a different arrow.  (Imagine the tangle your legs would get into if you tried!)  Similarly, you can cross your left foot over/behind your right.</p>', 'http://plg1.cs.uwaterloo.ca/~acm00/040131/A.html', '<p>You will be given multiple arrow sequences to provide foot guides for. Every sequence consists of a line containing from 1 to 70 characters, representing the arrow that must be hit at each time unit.  The possible characters are U, L, D, and R, signifying the four arrows, or a period, indicating that no arrow need be hit.  Assume that your left and right feet start on the Left and Right arrows for the first time unit of a sequence.</p>\r\n<p>There are at most 100 sequences.  Input is terminated by a line consisting of a single #.</p>', '<p>For each input sequence, output a string of the same length, indicating which foot should perform an action at each time step, or ''.'' if neither does.  If there are multiple solutions that require minimal energy, any will do.</p>', 'LRLRLLLLRLRLRRRRLLRRLRLDU...D...UUUUDDDD\r\n#\r\n', 'LRLRLLLLRLRLRRRRLLRRLRLRL...R...LLLLRRRR\r\n', '', 1, 0, '2010-08-20 00:38:44', '2010-08-20 00:38:44');
INSERT INTO `tbl_problems` (`id`, `user_id`, `title`, `time_limit`, `memory_limit`, `submission_no`, `accepted_no`, `description`, `source`, `input`, `output`, `input_sample`, `output_sample`, `hint`, `flag`, `visibility`, `created`, `modified`) VALUES
(311, 1, 'Jack and Jill', 1000, 134217728, 0000000000, 0000000000, '<p>Ever since the incident on the hill, Jack and Jill dislike each other and wish to remain as distant as possible.  Jack and Jill must attend school each day; Jack attends a boys'' school while Jill attends a girls''  school.  Both schools start at the same time.  You have been retained by their lawyers to arrange routes and a schedule that Jack and Jill will adhere to so as to maximize the closest straight-line distance between  them at any time during their trip to school.</p>\r\n<p>Jack and Jill live in a town laid out as an <i>n</i> by <i>n</i> square grid (<i>n</i> &lt;= <i>30</i>).  It takes 1 minute to walk from one location to an adjacent location.  In maximizing the distance between Jack and Jill you need consider only the distance between the locations they visit (i.e. you need not consider any intermediate points on the path they take from grid location to grid location).  Some locations are impassable due to being occupied by rivers, buildings, etc.   Jack must start at his house and walk continuously until he gets to school.  Jill must start at her house at the same time as Jack  and walk continuously until she arrives at her school. Jack''s house and school are impassable to Jill while Jill''s house and school are impassable to Jack.  Other grid locations that are impassable to both Jack and Jill are given in the input.</p>\r\n<p>Input will consist of several test cases.  Each test case will consist of <i>n</i>, followed by <i>n</i> lines with <i>n</i> characters representing a map of the town.  In the map, Jack''s house is represented by ''H'', Jack''s school is represented by ''S'', Jill''s house is represented by ''h'', Jill''s school is represented by ''s'', impassable locations  are represented by ''*'', and all other locations are represented by ''.'' You may assume the normal cartographic convention that North is at the top of the page and West is to the left.  A line containing 0 follows the last case.</p>\r\n<p>For each input case you should give three lines of output containing:</p>\r\n<ul>\r\n    <li>the closest that Jack and Jill come during the schedule (to 2 decimal places)</li>\r\n    <li>Jack''s route</li>\r\n    <li>Jill''s route.</li>\r\n</ul>\r\n<p>Each route is a sequence of directions that Jack or Jill  should follow for  each minute from the start time until arriving at school. Each direction is one of ''N'', ''S'', ''E'', or ''W''.  If several pairs of routes are possible, any one will do.  You may assume there is at least one solution. Leave a blank line between the output for successive cases.</p>\r\n<h3>&nbsp;</h3>', 'http://plg1.cs.uwaterloo.ca/~acm00/040131/D.html', '', '', '10\r\n..........\r\n...H......\r\n.**...s...\r\n.**.......\r\n.**.......\r\n.**.......\r\n.**.......\r\n.**.......\r\n...S..h..*\r\n..........\r\n0\r\n', '6.71\r\nWWWSSSSSSSEEE\r\nNEEENNNNNWWW\r\n', '', 1, 0, '2010-08-20 00:38:44', '2010-08-20 00:38:44'),
(312, 1, 'A Brief Gerrymander', 1000, 134217728, 0000000000, 0000000000, '<p>The evil ruling party, the Liberatives, are redistributing the  electoral regions (ridings) in your city, and are nefariously attempting to pack certain  opposition-friendly neighborhoods into as few ridings as possible.  If this plan succeeds, it will be the end of democracy as we know it!  As a card-carrying member of the noble, compassionate Conservals (the main opposition party),  you must foil their devious plot and safeguard the future of our country.</p>\r\n<p>Under the new plan, the city will be divided up into a grid of rectangles by selecting certain major streets and avenues as boundaries.  All streets and avenues stretch straight across the city, and are numbered starting from the southwest corner of the city.  The city is bounded by four roads: 1st Street (west edge), 100th Street (east edge), 1st Avenue (south edge), 100th Avenue (north edge).  Clearly these four roads must represent district boundaries; however, only a subset of the streets and avenues in between will divide districts.  The Liberatives have already been able to fix the North-South (street) boundaries; however, they have been forced to allow the Conservals  to select the East-West (avenue) boundaries.</p>\r\n<p>You know the location of all the opposition-friendly neighborhoods, which vote strongly Conserval. A neighborhood is exactly one block between adjacent streets and avenues.  For instance, one neighborhood might lie between 47th and 48th Street and 67th and 68th Avenue.   Place the avenue boundaries  so that as many ridings as possible contain at least one opposition-friendly  neighborhood.</p>\r\n<p>Input consists of multiple cases, each describing a city.  The first line  will give N, the number of Conserval neighborhoods in the city; the following N lines will contain the street and avenue number of the southwest corner of each neighborhood.  The next line will contain S, the number of street boundaries, and the S street numbers that they lie on, in increasing order. The final line will consist of A (at least 2), the number of avenue  boundaries you must place.  Input will be terminated by a line containing -1.</p>\r\n<p>For each case, output a single line giving A followed by <i>A</i> distinct avenue numbers for the optimal redistriubution, in increasing order.   If there are multiple such solutions, any one will do.</p>\r\n<h3>&nbsp;</h3>', '', '', '', '2\r\n49 49 \r\n50 50\r\n2 1 100\r\n3\r\n-1\r\n', '3 1 50 100\r\n', '', 1, 0, '2010-08-20 00:39:00', '2010-08-20 00:39:00'),
(313, 1, ' Russian Dolls', 1000, 134217728, 0000000000, 0000000000, '<p>Russian nesting dolls are brightly painted hollow wooden figures.  The dolls in a set have roughly  the same shape, typically humanoid, but different sizes. When the set is assembled, the biggest doll contains the second-biggest doll, the second-biggest contains the third-biggest, and so on.</p>\r\n<p>We can approximate the shape of a doll as a cylinder  of height <i>h</i>, diameter <i>d</i>, and wall  thickness <i>w</i>.  Such a doll would have a hollow of height <i>h-2w</i> and diameter <i>d-2w</i>.</p>\r\n<p>Boris and Natasha each has a set of dolls. The sets are nearly identical; each has the same number of dolls, which look the same but differ in their dimensions. Last night Boris and Natasha were playing with their dolls and left them in the living room.  Their mother tidied them away, dumping them all in one box.  Can you help Boris and Natasha separate their sets of dolls?</p>\r\n<p>Standard Input will consist of several test cases.  The first line of each test case will contain <i>n</i>, the number of dolls in each set (1 &lt; n &lt;= 100).  2n lines follow; each gives the dimensions, <i>h</i>, <i>d</i>, <i>w</i> of a different doll (h,d &gt;= 2w &gt; 0).   A line containing 0 follows the last test case.</p>\r\n<p>For each test case, separate the dolls into two sets of nesting dolls such that, within each set, the dolls fit within each other, standing straight up, as described  above.  The first <i>n</i> lines of output should give the dimensions of the dolls in one set, in decreasing order by height.  The next line should contain a single hyphen, &quot;-&quot;. The next <i>n</i> lines should give the dimensions of the dolls in the second set, also in decreasing order by height.   There will always be a solution.  If there are many solutions, any will do.  Output an empty line between test cases.</p>', '', '', '', '3\r\n100 100 3\r\n97 97 3\r\n94 94 3\r\n91 91 3\r\n88 88 3\r\n85 85 3\r\n5\r\n100 100 1\r\n97 97 3\r\n98 98 1\r\n96 96 1\r\n94 94 1\r\n92 92 1\r\n90 90 1\r\n88 88 1\r\n86 86 1\r\n84 84 1\r\n0\r\n\r\n', '100 100 3\r\n94 94 3\r\n88 88 3\r\n-\r\n97 97 3\r\n91 91 3\r\n85 85 3\r\n\r\n100 100 1\r\n98 98 1\r\n96 96 1\r\n94 94 1\r\n92 92 1\r\n-\r\n97 97 3\r\n90 90 1\r\n88 88 1\r\n86 86 1\r\n84 84 1\r\n', '', 1, 0, '2010-08-20 00:39:42', '2010-08-20 00:39:42'),
(314, 1, 'Home Work', 1000, 67108864, 0000000000, 0000000000, '<p>临近开学了，大家都忙着收拾行李准备返校，但I_Love_C却不为此担心! 因为他的心思全在暑假作业上：目前为止还未开动(-_-!!还以为他有多冷静呢)。<br />\n暑假作业是很多张试卷，我们这些从试卷里爬出来的人都知道，卷子上的题目有选择题、填空题、简答题、证明题等。 而做选择题的好处就在于工作量很少，但又因为选择题题目都普遍很长。 如果有5张试卷，其中4张是选择题，最后一张是填空题，很明显做最后一张所花的时间要比前4张长很多。 但如果你只做了选择题，虽然工作量很少，但表面上看起来也已经做了4/5的作业了。 I_Love_C决定就用这样的方法来蒙混过关。<br />\n他统计出了做完每一张试卷所需的时间以及它做完后能得到的价值（按上面的原理，选择题越多价值当然就越高咯）。 现在就请你帮他安排一下，用他仅剩的一点时间来做最有价值的作业。</p>', '陆泽西', '<p>测试数据包括多组。 每组测试数据以两个整数M，N(1&le;M&le;20, 1&le;N&le;10000)开头，分别表示试卷的数目和I_Love_C剩下的时间。 接下来有M行，每行包括两个整数T，V(1&le;T&le;N,0&lt;V&lt;10000)，分别表示做完这张试卷所需的时间以及做完后能得到的价值！ 输入以0 0结束。</p>', '<p>对应每组测试数据输出I_Love_C能获得的最大价值。<br />\n保留小数点2位</p>', '4 20\n4 10\n5 22\n10 3\n1 2\n0 0', '37.00', '<p>float的精度可能不够。 你应该使用double类型。 报告参见http://acm.zjgsu.edu.cn/Report/1001/1001.html</p>', 0, 0, '2010-08-20 00:59:53', '2010-08-20 00:59:53'),
(315, 1, '1、2、3、4、5...', 1000, 67108864, 0000000000, 0000000000, '<p><img align="right" src="Image/1003/1.jpg" alt="" /> 浙江工商大学校园里绿树成荫，环境非常舒适，因此也引来一批动物朋友来此居住。<br />\n童心未泯的redraiment就经常带些碎面包什么的去广场喂鸽子和兔子，并和它们玩耍。一点也不像大学生，还是一副老不正经的样子，呵呵。<br />\n随着鸽子和兔子数目的增多，redraiment带的那点食物已经不够它们瓜分了。为了能让自己的好朋友吃的饱饱的，redraiment决定统计一下有多少只鸽子和有多少只兔子，以便带来足够的食物。一、二、三、四、五...他开始数了。<br />\n现在，他已经知道有这些鸽子和兔子一共有n个头和m只脚。请你帮他写个程序计算一下一共有多少只鸽子和兔子。</p>', 'Redraiment', '<p>输入包括多组数据。 每行包括2个数据：n、m(代表上面题目中提到的意思1&le;n, m&le;2<sup>30</sup>)。 n、m都是整数。 输入以0 0作为结束。</p>', '<p>每组数据的输出都只有一行，分别是鸽子的数量和兔子数量。 如果输入的测试数据不能求得结果，那肯定是redraiment这个马大哈数错了，就输出&quot;Error&quot;提示他。</p>', '35 94\n1 3\n0 0', '23 12\nError', '<p>报告参见http://acm.zjgsu.edu.cn/Report/1003/1003.html</p>', 0, 0, '2010-08-20 00:59:59', '2010-08-20 00:59:59'),
(316, 1, '渊子赛马', 1000, 67108864, 0000000000, 0000000000, '<p>赛马是一古老的游戏，早在公元前四世纪的中国，处在诸侯割据的状态，历史上称为&ldquo;战国时期&rdquo;。在魏国作官的孙膑，因为受到同僚庞涓的迫害，被齐国使臣救出后，到达齐国国都。  赛马是当时最受齐国贵族欢迎的娱乐项目。上至国王，下到大臣，常常以赛马取乐，并以重金赌输赢。田忌多次与国王及其他大臣赌输赢，屡赌屡输。一天他赛马又输了，回家后闷闷不乐。孙膑安慰他说：&ldquo;下次有机会带我到马场看看，也许我能帮你。&rdquo;   孙膑仔细观察后发现，田忌的马和其他人的马相差并不远，只是策略运用不当，以致失败。 比赛前田忌按照孙膑的主意，用上等马鞍将下等马装饰起来，冒充上等马，与齐王的上等马比赛。第二场比赛，还是按照孙膑的安排，田忌用自己的上等马与国王的中等马比赛，在一片喝彩中，只见田忌的马竟然冲到齐王的马前面，赢了第二场。关键的第三场，田忌的中等马和国王的下等马比赛，田忌的马又一次冲到国王的马前面，结果二比一，田忌赢了国王。 就是这么简单，现在渊子也来赛一赛马。假设每匹马都有恒定的速度，所以速度大的马一定比速度小的马先到终点（没有意外！！）。不允许出现平局。最后谁赢的场数多于一半(不包括一半)，谁就是赢家(可能没有赢家)。渊子有N(1&le;N&le;1000)匹马参加比赛。对手的马的数量与渊子马的数量一样，并且知道所有的马的速度。聪明的你来预测一下这场世纪之战的结果，看看渊子能否赢得比赛。</p>', '王晓渊', '<p>输入有多组测试数据。 每组测试数据包括3行： 第一行输入N(1&le;N&le;1000)。表示马的数量。 第二行有N个整型数字，即渊子的N匹马的速度。 第三行有N个整型数字，即对手的N匹马的速度。 当N为0时退出。</p>', '<p>若通过聪明的你精心安排，如果渊子能赢得比赛，那么输出&ldquo;YES&rdquo;。 否则输出&ldquo;NO&rdquo;。</p>', '5\n2 3 3 4 5\n1 2 3 4 5\n4\n2 2 1 2\n2 2 3 1\n0', 'YES\nNO', '<p>报告参见http://acm.zjgsu.edu.cn/Report/1004/1004.html</p>', 0, 0, '2010-08-20 01:00:04', '2010-08-20 01:00:04'),
(317, 1, 'Hero In Maze', 1000, 67108864, 0000000000, 0000000000, '<p>500年前，Jesse是我国最卓越的剑客。他英俊潇洒，而且机智过人^_^。<br />\n突然有一天，Jesse心爱的公主被魔王困在了一个巨大的迷宫中。Jesse听说这个消息已经是两天以后了，他知道公主在迷宫中还能坚持T天，他急忙赶到迷宫，开始到处寻找公主的下落。 时间一点一点的过去，Jesse还是无法找到公主。最后当他找到公主的时候，美丽的公主已经死了。从此Jesse郁郁寡欢，茶饭不思，一年后追随公主而去了。T_T 500年后的今天，Jesse托梦给你，希望你帮他判断一下当年他是否有机会在给定的时间内找到公主。<br />\n他会为你提供迷宫的地图以及所剩的时间T。请你判断他是否能救出心爱的公主。</p>', '陆泽西', '<p>题目包括多组测试数据。 每组测试数据以三个整数N,M,T(0&lt;n, m&le;20, t&gt;0)开头，分别代表迷宫的长和高，以及公主能坚持的天数。 紧接着有M行，N列字符，由&quot;.&quot;，&quot;*&quot;，&quot;P&quot;，&quot;S&quot;组成。其中 &quot;.&quot; 代表能够行走的空地。 &quot;*&quot; 代表墙壁，Jesse不能从此通过。 &quot;P&quot; 是公主所在的位置。 &quot;S&quot; 是Jesse的起始位置。 每个时间段里Jesse只能选择&ldquo;上、下、左、右&rdquo;任意一方向走一步。 输入以0 0 0结束。</p>', '<p>如果能在规定时间内救出公主输出&ldquo;YES&rdquo;，否则输出&ldquo;NO&rdquo;。</p>', '4 4 10\n....\n....\n....\nS**P\n0 0 0', 'YES', '<p>报告参见http://acm.zjgsu.edu.cn/Report/1005/1005.html</p>', 0, 0, '2010-08-20 01:00:09', '2010-08-20 01:00:09'),
(318, 1, 'Redraiment猜想', 1000, 10485760, 0000000000, 0000000000, '<p>redraiment在家极度无聊，于是找了张纸开始统计素数的个数。 设函数f(n)返回从1-&gt;n之间素数的个数。 redraiment发现:  f(1)   = 0 f(10)  = 4 f(100) = 25 ...  满足g(m) = 17 * m<sup>2</sup> / 3 - 22 * m / 3 + 5 / 3 其中m为n的位数。 他很激动，是不是自己发现了素数分布的规律了！ 请你设计一个程序，求出1-&gt;n范围内素数的个数，来验证redraiment是不是正确的，也许还可以得诺贝尔奖呢。^_^</p>', 'Redraiment', '<p>输入包括多组数据。 每组数据仅有一个整数n (1&le;n&le;100000000)。 输入以０结束</p>', '<p>对于每组数据输入，输出一行，为1-&gt;n(包括n)之间的素数的个数。</p>', '1\n10\n65\n100\n0', '0\n4\n18\n25', '<p>报告参见http://acm.zjgsu.edu.cn/Report/1006/1006.html</p>', 0, 0, '2010-08-20 01:00:13', '2010-08-20 01:00:13'),
(319, 1, '童年生活二三事', 1000, 67108864, 0000000000, 0000000000, '<p>Redraiment小时候走路喜欢蹦蹦跳跳，他最喜欢在楼梯上跳来跳去。 但年幼的他一次只能走上一阶或者一下子蹦上两阶。 现在一共有N阶台阶，请你计算一下Redraiment从第0阶到第N阶共有几种走法。</p>', 'Redraiment', '<p>输入包括多组数据。 每组数据包括一行:N(1&le;N&le;40)。 输入以0结束。</p>', '<p>对应每个输入包括一个输出。 为redraiment到达第n阶不同走法的数量。</p>', '1\n2\n0', '1\n2', '<p>报告参见http://acm.zjgsu.edu.cn/Report/1007/1007.html</p>', 0, 0, '2010-08-20 01:00:17', '2010-08-20 01:00:17'),
(320, 1, 'University', 1000, 67108864, 0000000000, 0000000000, '<pre>\n在大学里，很多单词都是一词多义，偶尔在文章里还要用引申义。这困扰Redraiment很长的时间。\n他开始搜集那些单词的所有意义。他发现了一些规律，例如\n“a”能用“e”来代替, “c”能用“f”来代替……\n现在他给出了字母的替换规则，如下所示，A被E替换，B被C替换，依次类推。\nA B C D E F G H I J K L M N O P Q R S T U V W X Y Z\nE C F A J K L B D G H I V W Z Y M N O P Q R S T U X\na b c d e f g h i j k l m n o p q r s t u v w x y z\ne r w q t y g h b n u i o p s j k d l f a z x c v m\n</pre>', '陆泽西', '本题包括多组测试数据。\n每组测试数据为一行：为仅由字母和空格组成的字符串(空格不变)。\n输入以单行“#”结束。', '对应每组测试数据，替换后输出它的引申义。', 'Ilttabaje zaujljg\n#', 'Different meaning', '报告参见http://acm.zjgsu.edu.cn/Report/1008/1008.html', 0, 0, '2010-08-20 01:00:21', '2010-08-20 01:00:21'),
(321, 1, '目标柏林', 1000, 67108864, 0000000000, 0000000000, '<img src="Image/1009/1.jpg" align=right>\n1945年初，苏军和英美联军已从东西两面攻入德国国境。\n4月初，在苏军和英美联军的夹击下，德军只能龟缩在以柏林为中心的德国东部的狭长地带，成了瓮中之鳖。\n但希特勒困兽犹斗，一方面发出摧毁一切设施，实行“焦土”政策的指令；\n另一方面下令把德国分为南北两个行政区，各自作战，他自己则固守柏林。\n在这一天，苏军结果一份传自柏林的加密电文。经初步破译，显示希特勒要调集100万兵力，\n在柏林周围筑起了三层防卫圈，并集中3300架飞机，1500多辆坦克，1万门火炮和迫击炮，准备死守柏林。\n形势很危机，我们需要马上破译所有密码。请你来遍个程序帮忙破译。<br>\n苏军知道德军用的加密方法是这样的：\n1.获得一段文字后，求出它的长度(包括空格)len。\n2.进入加密运算的第1步:把所有下标是1倍数的字符做顺时针旋转。\n3.进入加密运算的第2步:把所有下标是2倍数的字符做逆时针旋转。\n4.进入加密运算的第3步:把所有下标是3倍数的字符做顺时针旋转。\n5.按上面的规则，第奇数步按顺时针旋转，偶数步按逆时针旋转，一直到第len步为止。<br>\n比如原文是:abcde\n1.获得长度len = 5\n2.1的倍数有1、2、3、4、5，所以把这5个字符按顺时针旋转，得到eabcd。\n3.2的倍数有2、4，所以把这2个字符按逆时针旋转，得到ecbad。\n4.3的倍数有3，所以把这1个字符按顺时针旋转，得到ecbad。\n5.4的倍数有4，所以把这1个字符按逆时针旋转，得到ecbad。\n6.5的倍数有5，所以把这1个字符按顺时针旋转，得到ecbad。\n最后的结果是ecbad。<br>\n现在给你加密后的文章，让你还原成原来的文章。\n</img>', 'Redraiment', '输入一篇加密后的文章，每行为一段。每段不超过1000个字符。\n输入以文件结束(EOF)为止。\n', '输出解密后的文章。\n每段一行。', 'ecbad', 'abcde', '<pre>\nC and C++ language can use :\n\nchar input[1001];\nwhile(gets(input))\n{\n	...\n}\n\n报告参见http://acm.zjgsu.edu.cn/Report/1009/1009.html\n</pre>', 0, 0, '2010-08-20 01:00:25', '2010-08-20 01:00:25'),
(322, 1, 'Rails', 1000, 67108864, 0000000000, 0000000000, '<p>There is a famous railway station in PopPush City. Country there is incredibly hilly. The station was built in last century. Unfortunately, funds were extremely limited that time. It was possible to establish only a surface track. Moreover, it turned out that the station could be only a dead-end one (see picture) and due to lack of available space it could have only one track.</p>\n<center><img alt="" src="http://acm.zjgsu.edu.cn/JudgeOnline/Image/1010/1.jpg" /></center>\n<p>The local tradition is that every train arriving from the direction A continues in the direction B with coaches reorganized in some way. Assume that the train arriving from the direction A has N &lt;= 1000 coaches numbered in increasing order 1, 2, ..., N. The chief for train reorganizations must know whether it is possible to marshal coaches continuing in the direction B so that their order will be a1, a2, ..., aN. Help him and write a program that decides whether it is possible to get the required order of coaches. You can assume that single coaches can be disconnected from the train before they enter the station and that they can move themselves until they are on the track in the direction B. You can also suppose that at any time there can be located as many coaches as necessary in the station. But once a coach has entered the station it cannot return to the track in the direction A and also once it has left the station in the direction B it cannot return back to the station.</p>', 'ZJGSU warmup 1', '<p>The input consists of blocks of lines. Each block except the last describes one train and possibly more requirements for its reorganization. In the first line of the block there is the integer N described above. In each of the next lines of the block there is a permutation of 1, 2, ..., N. The last line of the block contains just 0.   The last block consists of just one line containing 0.</p>', '<p>The output contains the lines corresponding to the lines with permutations in the input. A line of the output contains Yes if it is possible to marshal the coaches in the order required on the corresponding line of the input. Otherwise it contains No. In addition, there is one empty line after the lines corresponding to one block of the input. There is no line in the output corresponding to the last ``null'''' block of the input.</p>', '5\n1 2 3 4 5\n5 4 1 2 3\n0\n6\n6 5 4 3 2 1\n0\n0\n', 'Yes\nNo\n\nYes', '', 0, 0, '2010-08-20 01:00:29', '2010-08-20 01:00:29'),
(323, 1, 'Maximum sum', 1000, 33554432, 0000000000, 0000000000, '<p>\r\n	Given a set of n integers: A={a1, a2,..., an}, we define a function d(A) as below:</p>\r\n<blockquote>\r\n	<img src="/joj/userfiles/admin/0/323formula.png" style="width: 339px; height: 67px;" /></blockquote>\r\n<p>\r\n	Your task is to calculate d(A).</p>\r\n', 'http://acm.pku.edu.cn/JudgeOnline/problem?id=2479', '<p>\r\n	The input consists of T(&lt;=30) test cases. The number of test cases (T) is given in the first line of the input.<br />\r\n	Each test case contains two lines. The first line is an integer n(2&lt;=n&lt;=50000). The second line contains n integers: a1, a2, ..., an. (|ai| &lt;= 10000).There is an empty line after each case.</p>\r\n', '<p>\r\n	Print exactly one line for each test case. The line should contain the integer d(A)</p>\r\n', '1\r\n\r\n10\r\n1 -1 2 2 3 -3 4 -4 5 -5', '13', '<p>\r\n	In the sample, we choose {2,2,3,-3,4} and {5}, then we can get the answer.<br />\r\n	<br />\r\n	Huge input,scanf is recommended.</p>\r\n', 0, 0, '2010-08-20 08:33:49', '2010-08-20 08:33:49'),
(324, 1, 'Crossed ladders', 1000, 33554432, 0000000000, 0000000000, '<p>\r\n	A narrow street is lined with tall buildings. An x foot long ladder is rested at the base of the building on the right side of the street and leans on the building on the left side. A y foot long ladder is rested at the base of the building on the left side of the street and leans on the building on the right side. The point where the two ladders cross is exactly c feet from the ground. How wide is the street?</p>\r\n<center>\r\n	<p>\r\n		<img src="/joj/userfiles/admin/0/25071.jpg" style="width: 304px; height: 250px;" /></p>\r\n</center>\r\n', 'http://acm.pku.edu.cn/JudgeOnline/problem?id=2507', '<p>\r\n	Each line of input contains three positive floating point numbers giving the values of x, y, and c.</p>\r\n', '<p>\r\n	For each line of input, output one line with a floating point number giving the width of the street in feet, with three decimal digits in the fraction.</p>\r\n', '30 40 10\r\n12.619429 8.163332 3\r\n10 10 3\r\n10 10 1\r\n', '26.033\r\n7.000\r\n8.000\r\n9.798\r\n', '<br />\r\n', 0, 0, '2010-08-20 08:41:20', '2010-08-20 08:41:20'),
(325, 1, 'Binary Tree', 1000, 33554432, 0000000000, 0000000000, '<p>\r\n	<b>Background</b><br />\r\n	Binary trees are a common data structure in computer science. In this problem we will look at an infinite binary tree where the nodes contain a pair of integers. The tree is constructed like this:</p>\r\n<ul>\r\n	<li>\r\n		The root contains the pair (1, 1).</li>\r\n	<li>\r\n		If a node contains (a, b) then its left child contains (a + b, b) and its right child (a, a + b)</li>\r\n</ul>\r\n<br />\r\n<p>\r\n	<b>Problem</b><br />\r\n	Given the contents (a, b) of some node of the binary tree described above, suppose you are walking from the root of the tree to the given node along the shortest possible path. Can you find out how often you have to go to a left child and how often to a right child?</p>\r\n', 'http://acm.pku.edu.cn/JudgeOnline/problem?id=2499', '<p>\r\n	The first line contains the number of scenarios.<br />\r\n	Every scenario consists of a single line containing two integers i and j (1 &lt;= i, j &lt;= 2*10<sup>9</sup>) that represent<br />\r\n	a node (i, j). You can assume that this is a valid node in the binary tree described above.</p>\r\n', '<p>\r\n	The output for every scenario begins with a line containing &quot;Scenario #i:&quot;, where i is the number of the scenario starting at 1. Then print a single line containing two numbers l and r separated by a single space, where l is how often you have to go left and r is how often you have to go right when traversing the tree from the root to the node given in the input. Print an empty line after every scenario.</p>\r\n', '3\r\n42 1\r\n3 4\r\n17 73', 'Scenario #1:\r\n41 0\r\n\r\nScenario #2:\r\n2 1\r\n\r\nScenario #3:\r\n4 6\r\n', '<br />\r\n', 0, 0, '2010-08-20 08:44:19', '2010-08-20 08:44:19'),
(326, 1, 'Tight words', 1000, 33554432, 0000000000, 0000000000, '<p>\r\n	Given is an alphabet {0, 1, ... , k}, 0 &lt;= k &lt;= 9 . We say that a word of length n over this alphabet is tight if any two neighbour digits in the word do not differ by more than 1.</p>\r\n', 'http://acm.pku.edu.cn/JudgeOnline/problem?id=2537', '<p>\r\n	Input is a sequence of lines, each line contains two integer numbers k and n, 1 &lt;= n &lt;= 100.</p>\r\n', '<p>\r\n	For each line of input, output the percentage of tight words of length n over the alphabet {0, 1, ... , k} with 5 fractional digits.</p>\r\n', '4 1\r\n2 5\r\n3 5\r\n8 7', '100.00000\r\n40.74074\r\n17.38281\r\n0.10130\r\n', '<br />\r\n', 0, 0, '2010-08-20 08:51:16', '2010-08-20 08:51:16'),
(327, 1, 'Hamming Problem', 1000, 33554432, 0000000000, 0000000000, '<p>\r\n	For each three prime numbers p1, p2 and p3, let&#39;s define Hamming sequence Hi(p1, p2, p3), i=1, ... as containing in increasing order all the natural numbers whose only prime divisors are p1, p2 or p3.<br />\r\n	<br />\r\n	For example, H(2, 3, 5) = 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, 16, 18, 20, 24, 25, 27, ...<br />\r\n	<br />\r\n	So H5(2, 3, 5)=6.</p>\r\n', 'http://acm.pku.edu.cn/JudgeOnline/problem?id=2545', '<p>\r\n	In the single line of input file there are space-separated integers p1 p2 p3 i.</p>\r\n', '<p>\r\n	The output file must contain the single integer - Hi(p1, p2, p3). All numbers in input and output are less than 10^18.</p>\r\n', '7 13 19 100', '26590291', '<br />\r\n', 0, 0, '2010-08-20 08:57:11', '2010-11-18 16:28:10'),
(328, 1, 'Ones', 1000, 33554432, 0000000000, 0000000000, '<p>\r\n	Given any integer 0 &lt;= n &lt;= 10000 not divisible by 2 or 5, some multiple of n is a number which in decimal notation is a sequence of 1&#39;s. How many digits are in the smallest such a multiple of n?</p>\r\n', 'http://acm.pku.edu.cn/JudgeOnline/problem?id=2551', '<p>\r\n	Each line contains a number n.</p>\r\n', '<p>\r\n	Output the number of digits.</p>\r\n', '3\r\n7\r\n9901\r\n', '3\r\n6\r\n12\r\n\r\n', '', 0, 0, '2010-08-20 09:01:24', '2010-08-20 09:01:24'),
(329, 1, 'Heritage', 1000, 33554432, 0000000000, 0000000000, '<p>\r\n	Your rich uncle died recently, and the heritage needs to be divided among your relatives and the church (your uncle insisted in his will that the church must get something). There are N relatives (N &lt;= 18) that were mentioned in the will. They are sorted in descending order according to their importance (the first one is the most important). Since you are the computer scientist in the family, your relatives asked you to help them. They need help, because there are some blanks in the will left to be filled. Here is how the will looks:<br />\r\n	<br />\r\n	Relative #1 will get 1 / ... of the whole heritage,<br />\r\n	Relative #2 will get 1 / ... of the whole heritage,<br />\r\n	---------------------- ...<br />\r\n	Relative #n will get 1 / ... of the whole heritage.<br />\r\n	<br />\r\n	The logical desire of the relatives is to fill the blanks in such way that the uncle&#39;s will is preserved (i.e the fractions are non-ascending and the church gets something) and the amount of heritage left for the church is minimized.</p>\r\n', 'http://acm.pku.edu.cn/JudgeOnline/problem?id=1405', '<p>\r\n	The only line of input contains the single integer N (1 &lt;= N &lt;= 18).</p>\r\n', '<p>\r\n	Output the numbers that the blanks need to be filled (on separate lines), so that the heritage left for the church is minimized.</p>\r\n', '2', '2\r\n3', '<br />\r\n', 0, 0, '2010-08-20 09:04:56', '2010-08-20 09:04:56'),
(330, 1, 'Problem A: Shopping', 10000, 134217728, 0000000000, 0000000000, '<p></p>\r\n<h2>Problem A: Shopping</h2>\r\n<p><img align="right" alt="" src="http://plg1.cs.uwaterloo.ca/~acm00/100710/A.jpg" />  You have just moved into a new apartment and have a long list of items you need to buy. Unfortunately, to buy this many items requires going to many different stores. You would like to minimize the amount of driving necessary to buy all the items you need.</p>\r\n<p>Your city is organized as a set of intersections connected by roads. Your house and every store is located at some intersection. Your task is to find the shortest route that begins at your house, visits all the stores that you need to shop at, and returns to your house.</p>\r\n<p></p>', 'http://plg1.cs.uwaterloo.ca/~acm00/100710/A.html', '<p>The first line of input contains a single integer, the number of test cases to follow. Each test case begins with a line containing two integers N and M, the number of intersections and roads in the city, respectively. Each of these integers is between 1 and 100000, inclusive. The intersections are numbered from 0 to N-1.  Your house is at the intersection numbered 0. M lines follow, each containing three integers X, Y, and D, indicating that the intersections X and Y are connected by a bidirectional road of length D. The following line contains a single integer S, the number of stores you need to visit, which is between 1 and ten, inclusive. The subsequent S lines each contain one integer indicating the intersection at which each store is located. It is possible to reach all of the stores from your house.</p>', '<p>For each test case, output a line containing a single integer, the length of the shortest possible shopping trip from your house, visiting all the stores, and returning to your house.</p>', '1\r\n4 6\r\n0 1 1\r\n1 2 1\r\n2 3 1\r\n3 0 1\r\n0 2 5\r\n1 3 5\r\n3\r\n1\r\n2\r\n3\r\n', '4\r\n', '', 0, 0, '2010-08-28 01:25:19', '2010-08-28 01:25:19'),
(331, 1, 'Problem B: Stack Machine', 1000, 134217728, 0000000000, 0000000000, '<img align="right" src="http://plg1.cs.uwaterloo.ca/%7Eacm00/100710/B.png" alt="" />\r\n<p>A mathematician observes one person get on a bus. Then two people get off the bus. The mathematician says: &quot;If one more person gets on the bus, the bus will be empty.&quot;</p>\r\n<p>A stack machine is a special kind of bus. It only has doors at the front, and it is so narrow that the people on the bus cannot move past each other. Of the people on the bus, the person who got on the bus last must be the first to get off.</p>\r\n<p>The bus travels in a city in which roads connect intersections, and all the roads are unidirectional. Along each road, a  person either gets on or off the bus.</p>\r\n<p>The mathematician does not know the identity of the bus passengers, but can estimate their height. Note that there may be multiple people with the same height.</p>\r\n<p>Your task is to plan the route of the bus. The bus must be empty at the beginning and end of the route. Along the route, it must pick up and drop off the people corresponding to the roads it travels on. The height of the person that gets on or off the bus is fixed for each road.</p>', '', '<p>The first line of input contains a single integer, the number of test cases to follow. Each test case begins with a line containing three integers N, M, Q, the number of intersections and roads in the city and the number of queries, respectively. The number of intersections is between 1 and 100, inclusive. The number of roads and the number of queries are each between 1 and 100000, inclusive.  Intersections in the city are numbered from 1 to N. The first line of each test case is followed by M lines describing the roads. Each of these lines contains three integers X, Y, and Z. These integers indicate that a road exists from intersection X to intersection Y, and that when the bus travels on this road, a person who is Z centimetres tall gets on the bus, if Z is positive, or a person who is -Z centimetres tall gets off the bus, if Z is negative. For example, Z=170 indicates that a 170 cm tall person gets on the bus, and Z=-170 indicates that a 170 cm tall person gets off the bus. Each person is at least 40 cm and at most 220 cm tall. The lines describing the roads are followed by Q more lines, each describing a query. A line describing a query contains two integers, the beginning and ending intersections of the bus route.</p>', '<p>For each query, output a line containing a single integer giving the length of the shortest non-empty path that the bus can take from the beginning to the end of the route. The input data will be such that this length is no more than 10^9. If there is no such path, output a line containing the word <tt>impossible</tt>.</p>\r\n<h3></h3>', '1\r\n2 2 4\r\n1 2 100\r\n2 1 -100\r\n1 1\r\n2 2\r\n1 2\r\n2 1\r\n', '2\r\nimpossible\r\nimpossible\r\nimpossible\r\n', '', 0, 0, '2010-08-28 01:25:19', '2010-08-28 01:25:19'),
(332, 1, 'Problem C: Ideas', 10000, 134217728, 0000000000, 0000000000, '<p>A unique feature of ideas is that they are not consumed when used. A good idea can benefit arbitrarily many people without diminishing the value of the idea. An idea can even serve as the basis for creative people to derive even better ideas. Each person relies on a specific set of ideas to build on and create new ideas.</p>\r\n<p>In order to realize these benefits, ideas need to be communicated to the people who use them. People have developed an extensive worldwide communication network to satisfy this need. The network is composed of a series of tubes connecting people. The tubes are inhabited by curious creatures called packets which carry ideas from one person to another. In order to avoid collisions between packets, the tubes are all unidirectional. Each person can have zero or more incoming and zero or more outgoing tubes.</p>\r\n<p>All of the packets start at the same person, and each packet follows the following algorithm:</p>\r\n<ol>\r\n    <li>Learn and remember the ideas created by the current person.</li>\r\n    <li>If there are no outgoing tubes from the current person, stop         executing the algorithm.</li>\r\n    <li>Otherwise, choose an arbitrary outgoing tube and use it to         travel to a new person.</li>\r\n    <li>Tell the new person all of the ideas that he or she needs from         other people.</li>\r\n    <li>Go back to step 1.</li>\r\n</ol>\r\n<p>The input data is such that it is possible for a packet to reach every person from person 0, and whenever a person P relies on a given idea, every path a packet could have taken to reach P will have visited at least one person who created that idea. It is possible for more than one person to independently create the same idea.</p>\r\n<p>To ease the strain on each packet, you would like to minimize the number of ideas that it remembers at any given time by directing the packet to forget certain ideas in certain tubes. However, in so doing, you must ensure that no matter what path the packet takes, every time it visits a person, the packet knows all of the ideas that the person needs.</p>', '', '<p>The first line of input contains a single integer, the number of test cases to follow. Each test case begins with a line containing three integers N, M, I, the number of people, tubes, and ideas, respectively. Each of these integers is between 1 and one thousand, inclusive. People are numbered from 0 to N-1, ideas from 0 to I-1. All of the packets start at person 0.  2N lines follow, two lines for each person in order from 0 to N-1. Each of these lines contains some number of integers separated by spaces. For each person, the first line lists the ideas that the person needs, and the second line lists the ideas that the person creates. A given idea will never appear on both lines for the same person. M more lines follow, each describing a tube using two integers: the source and destination person of the tube.</p>', '<p>For each test case, output M lines, each corresponding to one of the tubes in the same order as in the input. For each tube, output a list of integers: the minimal set of ideas the packet must have in its memory when travelling through the given tube. Output the ideas in each set in increasing order.</p>', '1\r\n3 3 2\r\n\r\n1\r\n1\r\n0\r\n0\r\n1\r\n0 1\r\n1 2\r\n2 1\r\n', '1\r\n0\r\n1\r\n', '', 0, 0, '2010-08-28 01:25:20', '2010-08-28 01:25:20'),
(333, 1, 'Problem D: HST', 10000, 134217728, 0000000000, 0000000000, '<p>On July 1st, Ontario''s Provincial Sales Tax (PST) was merged with the Federal Goods and Services Tax (GST), creating the Harmonized Sales Tax (HST). This changed the rate of tax Ontarians pay on various items.</p>\r\n<p>Dalton would like to calculate how this change will affect his personal monthly budget.</p>', '', '<p>The first line of input contains a single integer, the number of test cases to follow. Each test case begins with a line containing two integers N, M, the number of categories of items and the number of purchases Dalton makes each month, respectively. Each of these integers is between 1 and 100000, inclusive. N lines follow, each describing a category of item. Each of these lines contains a category name, which is a string of at most 30 uppercase letters, followed by three percentages, giving the PST, GST, and HST rate on that category. Each percentage is a number with up to two digits after the decimal point, and each percentage is followed by the % symbol. Each percentage is at least 0% and at most 100%. These lines are followed by M more lines, each describing one of Dalton''s purchases. Each of these lines contains a category name and a price in dollars and cents and prefixed by the $ symbol. Each such line indicates the amount of pre-tax money that Dalton spends on an item in the specified category. The amount of each tax to be paid on an item is rounded to the nearest cent; if the tax amount is exactly half a cent more than a whole number of cents, it is rounded up to the nearest greater whole number of cents.</p>', '<p>For each test case, output the difference, in dollars and cents, between the total HST payable and the total sum of PST and GST payable on Dalton''s monthly purchases. If the HST is more than the PST+GST, output a positive amount. If the HST is less than the PST+GST, output a negative amount.</p>\r\n<h3></h3>', '1\r\n1 1\r\ngas 0% 5% 13%\r\ngas $100.00\r\n', '8.00\r\n', '', 0, 0, '2010-08-28 01:25:21', '2010-08-28 01:25:21'),
(334, 1, 'Problem E: Tunnelling the Earth', 1000, 134217728, 0000000000, 0000000000, '<p>There are different methods of transporting people from place to place: cars, bikes, boats, trains, planes, etc. For very long distances, people generally fly in a plane. But this has the disadvantage that the plane must fly around the curved surface of the earth. A distance travelled would be shorter if the traveller followed a straight line from one point to the other through a tunnel through the earth.</p>\r\n<p>For example, travelling from Waterloo to Cairo requires a distance of 9293521 metres following the great circle route around the earth, but only 8491188 metres following the straight line through the earth.</p>\r\n<p>For this problem, assume that the earth is a perfect sphere with radius of 6371009 metres.</p>', '', '<p>The first line of input contains a single integer, the number of test cases to follow. Each test case is one line containing four floating point numbers: the latitude and longitude of the origin of the trip, followed by the latitude and longitude of the destination of the trip. All of these measurements are in degrees. Positive numbers indicate North latitude and East longitude, while negative numbers indicate South latitude and West longitude.</p>', '<p>For each test case, output a line containing a single integer, the difference in the distance between the two points following the great circle route around the surface of the earth and following the straight line through the earth, in metres. Round the difference of the distances to the nearest integer number of metres.</p>', '1\r\n43.466667 -80.516667 30.058056 31.228889\r\n', '802333\r\n', '', 0, 0, '2010-08-28 01:25:22', '2010-08-28 01:25:22'),
(335, 1, '整数变换', 100, 33554432, 0000000000, 0000000000, '<p>\r\n	计算机中的数都是用二进制表示，现在有两个整数a，b</p>\r\n<p>\r\n	试问把a变成b需要改变多少个二进制位？</p>\r\n', '', '<p>\r\n	输入由多行组成，每一行有两个空格分隔的数a&nbsp; b</p>\r\n', '<p>\r\n	需要改变的二进制位数</p>\r\n', '0 1\r\n1 2\r\n3 4', '1\r\n2\r\n3', '<p>\r\n	参考&nbsp;<a href="http://hi.baidu.com/leoispace/blog/item/2b52a21bba9a460c34fa4151.html">http://hi.baidu.com/leoispace/blog/item/2b52a21bba9a460c34fa4151.html</a></p>\r\n', 0, 0, '2010-09-15 21:34:44', '2010-09-15 22:11:15'),
(336, 1, '按1的数目排序', 200, 33554432, 0000000000, 0000000000, '<p>\r\n	给定一个整数序列，求出每个整数的二进制中含位&quot;1&quot;的个数，<br />\r\n	然后根据含&quot;1&quot;的个数对原序列进行从小大大的排序。如果原序列中2个<br />\r\n	整数含&quot;1&quot;的个数相同，按照原数字的大小从小到大排放。</p>\r\n', '', '<p>\r\n	输入包含多个样例</p>\r\n<p>\r\n	每一行第一个整数n为数组大小 后面空格分隔的n个整数为待排序的整数</p>\r\n<p>\r\n	0&lt;=n&lt;=50000</p>\r\n', '<p>\r\n	每行包含由空格分隔的排序数组</p>\r\n', '3 2 3 4\r\n2 3 1\r\n2 -1 1', '2 4 3\r\n1 3\r\n1 -1', '', 0, 0, '2010-09-15 22:26:45', '2010-09-15 23:06:46'),
(337, 1, 'How many words', 3000, 33554432, 0000000000, 0000000000, '<pre>\r\nIn order to make a new word, we will pick out m letters from all the upper case letters \r\nand lower case letters(from &quot;a&quot; to &quot;Z&quot;). Therefore, that means you can pick some same letters. \r\nBut here are two rules:\r\n\r\n(1) as to all the neighbour letters, the absolute value of their ASCII code must be not greater than 32. \r\n(2) there must be at least one pair of neighbour letters whose absolute value of ASCII code is exactly\r\nequal to 32. For example, considering the word in the form like &quot;Xx&quot; or &quot;xX&quot;,the neighbour letters\r\nhave an absolute value of ASCII code exactly equal to 32.\r\n\r\nNow how many different words can we get?\r\n</pre>\r\n', 'http://zuojie.3322.org:88/soj/problem.action?id=3780', '<pre>\r\nThe first line of input is the number of test case.\r\nFor each test case:\r\nThere is only one line contains one integer m.\r\n\r\n2 &lt;= m &lt;= 109\r\n</pre>\r\n', '<pre>\r\nFor each test case output one line, just the answer mod 1000000007.\r\n</pre>\r\n', '4\r\n2\r\n3\r\n100\r\n7926778\r\n', '52\r\n4056\r\n533550434\r\n773908369\r\n', '<br />\r\n', 0, 0, '2010-09-24 20:39:38', '2010-09-24 20:55:49'),
(338, 1, '第K大和第K小的数', 400, 8388608, 0000000000, 0000000000, '<pre>\r\n给定n(0&lt;n&lt;=50000)个整数，\r\n保证每一个序列中的数字a[i]是小于1000的非负整数，\r\n编程要求出整个序列中第k大的数字减去第k小的数字的值m。(0&lt;=k&lt;n)\r\n本题第0大表示最大的数 第n-1大的数表示最小的数。\r\n本题在实现的时候请不要开大小为n的数组a[50000]来保存数据。</pre>\r\n', '', '<pre>\r\n文件中有多个问题需要测试\r\n每个问题的第一行为2个数n和k\r\n第二行为空格分隔n个数</pre>\r\n', '<p>\r\n	对于每一个测试的问题 把答案作为一行输出</p>\r\n', '1 0\r\n1\r\n2 1\r\n3 1', '0\r\n-2\r\n', '<p>\r\n	考虑计数<br />\r\n	&nbsp;</p>\r\n', 0, 0, '2010-09-29 20:15:07', '2010-09-30 08:26:28'),
(339, 1, '第K大的数', 600, 16777216, 0000000000, 0000000000, '<p>\r\n	现在有n个整数 0&lt;n&lt;10<sup>5</sup></p>\r\n<p>\r\n	要求r个数 这r个数 分别为n个数中第k<sub>1</sub>,k<sub>2</sub>,...,k<sub>r</sub>大的数 (0&lt;=k<sub>i</sub>&lt;=200)</p>\r\n<p>\r\n	r&lt;1000</p>\r\n', '', '<p>\r\n	每个文件有多个测试</p>\r\n<p>\r\n	每个测试的第一行包含 n和r</p>\r\n<p>\r\n	第二行为 r个整数 k<sub>1</sub>,k<sub>2</sub>,...,k<sub>r</sub></p>\r\n<p>\r\n	第三行为n个数</p>\r\n', '<p>\r\n	输出每行一个数</p>\r\n', '4 4\r\n1 2 1 2\r\n1 2 3 4\r\n3 4\r\n0 1 2 1\r\n1 2 3\r\n', '3\r\n2\r\n3\r\n2\r\n3\r\n2\r\n1\r\n2\r\n', '<p>\r\n	此题用快速排序做比较快</p>\r\n<p>\r\n	用堆做慢一些</p>\r\n<p>\r\n	但是如果数据很多不能放在内存中</p>\r\n<p>\r\n	采用堆比较好，只需一个200+2个或200+1个元素的堆</p>\r\n', 0, 0, '2010-09-29 23:22:04', '2010-09-30 09:42:26');
INSERT INTO `tbl_problems` (`id`, `user_id`, `title`, `time_limit`, `memory_limit`, `submission_no`, `accepted_no`, `description`, `source`, `input`, `output`, `input_sample`, `output_sample`, `hint`, `flag`, `visibility`, `created`, `modified`) VALUES
(340, 6, 'Reduced ID Numbers', 1000, 33554432, 0000000000, 0000000000, '<p>\r\n	T. Chur teaches various groups of students at university U. Every U-student has a unique&nbsp;Student Identification Number (SIN). A SIN s is an integer in the range 0 &le; s &le; MaxSIN withMaxSIN = 10^6 &minus; 1. T. Chur finds this range of SINs too large for identification within hergroups. For each group, she wants to find the smallest positive integer m, such that within&nbsp;the group all SINs reduced modulo m are unique.</p>\r\n', 'The 2005 ACM Northwestern European Programming Contest', '<p>\r\n	On the first line of the input is a single positive integer N, telling the number of test cases&nbsp;(groups) to follow. Each case starts with one line containing the integer G (1 &le; G &le; 300):&nbsp;the number of students in the group. The following G lines each contain one SIN. The SINs&nbsp;within a group are distinct, though not necessarily sorted.</p>\r\n<div id="cke_pastebin" style="position: absolute; left: -1000px; top: 0px; width: 1px; height: 1px; overflow-x: hidden; overflow-y: hidden; ">\r\n	follow. The first line of each test case consists of two integers n r, where 1 &le; n &le; 50 is the size</div>\r\n<div id="cke_pastebin" style="position: absolute; left: -1000px; top: 0px; width: 1px; height: 1px; overflow-x: hidden; overflow-y: hidden; ">\r\n	of the board and 1 &le; r &le; 50 the number of right-turners. The following r lines contain the</div>\r\n<div id="cke_pastebin" style="position: absolute; left: -1000px; top: 0px; width: 1px; height: 1px; overflow-x: hidden; overflow-y: hidden; ">\r\n	coordinates x y of the right-turners. No two right-turners will have the same coordinates.</div>\r\n<div id="cke_pastebin" style="position: absolute; left: -1000px; top: 0px; width: 1px; height: 1px; overflow-x: hidden; overflow-y: hidden; ">\r\n	Finally, a line with two integers indicating the laser position follows. The bottom of</div>\r\n<div id="cke_pastebin" style="position: absolute; left: -1000px; top: 0px; width: 1px; height: 1px; overflow-x: hidden; overflow-y: hidden; ">\r\n	column six is denoted by 6 0 and the start of row seven by 0 7. If the zeroes are replaced by</div>\r\n<div id="cke_pastebin" style="position: absolute; left: -1000px; top: 0px; width: 1px; height: 1px; overflow-x: hidden; overflow-y: hidden; ">\r\n	n + 1, the laser is placed at the top of column six and the end of row seven, respectively.</div>\r\n', '<p>\r\n	For each test case, output one line containing the smallest modulus m, such that all SINs reduced modulo m are distinct.</p>\r\n<div id="cke_pastebin" style="position: absolute; left: -1000px; top: 12px; width: 1px; height: 1px; overflow-x: hidden; overflow-y: hidden; ">\r\n	reduced modulo m are distinct.For each test case, output one line containing the smallest modulus m, such that all SINs</div>\r\n<div id="cke_pastebin" style="position: absolute; left: -1000px; top: 12px; width: 1px; height: 1px; overflow-x: hidden; overflow-y: hidden; ">\r\n	reduced modulo m are distinct.</div>\r\n', '2\r\n1\r\n124866\r\n3\r\n124866\r\n111111\r\n987651', '1\r\n8', '', 0, 0, '2010-09-30 21:49:08', '2010-09-30 23:23:19'),
(341, 6, 'Up the Stairs', 1000, 33554432, 0000000000, 0000000000, '<div>\r\n	John is moving to the penthouse of a tall sky-scraper. He packed all his stuff in boxes and drove them to the entrance of the building on the ground floor. Unfortunately the elevator is out of order, so the boxes have to be moved up the stairs.&nbsp;<br />\r\n	Luckily John has a lot of friends that want to help carrying his boxes up. They all walk the stairway at the same speed of 1 floor per minute, regardless of whether they carry a box or not. The stairway however is so narrow that two persons can&#39;t pass each other on it. Therefore they deciced to do the following: someone with a box in his hands is always moving up and someone empty-handed is always moving down. When two persons meet each other somewhere on the stairway, the lower one (with a box) hands it over to the higher one (without a box). (And then the lower one walks down again and the higher one walks up.) The box exchange is instantaneous. When someone is back on the ground floor, he picks up a box and starts walking up. When someone is at the penthouse, he drops the box and walks down again.&nbsp;<br />\r\n	<br />\r\n	After a while the persons are scattered across the stairway, some of them with boxes in their hands and some without. There are still a number of boxes on the ground floor and John is wondering how much more time it will take before all the boxes are up. Help him to find out!</div>\r\n', 'The 2005 ACM Northwestern European Programming Contest', '<p>\r\n	One line with a positive number: the number of test cases. Then for each test case</p>\r\n<p>\r\n	&nbsp;&nbsp; &nbsp; &nbsp;&bull; One line with three numbers N, F, B with 1 &le; N, F &le; 1, 000 and 1 &le; B &le; 1, 000, 000:&nbsp;the number of persons, the number of floors (0=ground floor, F=penthouse) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;and the&nbsp;number of boxes that are still on the ground floor.</p>\r\n<p>\r\n	&nbsp;&nbsp; &nbsp; &bull; N lines with two numbers fi and bi with 0 &le; fi &le; F and bi = 0 or bi = 1: the floors&nbsp;where the persons are initially and whether or not they have a box in their hands</p>\r\n<div>\r\n	&nbsp;&nbsp; &nbsp; &nbsp; (1=box, 0=no box).</div>\r\n<div>\r\n	<div id="cke_pastebin" style="position: absolute; left: -1000px; top: 39px; width: 1px; height: 1px; overflow-x: hidden; overflow-y: hidden; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">\r\n		<font class="Apple-style-span" face="''Times New Roman'', Times, serif" size="4">One line with a positive number: the number of test cases. Then for each test case:</font></div>\r\n	<div id="cke_pastebin" style="position: absolute; left: -1000px; top: 39px; width: 1px; height: 1px; overflow-x: hidden; overflow-y: hidden; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">\r\n		<font class="Apple-style-span" face="''Times New Roman'', Times, serif" size="4">&bull; One line with three numbers N, F, B with 1 &le; N, F &le; 1, 000 and 1 &le; B &le; 1, 000, 000:</font></div>\r\n	<div id="cke_pastebin" style="position: absolute; left: -1000px; top: 39px; width: 1px; height: 1px; overflow-x: hidden; overflow-y: hidden; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">\r\n		<font class="Apple-style-span" face="''Times New Roman'', Times, serif" size="4">the number of persons, the number of floors (0=ground floor, F=penthouse) and the</font></div>\r\n	<div id="cke_pastebin" style="position: absolute; left: -1000px; top: 39px; width: 1px; height: 1px; overflow-x: hidden; overflow-y: hidden; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">\r\n		<font class="Apple-style-span" face="''Times New Roman'', Times, serif" size="4">number of boxes that are still on the ground floor.</font></div>\r\n	<div id="cke_pastebin" style="position: absolute; left: -1000px; top: 39px; width: 1px; height: 1px; overflow-x: hidden; overflow-y: hidden; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">\r\n		<font class="Apple-style-span" face="''Times New Roman'', Times, serif" size="4">&bull; N lines with two numbers fi and bi with 0 &le; fi &le; F and bi = 0 or bi = 1: the floors</font></div>\r\n	<div id="cke_pastebin" style="position: absolute; left: -1000px; top: 39px; width: 1px; height: 1px; overflow-x: hidden; overflow-y: hidden; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">\r\n		<font class="Apple-style-span" face="''Times New Roman'', Times, serif" size="4">where the persons are initially and whether or not they have a box in their hands</font></div>\r\n	<div id="cke_pastebin" style="position: absolute; left: -1000px; top: 39px; width: 1px; height: 1px; overflow-x: hidden; overflow-y: hidden; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">\r\n		<font class="Apple-style-span" face="''Times New Roman'', Times, serif" size="4">(1=box, 0=no box).</font></div>\r\n</div>\r\n', '<p>\r\n	One line with the amount of time (in minutes) it will take to get all the remaining boxes to&nbsp;the penthouse.</p>\r\n<div id="cke_pastebin" style="position: absolute; left: -1000px; top: 12px; width: 1px; height: 1px; overflow-x: hidden; overflow-y: hidden; ">\r\n	<div>\r\n		<font class="Apple-style-span" face="''Times New Roman'', Times, serif" size="4"><span class="Apple-style-span" style="font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">One line with the amount of time (in minutes) it will take to get all the remaining boxes to</span></font></div>\r\n	<p>\r\n		<font class="Apple-style-span" face="''Times New Roman'', Times, serif" size="4"><span class="Apple-style-span" style="font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px;">the penthouse.One line with the amount of time (in minutes) it will take to get all the remaining boxes to</span></font></p>\r\n	<p>\r\n		<font class="Apple-style-span" face="''Times New Roman'', Times, serif" size="4"><span class="Apple-style-span" style="font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px;">the penthouse.One line with the amount of time (in minutes) it will take to get all the remaining boxes to</span></font></p>\r\n	<div>\r\n		<font class="Apple-style-span" face="''Times New Roman'', Times, serif" size="4"><span class="Apple-style-span" style="font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px;">the penthouse.One line with the amount of time (in minutes) it will take to get all the remaining boxes to</span></font></div>\r\n	<font class="Apple-style-span" face="''Times New Roman'', Times, serif" size="4"><span class="Apple-style-span" style="font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px;">the penthouse.One line with the amount of time (in minutes) it will take to get all the remaining boxes to</span></font></div>\r\n<div id="cke_pastebin" style="position: absolute; left: -1000px; top: 12px; width: 1px; height: 1px; overflow-x: hidden; overflow-y: hidden; ">\r\n	<font class="Apple-style-span" face="''Times New Roman'', Times, serif" size="4"><span class="Apple-style-span" style="font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px;">the penthouse.</span></font></div>\r\n', '2\r\n3 10 5\r\n0 0\r\n0 0\r\n0 0\r\n2 5 1\r\n2 1\r\n3 0', '30\r\n8\r\n', '', 0, 0, '2010-09-30 21:50:53', '2010-10-01 00:39:13'),
(342, 6, 'Unequalled Consumption', 1000, 33554432, 0000000000, 0000000000, '<p>\r\n	The Association of Candy Makers is preparing&nbsp;to launch a new product. Its idea is old with&nbsp;a novel twist: it simply sells boxes of candies.But since people are what they consume and everyone&nbsp;wants to be unique these days, the ACM&nbsp;wants every candy box to be unique, in the sense&nbsp;that no two boxes should contain the same composition&nbsp;of candy types.</p>\r\n<p>\r\n	The ACM is only able to make a small number&nbsp;n of different types of candy, but while limited&nbsp;in imagination, it is virtually limitless in resources,so it is able to produce as many as it&nbsp;wants of each type of candy. Furthermore, the&nbsp;candy types have different weights (though some may weigh the same), and in order to&nbsp;simplify pricing matters, the ACM wants all candy boxes to have the same total weight.</p>\r\n<p>\r\n	&nbsp;</p>\r\n<div>\r\n	<div>\r\n		With these restrictions, the ACM will only be able to make a limited number of boxes.For instance, if there are three types of candy, weighing 5, 5 and 10 grams respectively, 4&nbsp;different boxes can be made with total weight 10 grams (using either two of type 1, or two&nbsp;of type 2, or one of type 3, or one each of types 1 and 2). The ACM would like to be able&nbsp;to make at least one box for everyone in the cosmos. So, given queries in the form of the&nbsp;number of people P in the cosmos, your job is to find the smallest possible total weight w&nbsp;such that P different boxes containing exactly w grams of candies can be made.</div>\r\n</div>\r\n', 'The 2005 ACM Northwestern European Programming Contest', '<p>\r\n	The input consists of several data sets (at most 20). Each data set consists of four lines. The&nbsp;first line contains an integer 1 &le; n &le; 5, the number of candy types. The next line contains n&nbsp;integers w1, . . . ,wn, where 1 &le; wi &le; 10 is the weight (in grams) of the ith candy type. The&nbsp;third line contains an integer 1 &le; q &le; 10, the number of queries. The last line of a data set&nbsp;contains q integers P1, . . . , Pq, where 1 &le; Pj &le; 1015 is the jth query. Input is terminated byan incomplete data set where n = 0, which should not be processed.</p>\r\n<div style="font-family: Arial, Verdana, sans-serif; font-size: 12px; color: rgb(34, 34, 34); background-color: rgb(255, 255, 255); ">\r\n	<p>\r\n		&nbsp;</p>\r\n</div>\r\n', '<p>\r\n	For the i:th data set, write a line &ldquo;Set i&rdquo;, followed by q lines giving, for each query Pj, the&nbsp;minimal possible positive weight Wj (in grams) of a candy box. If there is no weight Wj such&nbsp;that at least Pj candy boxes can be made, print &ldquo;no candy for you&rdquo; for that query. Youmay assume that Wj, if it exists, will be at most 100 &middot; Pj.</p>\r\n', '3\r\n5 5 10\r\n1\r\n4\r\n4\r\n3 1 4 2\r\n2\r\n142 700\r\n1\r\n10\r\n1\r\n100\r\n0', 'Set 1\r\n10\r\nSet 2\r\n23\r\n42\r\nSet 3\r\nno candy for you', '', 0, 0, '2010-09-30 21:52:00', '2010-10-01 00:20:12'),
(343, 6, 'Depot Rearrangement', 2000, 63554432, 0000000000, 0000000000, '<div>\r\n	&nbsp;&nbsp; &nbsp; &nbsp;A company operates N shops, selling M different products in each shop. The company has a&nbsp;large depot where the products are packed before delivering to shops. Each shop receives the&nbsp;same number of items of each product. Hence the company packs a certain number of items&nbsp;of a given product into a container, and labels that container with the product identifier.&nbsp;Products are identified by the numbers from 1 to M. Thus, at the end of packing, there are&nbsp;N*M containers in the depot, and exactly N containers are labeled with a given product label&nbsp;for each product. Because the depot is in a narrow building, the containers are arranged in a&nbsp;single row. In order to speed-up distribution, the manager of the depot wants to rearrange the&nbsp;containers. Since the product delivery to the shops occurs by sending exactly one truck to&nbsp;each shop, and each truck carries one container of each product, a suitable arrangement is the&nbsp;following. The first M containers in the row must be labeled with different product labels, the&nbsp;second M containers in the row must be labeled with different product labels, and so on.</div>\r\n<div>\r\n	&nbsp;&nbsp; &nbsp; Unfortunately, there is only one free place at the end of the row to hold a container. Therefore&nbsp;the rearrangement must be performed by successively picking up a container and moving it to&nbsp;the free place. After the rearrangement the free place must be at the end of the row.</div>\r\n<div>\r\n	&nbsp;&nbsp; &nbsp; The goal is to achieve the required rearrangement by a minimal number of moves.</div>\r\n', 'CEOI2005', '<p>\r\n	The first line &nbsp;contains two integers, N and M. N (1 &lt;= N &lt;= 400) is&nbsp;the number of shops and M (1 &lt;= M &lt;= 400) is the number of products. The second line contains&nbsp;N*M integers, the labels of the containers in their initial order. Each product identifier x (1 &lt;=&nbsp;x &lt; = M) occurs exactly N times in the line.</p>\r\n', '<p>\r\n	The first line &nbsp;contains one integer S, the minimal number of&nbsp;moves that are necessary to obtain a required order of the container row (Subtask A). The&nbsp;following S lines describe a rearrangement (Subtask B). Each line contains a pair of integers&nbsp;x y. The pair x y describes a move: the container at position x is to move to position y.Positions are identified by the numbers from 1 to N*M+1; initially the position N*M+1 is free&nbsp;(holds no container). A move from x to y is legal only if position y is free prior to the move.After a move from x to y the position x will be free. It is enough to output only the first line if&nbsp;you solve only Subtask A.&nbsp;&nbsp;If there are multiple possibilities, your program should output only one; it does not matter&nbsp;which one.</p>\r\n', '5 6\r\n4 1 3 1 6 5 2 3 2 3 5 6 2 1 4 5 6 4 1 3 2 4 5 5 1 2 3 4 6 6', '8\r\n9 31\r\n18 9\r\n10 18\r\n4 10\r\n31 4\r\n30 31\r\n24 30\r\n31 24', '', 0, 0, '2010-10-09 15:37:54', '2010-10-18 13:17:24'),
(344, 1, '咬尾巴的蛇', 200, 2097152, 0000000000, 0000000000, '<p>\r\n	众所周知，有些蛇喜欢咬尾巴，据说有些眼睛蛇竟然把自己吃了</p>\r\n<p>\r\n	现在有一些蛇一起，第一条咬住第二条的尾巴，第二条咬住第三条的尾巴</p>\r\n<p>\r\n	如此进行下去（每条蛇只能咬住另一条蛇的尾巴）</p>\r\n<p>\r\n	现在这些蛇想知道它们中间的某些蛇是否组成了首尾一个圈。</p>\r\n<p>\r\n	如果有，你能告诉蛇他们组成的圈的长度吗</p>\r\n<p>\r\n	<br />\r\n	&nbsp;</p>\r\n', '', '<p>\r\n	输入有多个case</p>\r\n<p>\r\n	每个case 第一行是蛇的名字数目n&nbsp; 接下来的一行由空格分隔的n个蛇的名字 n&lt;=20000</p>\r\n<p>\r\n	蛇的名字由字符和数字组成 长度不超过100</p>\r\n<p>\r\n	<br />\r\n	&nbsp;</p>\r\n', '<p>\r\n	每个case在一行中输出圈的长度，没有圈，输出0</p>\r\n', '4\r\nshe1 she2 she3 she2\r\n2\r\nshe1 she1\r\n2\r\nshe1 she2', '2\r\n1\r\n0', '<p>\r\n	参考 http://superwind.javaeye.com/blog/706887</p>\r\n<p>\r\n	参考 http://www.javaeye.com/topic/112251</p>\r\n', 0, 0, '2010-10-13 22:42:21', '2010-10-17 12:11:56'),
(345, 1, '成队的蛇', 400, 67108864, 0000000000, 0000000000, '<p>\r\n	现在有两队咬着尾巴的蛇（每条蛇只能咬住另一条蛇的尾巴），他们想知道他们两队是否有公共的蛇</p>\r\n<p>\r\n	请输出两队中第一条在对方队列中的蛇的名字</p>\r\n<p>\r\n	如果没有输出none</p>\r\n', '', '<p>\r\n	有多个case需要测试</p>\r\n<p>\r\n	每个case有两行</p>\r\n<p>\r\n	第一行是第一个队列 第一个数n是队列中蛇的名字的数目 后面是前后相接的n条蛇的名字</p>\r\n<p>\r\n	第二行是第二个队列 第一个数m是队列中蛇的名字的数目 后面是前后相接的m条蛇的名字</p>\r\n<p>\r\n	n,m&lt;10000</p>\r\n<p>\r\n	蛇的名字长度小于100</p>\r\n<p>\r\n	每个队列中的所有蛇的名字都会出现</p>\r\n', '<p>\r\n	输出一行空格分隔的蛇的名字</p>\r\n<p>\r\n	如果没有 输出两个none</p>\r\n', '2 a1 a2\r\n3 b2 a1 a2\r\n1 a1\r\n1 b1\r\n', 'a1 a1\r\nnone none\r\n', '<p>\r\n	考虑有环的情形。</p>\r\n', 0, 0, '2010-10-13 23:36:13', '2010-10-25 10:58:23'),
(346, 6, '计算器的改良 ', 1000, 67108864, 0000000000, 0000000000, '<div>\r\n	&nbsp;&nbsp; &nbsp; &nbsp; NCL是一家专门从事计算器改良与升级的实验室，最近该实验室收到了某公司所委托的一个任务：需要在该公司某型号的计算器上加上解一元一次方程的功能。实验室将这个任务交给了一个刚进入的新手ZL先生。为了很好的完成这个任务，ZL先生首先研究了一些一元一次方程的实例：</div>\r\n<div>\r\n	<div>\r\n		&nbsp;&nbsp; &nbsp; &nbsp;4+3x=8</div>\r\n	<div>\r\n		&nbsp;&nbsp; &nbsp; &nbsp;6a-5+1=2-2a</div>\r\n	<div>\r\n		&nbsp;&nbsp; &nbsp; &nbsp;-5+12y=0</div>\r\n</div>\r\n<div>\r\n	&nbsp;&nbsp; &nbsp; &nbsp;ZL先生被主管告之，在计算器上键入的一个一元一次方程（长度少于100）中，只包含32位的整数、小写字母及＋、－、＝这三个数学符号（当然，符号&ldquo;─&rdquo;既可作减号，也可作负号），中间不含空格。方程中并没有括号，也没有除号，方程中的字母表示未知数。编写程序，解输入的一元一次方程, 将解方程的结果(精确至小数点后三位)输出至屏幕。你可假设对键入的方程的正确性的判断是由另一个程序员在做，或者说可认为键入的一元一次方程均为合法的，且有唯一实数解。</div>\r\n<div>\r\n	<div>\r\n		&nbsp;</div>\r\n</div>\r\n', 'NOIP2000普及组', '', '', '4+3x=8', 'x=1.333', '', 0, 0, '2010-10-14 16:16:19', '2010-10-17 00:51:32'),
(349, 6, '单词接龙 ', 1000, 67108864, 0000000000, 0000000000, '<p>\r\n	&nbsp;&nbsp; &nbsp; 单词接龙是一个与我们经常玩的成语接龙相类似的游戏，现在我们已知一组单词，且给定一个开头的字母，要求出以这个字母开头的最长的&ldquo;龙&rdquo;（每个单词都最多在&ldquo;龙&rdquo;中出现两次），在两个单词相连时，其重合部分合为一部分，例如beast和astonish，如果接成一条龙则变为beastonish，另外相邻的两部分不能存在包含关系，例如at和atide间不能相连。</p>\r\n', 'NOIP2000普及组', '<p>\r\n	&nbsp;&nbsp; &nbsp;输入的第一行为一个单独的整数n(1&lt;=n&lt;=20)表示单词数。以下n行每行有一个单词，单词长度不超过100，输入的最后一行为一个单个字符，表示&ldquo;龙&rdquo;开头的字母，也就是&quot;龙&quot;的第一个单词的第一个字母。你可以假定以此字母开头的&ldquo;龙&rdquo;一定存在.</p>\r\n', '<p>\r\n	只需输出以此字母开头的最长的&ldquo;龙&rdquo;的长度</p>\r\n', '5\r\nat\r\ntouch\r\ncheat\r\nchoose\r\ntact\r\na\r\n', '23', '<p>\r\n	样例中连成的&ldquo;龙&rdquo;为atoucheatactactouchoose。</p>\r\n<p>\r\n	所谓&ldquo;两部分不能存在包含关系&rdquo;，是指两部分接龙后不能长度不增加。例如ababab和ababab，可以接成ababababab，但不能为ababab。接龙时，如果两个单词接龙后的单词有多种情况，要尽可能保证接龙后的单词最长。例如cabab和ababc，一定要接成cabababc，为而不是cababc。</p>\r\n', 0, 0, '2010-10-17 10:11:46', '2010-10-17 11:44:13'),
(347, 6, '税收与补贴问题    ', 1000, 67108864, 0000000000, 0000000000, '<div>\r\n	&nbsp;&nbsp; &nbsp; &nbsp;每样商品的价格越低，其销量就会相应增大。现已知某种商品的成本及其在若干价位上的销量（产品不会低于成本销售），并假设相邻价位间销量的变化是线性的且在价格高于给定的最高价位后，销量以某固定数值递减。（我们假设价格及销售量都是整数）对于某些特殊商品，不可能完全由市场去调节其价格。这时候就需要政府以税收或补贴的方式来控制。（所谓税收或补贴就是对于每个产品收取或给予生产厂家固定金额的货币）你是某家咨询公司的项目经理，现在你已经知道政府对某种商品的预期价格，以及在各种价位上的销售情况。要求你确定政府对此商品是应收税还是补贴的<u>最少</u>金额（也为整数），才能使商家在这样一种政府预期的价格上，获取相对其他价位上的最大总利润。</div>\r\n<div>\r\n	&nbsp;&nbsp; &nbsp; &nbsp;总利润 &nbsp;= 单位商品利润* 销量</div>\r\n<div>\r\n	<strong><em>&nbsp;&nbsp; &nbsp; &nbsp;</em></strong>单位商品利润 = 单位商品价格 &ndash; 单位商品成本 （&ndash; 税金&nbsp; or&nbsp; + 补贴）</div>\r\n', 'NOIP2000普及组', '<p>\r\n	&nbsp;&nbsp; &nbsp; &nbsp;输入的第一行为政府对某种商品的预期价，第二行有两个整数，第一个整数为商品成本，第二个整数为以成本价销售时的销量售，以下若干行每行都有两个整数，第一个为某价位时的单价，第二个为此时的销量，以一行-1，-1表示所有已知价位及对应的销量输入完毕，输入的最后一行为一个单独的整数表示在已知的最高单价外每升高一块钱将减少的销量。</p>\r\n', '<p>\r\n	&nbsp;&nbsp; &nbsp; &nbsp;输出有两种情况：若在政府预期价上能得到最大总利润，则输出一个单独的整数，数的正负表示是补贴还是收税，数的大小表示补贴或收税的金额最小值。若有多解，取绝对值最小的输出。如在政府预期价上不能得到最大总利润，则输出&ldquo;NO SOLUTION&rdquo;.</p>\r\n', '31\r\n28 130\r\n30 120\r\n31 110\r\n-1 -1\r\n15\r\n\r\n', ' 4', '', 0, 0, '2010-10-14 17:15:52', '2010-10-16 14:32:52'),
(348, 6, '乘积最大', 1000, 67108864, 0000000000, 0000000000, '<div>\r\n	今年是国际数学联盟确定的&ldquo;2000&mdash;&mdash;世界数学年&rdquo;，又恰逢我国著名数学家华罗庚先生诞辰90周年。在华罗庚先生的家乡江苏金坛，组织了一场别开生面的数学智力竞赛的活动，你的一个好朋友XZ也有幸得以参加。活动中，主持人给所有参加活动的选手出了这样一道题目：</div>\r\n<div>\r\n	设有一个长度为N的数字串，要求选手使用K个乘号将它分成K+1个部分，找出一种分法，使得这K+1个部分的乘积能够为最大。</div>\r\n<div>\r\n	同时，为了帮助选手能够正确理解题意，主持人还举了如下的一个例子：</div>\r\n<div>\r\n	有一个数字串：312，当N=3，K=1时会有以下两种分法：</div>\r\n<div>\r\n	1)&nbsp; 3*12=36</div>\r\n<div>\r\n	2)&nbsp; 31*2=62</div>\r\n<div>\r\n	这时，符合题目要求的结果是：31*2=62</div>\r\n<div>\r\n	&nbsp;现在，请你帮助你的好朋友XZ设计一个程序，求得正确的答案。</div>\r\n', 'NOIP2000普及组', '<p>\r\n	程序的输入共有两行：</p>\r\n<p>\r\n	第一行共有2个自然数N，K（6&le;N&le;40，1&le;K&le;6）</p>\r\n<p>\r\n	第二行是一个长度为N的数字串。</p>\r\n', '<p>\r\n	每次输出答案在一行上，即所求得的最大乘积。</p>\r\n', '4  2\r\n1231\r\n', '62', '<p>\r\n	数据已在NOIP数据基础加强，此题需要用高精度乘法</p>\r\n', 0, 0, '2010-10-16 17:25:44', '2010-10-17 00:14:59'),
(350, 6, '方格取数一', 1000, 67108864, 0000000000, 0000000000, '<div>\r\n	设有N*N的方格图(1&lt;=N&lt;=10,我们将其中的某些方格中填入正整数,而其他的方格中则放入数字0。如下图所示（见样例）：</div>\r\n<div>\r\n	<img src="http://judge.noi.cn/images/1097_1.JPG" style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; " /></div>\r\n<div>\r\n	某人从图的左上角的A 点出发，可以向下行走，也可以向右走，直到到达右下角的B点。在走过的路上，他可以取走方格中的数（取走后的方格中将变为数字0）。</div>\r\n<div>\r\n	此人从A点到B 点共走两次，试找出2条这样的路径，使得取得的数之和为最大。</div>\r\n', 'NOIP2000提高组', '<p>\r\n	<font class="Apple-style-span" face="''Times New Roman'', Times, serif" size="4"><span class="Apple-style-span" style="font-size: 16px; line-height: 25px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px;">输入的第一行为一个整数N（表示N*N的方格图），接下来的每行有三个整数，前两个表示位置，第三个数为该位置上所放的数。一行单独的0表示输入结束。</span></font></p>\r\n', '<p>\r\n	只需输出一个整数，表示2条路径上取得的最大的和。</p>\r\n', '8\r\n2  3  13\r\n2  6   6\r\n3  5   7\r\n4  4  14\r\n5  2  21 \r\n5  6   4\r\n6  3  15\r\n7  2  14\r\n0  0  0', '67', '', 0, 0, '2010-10-17 21:10:21', '2010-10-17 21:29:08'),
(351, 6, '方格取数二', 1000, 67108864, 0000000000, 0000000000, '<p>\r\n	设有N*N的方格图(1&lt;=N&lt;=50,我们在方格中填入非负整数。如下图所示（见样例）：</p>\r\n<div>\r\n	<img src="http://judge.noi.cn/images/1097_1.JPG" style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; " /></div>\r\n<div>\r\n	某人从图的左上角的A 点出发，可以向下行走，也可以向右走，直到到达右下角的B点。在走过的路上，他可以取走方格中的数（取走后的方格中将变为数字0）。</div>\r\n<div>\r\n	此人从A点到B 点共走K次，试找出K条这样的路径，使得取得的数之和为最大。</div>\r\n', 'POJ3422', '<p>\r\n	输入的第一行为两个整数，第一个整数N（表示N*N的方格图），第二个是K（0&lt;=K&lt;=10），接下来的N行每行有N个整数，表示的方格中的数，其中方格中的数的数值不超过100。</p>\r\n', '<p>\r\n	只需输出一个整数，表示K条路径上取得的最大的和。</p>\r\n', '3 2\r\n1 2 3\r\n0 2 1\r\n1 4 2', '15', '', 0, 0, '2010-10-17 22:18:32', '2010-10-17 22:48:42'),
(352, 6, 'ALADIN', 8000, 67108864, 0000000000, 0000000000, '<div>\r\n	Aladin was walking down the path one day when he found the strangest thing.N empty boxes right next to a weird alien machine. After a bit of fumbling&nbsp;around he got the machine to do something. The machine now accepts 4&nbsp;integers L, R, A and B. After that hitting the big red glowing button labeled &nbsp;&quot;NEDIRAJ&quot; causes the machine to go crazy and follow the next routine:</div>\r\n<div>\r\n	&middot; Set the number of stones in the box labeled L to A modulo B.</div>\r\n<div>\r\n	&middot; It procedes to fly to the box labeled L+1, and set the number of stones&nbsp;there to (2∙A) mod B.</div>\r\n<div>\r\n	&middot; It procedes to fly to the box labeled L+2, and set the number of stones&nbsp;there to (3∙A) mod B.</div>\r\n<div>\r\n	&middot; Generaly, it visits each box labeled between L and R, and set the number&nbsp;of stones there to ( (X - L + 1)∙A) mod B. where X is the box label.</div>\r\n<div>\r\n	&middot; After it visits the box labeled R. It settles down for further instructions.</div>\r\n<div>\r\n	&nbsp;During the game Aladin wonders what is the total number of stones in some&nbsp;range of boxes.</div>\r\n<div>\r\n	&nbsp;Write a program that simulates the device and answers Aladins questions.</div>\r\n', 'COCI2009/2010CONTEST #1', '<p>\r\n	The first line contains two integers N and Q (1 &le; N &le; 1 000 000 000) (1 &le; Q &le; 50000), number of boxes and number of queries.The next Q lines contain information about the simulation.If the line starts with 1, than it follows the format &quot;1 L R A B&quot; (1 &le; L &le; R &le; N) (1&le; A, B &le; 1 000 000), meaning that Aladin keyed in numbers L, R, A and B in the&nbsp;device and allowed the device to do its job.If the line starts with 2, than it follows the format &quot;2 L R&quot; (1 &le; L &le; R &le; N).Meaning that Aladin wonders how many stones in total are the stones are in boxes labeled L to R (inclusive).</p>\r\n', '<p>\r\n	For each query beginning with 2 output the answer to that particular query.Queries should be processed in the order they are given in the input.</p>\r\n', '6 3\r\n2 1 6\r\n1 1 5 1 2\r\n2 1 6\r\n4 5\r\n1 1 4 3 4\r\n2 1 1\r\n2 2 2\r\n2 3 3\r\n2 4 4\r\n4 4\r\n1 1 4 7 9\r\n2 1 4\r\n1 1 4 1 1\r\n2 1 4\r\n', '0\r\n3\r\n3\r\n2\r\n1\r\n0\r\n16\r\n0', '<p>\r\n	&nbsp;</p>\r\n<div>\r\n	The boxes start containing {0, 0, 0, 0, 0, 0}, 0 stones in total.After that the device sets the stones to {1 mod 2, 2 mod 2, 3 mod 2, 4 mod 2,5 mod 2, 0} = {1,0,1,0,1,0}, or 3 stones in total.</div>\r\n<div id="cke_pastebin" style="position: absolute; left: -1000px; top: 0px; width: 1px; height: 1px; overflow-x: hidden; overflow-y: hidden; ">\r\n	5 mod 2, 0} = {1,0,1,0,1,0}, or 3 stones in total.The boxes start containing {0, 0, 0, 0, 0, 0}, 0 stones in total.</div>\r\n<div id="cke_pastebin" style="position: absolute; left: -1000px; top: 0px; width: 1px; height: 1px; overflow-x: hidden; overflow-y: hidden; ">\r\n	After that the device sets the stones to {1 mod 2, 2 mod 2, 3 mod 2, 4 mod 2,</div>\r\n<div id="cke_pastebin" style="position: absolute; left: -1000px; top: 0px; width: 1px; height: 1px; overflow-x: hidden; overflow-y: hidden; ">\r\n	5 mod 2, 0} = {1,0,1,0,1,0}, or 3 stones in total.</div>\r\n<div id="cke_pastebin" style="position: absolute; left: -1000px; top: 12px; width: 1px; height: 1px; overflow-x: hidden; overflow-y: hidden; ">\r\n	5 mod 2, 0} = {1,0,1,0,1,0}, or 3 stones in total.The boxes start containing {0, 0, 0, 0, 0, 0}, 0 stones in total.</div>\r\n<div id="cke_pastebin" style="position: absolute; left: -1000px; top: 12px; width: 1px; height: 1px; overflow-x: hidden; overflow-y: hidden; ">\r\n	After that the device sets the stones to {1 mod 2, 2 mod 2, 3 mod 2, 4 mod 2,</div>\r\n<div id="cke_pastebin" style="position: absolute; left: -1000px; top: 12px; width: 1px; height: 1px; overflow-x: hidden; overflow-y: hidden; ">\r\n	5 mod 2, 0} = {1,0,1,0,1,0}, or 3 stones in total.</div>\r\n', 0, 0, '2010-10-18 14:06:21', '2010-10-18 20:33:59'),
(353, 6, 'NOTE', 1000, 33554432, 0000000000, 0000000000, '<div>\r\n	C major scale consists of 8 tones: c d e f g a h C. For this task we number the&nbsp;notes using numbers 1 through 8. The scale can be played ascending, from 1&nbsp;to 8, descending, from 8 to 1, or mixed. Write a program that, given the&nbsp;sequence of notes, determines wether the scale was played ascending,&nbsp;descending or mixed.</div>\r\n', 'COCI2009/2010CONTEST#1', '<p>\r\n	First and only line of input will contain 8 integers, from 1 to 8 inclusive. Each&nbsp;integer will appear exactley once in the input.</p>\r\n', '<p>\r\n	In the first and only line of input print &quot;descending&quot; if the scale was played&nbsp;descending, &quot;ascending&quot; if the scale was played ascending and &quot;mixed&quot; if&nbsp;the scale was played mixed.</p>\r\n', '1 2 3 4 5 6 7 8\r\n8 7 6 5 4 3 2 1\r\n8 1 7 2 6 3 5 4', 'ascending\r\ndescending\r\nmixed', '', 0, 0, '2010-10-18 23:21:00', '2010-10-18 23:21:48'),
(354, 6, 'DOMINO', 1000, 33554432, 0000000000, 0000000000, '<div>\r\n	Dominoes are gaming pieces used in numerous tile games. Each doimno piece&nbsp;contains two marks. Each mark consists of a number of spots (possibly zero).</div>\r\n<div>\r\n	The number of spots depends on the set size. Each mark in a size N domino set&nbsp;can contain between 0 and N spots, inclusive. Two tiles are considered&nbsp;identical if their marks have the same number of spots, irregardles of reading&nbsp;order. For example tile with 2 and 8 spot marks is identical to the tile having 8&nbsp;and 2 spot marks. A proper domino set contains no duplicate tiles. A complete&nbsp;set of size N contains all posible tiles with N or less spots and no duplicate&nbsp;tiles. For example, complete set of size 2 contains 6 tiles:</div>\r\n<div>\r\n	<img alt="" src="/joj/app/webroot/userfiles/4.JPG" style="cursor: default; width: 264px; height: 53px; " /></div>\r\n<div>\r\n	Write a program that will determine the total number of spots on all tiles of a&nbsp;complete size N set.</div>\r\n<div>\r\n	<div id="cke_pastebin" style="position: absolute; left: -1000px; top: 136px; width: 1px; height: 1px; overflow-x: hidden; overflow-y: hidden; ">\r\n		complete size N set.Write a program that will determine the total number of spots on all tiles of a</div>\r\n	<div id="cke_pastebin" style="position: absolute; left: -1000px; top: 136px; width: 1px; height: 1px; overflow-x: hidden; overflow-y: hidden; ">\r\n		complete size N set.</div>\r\n</div>\r\n', 'COCI2009/2010CONTEST#1', '<p>\r\n	The first and only line of input contains a single integer, N (1 &le; N &le; 1000), the&nbsp;size of the complete set.</p>\r\n', '<p>\r\n	The first and only line of output should contain a single integer, total number of&nbsp;spots in a complete size N set.</p>\r\n', '2\r\n3\r\n15\r\n', '12\r\n30\r\n2040\r\n', '<p>\r\n	Size 3 set contains tiles: [0|0], [0|1], [0|2], [0|3], [1|1], [1|2], [1|3], [2|2], [2|3]&nbsp;and [3|3].</p>\r\n', 0, 0, '2010-10-19 13:35:26', '2010-10-19 13:35:26'),
(355, 6, 'DOBRA', 1000, 33554432, 0000000000, 0000000000, '<div>\r\n	Lea runs into a lot of words in her life. A lot of them she finds unpleasant. To&nbsp;compensate for that she started making up plesant words. Lea makes up new&nbsp;words by writing a nice looking string of characters on a piece of paper. She&nbsp;then erases a few of the most nasty looking characters and replaces them with&nbsp;underscores &#39;_&#39;. After that she tries to replace the underscores with more&nbsp;acceptable characters trying to form a plesant word.&nbsp;Lea considers words plesant if they do not contain 3 sequential vowels, 3&nbsp;sequential consonants and contain at least one letter &#39;L&#39;.&nbsp;In Croatian vowels are letters A, E, I, O, U only. All other lettters are&nbsp;consonants.</div>\r\n', 'COCI2009/2010CONTEST#1', '<p>\r\n	The first and only line of input contains a string of characters, at most 100. The&nbsp;string contains only of uppercase english letters and characters &#39;_&#39;. There&nbsp;will be at most 10 characters &#39;_&#39;.</p>\r\n', '<p>\r\n	The first and only line of output should cotain a single integer - the total&nbsp;number of plesant words that can be formed by substituing underscores with&nbsp;uppercase letters of the english alphabet.</p>\r\n', 'L_V\r\nV__K\r\nJA_BU_K_A\r\n\r\n', '5\r\n10\r\n485\r\n', '<p>\r\n	Warning: Use 64 bit number formats. long long in C/C++, int64 in Pascal.</p>\r\n', 0, 0, '2010-10-19 20:00:21', '2010-10-19 20:00:50'),
(356, 6, 'MALI', 1000, 33554432, 0000000000, 0000000000, '<div>\r\n	Mirko and Slavko are playing a new game. Again. Slavko starts each round by&nbsp;giving Mirko two numbers A and B, both smaller than 100. Mirko then has to&nbsp;slove the following task for Slavko: how to pair all given A numbers with all&nbsp;given B numbes so that the maximal sum of such pairs is as small as&nbsp;possible.&nbsp;In other words, if during previous rounds Slavko gave numbers a1, a2, a3 .... an&nbsp;and b1, b2, b3 ... bn, determine n pairings (ai, bj) such that each number in A&nbsp;sequence is used in exactley one pairing, and each number in B sequenct is&nbsp;used in exactely one pairing and the maximum of all sums ai + bj is minimal.</div>\r\n', 'COCI2009/2010CONTEST#1', '<p>\r\n	The first line of input contains a single integer N (1 &le; N &le; 100000), number of&nbsp;rounds.Next N lines contain two integers A and B (1 &le; A, B &le; 100), numbers given by&nbsp;Slavko in that round.</p>\r\n', '<p>\r\n	Output consists of N lines, one for each round. Each line should contain the&nbsp;smallest maximal sum for that round.</p>\r\n', '3\r\n2 8\r\n3 1\r\n1 4\r\n3\r\n1 1\r\n2 2\r\n3 3', '10\r\n10\r\n9\r\n2\r\n3\r\n4', '', 0, 0, '2010-10-19 21:23:49', '2010-10-19 21:24:09'),
(357, 6, 'GENIJALAC', 1000, 33554432, 0000000000, 0000000000, '<p>\r\n	Mirko is a genius. But the purpose of his inventions is not always obvious. His&nbsp;latest invention, the Shuffle-o-matic 3175, is one of those. The Shuffle-o-maticis used in a very special way. First Mirko places N paper cards, with numbers 1&nbsp;to N printed on them, on the Shuffle-o-matic working surface. Then he inputs&nbsp;the shuffle sequence in the special input console and hits the go button. The&nbsp;machine than reads the paper cards and outputs the read sequence of&nbsp;numbers on its output tape. It then shuffles the cards according to the shuffle&nbsp;sequence. After that it reads the newly obtaind sequence and writes it onto a&nbsp;new line on its output tape. Then it procedes to shuffle the cards again&nbsp;according to the same shuffle sequence, scans and writes the output to the&nbsp;tape. The machine does this until it runs out of tape.After experimenting with the machine Mirko decided to rest a bit on the floor.There he noticed a piece of output tape. The piece is neatly cut just before the&nbsp;A-th output row nad just after the B-th output row. It is also missing the first C&nbsp;number and the last D numbers in all rows.&nbsp;He now wonders how many rows on that piece of paper have the property that&nbsp;all numbers in the row, that are still on the paper, are in the exact&nbsp;same spot they were before all the shuffling began.</p>\r\n', 'COCI2009/2010CONTEST#1', '<p>\r\n	The first line of input contains integers N, A, B, C and D in that order(1 &le; N &le;&nbsp;500 000, A &le; B &le; 10^12, 0 &le; C, D &le; N, C + D &lt; N).The second line contains the shuffle sequence. The sequence is given as a&nbsp;permutation of numbers 1 to N. If the k-th number in the shuffle sequence is x,&nbsp;after each shuffle the k-th element in the resulting sequence is the x-th&nbsp;element in the previous sequence.</p>\r\n', '<p>\r\n	In the first and only line of input print the number of rows that have the&nbsp;property Mirko is looking for.</p>\r\n', '4 1 5 0 1\r\n1 3 4 2\r\n7 3 8 1 2\r\n2 3 1 6 4 7 5\r\n6 2 11 3 0\r\n6 3 5 4 2 1\r\n', '2\r\n0\r\n1\r\n', '<div>\r\n	For the first case:</div>\r\n<div>\r\n	Schuffle-o-matic&nbsp;outputs:</div>\r\n<div>\r\n	1 2 3 4</div>\r\n<div>\r\n	1 3 4 2</div>\r\n<div>\r\n	1 4 2 3</div>\r\n<div>\r\n	1 2 3 4</div>\r\n<div>\r\n	1 3 4 2</div>\r\n<div>\r\n	1 4 2 3</div>\r\n<div>\r\n	1 2 3 4</div>\r\n<div>\r\n	Mirko finds:</div>\r\n<div>\r\n	1 2 3</div>\r\n<div>\r\n	1 3 4</div>\r\n<div>\r\n	1 4 2</div>\r\n<div>\r\n	1 2 3</div>\r\n<div>\r\n	1 3 4</div>\r\n<div>\r\n	The first and forth&nbsp;row are interesting&nbsp;to Mirko.</div>\r\n<div>\r\n	&nbsp;</div>\r\n<div>\r\n	For the second case:</div>\r\n<div>\r\n	Schuffle-o-matic&nbsp;outputs:</div>\r\n<div>\r\n	1 2 3 4 5 6 7</div>\r\n<div>\r\n	2 3 1 6 4 7 5</div>\r\n<div>\r\n	3 1 2 7 6 5 4</div>\r\n<div>\r\n	1 2 3 5 7 4 6</div>\r\n<div>\r\n	2 3 1 4 5 6 7</div>\r\n<div>\r\n	3 1 2 6 4 7 5</div>\r\n<div>\r\n	1 2 3 7 6 5 4</div>\r\n<div>\r\n	2 3 1 5 7 4 6</div>\r\n<div>\r\n	3 1 2 4 5 6 7</div>\r\n<div>\r\n	1 2 3 6 4 7 5</div>\r\n<div>\r\n	&nbsp;</div>\r\n<div>\r\n	For the third case:</div>\r\n<div>\r\n	Schuffle-o-matic&nbsp;outputs:</div>\r\n<div>\r\n	<div>\r\n		1 2 3 4 5 6</div>\r\n	<div>\r\n		6 3 5 4 2 1</div>\r\n	<div>\r\n		1 5 2 4 3 6</div>\r\n	<div>\r\n		6 2 3 4 5 1</div>\r\n	<div>\r\n		1 3 5 4 2 6</div>\r\n	<div>\r\n		6 5 2 4 3 1</div>\r\n	<div>\r\n		1 2 3 4 5 6</div>\r\n	<div>\r\n		6 3 5 4 2 1</div>\r\n	<div>\r\n		1 5 2 4 3 6</div>\r\n	<div>\r\n		6 2 3 4 5 1</div>\r\n	<div>\r\n		1 3 5 4 2 6</div>\r\n</div>', 0, 0, '2010-10-20 10:15:08', '2010-10-20 10:32:51'),
(358, 6, 'Fire extinguishers', 10000, 67108864, 0000000000, 0000000000, '<div>\r\n	Byteasar has had a new palace built. It consists of n chambers and n &minus; 1 corridors connecting them. Each&nbsp;corridor connects exactly two chambers. The rooms are numbered from 1 to n. There is only a single entrance&nbsp;to the palace, which leads to chamber no. 1. For each chamber there is exactly one route leading to it from&nbsp;the entrance, without turning back on the way. In other words, the chambers and the corridors form a tree &mdash;&nbsp;a connected acyclic graph.</div>\r\n<div>\r\n	The fire marshal who is to approve the building demands placing fire extinguishers inside. The following&nbsp;are his exact requirements:</div>\r\n<div>\r\n	&bull; The fire extinguishers should be placed in (some) chambers, and one chamber may store any number of&nbsp;extinguishers.</div>\r\n<div>\r\n	&bull; Each chamber has to be assigned one fire extinguisher, though it may be stored in another chamber.</div>\r\n<div>\r\n	&bull; Each fire extinguisher can be assigned to at most s different chambers.</div>\r\n<div>\r\n	&bull; For each room its assigned extinguisher is within the range of k corridors.</div>\r\n<div>\r\n	Byteasar has a week spot for lavish palaces, so it is no surprise he has very little money now, right after&nbsp;completion of another splendid palace. Therefore he is interested in the minimum number of fire extinguishers&nbsp;sufficient for satisfying fire marshal&rsquo;s demands.</div>\r\n', 'POI2008/2009', '<p>\r\n	The first line of the standard input contains three integers n, s and k separated by single spaces, 1 &lt;= n &lt;=&nbsp;100 000, 1 &lt;= s &lt;= n, 1 &lt;= k &lt;= 20. Each of the following n &minus; 1 lines holds two integers separated by a single&nbsp;space. Line no. i + 1 contains the numbers 1 &lt;= xi &lt; yi &lt;= n denoting the corridor connecting chambers no.xi&nbsp;and yi.</p>\r\n', '<p>\r\n	The first and only line of the standard output is to hold one integer&mdash;the minimum number of fire extinguishers&nbsp;that have to be installed in palace.</p>\r\n', '12 3 1\r\n1 12\r\n3 8\r\n7 8\r\n8 9\r\n2 12\r\n10 12\r\n9 12\r\n4 8\r\n5 8\r\n8 11\r\n6 8\r\n', '4\r\n', '<p>\r\n	For the sample case :</p>\r\n<p>\r\n	<img alt="" src="/joj/app/webroot/userfiles/gas.JPG" style="width: 445px; height: 239px; " /></p>\r\n', 0, 0, '2010-10-20 11:24:37', '2010-10-20 13:24:07'),
(359, 6, 'Elephants', 1000, 67108864, 0000000000, 0000000000, '<div>\r\n	A parade of all elephants is to commence soon at the Byteotian zoo. The zoo employees have encouraged these&nbsp;enormous animals to form a single line, as the manager wills it to be the initial figure of the parade.&nbsp;Unfortunately, the manager himself came to the parade and did not quite like what he saw &mdash; he had&nbsp;intended an entirely different order of the elephants. Therefore he enforced his ordering, claiming the animals&nbsp;would seem most majestic this way, and made the employees reorder the elephants accordingly.&nbsp;As a pack of moving elephants can wreak havoc, the employees decided to have them rearranged by swapping&nbsp;one pair at a time. Luckily the animals need not stand next to each other in order to swap positions in the&nbsp;line. Making an elephant move, however, is not as easy as it sounds. In fact, the effort one has to put into it&nbsp;is proportional to the animal&rsquo;s mass. Hence, the effort involved in swapping a pair of elephants of respective&nbsp;masses m1 and m2 can be estimated by m1 + m2. What is the minimum effort involved in rearranging the&nbsp;elephants according to manager&rsquo;s will?</div>\r\n<div>\r\n	Write a programme that:</div>\r\n<div>\r\n	&bull; reads from the standard input the masses of all elephants from the zoo, along with their current and</div>\r\n<div>\r\n	<div>\r\n		desired order in the line,</div>\r\n	<div>\r\n		&bull; determines a sequence of elephant swaps leading from the initial to the desired order of animals in the</div>\r\n	<div>\r\n		line, such that this sequence minimises the summary effort involved in all the swaps,</div>\r\n	<div>\r\n		&bull; prints out the summary effort on the standard output.</div>\r\n</div>\r\n', 'POI2008/2009', '<p>\r\n	The first line of the standard input contains a single integer n (2 &lt;= n &lt;= 1 000 000) denoting the number of&nbsp;elephants in the zoo. We assume that the elephants are numbered from 1 to n to simplify things. The second&nbsp;line holds n integers mi (100 &lt;= mi &lt;= 6 500 &nbsp;,1 &lt;= i &lt;= n) separated by single spaces and denoting the masses&nbsp;of respective elephants (in kilogrammes).&nbsp;The third line of input contains n pairwise different integers ai (1 &lt;= ai &lt;= n) separated by single spaces and&nbsp;denoting the numbers of successive elephants in the initial ordering. The fourth line holds n pairwise different&nbsp;integers bi (1 &lt;= bi &lt;= n) separated by single spaces and denoting the numbers of successive elephants in the&nbsp;ordering desired by the zoo manager. You may assume that the sequences (ai) and (bi) differ.</p>\r\n', '<p>\r\n	The first and only line of the standard output should contain a single integer denoting the minimum summary&nbsp;effort involved in reordering the elephants from the order represented by the sequence to the one represented&nbsp;by (bi).</p>\r\n', '6\r\n2400 2000 1200 2400 1600 4000\r\n1 4 5 3 6 2\r\n5 3 2 4 6 1\r\n', '11200\r\n', '<div>\r\n	One of the optimal rearrangements consists of swapping the following pairs of elephants:</div>\r\n<div>\r\n	&bull; 2 and 5 &mdash; effort involved: 2 000 + 1 600 = 3 600, order achieved: 1 4 2 3 6 5,</div>\r\n<div>\r\n	&bull; 3 and 4 &mdash; effort involved: 1 200 + 2 400 = 3 600, order achieved: 1 3 2 4 6 5,</div>\r\n<div>\r\n	&bull; 1 and 5 &mdash; effort involved: 2 400 + 1 600 = 4 000, order achieved: 5 3 2 4 6 1, which is the one desired.</div>\r\n', 0, 0, '2010-10-20 20:19:15', '2010-10-20 20:20:23');
INSERT INTO `tbl_problems` (`id`, `user_id`, `title`, `time_limit`, `memory_limit`, `submission_no`, `accepted_no`, `description`, `source`, `input`, `output`, `input_sample`, `output_sample`, `hint`, `flag`, `visibility`, `created`, `modified`) VALUES
(360, 6, 'Fire brigade', 1000, 33554432, 0000000000, 0000000000, '<div>\r\n	&nbsp;&nbsp; &nbsp; &nbsp;In the capital of Byteotia, Bytau, the layout of streets is highly regular. Every street leads either from north&nbsp;to south, or from east to west. Therefore every north-south street intersects every east-west street in exactly&nbsp;one spot. Furthermore, along every street its successive intersections are exactly 1 km apart.&nbsp;Bytau is not only the capital, but also one of the oldest cities in Byteotia. No wonder that there are as&nbsp;many as n historic buildings, each at one of the intersections. The City Council cares for their protection very&nbsp;much, and is now concerned with the risk of fire. Hence they have decided to establish two main fire stations&nbsp;in the city. Each monument is going to be protected by the nearest station; by both, should both fire stations&nbsp;be equally close.Housing is very dense in Bytau, so Euclidean distance is not the measure of choice.&nbsp;The distance between&nbsp;a monument and fire station should rather be defined as the length of the shortest path along the streets&nbsp;between them.</div>\r\n<div>\r\n	&nbsp;&nbsp; &nbsp; The City Council has prepared several projects of the stations&rsquo; location. And you have been asked to&nbsp;determine, for each of them, the number of monuments protected by: the first station only, the second station&nbsp;only, and both stations, respectively.</div>\r\n', 'POI2008/2009', '<div>\r\n	&nbsp;&nbsp; &nbsp;In the first line of the standard input there are four integers n, m, z and p (1 &lt;= &nbsp;n,m &lt;= 1 000 000 000,1 &lt;= z, p &lt;= 100 000) separated by single spaces and denoting respectively: the number of streets leading from&nbsp;north to south, the number of streets leading from east to west, the number of historic buildings in Bytau,&nbsp;and the number of projects proposed by the City Council.&nbsp;The north-south streets are numbered from 1 to n, west to east. The east-west streets are numbered from&nbsp;1 to m, north to south. The intersection of x-th north-south and y-th east-west street will be denoted by the&nbsp;coordinates (x, y).</div>\r\n<div>\r\n	&nbsp;&nbsp; &nbsp; In each of the following z lines there are two integers xi and yi (1 &lt;= xi &lt;= n, 1 &lt;= yi &lt;= m) separated by a&nbsp;single space and denoting the coordinates of the i-th monument. No pair of different monuments is located at&nbsp;the same intersection.&nbsp;Each of the following p lines contains one proposal of the City Council &mdash; four integers xj,1, yj,1, xj,2, yj,2&nbsp;separated by single spaces, 1 &lt;= &nbsp;xj,1, xj,2 &lt;= n, 1 &lt;= yj,1, yj,2 &lt;= m, (xj,1, yj,1) != (xj,2, yj,2). The coordinates&nbsp;(xj,1, yj,1) and (xj,2, yj,2) describe the intersections at which the fire stations are to be located according to&nbsp;the j-th proposal (1 &lt;= j &lt;= p).</div>\r\n', '<p>\r\n	&nbsp;&nbsp; &nbsp; Your programme should print out exactly p lines on the standard output. There should be three integers in&nbsp;the j-th line, denoting: the number of monuments protected by the first station of j-th proposal of the City&nbsp;Council only, the number of monuments protected by the second station only and the number of monuments&nbsp;protected by both stations, respectively. These numbers should be separated by single spaces.</p>\r\n', '6 5 6 1\r\n1 2\r\n6 5\r\n5 1\r\n3 3\r\n3 4\r\n4 1\r\n2 3 4 3\r\n', '1 3 2\r\n', '<p>\r\n	<img alt="" src="/joj/app/webroot/userfiles/str.JPG" style="cursor: default; width: 487px; height: 373px; " /></p>\r\n<p>\r\n	&nbsp;</p>\r\n<div>\r\n	The dashed lines in the figure represent streets, circles &mdash; locations of monuments, while crosses &mdash; proposed&nbsp;locations of fire stations. White circles depict monuments protected by the first station only, black circles &mdash;by second station only, while grey ones &mdash; by both stations.</div>\r\n<p>\r\n	&nbsp;</p>\r\n<div id="cke_pastebin" style="position: absolute; left: -1000px; top: 397px; width: 1px; height: 1px; overflow-x: hidden; overflow-y: hidden; ">\r\n	The dashed lines in the figure represent streets, circles &mdash; locations of monuments, while crosses &mdash; proposed</div>\r\n<div id="cke_pastebin" style="position: absolute; left: -1000px; top: 397px; width: 1px; height: 1px; overflow-x: hidden; overflow-y: hidden; ">\r\n	locations of fire stations. White circles depict monuments protected by the first station only, black circles &mdash;</div>\r\n<div id="cke_pastebin" style="position: absolute; left: -1000px; top: 397px; width: 1px; height: 1px; overflow-x: hidden; overflow-y: hidden; ">\r\n	by second station only, while grey ones &mdash; by both stations.</div>\r\n', 0, 0, '2010-10-20 23:19:06', '2010-10-20 23:23:26'),
(361, 6, 'Letter Grid', 1000, 67108864, 0000000000, 0000000000, '<p>\r\n	&nbsp;</p>\r\n<div>\r\n	Consider the following letter grid:</div>\r\n<div>\r\n	<div>\r\n		<img alt="" src="/joj/app/webroot/userfiles/BOI1.JPG" style="cursor: default; width: 213px; height: 115px; " /></div>\r\n	<div>\r\n		There are 7 ways to read the word TARTU from the grid:</div>\r\n	<p>\r\n		&nbsp;</p>\r\n	<div style="font-family: Arial, Verdana, sans-serif; font-size: 12px; color: rgb(34, 34, 34); background-color: rgb(255, 255, 255); ">\r\n		<div>\r\n			<img alt="" src="/joj/app/webroot/userfiles/BOI2.JPG" style="cursor: default; width: 1045px; height: 264px; " /></div>\r\n	</div>\r\n	<p>\r\n		&nbsp;</p>\r\n	<div>\r\n		Given a letter grid and a word, your task is to determine the number of ways the word can&nbsp;be read from the grid. The first letter of the word can be in any cell of the grid, and after&nbsp;each letter, the next letter has to be in one of the neighbour cells (horizontally, vertically or&nbsp;diagonally). A cell can be used multiple times when reading the word.</div>\r\n</div>\r\n<div>\r\n	&nbsp;</div>', 'BOI2010', '<p>\r\n	&nbsp;</p>\r\n<p>\r\n	The first line of the file grid.in contains three integers: H (1  &lt;= H &lt;=  200), the height of&nbsp;the grid, W (1 &lt;=  W &lt;= 200), the width of the grid, and L (1 &lt;=  L &lt;=  100), the length of the word.The following H lines each containing W letters describe the grid. The last line containing L&nbsp;letters describes the word. All letters in the grid and in the word are uppercase English letters&nbsp;(A. . . Z).</p>\r\n', '<p>\r\n	&nbsp;</p>\r\n<p>\r\n	The only line of the file grid.out should contain one integer: the number of ways the&nbsp;word can be read from the grid. You may assume that the answer is always at most 1018.</p>\r\n', '3 4 5\r\nERAT\r\nATSR\r\nAUTU\r\nTARTU\r\n2 2 10\r\nAA\r\nAA\r\nAAAAAAAAAA\r\n', '7\r\n78732\r\n', '', 0, 0, '2010-10-23 09:20:33', '2010-10-23 09:20:33'),
(362, 6, 'BEARs', 1000, 67108864, 0000000000, 0000000000, '<div>\r\n	&nbsp;&nbsp; &nbsp; The Infinite city is divided into unitary square blocks by an infinite number of south-north and west-east two-way streets. One of the south-north streets is labeled 0, and the street numbers increase to the east and decrease to west. Similarly, one of the west-east streets is labeled 0, and the numbers increase to the north and decrease to the south.</div>\r\n<div>\r\n	&nbsp;&nbsp; &nbsp; &nbsp;Every intersection is labeled by an ordered pair of numbers of the streets that intersect (the first being the number of south-north street). Some street sections are more important and are called main streets.&nbsp;One day sheriff &nbsp;Wolf (the fiercest caretaker of the Infinite city) is patrolling the streets and at intersection (<i>A</i>,<i>B</i>) he notices a car with a few members of the well-known BEAR gang. Wolf has heard of the BEARs&#39; plans to break into the city&#39;s Honey Warehouse, which is located near the intersection (0,0), and decides to stop them.</div>\r\n<div>\r\n	&nbsp;&nbsp; &nbsp; &nbsp; However, they haven&#39;t commited any crime so far and Wolf can&#39;t arrest them. But he has the authority to stop his car at any intersection and block exactly one of the four unit segments that meet at this intersection. However he can&#39;t block a unit segment that belongs to a main street.So Wolf decides to pursue the BEARs and just before they reach an intersection, he may overtake their car and block one of the four unit segments at the intersection. The BEARs will be able to drive into the intersection, but they won&#39;t be able to exit the intersection to a segment blocked by the sheriff&#39;s car.The sheriff wants to keep the BEARs as far away from the Honey Warehouse as possible. Find the maximum distance&nbsp;<i>D</i>, such that any intersection (<i>x</i>,<i>y</i>) the BEARs may reach satisfies the condition max(|<i>x</i>|,|<i>y</i>|)&nbsp;&ge;&nbsp;<i>D</i>.</div>\r\n', 'BOI2010', '<p>\r\n	<span class="Apple-style-span" style="font-family: sans-serif; ">The first line of the file<span class="Apple-style-span" style="font-family: sans-serif; ">&nbsp;</span><span class="Apple-style-span" style="font-family: sans-serif; "><tt>bears.in</tt></span><span class="Apple-style-span" style="font-family: sans-serif; ">&nbsp;</span><span class="Apple-style-span" style="font-family: sans-serif; ">contains two integers:</span><span class="Apple-style-span" style="font-family: sans-serif; ">&nbsp;</span><span class="Apple-style-span" style="font-family: sans-serif; "><i>A</i></span><span class="Apple-style-span" style="font-family: sans-serif; ">&nbsp;</span><span class="Apple-style-span" style="font-family: sans-serif; ">and</span><span class="Apple-style-span" style="font-family: sans-serif; ">&nbsp;</span><span class="Apple-style-span" style="font-family: sans-serif; "><i>B</i></span><span class="Apple-style-span" style="font-family: sans-serif; ">&nbsp;</span><span class="Apple-style-span" style="font-family: sans-serif; ">(|</span><span class="Apple-style-span" style="font-family: sans-serif; "><i>A</i></span><span class="Apple-style-span" style="font-family: sans-serif; ">|&nbsp;&le;&nbsp;10</span><span class="Apple-style-span" style="font-family: sans-serif; "><sup>6</sup></span><span class="Apple-style-span" style="font-family: sans-serif; ">, |</span><span class="Apple-style-span" style="font-family: sans-serif; "><i>B</i></span><span class="Apple-style-span" style="font-family: sans-serif; ">|&nbsp;&le;&nbsp;10</span><span class="Apple-style-span" style="font-family: sans-serif; "><sup>6</sup></span><span class="Apple-style-span" style="font-family: sans-serif; ">), the starting point of the BEARs. The second line contains one integer</span><span class="Apple-style-span" style="font-family: sans-serif; ">&nbsp;</span><span class="Apple-style-span" style="font-family: sans-serif; "><i>N</i></span><span class="Apple-style-span" style="font-family: sans-serif; ">&nbsp;</span><span class="Apple-style-span" style="font-family: sans-serif; ">(0&nbsp;&le;&nbsp;</span><span class="Apple-style-span" style="font-family: sans-serif; "><i>N</i></span><span class="Apple-style-span" style="font-family: sans-serif; ">&nbsp;&le;&nbsp;500), the number of main streets. Each of the following</span><span class="Apple-style-span" style="font-family: sans-serif; ">&nbsp;</span><span class="Apple-style-span" style="font-family: sans-serif; "><i>N</i></span><span class="Apple-style-span" style="font-family: sans-serif; ">&nbsp;</span><span class="Apple-style-span" style="font-family: sans-serif; ">lines contains four integers:</span><span class="Apple-style-span" style="font-family: sans-serif; ">&nbsp;</span><span class="Apple-style-span" style="font-family: sans-serif; "><i>X<sub>1</sub></i></span><span class="Apple-style-span" style="font-family: sans-serif; ">,</span><span class="Apple-style-span" style="font-family: sans-serif; ">&nbsp;</span><span class="Apple-style-span" style="font-family: sans-serif; "><i>Y<sub>1</sub></i></span><span class="Apple-style-span" style="font-family: sans-serif; ">,</span><span class="Apple-style-span" style="font-family: sans-serif; ">&nbsp;</span><span class="Apple-style-span" style="font-family: sans-serif; "><i>X<sub>2</sub></i></span><span class="Apple-style-span" style="font-family: sans-serif; ">,</span><span class="Apple-style-span" style="font-family: sans-serif; ">&nbsp;</span><span class="Apple-style-span" style="font-family: sans-serif; "><i>Y<sub>2</sub></i></span><span class="Apple-style-span" style="font-family: sans-serif; ">(|</span><span class="Apple-style-span" style="font-family: sans-serif; "><i>X<sub>i</sub></i></span><span class="Apple-style-span" style="font-family: sans-serif; ">|&nbsp;&le;&nbsp;10</span><span class="Apple-style-span" style="font-family: sans-serif; "><sup>6</sup></span><span class="Apple-style-span" style="font-family: sans-serif; ">, |</span><span class="Apple-style-span" style="font-family: sans-serif; "><i>Y<sub>i</sub></i></span><span class="Apple-style-span" style="font-family: sans-serif; ">|&nbsp;&le;&nbsp;10</span><span class="Apple-style-span" style="font-family: sans-serif; "><sup>6</sup></span><span class="Apple-style-span" style="font-family: sans-serif; ">), meaning that the street section between intersections (</span><span class="Apple-style-span" style="font-family: sans-serif; "><i>X<sub>1</sub></i></span><span class="Apple-style-span" style="font-family: sans-serif; ">,</span><span class="Apple-style-span" style="font-family: sans-serif; "><i>Y<sub>1</sub></i></span><span class="Apple-style-span" style="font-family: sans-serif; ">) and (</span><span class="Apple-style-span" style="font-family: sans-serif; "><i>X<sub>2</sub></i></span><span class="Apple-style-span" style="font-family: sans-serif; ">,</span><span class="Apple-style-span" style="font-family: sans-serif; "><i>Y<sub>2</sub></i></span><span class="Apple-style-span" style="font-family: sans-serif; ">) is a main street. Either</span><span class="Apple-style-span" style="font-family: sans-serif; ">&nbsp;</span><span class="Apple-style-span" style="font-family: sans-serif; "><i>X<sub>1</sub></i></span><span class="Apple-style-span" style="font-family: sans-serif; ">&nbsp;=&nbsp;</span><span class="Apple-style-span" style="font-family: sans-serif; "><i>X<sub>2</sub></i></span><span class="Apple-style-span" style="font-family: sans-serif; ">&nbsp;</span><span class="Apple-style-span" style="font-family: sans-serif; ">or</span><span class="Apple-style-span" style="font-family: sans-serif; ">&nbsp;</span><span class="Apple-style-span" style="font-family: sans-serif; "><i>Y<sub>1</sub></i></span><span class="Apple-style-span" style="font-family: sans-serif; ">&nbsp;=&nbsp;</span><span class="Apple-style-span" style="font-family: sans-serif; "><i>Y<sub>2&nbsp;</sub></i></span><span class="Apple-style-span" style="font-family: sans-serif; ">holds.</span></span></p>\r\n<div id="cke_pastebin" style="position: absolute; left: -1000px; top: 18px; width: 1px; height: 1px; overflow-x: hidden; overflow-y: hidden; ">\r\n	<font class="Apple-style-span" face="sans-serif">the starting point of the BEARs. The second line contains one integer N (0  N  500), the</font></div>\r\n<div id="cke_pastebin" style="position: absolute; left: -1000px; top: 18px; width: 1px; height: 1px; overflow-x: hidden; overflow-y: hidden; ">\r\n	<font class="Apple-style-span" face="sans-serif">number of main streets. Each of the following N lines contains four integers: X1, Y1, X2, Y2</font></div>\r\n<div id="cke_pastebin" style="position: absolute; left: -1000px; top: 18px; width: 1px; height: 1px; overflow-x: hidden; overflow-y: hidden; ">\r\n	<font class="Apple-style-span" face="sans-serif">(|Xi|  106, |Yi|  106), meaning that the street section between intersections (X1, Y1) and</font></div>\r\n<div id="cke_pastebin" style="position: absolute; left: -1000px; top: 18px; width: 1px; height: 1px; overflow-x: hidden; overflow-y: hidden; ">\r\n	<font class="Apple-style-span" face="sans-serif">(X2, Y2) is a main street. Either X1 = X2 or Y1 = Y2 holds.</font></div>\r\n', '<p>\r\n	<span class="Apple-style-span" style="font-family: sans-serif; ">The only line of the file</span><span class="Apple-style-span" style="font-family: sans-serif; ">&nbsp;</span><span class="Apple-style-span" style="font-family: sans-serif; "><tt>bears.out</tt></span><span class="Apple-style-span" style="font-family: sans-serif; ">&nbsp;</span><span class="Apple-style-span" style="font-family: sans-serif; ">must contain the maximum value of</span><span class="Apple-style-span" style="font-family: sans-serif; ">&nbsp;</span><span class="Apple-style-span" style="font-family: sans-serif; "><i>D</i></span><span class="Apple-style-span" style="font-family: sans-serif; ">.</span></p>\r\n', '3 3\r\n3\r\n1 0 3 0\r\n0 0 0 3\r\n3 0 3 1\r\n', '1\r\n', '<p>\r\n	<span class="Apple-style-span" style="font-family: sans-serif; ">The following figure illustrates how the BEARs can get to within distance 1 of the warehouse:</span><br />\r\n	<span class="Apple-style-span" style="font-family: sans-serif; "><img src="http://www.ut.ee/boi/tasks/bears1.png" /></span><br />\r\n	<span class="Apple-style-span" style="font-family: sans-serif; ">Even though the BEARs may continue trying forever, the sheriff can prevent them from ever getting closer to the warehouse.</span></p>\r\n', 0, 0, '2010-10-23 10:06:21', '2010-10-23 10:56:43'),
(363, 6, 'Lego', 1000, 67108864, 0000000000, 0000000000, '<div>\r\n	<span style="font-size:16px;">You are using Lego building blocks to train an artificial vision system. Write a program that, given pictures of a Lego construction taken from two angles, calculates in how many different ways it can be built.</span></div>\r\n<div>\r\n	&nbsp;</div>\r\n<div>\r\n	<span style="font-size:16px;">&nbsp;In this task, there is only one kind of lego block (with 2x2 &quot;knobs&quot;, see picture below), but it can have three different colors: white (W), gray (G) or black (B). All blocks exist in unlimited amounts. You use a quadratic base with 6x6 knobs. Every block must have its edges parallel to this base and no block may extend outside of it. Every block must rest upon at least one underlying block.</span></div>\r\n<div>\r\n	<span style="font-size:16px;"><img src="http://www.ut.ee/boi/tasks/lego1.png" /></span></div>\r\n<div>\r\n	<span style="font-size:16px;">Left: An allowed way to place a block on top of another one.<br />\r\n	Center: An illegal way (the upper block hangs in the air).<br />\r\n	Right: Another illegal way (the upper block extends outside the base).</span></div>\r\n', 'BOI2010', '<div>\r\n	<span style="font-size:16px;"><span style="font-family:arial,helvetica,sans-serif;"><span class="Apple-style-span">The first line of the file&nbsp;<tt>lego.in</tt>&nbsp;contains&nbsp;<i>H</i>&nbsp;(1&nbsp;&le;&nbsp;<i>H</i>&nbsp;&le;&nbsp;6), the height of the construction.</span></span></span></div>\r\n<div>\r\n	&nbsp;</div>\r\n<div>\r\n	<span style="font-size:16px;"><span style="font-family:arial,helvetica,sans-serif;">Then follow&nbsp;<i>H</i>&nbsp;lines with 6 characters on each line, giving a picture of the construction as seen from one side (marked A on the figure below). The&nbsp;<i>j</i>th character on the&nbsp;<i>i</i>th line specifies what you see looking at the&nbsp;<i>j</i>th column from the left on the&nbsp;<i>i</i>th row from above. Each character may be one of &#39;W&#39;, &#39;G&#39;, &#39;B&#39; or &#39;.&#39;, specifying a color (&#39;W&#39;, &#39;G&#39;, or &#39;B&#39;) or a hole (&#39;.&#39;). Note that you cannot estimate the depth, so a color seen in a certain position may either belong to a block near the front edge, or further back, provided no other block is blocking the sight.</span></span></div>\r\n<div>\r\n	&nbsp;</div>\r\n<div>\r\n	<span style="font-size:16px;"><span style="font-family:arial,helvetica,sans-serif;">The first picture is followed by another set of&nbsp;<i>H</i>&nbsp;lines with the construction seen from an angle where the observer has moved 90 degrees counterclockwise around the construction (marked B on the figure below).</span></span></div>\r\n', '<div>\r\n	<span style="font-size:16px;"><span style="font-family:arial,helvetica,sans-serif;"><span class="Apple-style-span">The program should output one line to the</span><span class="Apple-style-span">&nbsp;</span><span class="Apple-style-span"><tt>lego.out</tt></span><span class="Apple-style-span">&nbsp;</span><span class="Apple-style-span">output file, containing a single integer: the number of different Lego constructions that satisfy the pictures given in the input. Note that even if two different possible constructions could be obtained from each other by rotating or mirroring, they both should be counted. For the given input, the answer will always fit in a signed 64-bit integer.</span></span></span></div>\r\n', '2\r\nWWGG..\r\n.BB.WW\r\n.WGG..\r\nWWGG..	\r\n', '6\r\n', '<p>\r\n	<span style="font-size:16px;"><span class="Apple-style-span" style="font-family: sans-serif; "><img src="http://www.ut.ee/boi/tasks/lego2.png" /></span><br />\r\n	<span style="font-family:arial,helvetica,sans-serif;"><span class="Apple-style-span">One of the possible constructions in the example.</span></span></span></p>\r\n', 0, 0, '2010-10-23 12:05:21', '2010-10-23 12:20:00'),
(364, 6, 'Printed Circuit Board', 1000, 67108864, 0000000000, 0000000000, '<div>\r\n	<span style="font-size:14px;"><span class="Apple-style-span" style="font-family: arial, helvetica, sans-serif; ">I<span style="font-size:16px;">n a printed circuit board, conductive wires are laid on a non-conductive board. Because the conductors in the same layer cannot cross without creating short-circuits, boards with conductors divided into several layers separated by non-conductive board material are used in more complex cases. However, boards with more layers are more expensive. So, manufacturers try to allocate the required conductors to layers in a way that minimizes the number of layers needed.</span></span></span></div>\r\n<div>\r\n	&nbsp;</div>\r\n<div>\r\n	<span style="font-size:16px;"><span style="font-family:arial,helvetica,sans-serif;">In this task we look at boards where each conductor is connecting two ports located on opposite edges of the board and seek to minimize the cost of such a board.</span></span></div>\r\n<div>\r\n	&nbsp;</div>\r\n<div>\r\n	<span style="font-size:16px;"><span style="font-family:arial,helvetica,sans-serif;">Consider, for example, the board shown on the left on the figure below. If one conductor has to connect A to B and another D to C, this could be achieved in a single layer, as shown in the middle on the figure. But a conductor connecting A to C and another connecting D to B could not be laid out in the same layer, as can be seen on the right on the figure.</span></span></div>\r\n<div>\r\n	<span style="font-size:16px;"><span style="font-family:arial,helvetica,sans-serif;"><img src="http://www.ut.ee/boi/tasks/pcb1.png" /></span></span></div>\r\n<div>\r\n	<span style="font-size:16px;"><span style="font-family:arial,helvetica,sans-serif;">Write a program that is given the locations of the endpoints of the&nbsp;<i>N</i>&nbsp;conductors on a&nbsp;<i>W&nbsp;</i>x&nbsp;<i>H</i>&nbsp;board and determines the minimal number of layers needed to accommodate all of them.</span></span></div>\r\n<div>\r\n	&nbsp;</div>\r\n<div>\r\n	<span style="font-size:16px;"><span style="font-family:arial,helvetica,sans-serif;">It may be assumed the width of the conductors is very small compared to the distances between the ports. That is, between any two conductors, there is always enough room for a third one.</span></span></div>\r\n', 'BOI2010', '<p>\r\n	<span style="font-size:16px;"><span style="font-family:arial,helvetica,sans-serif;"><span class="Apple-style-span">The first line of the text file</span><span class="Apple-style-span">&nbsp;</span><span class="Apple-style-span"><tt>pcb.in</tt></span><span class="Apple-style-span">&nbsp;</span><span class="Apple-style-span">contains</span><span class="Apple-style-span">&nbsp;</span><span class="Apple-style-span"><i>N</i></span><span class="Apple-style-span">&nbsp;</span><span class="Apple-style-span">(1&nbsp;&le;&nbsp;</span><span class="Apple-style-span"><i>N</i></span><span class="Apple-style-span">&nbsp;&le;&nbsp;10</span><span class="Apple-style-span"><sup>5</sup></span><span class="Apple-style-span">), the number of connectors. Each of the following</span><span class="Apple-style-span">&nbsp;</span><span class="Apple-style-span"><i>N</i></span><span class="Apple-style-span">&nbsp;</span><span class="Apple-style-span">lines contains two integers,</span><span class="Apple-style-span"><i>X<sub>i1</sub></i></span><span class="Apple-style-span">&nbsp;</span><span class="Apple-style-span">and</span><span class="Apple-style-span">&nbsp;</span><span class="Apple-style-span"><i>X<sub>i2</sub></i></span><span class="Apple-style-span">&nbsp;</span><span class="Apple-style-span">(0&nbsp;&le;&nbsp;</span><span class="Apple-style-span"><i>X<sub>ij</sub></i></span><span class="Apple-style-span">&nbsp;&le;&nbsp;10</span><span class="Apple-style-span"><sup>6</sup></span><span class="Apple-style-span">), separated by a space, meaning that the</span><span class="Apple-style-span">&nbsp;</span><span class="Apple-style-span"><i>i</i></span><span class="Apple-style-span">-th conductor has to connect the points (</span><span class="Apple-style-span"><i>X<sub>i1</sub></i></span><span class="Apple-style-span">,0) and (</span><span class="Apple-style-span"><i>X<sub>i2</sub></i></span><span class="Apple-style-span">,</span><span class="Apple-style-span"><i>H</i></span><span class="Apple-style-span">). It may be assumed that all the 2</span><span class="Apple-style-span"><i>N</i></span><span class="Apple-style-span">&nbsp;</span><span class="Apple-style-span">endpoints given in the input are distinct.</span></span></span></p>\r\n', '<p>\r\n	<span style="font-size:16px;"><span style="font-family:arial,helvetica,sans-serif;"><span class="Apple-style-span">The first and only line of the text file</span><span class="Apple-style-span">&nbsp;</span><span class="Apple-style-span"><tt>pcb.out</tt></span><span class="Apple-style-span">&nbsp;</span><span class="Apple-style-span">should contain a single integer, the minimal number of layers needed to accommodate all the required conductors.</span></span></span></p>\r\n', '2\r\n1 1\r\n3 3\r\n2\r\n1 3\r\n3 1\r\n', '1\r\n2', '', 0, 0, '2010-10-23 14:21:50', '2010-10-23 14:30:19'),
(365, 6, 'Escape', 1000, 33554432, 0000000000, 0000000000, '<div>\r\n	A group of war prisoners are trying to escape from a prison. They have thoroughly planned the&nbsp;escape from the prison itself, and after that they hope to find shelter in a nearby village. However,&nbsp;the village (marked as B, see picture below) and the prison (marked as A) are separated by a canyon&nbsp;which is also guarded by soldiers. These soldiers sit in their pickets and rarely walk; the range of view&nbsp;of each soldier is limited to exactly 100 meters. Thus, depending on the locations of soldiers, it may&nbsp;be possible to pass the canyon safely, keeping the distance to the closest soldier strictly larger than&nbsp;100 meters at any moment.</div>\r\n<div>\r\n	<div style="font-family: Arial, Verdana, sans-serif; font-size: 12px; color: rgb(34, 34, 34); background-color: rgb(255, 255, 255); ">\r\n		<div>\r\n			<img alt="" src="/joj/app/webroot/userfiles/escape.JPG" style="cursor: default; width: 612px; height: 516px; " /></div>\r\n		<div>\r\n			<span style="font-size:16px;">You are to write a program which, given the width and the length of the canyon and the coordinates&nbsp;of every soldier in the canyon, and assuming that soldiers do not change their locations, first&nbsp;determines whether prisoners can pass the canyon unnoticed. If this is impossible then the prisoners&nbsp;(having seen enough violence) would like to know the minimum number of soldiers that have to be&nbsp;eliminated in order to pass the canyon safely. A soldier may be eliminated regardless of whether he is&nbsp;visible to any other soldier or not.</span></div>\r\n	</div>\r\n</div>\r\n', 'BOI2007', '<p>\r\n	The first line contains three integers L, W,&nbsp;and N (1 &lt;= W &lt;= 50,000 1&lt;=  L &lt;= 50,000 1&lt;=  N &lt;= 250) &ndash; the length and the width of the canyon, and the number of soldiers, respectively. Each of&nbsp;the following N lines contains a pair of integers Xi and Yi &ndash; the coordinates of i-th soldier in the&nbsp;canyon (0 &lt;=Xi &lt;= L, 0 &lt;= Yi &lt;=  W). The coordinates are given in meters, relative to the canyon: the&nbsp;southwestern corner of the canyon has coordinates (0, 0), and the northeastern corner of the canyon&nbsp;has coordinates (L,W), as seen in the picture above.</p>\r\n<div>\r\n	Note that passing the canyon may start at coordinate (0, ys) for any 0 &lt;= ys &lt;=  W and end at&nbsp;coordinate (L, ye) for any 0  &lt;=ye &lt;=  W. Neither ys nor ye need to be integer.</div>\r\n<p>\r\n	&nbsp;</p>\r\n<div id="cke_pastebin" style="position: absolute; left: -1000px; top: 84px; width: 1px; height: 1px; overflow-x: hidden; overflow-y: hidden; ">\r\n	Note that passing the canyon may start at coordinate (0, ys) for any 0  ys  W and end at</div>\r\n<div id="cke_pastebin" style="position: absolute; left: -1000px; top: 84px; width: 1px; height: 1px; overflow-x: hidden; overflow-y: hidden; ">\r\n	coordinate (L, ye) for any 0  ye  W. Neither ys nor ye need to be integer.</div>\r\n<div id="cke_pastebin" style="position: absolute; left: -1000px; top: 12px; width: 1px; height: 1px; overflow-x: hidden; overflow-y: hidden; ">\r\n	has coordinates (L,W), as seen in the picture above.</div>\r\n<div id="cke_pastebin" style="position: absolute; left: -1000px; top: 12px; width: 1px; height: 1px; overflow-x: hidden; overflow-y: hidden; ">\r\n	southwestern corner of the canyon has coordinates (0, 0), and the northeastern corner of the canyon</div>\r\n<div id="cke_pastebin" style="position: absolute; left: -1000px; top: 12px; width: 1px; height: 1px; overflow-x: hidden; overflow-y: hidden; ">\r\n	has coordinates (L,W), as seen in the picture above.</div>\r\n<div id="cke_pastebin" style="position: absolute; left: -1000px; top: 12px; width: 1px; height: 1px; overflow-x: hidden; overflow-y: hidden; ">\r\n	Note that passing the canyon may start at coordinate (0, ys) for any 0  ys  W and end at</div>\r\n<div id="cke_pastebin" style="position: absolute; left: -1000px; top: 12px; width: 1px; height: 1px; overflow-x: hidden; overflow-y: hidden; ">\r\n	coordinate (L, ye) for any 0  ye  W. Neither ys nor ye need to be integer.</div>\r\n', '<p>\r\n	In the first and only line of the output file&nbsp;the program should print the minimum number of soldiers that have to be eliminated in order for the&nbsp;prisoners to pass the canyon safely. If the prisoners can escape without any elimination, the program&nbsp;should print 0 (zero).</p>\r\n', '130 340 5\r\n10 50\r\n130 130\r\n70 170\r\n0 180\r\n60 260\r\n', '1', '', 0, 0, '2010-10-23 16:16:52', '2010-10-23 18:40:36'),
(366, 6, 'Sorting', 1000, 33554432, 0000000000, 0000000000, '<div>\r\n	You are given the scores of several players in a competition. Your task is to&nbsp;create a ranklist of the players, sorted in decreasing order by score.Unfortunately, the data structure used for the list of players supports only&nbsp;one operation, which moves a player from position i to position j without&nbsp;changing the relative order of other players. If i &gt; j, the positions of players&nbsp;at positions between j and i&minus;1 increase by 1, otherwise if i &lt; j the positions&nbsp;of players at positions between i + 1 and j&nbsp;decrease by 1.&nbsp;</div>\r\n<div>\r\n	This operation takes i steps to locate the player to be moved, and j steps&nbsp;to locate the position where he or she is moved to, so the overall cost of moving&nbsp;a player from position i to position j is i + j. Here, positions are numbered&nbsp;starting with 1.Determine a sequence of moves to create the ranklist such that the sum of&nbsp;the costs of the moves is minimized.</div>\r\n', 'BOI2007', '<p>\r\n	The first line contains n(2 &lt;= n &lt;= 1000), the number of players. Each of the following n lines contains&nbsp;one non-negative integer si (0  &lt;=si &lt;= 1,000,000), the scores of the players in&nbsp;the current order. You may assume that all scores are distinct.</p>\r\n', '<p>\r\n	&nbsp;In the first line&nbsp;of the output print the number of moves used to create the ranklist. The&nbsp;following lines should specify the moves in the order in which they are applied.Each move should be described by a line containing two integers i and j, which&nbsp;means that the player at position i is moved to position j. The numbers i and&nbsp;j must be separated by a single space.</p>\r\n', '5\r\n20\r\n30\r\n5\r\n15\r\n10\r\n', '2\r\n2 1\r\n3 5\r\n', '', 0, 0, '2010-10-23 20:51:03', '2010-10-27 13:33:36'),
(367, 6, 'Sound', 8000, 33554432, 0000000000, 0000000000, '<p>\r\n	In digital recording, sound is described by a sequence of numbers representing the air pressure,&nbsp;measured at a rapid rate with a fixed time interval between successive measurements. Each value in&nbsp;the sequence is called a sample.&nbsp;An important step in many voice-processing tasks is breaking the recorded sound into chunks of&nbsp;non-silence separated by silence.</p>\r\n<div>\r\n	To avoid accidentally breaking the recording into too few or too&nbsp;many pieces, the silence is often defined as a sequence of m samples where the difference between&nbsp;the lowest and the highest value does not exceed a certain treshold c.Write a program to detect silence in a given recording of n samples according to the given parameter&nbsp;values m and c.</div>\r\n', 'BOI2007', '<p>\r\n	The first line of the file contains three integers: n (1  &lt;= n &lt;=  1,000,000), the&nbsp;number of samples in the recording; m (1 &lt;= m &lt;= 10,000), the required length&nbsp;of the silence; and c (0 &lt;= c&lt;=  10,000), the maximal noise level allowed within&nbsp;silence.The second line of the file contains n integers ai (0 &lt;=  ai &lt;=  1,000,000 for&nbsp;1 &lt;= i &lt;=  n), separated by single spaces: the samples in the recording.</p>\r\n', '<p>\r\n	The file should list all values of i such that max(a[i . . . i + m &minus; 1]) &minus;min(a[i . . . i + m &minus; 1]) &lt;= c. The values should be listed in increasing order,each on a separate line.If there is no silence in the input file, write NONE on the first and only line&nbsp;of the output file.</p>\r\n', '7 2 0\r\n0 1 1 2 3 2 2', '2\r\n6\r\n', '', 0, 0, '2010-10-23 21:13:07', '2010-10-24 16:04:49'),
(368, 6, 'Fence', 5000, 33554432, 0000000000, 0000000000, '<div>\r\n	<div>\r\n		Leopold is indeed a lucky fellow. He just won a huge estate in the lottery. The estate contains&nbsp;several grand buildings in addition to the main mansion, in which he intends to live from now on.&nbsp;However, the estate lacks a fence protecting the premises from trespassers, which concerns Leopold&nbsp;to a great extent. He wants to build a fence and, in order to save money, he decides it is sufficient to&nbsp;have a fence that encloses the main mansion, except for one important restriction: the fence must not&nbsp;lie too close to any of the buildings. To be precise, seen from above, each building is enclosed in a&nbsp;surrounding forbidden rectangle within which no part of the fence may lie. The rectangles&rsquo; sides are&nbsp;parallel to the x-axis and y-axis. Each part of the fence must also be parallel either to the x-axis or the&nbsp;y-axis.</div>\r\n	<div>\r\n		Help Leopold to compute the minimum length of any allowed fence enclosing the main mansion.</div>\r\n	<div>\r\n		<img alt="" src="/joj/app/webroot/userfiles/fence.JPG" style="cursor: default; width: 679px; height: 349px; " /></div>\r\n	<div>\r\n		<div>\r\n			Figure 1: The main mansion (black) and three other buildings with surrounding forbidden rectangles.The thick black line shows a shortest allowed fence enclosing the main mansion.</div>\r\n	</div>\r\n</div>\r\n', 'BOI2007', '<p>\r\n	The first line of the input file contains a positive&nbsp;integer m (1 &lt;= m &lt;= 100), the number of buildings of the estate. Then follow m lines each describing&nbsp;a forbidden rectangle enclosing a building. Each row contains four space-separated integers tx, ty,&nbsp;bx, and by, where (tx, ty) are the coordinates of the upper left corner and (bx, by) the coordinates&nbsp;of the bottom right corner of the rectangle. All coordinates obey 0 &lt;= tx &lt; bx &lt;= 10,000 and&nbsp;0 &lt;= ty &lt; by  &lt;= 10,000. The first rectangle is the forbidden rectangle enclosing the main mansion.</p>\r\n', '<p>\r\n	&nbsp;It contains one line with a single positive&nbsp;integer equal to the minimum length of any allowed fence enclosing the main mansion.</p>\r\n', '4\r\n8 4 13 8\r\n2 1 6 7\r\n4 7 9 11\r\n14 7 19 11\r\n', '32\r\n', '', 0, 0, '2010-10-23 21:14:42', '2010-10-24 16:40:15'),
(369, 6, 'Connected Points', 5000, 33554432, 0000000000, 0000000000, '<div>\r\n	<div>\r\n		Consider a regular grid of 3 &times; N points. Every point in the grid has up to eight neighboring points&nbsp;(see Fig. 1).</div>\r\n	<div>\r\n		<img alt="" src="/joj/app/webroot/userfiles/point.JPG" style="cursor: default; width: 250px; height: 222px; " /></div>\r\n	<div>\r\n		Figure 1: Neighboring points (marked by arrows).</div>\r\n	<div>\r\n		We are interested in counting the number of different ways to connect the points of the grid to form&nbsp;a polygon that fulfills the following conditions:</div>\r\n	<div>\r\n		<div>\r\n			1. The set of vertices of the polygon consists of all 3 &times; N points.</div>\r\n		<div>\r\n			2. Adjacent vertices of the polygon are neighboring points in the grid.</div>\r\n		<div>\r\n			3. Each polygon is simple, i.e. there must not be any self-intersections.</div>\r\n		<div>\r\n			Two possible polygons for N = 6 are given in the Fig. 2.</div>\r\n		<div>\r\n			<div style="font-family: Arial, Verdana, sans-serif; font-size: 12px; color: rgb(34, 34, 34); background-color: rgb(255, 255, 255); ">\r\n				<p>\r\n					<img alt="" src="/joj/app/webroot/userfiles/admin/0/point1.JPG" style="cursor: default; width: 962px; height: 221px; " /></p>\r\n			</div>\r\n		</div>\r\n		<div>\r\n			Figure 2: Two possible connections of points for N = 6.</div>\r\n		<div>\r\n			<div>\r\n				Write a program that calculates for a given N the number of possible ways to connect the points as&nbsp;described modulo 1,000,000,000.</div>\r\n		</div>\r\n	</div>\r\n	<div>\r\n		&nbsp;</div>\r\n</div>\r\n', 'BOI2007', '<p>\r\n	The first and only line contains one positive&nbsp;integer N (N &lt;= 1,000,000,000).</p>\r\n', '<p>\r\n	The only line to be written contains the&nbsp;remainder of the number of ways to connect the points modulo 1,000,000,000.</p>\r\n', '3\r\n4\r\n', '8\r\n40\r\n\r\n\r\n', '', 0, 0, '2010-10-23 21:15:29', '2010-10-24 16:39:29'),
(370, 6, 'Sequence', 5000, 33554432, 0000000000, 0000000000, '<div>\r\n	<div>\r\n		We are given a sequence a1, ..., an. We can manipulate this sequence using the operation reduce(i),&nbsp;which replaces elements ai and ai+1 with a single element max(ai, ai+1), resulting in a new shorter&nbsp;sequence. The cost of this operation is max(ai, ai+1). After n &minus; 1 operations reduce, we obtain a&nbsp;sequence of length 1. Our task is to compute the cost of the optimal reducing scheme, i.e. the sequence&nbsp;of reduce operations with minimal cost leading to a sequence of length 1.</div>\r\n</div>\r\n', 'BOI2007', '<p>\r\n	&nbsp;The first line contains n (1 &lt;= n &lt;=1,000,000), the length of the sequence. The following n lines contain one integer ai, the elements&nbsp;of the sequence (0 &lt;= ai &lt;=1,000,000,000).</p>\r\n', '<p>\r\n	&nbsp;In the first and only line of the output&nbsp;print the minimal cost of reducing the sequence to a single element.</p>\r\n', '3\r\n1\r\n2\r\n3', '5', '', 0, 0, '2010-10-23 21:16:08', '2010-10-24 17:14:54'),
(374, 1, 'Max Sum', 80, 16777216, 0000000000, 0000000000, '<p>\r\n	Given a sequence a[1],a[2],a[3]......a[n], your job is to calculate the max sum of a sub-sequence. For example, given (6,-1,5,4,-7), the max sum in this sequence is 6 + (-1) + 5 + 4 = 14.</p>\r\n', 'Ignatius.L', '<p>\r\n	The first line of the input contains an integer T) which means the number of test cases. Then T lines follow, each line starts with a number N(1&lt;=N&lt;=20000), then N integers followed.</p>\r\n', '<p>\r\n	For each test case, you should output two lines. The first line is &quot;Case #:&quot;, # means the number of the test case. The second line contains three integers, the Max Sum in the sequence, the start position of the sub-sequence, the end position of the sub-sequence. If there are more than one result, output the first one. Output a blank line between two cases.</p>\r\n', '2\r\n5 6 -1 5 4 -7\r\n7 0 6 -1 1 -6 7 -5\r\n', 'Case 1:\r\n14 1 4\r\n\r\nCase 2:\r\n7 1 6\r\n', '<br />\r\n', 0, 0, '2010-10-27 18:20:42', '2010-10-27 18:22:09'),
(371, 6, 'Building A New Barn', 2000, 67108864, 0000000000, 0000000000, '<div>\r\n	<p style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">\r\n		<span class="Apple-style-span" style="color: rgb(0, 0, 255); font-family: Arial, Helvetica, sans-serif; -webkit-border-horizontal-spacing: 0px; -webkit-border-vertical-spacing: 0px; font-size: 24px; "><b><span class="Apple-style-span" style="color: rgb(0, 0, 0); font-family: ''Times New Roman'', Times, serif; font-weight: normal; font-size: 16px; ">After scrimping and saving for years, Farmer John has decided to build a new barn. He wants the barn to be highly accessible, and he knows the coordinates of the grazing spots of all&nbsp;<i>N</i>&nbsp;(2 &le;&nbsp;<i>N</i>&nbsp;&le; 10,000 cows. Each grazing spot is at a point with integer coordinates (<i>X<sub>i</sub></i>,&nbsp;<i>Y<sub>i</sub></i>) (-10,000 &le;&nbsp;<i>X<sub>i</sub></i>&nbsp;&le; 10,000; -10,000 &le;&nbsp;<i>Y<sub>i</sub></i>&nbsp;&le; 10,000). The hungry cows never graze in spots that are horizontally or vertically adjacent.</span></b></span></p>\r\n	<p>\r\n		<font class="Apple-style-span" color="#0000FF" face="Arial, Helvetica, sans-serif" size="6"><span class="Apple-style-span" style="font-size: 24px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px;"><b><span class="Apple-style-span" style="color: rgb(0, 0, 0); font-family: ''Times New Roman'', Times, serif; font-weight: normal; font-size: 16px; ">The barn must be placed at integer coordinates and cannot be on any cow&#39;s grazing spot. The inconvenience of the barn for any cow is given the Manhattan distance formula |&nbsp;<i>X</i>&nbsp;-&nbsp;<i>X<sub>i</sub></i>&nbsp;| + |&nbsp;<i>Y</i>&nbsp;-&nbsp;<i>Y<sub>i</sub></i>|, where (<i>X</i>,&nbsp;<i>Y</i>) and (<i>X<sub>i</sub></i>,&nbsp;<i>Y<sub>i</sub></i>) are the coordinates of the barn and the cow&#39;s grazing spot, respectively. Where should the barn be constructed in order to minimize the sum of its inconvenience for all the cows?</span></b></span></font></p>\r\n</div>\r\n', 'USACO 2007 February Gold', '<p>\r\n	<span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">Line 1: A single integer:</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">&nbsp;</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; "><i>N</i></span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">&nbsp;</span><br />\r\n	<span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">Lines 2..</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; "><i>N</i></span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">+1: Line</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">&nbsp;</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; "><i>i</i></span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">+1 contains two space-separated integers which are the grazing location (</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; "><i>X<sub>i</sub></i></span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">,</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">&nbsp;</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; "><i>Y<sub>i</sub></i></span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">) of cow</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">&nbsp;</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; "><i>i</i></span></p>\r\n', '<p>\r\n	<span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">Line 1: Two space-separated integers: the minimum inconvenience for the barn and the number of spots on which Farmer John can build the barn to achieve this minimum.</span></p>\r\n', '4\r\n1 -3\r\n0 1\r\n-2 1\r\n1 -1\r\n', '10 4', '<p>\r\n	<font class="Apple-style-span" face="''Times New Roman'', Times, serif" size="4"><span class="Apple-style-span" style="font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px;">The minimum inconvenience is 10, and there are 4 spots that Farmer John can build the farm to achieve this: (0, -1), (0, 0), (1, 0), and (1, 1).</span></font></p>\r\n', 0, 0, '2010-10-23 21:17:01', '2010-11-29 13:40:38');
INSERT INTO `tbl_problems` (`id`, `user_id`, `title`, `time_limit`, `memory_limit`, `submission_no`, `accepted_no`, `description`, `source`, `input`, `output`, `input_sample`, `output_sample`, `hint`, `flag`, `visibility`, `created`, `modified`) VALUES
(372, 6, 'Cow Sorting', 2000, 67108864, 0000000000, 0000000000, '<div>\r\n	<p>\r\n		Farmer John&#39;s&nbsp;<i>N</i>&nbsp;(1 &le;&nbsp;<i>N</i>&nbsp;&le; 10,000) cows are lined up to be milked in the evening. Each cow has a unique &quot;grumpiness&quot; level in the range 1...100,000. Since grumpy cows are more likely to damage FJ&#39;s milking equipment, FJ would like to reorder the cows in line so they are lined up in increasing order of grumpiness. During this process, the places of any two cows (not necessarily adjacent) can be interchanged. Since grumpy cows are harder to move, it takes FJ a total of&nbsp;<i>X</i>+<i>Y</i>&nbsp;units of time to exchange two cows whose grumpiness levels are&nbsp;<i>X</i>&nbsp;and&nbsp;<i>Y</i>.</p>\r\n	<p>\r\n		Please help FJ calculate the minimal time required to reorder the cows.</p>\r\n</div>\r\n', 'USACO 2007 February Gold', '<p>\r\n	Line 1: A single integer:&nbsp;<i>N</i>.&nbsp;<br />\r\n	Lines 2..<i>N</i>+1: Each line contains a single integer: line&nbsp;<i>i</i>+1 describes the grumpiness of cow&nbsp;<i>i</i>.&nbsp;</p>\r\n', '<p>\r\n	<span style="font-size:16px;"><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">Line 1: A single line with the minimal time required to reorder the cows in increasing order of grumpiness.</span></span></p>\r\n', '3\r\n2\r\n3\r\n1', '7', '<p>\r\n	<span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">2 3 1 : Initial order.</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">&nbsp;</span><br />\r\n	<span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">2 1 3 : After interchanging cows with grumpiness 3 and 1 (time=1+3=4).</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">&nbsp;</span><br />\r\n	<span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">1 2 3 : After interchanging cows with grumpiness 1 and 2 (time=2+1=3).</span></p>\r\n', 0, 0, '2010-10-23 21:18:15', '2010-11-29 21:24:47'),
(373, 6, 'Lilypad Pond', 2000, 67108864, 0000000000, 0000000000, '<div>\r\n	<div>\r\n		<div>\r\n			<span style="font-size:16px;"><span style="font-family:arial,helvetica,sans-serif;"><span class="Apple-style-span" style="-webkit-border-horizontal-spacing: 0px; -webkit-border-vertical-spacing: 0px; ">FJ has installed a beautiful pond for his cows&#39; aesthetic enjoyment and exercise.</span>The rectangular pond has been partitioned into square cells of&nbsp;<i>M</i>&nbsp;rows and&nbsp;<i>N</i>&nbsp;columns (1 &le;&nbsp;<i>M</i>&nbsp;&le; 30; 1 &le;&nbsp;<i>N</i>&nbsp;&le; 30).Some of the cells have astonishingly sturdy lilypads; others have rocks; the remainder are just beautiful, cool, blue water.</span></span></div>\r\n		<div>\r\n			&nbsp;</div>\r\n		<div>\r\n			<span style="font-size:16px;"><span style="font-family:arial,helvetica,sans-serif;">Bessie is practicing her ballet moves by jumping from one lilypad to another and is currently located at one of the lilypads. She wants to travel to another lilypad in the pond by jumping from one lilypad to another.Surprising only to the uninitiated, Bessie&#39;s jumps between lilypads always appear as a chess-knight&#39;s move: one move in one direction and then two more in the orthogonal direction (or perhaps two in one direction and then one in the orthogonal direction).</span></span></div>\r\n		<div>\r\n			&nbsp;</div>\r\n		<div>\r\n			<span style="font-size:16px;"><span style="font-family:arial,helvetica,sans-serif;">Farmer John is observing Bessie&#39;s ballet drill and realizes that sometimes she might not be able to jump to her destination lilypad because intermediary lilypads are missing.Ever thrifty, he wants to place additional lilypads so she can complete her quest (perhaps quickly, perhaps by using a large number of intermediate lilypads). Of course, lilypads cannot be placed where rocks already intrude on a cell.</span></span></div>\r\n		<div>\r\n			<span style="font-size:16px;"><span style="font-family:arial,helvetica,sans-serif;">Help Farmer John determine the minimum number of additional lilypads he has to place, and in how many ways he can place that minimum number.</span></span></div>\r\n	</div>\r\n</div>\r\n', 'USACO 2007 February Gold', '<p>\r\n	<span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">Line 1: Two space-separated integers:</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">&nbsp;</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; "><i>M</i></span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">&nbsp;</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">and</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">&nbsp;</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; "><i>N</i></span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">&nbsp;</span><br />\r\n	<span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">Lines 2..</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; "><i>M</i></span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">+1: Line</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">&nbsp;</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; "><i>i</i></span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">+1 describes row i of the pond using</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">&nbsp;</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; "><i>N</i></span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">&nbsp;</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">space-separated integers with these values: 0 indicates empty water; 1 indicates a lilypad in place; 2 indicates rock in place; 3 indicates the lilypad Bessie starts on; 4 indicates the lilypad Bessie wants to travel to.</span></p>\r\n', '<p>\r\n	<span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">Line 1: One integer: the minimum number of additional lilypads required. If it is not possible to help Bessie jump to her destination, print -1.</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">&nbsp;</span><br />\r\n	<span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">Line 2: One integer: the total number of possible ways the additional lilypads can be positioned. This number is guaranteed to fit into a single 64-bit signed integer. Do not output this line if line 1 contains -1.</span></p>\r\n', '4 5\r\n1 0 0 0 0\r\n3 0 0 0 0\r\n0 0 2 0 0\r\n0 0 0 4 0\r\n', '2\r\n3', '<p>\r\n	<span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">Two lilypads are required. There are three ways to place them: row 4 column 2 and row 2 column 3; row 1 column 3 and row 3 column 2; or row 1 column 3 and row 2 column 5:</span></p>\r\n<div>\r\n	<span class="Apple-style-span" style="font-family: monospace; font-size: 16px; white-space: pre; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">R1C2,R2C3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; R1C3,R3C2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; R1C3,R2C5</span><br />\r\n	<span class="Apple-style-span" style="font-family: monospace; font-size: 16px; white-space: pre; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">1 0 0 0 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 0 X 0 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 0 X 0 0</span><br />\r\n	<span class="Apple-style-span" style="font-family: monospace; font-size: 16px; white-space: pre; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">3 0 X 0 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3 0 0 0 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3 0 0 0 X</span><br />\r\n	<span class="Apple-style-span" style="font-family: monospace; font-size: 16px; white-space: pre; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">0 0 2 0 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 X 2 0 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 0 2 0 0</span><br />\r\n	<span class="Apple-style-span" style="font-family: monospace; font-size: 16px; white-space: pre; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">0 X 0 4 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 0 0 4 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 0 0 4 0</span></div>\r\n<pre>\r\n</pre>\r\n', 0, 0, '2010-10-23 21:27:34', '2010-11-29 22:54:34'),
(375, 1, '最少拦截系统', 500, 33554432, 0000000000, 0000000000, '<p>\r\n	某国为了防御敌国的导弹袭击,发展出一种导弹拦截系统.但是这种导弹拦截系统有一个缺陷:虽然它的第一发炮弹能够到达任意的高度,但是以后每一发炮弹都只能低于前一发的高度.某天,雷达捕捉到敌国的导弹来袭.由于该系统还在试用阶段,所以只有一套系统,因此有可能不能拦截所有的导弹.<br />\r\n	怎么办呢?多搞几套系统呗!你说说倒蛮容易,成本呢?成本是个大问题啊.所以俺就到这里来求救了,请帮助计算一下最少需要多少套拦截系统.</p>\r\n', 'hdu 1257', '<p>\r\n	输入若干组数据.每组数据包括:导弹总个数(正整数),导弹依此飞来的高度(雷达给出的高度数据是正整数,用空格分隔)，飞来的导弹不超过5万枚</p>\r\n', '<p>\r\n	对应每组数据输出拦截所有导弹最少要配备多少套这种导弹拦截系统.</p>\r\n', '8 389 207 155 300 299 170 158 65\r\n', '2\r\n', '<br />\r\n', 0, 0, '2010-10-27 18:33:18', '2010-10-28 08:49:20'),
(376, 1, '最大乘积组合问题', 200, 33554432, 0000000000, 0000000000, '<p>\r\n	<font size="4">给定一个长度为N的整数数组，只允许用乘法，不能用除法，计算任意（N-1）个数的组合中乘积最大的一组。</font></p>\r\n', '', '<p>\r\n	文件有多个case</p>\r\n<p>\r\n	每行的第一个数是N 后面跟着n个整数 N&lt;=50000</p>\r\n', '<p>\r\n	每行输出最大乘积 结果的绝对值&lt;=2^63</p>\r\n', '2 1 2\r\n3 1 2 3\r\n2 -1 -2', '2\r\n6\r\n-1\r\n', '', 0, 0, '2010-10-27 20:15:32', '2010-10-27 20:21:33'),
(378, 1, '判断点相对多边形的位置', 1000, 33554432, 0000000000, 0000000000, '<p>\r\n	请判断一些点和某个多边形的相对位置</p>\r\n<p>\r\n	如果点在多边形里面输出1 在外面 输出-1 在边上 输出0</p>', '', '<p>\r\n	输入有多个测试</p>\r\n<p>\r\n	每个测试的第一行是两个空格分隔的整数 n m</p>\r\n<p>\r\n	n是多边形的边数,m为要测的点数</p>\r\n<p>\r\n	接下来n行为逆时针方向排列的多边形的n个顶点的x y坐标</p>\r\n<p>\r\n	接下来m行为要测试的m个点的x y坐标</p>\r\n<p>\r\n	n&lt;300</p>\r\n', '<p>\r\n	每行输出-1 0 或者 1</p>', '3 3\r\n0 0\r\n1.2 1.2\r\n0 1.2\r\n0 0\r\n-1 -1\r\n0.1 1.1\r\n4 2\r\n0 0\r\n1 0\r\n1 1\r\n0 1\r\n0.5 0.5\r\n-3 -2\r\n', '0\r\n-1\r\n1\r\n1\r\n-1\r\n\r\n', '<br />\r\n', 0, 0, '2010-11-10 23:03:43', '2010-11-11 07:55:31'),
(379, 1, 'Sweet Butter (香甜的黄油 )', 1000, 33554432, 0000000000, 0000000000, '<p>\r\n	农夫John发现做出全威斯康辛州最甜的黄油的方法：糖。把糖放在一片牧场上，他知道N（1&lt;=N&lt;=500）只奶牛会过来舔它，这样就能做出能卖好价钱的超甜黄油。当然，他将付出额外的费用在奶牛上。</p>\r\n<p>\r\n	农夫John很狡猾。像以前的巴甫洛夫，他知道他可以训练这些奶牛，让它们在听到铃声时去一个特定的牧场。他打算将糖放在那里然后下午发出铃声，以至他可以在晚上挤奶。</p>\r\n<p>\r\n	农夫John知道每只奶牛都在各自喜欢的牧场（一个牧场不一定只有一头牛）。给出各头牛在的牧场和牧场间的路线，找出使所有牛到达的路程和最短的牧场（他将把糖放在那）。</p>\r\n', 'USACO', '<p>\r\n	第一行: 三个数：奶牛数N，牧场数P（2&lt;=P&lt;=800），牧场间道路数C(1&lt;=C&lt;=1450).</p>\r\n<p>\r\n	第二行到第N+1行: 1到N头奶牛所在的牧场号.</p>\r\n<p>\r\n	第N+2行到第N+C+1行： 每行有三个数：相连的牧场A、B，两牧场间距（1&lt;=D&lt;=255），当然,连接是双向的.</p>\r\n<pre>\r\nP2  \r\nP1 @--1--@ C1\r\n    \\    |\\\r\n     \\   | \\\r\n      5  7  3\r\n       \\ |   \\\r\n        \\|    \\ C3\r\n      C2 @--5--@\r\n         P3    P4\r\n</pre>', '<p>\r\n	一行 输出奶牛必须行走的最小的距离和.</p>\r\n', '3 4 5\r\n2\r\n3\r\n4\r\n1 2 1\r\n1 3 5\r\n2 3 7\r\n2 4 3\r\n3 4 5\r\n', '8\r\n', '', 0, 0, '2010-11-23 22:58:53', '2010-11-23 22:58:53'),
(380, 1, 'Minimum Transport Cost', 1000, 33554432, 0000000000, 0000000000, '<p>\r\n	These are N cities in Spring country. Between each pair of cities there may be one transportation track or none. Now there is some cargo that should be delivered from one city to another. The transportation fee consists of two parts:<br />\r\n	The cost of the transportation on the path between these cities, and<br />\r\n	<br />\r\n	a certain tax which will be charged whenever any cargo passing through one city, except for the source and the destination cities.<br />\r\n	<br />\r\n	You must write a program to find the route which has the minimum cost.</p>\r\n', 'hdu 1385', '<p>\r\n	First is N, number of cities. N = 0 indicates the end of input.<br />\r\n	<br />\r\n	The data of path cost, city tax, source and destination cities are given in the input, which is of the form:<br />\r\n	<br />\r\n	a11 a12 ... a1N<br />\r\n	a21 a22 ... a2N<br />\r\n	...............<br />\r\n	aN1 aN2 ... aNN<br />\r\n	b1 b2 ... bN<br />\r\n	<br />\r\n	c d<br />\r\n	e f<br />\r\n	...<br />\r\n	g h<br />\r\n	<br />\r\n	where aij is the transport cost from city i to city j, aij = -1 indicates there is no direct path between city i and city j. bi represents the tax of passing through city i. And the cargo is to be delivered from city c to city d, city e to city f, ..., and g = h = -1. You must output the sequence of cities passed by and the total cost which is of the form:</p>\r\n', '<p>\r\n	From c to d :<br />\r\n	Path: c--&gt;c1--&gt;......--&gt;ck--&gt;d<br />\r\n	Total cost : ......<br />\r\n	......<br />\r\n	<br />\r\n	From e to f :<br />\r\n	Path: e--&gt;e1--&gt;..........--&gt;ek--&gt;f<br />\r\n	Total cost : ......<br />\r\n	<br />\r\n	Note: if there are more minimal paths, output the lexically smallest one. Print a blank line after each test case.</p>\r\n', '5\r\n0 3 22 -1 4\r\n3 0 5 -1 -1\r\n22 5 0 9 20\r\n-1 -1 9 0 4\r\n4 -1 20 4 0\r\n5 17 8 3 1\r\n1 3\r\n3 5\r\n2 4\r\n-1 -1\r\n0\r\n', 'From 1 to 3 :\r\nPath: 1-->5-->4-->3\r\nTotal cost : 21\r\n\r\nFrom 3 to 5 :\r\nPath: 3-->4-->5\r\nTotal cost : 16\r\n\r\nFrom 2 to 4 :\r\nPath: 2-->1-->5-->4\r\nTotal cost : 17\r\n', '<p>\r\n	http://acm.split.hdu.edu.cn/forum/read.php?tid=9754</p>\r\n', 0, 0, '2010-11-23 23:07:33', '2010-11-23 23:07:33'),
(381, 1, 'Dizzy Cows(此题需要special judge，加题中)', 1000, 33554432, 0000000000, 0000000000, '<p>\r\n	<font class="Apple-style-span" face="monospace">The cows have taken to racing each other around the farm but they get very dizzy when running in circles, and everyone knows that dizzy cows don&#39;t produce any milk. Farmer John wants to convert all of the two-way cow paths in the farm to one-way paths in order to eliminate any &#39;cycles&#39; and prevent the cows from getting dizzy. A &#39;cycle&#39; enables a cow to traverse one or more cow paths and arrive back at her starting point, thus completing a loop or circle.<br style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; " />\r\n	<br style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; " />\r\n	The farm comprises N pastures (1 &lt;= N &lt;= 100,000) conveniently numbered 1..N. M1 (1 &lt;= M1 &lt;= 100,000) one-way cow paths and M2 two-way cow paths (1 &lt;= M2 &lt;= 100,000) connect the pastures. No path directly connects a pasture to itself, although multiple paths might connect two different pastures. A cow may or may not be able to travel between any two given pastures by following a sequence of cow paths.&nbsp;<br style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; " />\r\n	<br style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; " />\r\n	Your job is to assign a direction to the two-way cow paths such that the entire farm (ultimately with only one-way paths) has no cycles. That is, there should be no sequence of one-way cow paths which leads back to its starting position. The existing one-way cow paths do not form a cycle and should be left as they are.<br style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; " />\r\n	<br style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; " />\r\n	One-way cow paths run from pasture A_i (1 &lt;= A_i &lt;= N) to pasture B_i (1 &lt;= B_i &lt;= N). Two-way cow paths connect pastures X_i (1 &lt;= X_i &lt;= N) and Y_i (1 &lt;= Y_i &lt;= N).<br style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; " />\r\n	<br style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; " />\r\n	Consider this example:</font></p>\r\n<pre style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; ">\r\n1--&gt;2\r\n|  /|\r\n| / |\r\n|/  |\r\n3&lt;--4\r\n</pre>\r\n<p>\r\n	<font class="Apple-style-span" face="monospace">The cow paths between pastures 1 and 3, 2 and 3, and 2 and 4 are two-way paths. One-way paths connect 1 to 2 and also 4 to 3. One valid way to convert the two-way paths into one-way paths in such a way that there are no cycles would be to direct them from 1 to 3, from 2 to 3, and from 3 to 4:</font></p>\r\n<pre style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; ">\r\n1--&gt;2\r\n|  /|\r\n| / |\r\nvL  v\r\n3&lt;--4</pre>\r\n', 'USACO DEC09', '<p>\r\n	<font class="Apple-style-span" face="monospace">* Line 1: Three space separated integers: N, M1, and M2<br style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; " />\r\n	<br style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; " />\r\n	* Lines 2..1+M1: Line i+1 describes a one-way cow path using two space separated integers: A_i and B_i<br style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; " />\r\n	<br style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; " />\r\n	* Lines 2+M1..1+M1+M2: Line i+M1+1 describes a two-way cow path using two space separated integers: X_i and Y_i</font></p>\r\n', '<p>\r\n	<font class="Apple-style-span" face="monospace">* Lines 1..<i>M2</i>: Line&nbsp;<i>i</i>&nbsp;should contain two space-separated integers: either&nbsp;<i>X<sub>i</sub></i>&nbsp;and&nbsp;<i>Y<sub>i</sub></i>&nbsp;or&nbsp;<i>Y<sub>i</sub></i>&nbsp;and&nbsp;<i>X<sub>i</sub></i>, depending on the direction assigned to the&nbsp;<i>i</i>-th two-way path. The two-way paths must appear in the same order in the output as they do in the input. If there is no solution, output &quot;-1&quot; on a single line.</font></p>\r\n', '4 2 3\r\n1 2\r\n4 3\r\n1 3\r\n4 2\r\n3 2\r\n\r\n', '1 3\r\n2 4\r\n2 3\r\n', '', 0, 0, '2010-11-23 23:26:07', '2010-12-04 11:24:30'),
(382, 6, 'Silver Cow Party', 2000, 67108864, 0000000000, 0000000000, '<p>\r\n	<span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">One cow from each of&nbsp;<i>N&nbsp;</i>&nbsp;farms (1 &le;&nbsp;<i>N</i>&nbsp;&le; 1000) conveniently numbered 1..<i>N</i>&nbsp;is going to attend the big cow party to be held at farm #<i>X</i>&nbsp;(1 &le;&nbsp;<i>X</i>&nbsp;&le;&nbsp;<i>N</i>). A total of&nbsp;<i>M</i>&nbsp;(1 &le;&nbsp;<i>M</i>&nbsp;&le; 100,000) unidirectional (one-way roads connects pairs of farms; road&nbsp;<i>i</i>&nbsp;requires&nbsp;<i>T<sub>i</sub></i>&nbsp;(1 &le;&nbsp;<i>T<sub>i</sub></i>&nbsp;&le; 100) units of time to traverse.</span></p>\r\n<p style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">\r\n	Each cow must walk to the party and, when the party is over, return to her farm. Each cow is lazy and thus picks an optimal route with the shortest time. A cow&#39;s return route might be different from her original route to the party since roads are one-way.</p>\r\n<p style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">\r\n	Of all the cows, what is the longest amount of time a cow must spend walking to the party and back?</p>\r\n', 'USACO 2007 February Silver', '<p>\r\n	<font class="Apple-style-span" face="''Times New Roman'', Times, serif" size="3"><span class="Apple-style-span" style="-webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px;"><span class="Apple-style-span" style="font-size: 16px; ">Line 1: Three space-separated integers, respectively:</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">&nbsp;</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; "><i>N</i></span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">,</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">&nbsp;</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; "><i>M</i></span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">, and</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">&nbsp;</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; "><i>X</i></span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">&nbsp;</span><br />\r\n	<span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">Lines 2..</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; "><i>M</i></span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">+1: Line</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">&nbsp;</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; "><i>i</i></span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">+1 describes road</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">&nbsp;</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; "><i>i</i></span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">&nbsp;</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">with three space-separated integers:</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">&nbsp;</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; "><i>A<sub>i</sub></i></span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">,</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">&nbsp;</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; "><i>B<sub>i</sub></i></span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">, and</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">&nbsp;</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; "><i>T<sub>i</sub></i></span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">. The described road runs from farm</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">&nbsp;</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; "><i>A<sub>i</sub></i></span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">&nbsp;</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">to farm</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">&nbsp;</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; "><i>B<sub>i</sub></i></span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">, requiring</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">&nbsp;</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; "><i>T<sub>i</sub></i></span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">&nbsp;</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">time units to traverse.</span></span></font></p>\r\n', '<p>\r\n	<font class="Apple-style-span" face="''Times New Roman'', Times, serif" size="3"><span class="Apple-style-span" style="-webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px;"><span class="Apple-style-span" style="font-size: 16px; ">Line 1: One integer: the maximum of time any one cow must walk.</span></span></font></p>\r\n', '4 8 2\r\n1 2 4\r\n1 3 2\r\n1 4 7\r\n2 1 1\r\n2 3 5\r\n3 1 2\r\n3 4 4\r\n4 2 3\r\n', '10', '<p>\r\n	Cow 4 proceeds directly to the party (3 units) and returns via farms 1 and 3 (7 units), for a total of 10 time units.</p>\r\n', 0, 0, '2010-12-04 15:20:55', '2010-12-04 16:17:52'),
(383, 6, 'The Cow Lexicon', 2000, 67108864, 0000000000, 0000000000, '<p>\r\n	<span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">Few know that the cows have their own dictionary with&nbsp;<i>W</i>&nbsp;(1 &le;&nbsp;<i>W</i>&nbsp;&le; 600) words, each containing no more 25 of the characters &#39;a&#39;..&#39;z&#39;. Their cowmunication system, based on mooing, is not very accurate; sometimes they hear words that do not make any sense. For instance, Bessie once received a message that said &quot;browndcodw&quot;. As it turns out, the intended message was &quot;browncow&quot; and the two letter &quot;d&quot;s were noise from other parts of the barnyard.</span></p>\r\n<p style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">\r\n	The cows want you to help them decipher a received message (also containing only characters in the range &#39;a&#39;..&#39;z&#39;) of length&nbsp;<i>L</i>&nbsp;(2 &le;&nbsp;<i>L</i>&nbsp;&le; 300) characters that is a bit garbled. In particular, they know that the message has some extra letters, and they want you to determine the smallest number of letters that must be removed to make the message a sequence of words from the dictionary.</p>\r\n', 'USACO 2007 February Silver', '<p>\r\n	<span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">Line 1: Two space-separated integers, respectively:</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">&nbsp;</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; "><i>W</i></span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">&nbsp;</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">and</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">&nbsp;</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; "><i>L</i></span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">&nbsp;</span><br />\r\n	<span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">Line 2:</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">&nbsp;</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; "><i>L</i></span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">&nbsp;</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">characters (followed by a newline, of course): the received message</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">&nbsp;</span><br />\r\n	<span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">Lines 3..</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; "><i>W</i></span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">+2: The cows&#39; dictionary, one word per line</span></p>\r\n', '<p>\r\n	<span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">Line 1: a single integer that is the smallest number of characters that need to be removed to make the message a sequence of dictionary words.</span></p>\r\n', '6 10\r\nbrowndcodw\r\ncow\r\nmilk\r\nwhite\r\nblack\r\nbrown\r\nfarmer\r\n', '2', '', 0, 0, '2010-12-04 15:21:08', '2010-12-04 16:16:53'),
(384, 6, 'Silver Lilypad Pond', 1000, 67108864, 0000000000, 0000000000, '<p>\r\n	FJ has installed a beautiful pond for his cows&#39; esthetic enjoyment and exercise. The rectangular pond has been partitioned into square cells of&nbsp;<i>M</i>&nbsp;rows and&nbsp;<i>N</i>&nbsp;columns (1 &le;&nbsp;<i>M</i>&nbsp;&le; 30; 1 &le;&nbsp;<i>N</i>&nbsp;&le; 30). Some of the cells have astonishingly sturdy lilypads; others have rocks; the remainder are just beautiful, cool, blue water.</p>\r\n<p>\r\n	Bessie is practicing her ballet moves by jumping from one lilypad to another and is currently located at one of the lilypads. She wants to travel to another lilypad in the pond by jumping from one lilypad to another.</p>\r\n<p>\r\n	Surprising only to the uninitiated, Bessie&#39;s jumps between lilypads always appear as a chess-knight&#39;s move: one move in one direction and then two more in the orthogonal direction (or perhaps two in one direction and then one in the orthogonal direction).</p>\r\n<p>\r\n	Farmer John is observing Bessie&#39;s ballet drill and realizes that sometimes she might not be able to jump to her destination lilypad because intermediary lilypads are missing.</p>\r\n<p>\r\n	Ever thrifty, he wants to place a minimum of additional lilypads so she can complete her quest (perhaps quickly; perhaps by using a large number of intermediate lilypads). Of course, lilypads cannot be placed where rocks are present.</p>\r\n<p>\r\n	Help Farmer John determine the minimum number of additional lilypads he has to place. Also determine the minimum number of jumps required to reach the destination when placing that minimum number of additional lilypads in some optimal location. Finally, determine the total number of unique ways Bessie can jump from the start to the end in the minimum number of jumps (after the smallest number of lily pads is placed in locations as needed, of course). The final number includes jumps using any of the possible ways the new lilypads are placed!</p>\r\n', 'USACO 2007 January Silver ', '<p>\r\n	<font class="Apple-style-span" face="''Times New Roman'', Times, serif" size="3"><span class="Apple-style-span" style="-webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px;">* Line 1: Two space-separated integers:&nbsp;<i>M</i>&nbsp;and&nbsp;<i>N</i></span></font></p>\r\n<p>\r\n	<font class="Apple-style-span" face="''Times New Roman'', Times, serif" size="3"><span class="Apple-style-span" style="-webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px;">* Lines 2..<i>M</i>&nbsp;+ 1: Line&nbsp;<i>i</i>&nbsp;+ 1 describes row&nbsp;<i>i</i>&nbsp;of the pond using&nbsp;<i>N</i>&nbsp;space-separated integers with these values: 0 indicates empty water; 1 indicates a lilypad in place; 2 indicates rock in place; 3 indicates the lilypad Bessie starts on; 4 indicates the lilypad Bessie wants to travel to.</span></font></p>\r\n', '<p>\r\n	<font class="Apple-style-span" face="''Times New Roman'', Times, serif" size="3"><span class="Apple-style-span" style="-webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px;">* Line 1: One integer: the minimum number of additional lilypads required. If it is not possible to help Bessie jump to her destination, print -1.</span></font></p>\r\n<p>\r\n	<font class="Apple-style-span" face="''Times New Roman'', Times, serif" size="3"><span class="Apple-style-span" style="-webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px;">* Line 2: One integer: the minimum number of jumps Bessie must make when placing the minimum number of additional lilypads. Do not output this line if line 1 contains -1.</span></font></p>\r\n<p>\r\n	<font class="Apple-style-span" face="''Times New Roman'', Times, serif" size="3"><span class="Apple-style-span" style="-webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px;">* Line 3: One integer: the number of paths from start to end that uses the minimum number of additional pads and the minimum number of jumps calculated in line 2. Do not output this line if line 1 contains -1.</span></font></p>\r\n', '4 8\r\n0 0 0 1 0 0 0 0\r\n0 0 0 0 0 2 0 1\r\n0 0 0 0 0 4 0 0\r\n3 0 0 0 0 0 1 0', '2\r\n6\r\n2\r\n', '<p>\r\n	<span class="Apple-style-span" style="font-family: monospace; font-size: medium; font-weight: bold; white-space: pre; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">Input Details</span></p>\r\n<p>\r\n	<font class="Apple-style-span" face="monospace" size="3"><span class="Apple-style-span" style="white-space: pre; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px;">The ponds has 4 rows and 8 columns. Bessie is at row 4 column 1, and she wants to reach row 3 column 6. A rock and five lilypads are present.</span></font></p>\r\n<p>\r\n	<span class="Apple-style-span" style="font-family: monospace; font-size: medium; font-weight: bold; white-space: pre; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">Output Details</span></p>\r\n<p>\r\n	<font class="Apple-style-span" face="monospace" size="3"><span class="Apple-style-span" style="white-space: pre; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px;">Two lilypads are required as shown by the x&#39;s in each of the two instances below:</span></font></p>\r\n<pre>\r\n<span class="Apple-style-span" style="white-space: pre; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px;"><tt>    0 0 0 1 0 0 0 0     0 0 0 1 0 0 0 0\r\n    0 x 0 0 0 2 0 1     0 0 0 0 0 2 0 1\r\n    0 0 0 0 x 4 0 0     0 0 x 0 x 4 0 0\r\n    3 0 0 0 0 0 1 0     3 0 0 0 0 0 1 0\r\n</tt></span></pre>\r\n<p>\r\n	<font class="Apple-style-span" face="monospace" size="3"><span class="Apple-style-span" style="white-space: pre; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px;">Bessie must make at least 6 jumps to reach destination and there are two different paths of 6 jumps as shown below.</span></font></p>\r\n<pre>\r\n<span class="Apple-style-span" style="white-space: pre; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px;"><tt>    0 0 0 C 0 0 0 0     0 0 0 C 0 0 0 0\r\n    0 B 0 0 0 2 0 F     0 0 0 0 0 2 0 F\r\n    0 0 0 0 D G 0 0     0 0 B 0 D G 0 0\r\n    A 0 0 0 0 0 E 0     A 0 0 0 0 0 E 0</tt></span></pre>\r\n', 0, 0, '2010-12-04 18:04:35', '2010-12-05 10:53:20'),
(399, 6, 'Parity', 2000, 16777216, 0000000000, 0000000000, '<p>\r\n	Now and then you play the following game with your friend. Your friend writes down a sequence consisting of zeroes and ones. You choose a continuous subsequence (for example the subsequence from the third to the fifth digit inclusively) and ask him, whether this subsequence contains even or odd number of ones. Your friend answers your question and you can ask him about another subsequence and so on.&nbsp;</p>\r\n<p>\r\n	&nbsp;</p>\r\n<p>\r\n	Your task is to guess the entire sequence of numbers. You suspect some of your friend&#39;s answers may not be correct and you want to convict him of falsehood. Thus you have decided to write a program to help you in this matter. The program will receive a series of your questions together with the answers you have received from your friend. The aim of this program is to find the first answer which is provably wrong, i.e. that there exists a sequence satisfying answers to all the previous questions, but no such sequence satisfies this answer.&nbsp;</p>\r\n', 'URAL 1003', '<p>\r\n	Input contains a series of tests. The first line of each test contains one number, which is the length of the sequence of zeroes and ones. This length is less or equal to 1000000000. In the second line, there is one positive integer which is the number of questions asked and answers to them. The number of questions and answers is less or equal to 5000. The remaining lines specify questions and answers. Each line contains one question and the answer to this question: two integers (the position of the first and last digit in the chosen subsequence) and one word which is either `even&#39; or `odd&#39; (the answer, i.e. the parity of the number of ones in the chosen subsequence, where `even&#39; means an even number of ones and `odd&#39; means an odd number). The file is ended with a line containing -1.&nbsp;</p>\r\n', '<p>\r\n	Each line of output containing one integer X. Number X says that there exists a sequence of zeroes and ones satisfying first X parity conditions, but there exists none satisfying X+1 conditions. If there exists a sequence of zeroes and ones satisfying all the given conditions, then number X should be the number of all the questions asked.</p>\r\n', '10\r\n5\r\n1 2 even\r\n3 4 odd\r\n5 6 even\r\n1 6 even\r\n7 10 odd\r\n-1\r\n', '3\r\n', '', 0, 0, '2010-12-06 18:00:25', '2010-12-06 18:07:34');
INSERT INTO `tbl_problems` (`id`, `user_id`, `title`, `time_limit`, `memory_limit`, `submission_no`, `accepted_no`, `description`, `source`, `input`, `output`, `input_sample`, `output_sample`, `hint`, `flag`, `visibility`, `created`, `modified`) VALUES
(400, 6, 'Sightseeing trip ', 2000, 16777216, 0000000000, 0000000000, '<p>\r\n	There is a travel agency in Adelton town on Zanzibar island. It has decided to offer its clients, besides many other attractions, sightseeing the town. To earn as much as possible from this attraction, the agency has accepted a shrewd decision: it is necessary to find the shortest route which begins and ends at the same place.</p>\r\n<p>\r\n	Your task is to write a program which finds such a route. In the town there are N crossing points numbered from 1 to N and M two-way roads numbered from 1 to M. Two crossing points can be connected by multiple roads, but no road connects a crossing point with itself. Each sightseeing route is a sequence of road numbers y_1, ..., y_k, k&gt;2. The road y_i (1&lt;=i&lt;=k-1) connects crossing points x_i and x_{i+1}, the road y_k connects crossing points x_k and x_1. All the numbers x_1,...,x_k should be different. The length of the sightseeing route is the sum of the lengths of all roads on the sightseeing route, i.e. L(y_1)+L(y_2)+...+L(y_k) where L(y_i) is the length of the road y_i (1&lt;=i&lt;=k). Your program has to find such a sightseeing route, the length of which is minimal, or to specify that it is not possible, because there is no sightseeing route in the town.</p>\r\n', 'URAL 1004', '<p>\r\n	Input contains a series of tests. The first line of each test contains two positive integers: the number of crossing points N&lt;=100 and the number of roads M&lt;=10000. Each of the next M lines describes one road. It contains 3 positive integers: the number of its first crossing point, the number of the second one, and the length of the road (a positive integer less than 500). Input is ended with a &#39;-1&#39; line.</p>\r\n', '<p>\r\n	Each line of output is an answer. It contains either a string `No solution.&#39; in case there isn&#39;t any sightseeing route, or it contains the numbers of all crossing points on the shortest sightseeing route in the order how to pass them (i.e. the numbers x_1 to x_k from our definition of a sightseeing route), separated by single spaces. If there are multiple sightseeing routes of the minimal length, you can output any one of them.</p>\r\n', '5 7\r\n1 4 1\r\n1 3 300\r\n3 1 10\r\n1 2 16\r\n2 3 100\r\n2 5 15\r\n5 3 20\r\n4 3\r\n1 2 10\r\n1 3 20\r\n1 4 30\r\n-1\r\n', '1 3 5 2\r\nNo solution', '', 0, 0, '2010-12-06 18:00:36', '2010-12-06 20:45:45'),
(401, 6, 'Phone Numbers', 2000, 16777216, 0000000000, 0000000000, '<p>\r\n	In the present world you frequently meet a lot of call numbers and they are going to be longer and longer. You need to remember such a kind of numbers. One method to do it in an easy way is to assign letters to digits as shown in the following picture:&nbsp;</p>\r\n<p>\r\n	&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 ij &nbsp; 2 abc &nbsp;3 def</p>\r\n<p>\r\n	&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 4 gh &nbsp;5 kl &nbsp; &nbsp;6 mn</p>\r\n<p>\r\n	&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 7 prs&nbsp;&nbsp;8 tuv 9 wxy</p>\r\n<p>\r\n	&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 oqz</p>\r\n<p>\r\n	This way every word or a group of words can be assigned a unique number, so you can remember words instead of call numbers. It is evident that it has its own charm if it is possible to find some simple relationship between the word and the person itself. So you can learn that the call number 941837296 of a chess playing friend of yours can be read as WHITEPAWN, and the call number 2855304 of your favourite teacher is read BULLDOG.</p>\r\n<p>\r\n	&nbsp;</p>\r\n<p>\r\n	Write a program to find the shortest sequence of words (i.e. one having the smallest possible number of words) which corresponds to a given number and a given list of words. The correspondence is described by the picture above. &nbsp;</p>\r\n', 'URAL 1002', '<p>\r\n	Input contains a series of tests. The first line of each test contains the call number, the transcription of which you have to find. The number consists of at most 100 digits. The second line contains the total number of the words in the dictionary (maximum is 50000). Each of the remaining lines contains one word, which consists of maximally 50 small letters of the English alphabet. The total size of the input file doesn&#39;t exceed 300KB. The last line of input file contains call number -1.</p>\r\n', '<p>\r\n	&nbsp;</p>\r\n<p>\r\n	Each line of output contains the shortest sequence of words which has been found by your program. The words are separated by single spaces. If there is no solution to the input data, the line contains text `No solution.&#39;. If there are more solutions having the minimum number of words, you can choose any single one of them.&nbsp;</p>\r\n', '7325189087\r\n5\r\nit\r\nyour\r\nreality\r\nreal\r\nour\r\n4294967296\r\n5\r\nit\r\nyour\r\nreality\r\nreal\r\nour\r\n-1\r\n', 'reality our\r\nNo solution.\r\n', '', 0, 0, '2010-12-06 18:00:51', '2010-12-06 21:12:58'),
(385, 6, 'Problem Solving', 2000, 67108864, 0000000000, 0000000000, '<p>\r\n	<span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">In easier times, Farmer John&#39;s cows had no problems. These days, though, they have problems, lots of problems; they have&nbsp;<i>P</i>&nbsp;(1 &le;&nbsp;<i>P</i>&nbsp;&le; 300) problems, to be exact. They have quit providing milk and have taken regular jobs like all other good citizens. In fact, on a normal month they make&nbsp;<i>M</i>&nbsp;(1 &le;&nbsp;<i>M</i>&nbsp;&le; 1000) money.</span></p>\r\n<p style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">\r\n	Their problems, however, are so complex they must hire consultants to solve them. Consultants are not free, but they are competent: consultants can solve any problem in a single month. Each consultant demands two payments: one in advance (1 &le;&nbsp;<i>payment</i>&nbsp;&le;&nbsp;<i>M</i>) to be paid at the start of the month problem-solving is commenced and one more payment at the start of the month after the problem is solved (1 &le;&nbsp;<i>payment</i>&nbsp;&le;&nbsp;<i>M</i>). Thus, each month the cows can spend the money earned during the previous month to pay for consultants. Cows are spendthrifts: they can never save any money from month-to-month; money not used is wasted on cow candy.</p>\r\n<p style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">\r\n	Since the problems to be solved depend on each other, they must be solved mostly in order. For example, problem 3 must be solved before problem 4 or during the same month as problem 4.</p>\r\n<p style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">\r\n	Determine the number of months it takes to solve all of the cows&#39; problems and pay for the solutions.</p>\r\n', 'USACO 2007 January Gold', '<p>\r\n	<span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">Line 1: Two space-separated integers:</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">&nbsp;</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; "><i>M</i></span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">&nbsp;</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">and</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">&nbsp;</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; "><i>P</i></span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">.</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">&nbsp;</span><br />\r\n	<span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">Lines 2..</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; "><i>P</i></span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">+1: Line</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">&nbsp;</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; "><i>i</i></span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">+1 describes problem</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">&nbsp;</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; "><i>i</i></span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">&nbsp;</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">with two space-separated integers:</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">&nbsp;</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; "><i>B<sub>i</sub></i></span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">&nbsp;</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">and</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">&nbsp;</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; "><i>A<sub>i</sub></i></span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">.</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">&nbsp;</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; "><i>B<sub>i</sub></i></span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">&nbsp;</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">is the payment to the consult BEFORE the problem is solved;</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">&nbsp;</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; "><i>A<sub>i</sub></i></span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">&nbsp;</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">is the payment to the consult AFTER the problem is solved.</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">&nbsp;</span></p>\r\n', '<p>\r\n	<span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">Line 1: The number of months it takes to solve and pay for all the cows&#39; problems.</span></p>\r\n', '100 5\r\n40 20\r\n60 20\r\n30 50\r\n30 50\r\n40 40\r\n', '6\r\n', '<p>\r\n	<span class="Apple-style-span" style="font-family: monospace; font-size: 16px; white-space: pre; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">+------+-------+--------+---------+---------+--------+</span><br />\r\n	<span class="Apple-style-span" style="font-family: monospace; font-size: 16px; white-space: pre; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Avail | Probs&nbsp; | Before&nbsp; | After&nbsp;&nbsp; | Candy&nbsp; |</span><br />\r\n	<span class="Apple-style-span" style="font-family: monospace; font-size: 16px; white-space: pre; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">|Month | Money | Solved | Payment | Payment | Money&nbsp; |</span><br />\r\n	<span class="Apple-style-span" style="font-family: monospace; font-size: 16px; white-space: pre; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">+------+-------+--------+---------+---------+--------+</span><br />\r\n	<span class="Apple-style-span" style="font-family: monospace; font-size: 16px; white-space: pre; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">| 1&nbsp;&nbsp;&nbsp; | 0&nbsp;&nbsp;&nbsp;&nbsp; | -none- | 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span><br />\r\n	<span class="Apple-style-span" style="font-family: monospace; font-size: 16px; white-space: pre; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">| 2&nbsp;&nbsp;&nbsp; | 100&nbsp;&nbsp; | 1, 2&nbsp;&nbsp; | 40+60&nbsp;&nbsp; | 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span><br />\r\n	<span class="Apple-style-span" style="font-family: monospace; font-size: 16px; white-space: pre; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">| 3&nbsp;&nbsp;&nbsp; | 100&nbsp;&nbsp; | 3, 4&nbsp;&nbsp; | 30+30&nbsp;&nbsp; | 20+20&nbsp;&nbsp; | 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span><br />\r\n	<span class="Apple-style-span" style="font-family: monospace; font-size: 16px; white-space: pre; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">| 4&nbsp;&nbsp;&nbsp; | 100&nbsp;&nbsp; | -none- | 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 50+50&nbsp;&nbsp; | 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span><br />\r\n	<span class="Apple-style-span" style="font-family: monospace; font-size: 16px; white-space: pre; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">| 5&nbsp;&nbsp;&nbsp; | 100&nbsp;&nbsp; | 5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 40&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 60&nbsp;&nbsp;&nbsp;&nbsp; |</span><br />\r\n	<span class="Apple-style-span" style="font-family: monospace; font-size: 16px; white-space: pre; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">| 6&nbsp;&nbsp;&nbsp; | 100&nbsp;&nbsp; | -none- | 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 40&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 60&nbsp;&nbsp;&nbsp;&nbsp; | </span><br />\r\n	<span class="Apple-style-span" style="font-family: monospace; font-size: 16px; white-space: pre; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">+------+-------+--------+---------+---------+--------+</span></p>\r\n', 0, 0, '2010-12-04 18:04:50', '2010-12-04 18:04:50'),
(386, 6, 'Cow Yahtzee', 1000, 67108864, 0000000000, 0000000000, '<p>\r\n	In their usual clumsy way, the cows are play a version of Yahtzee, the dice-rolling game. They roll&nbsp;<i>N</i>&nbsp;(1 &le;&nbsp;<i>N</i>&nbsp;&le; 20) dice, each having&nbsp;<i>S</i>&nbsp;(1 &le;&nbsp;<i>S</i>&nbsp;&le; 8) sides. They are curious as to the number of ways a dice roll can meet a particular criterion (like &quot;contains three 2&#39;s&quot; or &quot;contains one 2 and two 3&#39;s&quot;).</p>\r\n<p>\r\n	Help them learn about probability. Write a program that reads not only&nbsp;<i>N</i>&nbsp;and&nbsp;<i>S</i>&nbsp;but also some expressions that describe their criteria. Count the number ways the expression can be satisfied over the entire set of all possible dice rolls (the entire set of rolls for three two-sided dice is: {1,1,1; 1,1,2; 1,2,1; 1,2,2; 2,1,1; 2,1,2; 2,2,1; 2,2,2};</p>\r\n<p>\r\n	Expressions comprise combinations of a basic form that expresses the thought &quot;want at least&nbsp;<i>W</i>&nbsp;copies of result&nbsp;<i>R</i>&quot;. It looks like this:</p>\r\n<p>\r\n	WxR</p>\r\n<p>\r\n	where (0 &le;&nbsp;<i>W</i>&nbsp;&le;&nbsp;<i>N</i>&nbsp;and 1 &le;&nbsp;<i>R</i>&nbsp;&le;&nbsp;<i>S</i>). Each test run will supply&nbsp;<i>E</i>&nbsp;expressions (1 &le;&nbsp;<i>E</i>&nbsp;&le; 20), each of which contains a number 1..10 of the basic forms separated by a &#39;+&#39;, which means &#39;and&#39; (see below). The set of lines expresses the thought that is the &#39;inclusive or&#39; of each of the lines individually. Thus the pair of expressions shown below means &quot;at least three rolls of five OR both at least one roll of 3 and also at least two rolls of 4&quot;:</p>\r\n<p>\r\n	3x5&nbsp;<br />\r\n	1x3+2x4</p>\r\n<p>\r\n	Here are some of the combinations of four five-sided dice that satisfy the above expression: 5,5,5,1; 4,5,5,5; 3,4,4,2; 3,4,4,3; 3,4,4,5; 4,4,5,3.</p>\r\n<p>\r\n	Programming note: Be sure to verify that you can read in two integers from one line and a string from the next line. In some languages&#39; I/O schema, this is harder than it looks!</p>\r\n<p>\r\n	Also note that the total number of dice combinations will never exceed 1,512,768 in the supplied test data.</p>\r\n', 'USACO 2007 January Bronze', '<p>\r\n	* Line 1: Three space-separated integers:&nbsp;<i>N</i>,&nbsp;<i>S</i>, and&nbsp;<i>E</i></p>\r\n<p>\r\n	* Lines 2..<i>E</i>&nbsp;+ 1: Line&nbsp;<i>i</i>&nbsp;+ 1 describes expression&nbsp;<i>i</i>&nbsp;as above</p>\r\n', '<p>\r\n	<font class="Apple-style-span" face="''Times New Roman'', Times, serif" size="3"><span class="Apple-style-span" style="-webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px;">* Line 1: A single integer that is the number of ways the expression(s) can be satisfied by rolling the dice in all combinations.</span></font></p>\r\n', '4 5 2\r\n3x5\r\n1x3+2x4', '63', '<p>\r\n	<span class="Apple-style-span" style="font-size: 14px; font-weight: bold; ">Input Details</span></p>\r\n<p>\r\n	This is the encoding of the expression used as an example in the task text.</p>\r\n<p>\r\n	<span class="Apple-style-span" style="font-size: 14px; font-weight: bold; ">Output Details</span></p>\r\n<p>\r\n	63 rolls satisfy the expression.</p>\r\n', 0, 0, '2010-12-04 18:13:45', '2010-12-05 10:57:00'),
(398, 6, 'Robot Encryption', 1000, 33554432, 0000000000, 0000000000, '<p>\r\n	Due to suspicion of cheaters, one of the more paranoid problem setters has started encrypting all messages to the rest of the jury before sending them. He didn&#39;t use any standard encryption, however, as he believes those are all part of a giant conspiracy network trying to crush IDI Open from the inside.&nbsp;<br />\r\n	<br />\r\n	Instead, he based it on the fact that the cheaters are likely to be the worst programmers. The decryption requires some programming skill, and should<br />\r\n	therefore be safe.</p>\r\n<br />\r\n<center>\r\n	<img src="http://acm.hdu.edu.cn/data/images/con211-1011-1.jpg" style="border-top-style: none; border-right-style: none; border-bottom-style: none; border-left-style: none; border-width: initial; border-color: initial; " /></center>\r\n<br />\r\n<p>\r\n	Along with the encrypted message, he sent explanation of how to decrypt it. The only problem now is that not all jury members are able to implement the decryption. This is where we need your help.<br />\r\n	<br />\r\n	You need to help us decrypt these messages by writing a program that does the task. Decryption is performed by simulating a robots movement on a grid. The robot is initially placed in the north-west corner of the grid, facing south. The robot is a simple one, and only accepts three dierent commands:<br />\r\n	<br />\r\n	L turns the robot 90 angle to the left.<br />\r\n	<br />\r\n	R turns the robot 90 angle to the right.<br />\r\n	<br />\r\n	F moves the robot one square forward. If moving forward would cause the robot to fall of the grid, the robot instead makes a 180 angle turn without moving.<br />\r\n	<br />\r\n	Instructions to the robot is given in a series of commandsets. A commandset is a string of commands, with the possible addition of loops. A loop is given on the form &quot;(commandset)number&quot; where number is the number of times the commandset inside the parentheses should be run. Longer sequences of commands can be built up recursively in this fashion. More formally:<br />\r\n	<br />\r\n	commandset ::= instruction+<br />\r\n	<br />\r\n	instruction ::= command | loop<br />\r\n	<br />\r\n	loop ::= &quot;(&quot; commandset &quot;)&quot; number<br />\r\n	<br />\r\n	command ::= R | L | F<br />\r\n	<br />\r\n	number ::= 1 |2 | 3 | 4 | 5 | 6 | 7 | 8 | 9<br />\r\n	<br />\r\n	The decrypted text is the text string obtained by concatenating the characters on the grid positions the robot stands on after executing each commandline.</p>\r\n', 'IDI Open 2009', '<p>\r\n	The first line of input gives T, the number of test scenarios. Each scenario starts with a line containing W and H, separated by a single space, describing the dimensions of the grid. Then follows H lines, each consisting of W characters, making up the grid. After this comes a line containing N, the number of commandlines, followed by the N lines the robot will be executing.</p>\r\n', '<p>\r\n	One line per test scenario, containing the decrypted text.<br />\r\n	<br />\r\n	Notes and Constraints<br />\r\n	0 &lt; T &lt;= 100<br />\r\n	0 &lt; W &lt;= 50<br />\r\n	0 &lt; H &lt;= 50<br />\r\n	0 &lt; N &lt;= 20<br />\r\n	<br />\r\n	Commandlines will be no longer than 50 characters, and will follow the syntax given in the problem text.<br />\r\n	<br />\r\n	No character with ASCII value lower than 32 or higher than 126 will appear on the robots grid.</p>\r\n', '1\r\n6 7\r\n012345\r\n6789AB\r\nCDEFGH\r\nIJKLMN\r\nOPQRST\r\nUVWXYZ\r\n_! .,&\r\n12\r\nFFL(F)5\r\n(F)4\r\n(LF)2\r\n(L(R)6L)9\r\nRFRFFF\r\n(L(F)2)2\r\nLF\r\nFLFF\r\nFFFF\r\nLF\r\nFLFF\r\nL(F)4', 'HELLO WORLD!', '', 0, 0, '2010-12-06 17:42:04', '2010-12-06 17:42:04'),
(387, 6, 'Cow School', 2000, 67108864, 0000000000, 0000000000, '<p>\r\n	<span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">Bessy is going to school and doing well. She has taken&nbsp;<i>N</i>&nbsp;(1 &le;&nbsp;<i>N</i>&nbsp;&le; 5000 -- except one case where 1 &le;&nbsp;<i>N</i>&nbsp;&le; 50,000) tests and recorded the scores (<i>T<sub>i</sub></i>&nbsp;points out of&nbsp;<i>P<sub>i</sub></i>&nbsp;points for test&nbsp;<i>i</i>; 0 &le;&nbsp;<i>T<sub>i</sub></i>&nbsp;&le;&nbsp;<i>P<sub>i</sub></i>&nbsp;&lt; 40,000; 0 &lt;&nbsp;<i>P<sub>i</sub></i>) as this task&#39;s input.</span></p>\r\n<p style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">\r\n	Her teacher will drop the&nbsp;<i>D</i>&nbsp;tests with the lowest percentage (<sup><i>T<sub>i</sub></i></sup>&frasl;<sub><i>P<sub>i</sub></i></sub>) before calculating Bessie&#39;s final grade (which is the sum of the remaining test score points over the sum of the remaining total test points). Bessy is good at math and quickly realizes that this does not benefit her as much as it might.</p>\r\n<p style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">\r\n	To prove her point, Bessy wants to find all values of&nbsp;<i>D</i>&nbsp;for which she could have ended up with a higher grade by choosing to drop different tests than the teacher would have. Help her by finding and printing all values of&nbsp;<i>D</i>&nbsp;for which this is possible.</p>\r\n<p style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">\r\n	Bessy has noted that, amazingly, she has never scored the same percentage on two different tests.</p>\r\n', 'USACO 2007 January Gold', '<p>\r\n	<span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">Line 1: A single integer,&nbsp;<i>N</i>&nbsp;</span></p>\r\n<div class="ptx" lang="en-US" style="font-family: ''Times New Roman'', Times, serif; font-size: 12pt; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">\r\n	Lines 2..<i>N</i>+1: Line&nbsp;<i>i</i>+1 contains two space-separated integers:&nbsp;<i>T<sub>i</sub></i>&nbsp;and&nbsp;<i>P<sub>i</sub></i></div>\r\n', '<p>\r\n	<span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">Line 1: A single integer</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">&nbsp;</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; "><i>K</i></span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">&nbsp;</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">(0 &le;</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">&nbsp;</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; "><i>K</i></span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">&nbsp;</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">&le;</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">&nbsp;</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; "><i>N</i></span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">) that is the number of values of</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">&nbsp;</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; "><i>D</i></span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">&nbsp;</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">for which Bessy could have ended up with a higher grade by dropping a different set of</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">&nbsp;</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; "><i>D</i></span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">&nbsp;</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">tests than the teacher.</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">&nbsp;</span><br />\r\n	<span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">Lines 2..</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; "><i>K</i></span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">+1: The values of</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">&nbsp;</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; "><i>D</i></span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">&nbsp;</span><span class="Apple-style-span" style="font-family: ''Times New Roman'', Times, serif; font-size: 16px; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px; ">for which this is true, in ascending numerical order.</span></p>\r\n', '5\r\n1 2\r\n5 9\r\n3 8\r\n4 10\r\n1 3\r\n', '2\r\n1\r\n2\r\n', '', 0, 0, '2010-12-04 18:13:53', '2010-12-06 20:50:36'),
(388, 6, 'Letter Cookies', 1000, 33554432, 0000000000, 0000000000, '<p>\r\n	<span class="Apple-style-span" style="font-family: ''Times New Roman''; font-size: 14px; ">Satre has finally decided to put their famous Letter Cookies back on market again. Of course they are just as interesting to play with as to eat. Your little sister is trying to make words out of the letters she found in the box, but you want to be faster than her to decide whether it is possible to make the word or not.</span></p>\r\n<br />\r\n<br />\r\n<center style="font-family: ''Times New Roman''; font-size: 14px; ">\r\n	<img src="http://acm.hdu.edu.cn/data/images/con211-1001-1.jpg" style="border-top-style: none; border-right-style: none; border-bottom-style: none; border-left-style: none; border-width: initial; border-color: initial; " /></center>\r\n<br />\r\n<p>\r\n	<span class="Apple-style-span" style="font-family: ''Times New Roman''; font-size: 14px; ">Given the letters in the cookie box, is it possible to spell out the words your little sister knows how to spell? (After creating a word, she scrambles the cookies again and can reuse the letters for later words.)</span></p>\r\n', 'IDI Open 2009', '<p>\r\n	<span class="Apple-style-span" style="font-family: ''Times New Roman''; font-size: 14px; ">The first line of the input consists of a single number T, the number of letter cookie boxes your sister has. Each test case starts with a line describing all the letters in this box, in no particular order. Then follows a line with W, the number of words she would like to spell, and then follow the W words to write on a single line each.</span></p>\r\n', '<p>\r\n	<span class="Apple-style-span" style="font-family: ''Times New Roman''; font-size: 14px; ">For each word, output a line containing YES if it is possible to spell the word, or NO if it is not possible.</span><br />\r\n	<span class="Apple-style-span" style="font-family: ''Times New Roman''; font-size: 14px; ">Notes and Constraints</span><br />\r\n	<br />\r\n	<span class="Apple-style-span" style="font-family: ''Times New Roman''; font-size: 14px; ">0 &lt; T &lt;= 100</span><br />\r\n	<br />\r\n	<span class="Apple-style-span" style="font-family: ''Times New Roman''; font-size: 14px; ">0 &lt; W &lt;= 100</span><br />\r\n	<br />\r\n	<span class="Apple-style-span" style="font-family: ''Times New Roman''; font-size: 14px; ">All letters are uppercase letters from the english alphabet (A-Z).</span><br />\r\n	<br />\r\n	<span class="Apple-style-span" style="font-family: ''Times New Roman''; font-size: 14px; ">There are at most 1000 letters in each cookie box.</span><br />\r\n	<br />\r\n	<span class="Apple-style-span" style="font-family: ''Times New Roman''; font-size: 14px; ">Each word has at most 100 letters (but is not necessarily an actual English word).</span></p>\r\n', '1\r\nABANANACOOKIE\r\n4\r\nBANANA\r\nLETTER\r\nCOOKIES\r\nCAN\r\n', 'YES\r\nNO\r\nNO\r\nYES\r\n', '', 0, 0, '2010-12-04 18:30:13', '2010-12-04 18:30:13'),
(389, 6, 'Box Betting', 1000, 33554432, 0000000000, 0000000000, '<p>\r\n	<font class="Apple-style-span" face="''Times New Roman''"><span class="Apple-style-span" style="font-size: 14px;">Theres a new delivery boy at your company, supposed to drive around delivering a specific number of items to difierent locations. He needs to deliver at least X of an item, while the truck can at most take Y of the item.</span></font></p>\r\n<br />\r\n<center>\r\n	<font class="Apple-style-span" face="''Times New Roman''"><span class="Apple-style-span" style="font-size: 14px;"><img src="http://acm.hdu.edu.cn/data/images/con211-1004-1.jpg" style="border-top-style: none; border-right-style: none; border-bottom-style: none; border-left-style: none; border-width: initial; border-color: initial; " /></span></font></center>\r\n<br />\r\n<br />\r\n<p>\r\n	<font class="Apple-style-span" face="''Times New Roman''"><span class="Apple-style-span" style="font-size: 14px;">If there are more, the truck is will to break down due to the weight. If there are less, that means he hasn&#39;t fulfilled the assignment. At the loading station, there&#39;s a row of boxes he can bring along.&nbsp;<br />\r\n	<br />\r\n	Each box contains a specified number of items. This driver isn&#39;t the sharpest snail on the rock, however. Since he&#39;s also too shy to ask for help, he&#39;s decided to just choose one entirely random starting point in the row of boxes. Then he chooses a random end point among the boxes from the starting point to the end, inclusive.&nbsp;</span></font><br />\r\n	&nbsp;</p>\r\n<p>\r\n	<font class="Apple-style-span" face="''Times New Roman''"><span class="Apple-style-span" style="font-size: 14px;">All the boxes between those points (inclusive) are loaded onto the truck. You and the other employees have started betting on whether or not the truck breaks&nbsp;</span></font><span class="Apple-style-span" style="font-family: ''Times New Roman''; font-size: 14px; ">down, he brings to few items along or if he should happen to be lucky enough to fulfil the assignment without any problems. This gets you wondering. What is the actual probability for each of these scenarios to occur? Assume for the sake of this problem that the driver will always be able to fit all the boxes into the truck (after all, he had to have SOME skill, seeing as he was hired).</span></p>\r\n', 'IDI Open 2009', '<p>\r\n	<font class="Apple-style-span" face="''Times New Roman''"><span class="Apple-style-span" style="font-size: 14px;">The input will start with a line containing a single number T, the number of test cases.<br />\r\n	&nbsp;Each test case consists of three lines. The first one contains a single number N, the number of boxes. The second line contains a sequence of N characters (A-Z), B1B2...BN (no whitespace), representing the amount of items in each of the boxes in the same order as they&#39;re located on the loading dock. An A represents an empty box, B a box with 1 item, and so on until Z, which represents a box with 25 items in it. The third line contains the two numbers L and U. L is the number of items the driver is supposed to deliver, while U is the maximum number of items the truck can take before it&#39;ll break down.</span></font></p>\r\n', '<p>\r\n	<font class="Apple-style-span" face="''Times New Roman''"><span class="Apple-style-span" style="font-size: 14px;">For each test case, output three floating point numbers on a single line. The first number gives the probability that the driver succeeds, the second one that that he brings along too few items, and the third one that the truck breaks down.</span></font><br />\r\n	&nbsp;</p>\r\n<p>\r\n	<font class="Apple-style-span" face="''Times New Roman''"><span class="Apple-style-span" style="font-size: 14px;">Notes and Constraints<br />\r\n	0 &lt; T &lt;= 100<br />\r\n	1 &lt; B &lt;= 200000<br />\r\n	&#39;A&#39; &lt;= Ai &lt;= &#39;Z&#39;<br />\r\n	0 &lt;= L &lt;= U &lt;= 50000<br />\r\n	Both the starting and ending points of the segment are chosen with a uniform<br />\r\n	probability distribution.<br />\r\n	<br />\r\n	Any answer within 10^-6 of the correct one will be accepted.</span></font></p>\r\n', '2\r\n4\r\nKCHA\r\n2 9\r\n3\r\nBCD\r\n4 5\r\n', '0.5 0.25 0.25\r\n0.16666667 0.72222222 0.11111111', '', 0, 0, '2010-12-04 18:32:19', '2010-12-05 10:46:27'),
(390, 6, 'Bicycle Puzzle', 1000, 33554432, 0000000000, 0000000000, '<p>\r\n	<span class="Apple-style-span" style="font-family: ''Times New Roman''; font-size: 14px; ">Per and Gunnar has found a wonderful online bicycle picture puzzle fiash solitaire game, and since they are very competitive, they want to find out who is best.</span><br />\r\n	<span class="Apple-style-span" style="font-family: ''Times New Roman''; font-size: 14px; ">The purpose of the game is to descramble a picture of a bicycle. At the start of each game, the picture of the bicycle is cut into W times H equally sized rectangles and scrambled randomly.</span></p>\r\n<p>\r\n	<br />\r\n	&nbsp;</p>\r\n<center style="font-family: ''Times New Roman''; font-size: 14px; ">\r\n	<p>\r\n		<img src="http://acm.hdu.edu.cn/data/images/con211-1002-1.jpg" style="border-top-style: none; border-right-style: none; border-bottom-style: none; border-left-style: none; border-width: initial; border-color: initial; " /></p>\r\n</center>\r\n<p>\r\n	<span class="Apple-style-span" style="font-family: ''Times New Roman''; font-size: 14px; ">Then the player repeatedly chooses two arbitrary rectangles and swaps them. He continues to swap rectangles until the picture is complete again. The game keeps track of the number of swaps, which is the score for that particular playthrough.</span><br />\r\n	<span class="Apple-style-span" style="font-family: ''Times New Roman''; font-size: 14px; ">After Gunnar has played a game, he sends his score (along with W and H) to Per, and challenges Per to beat this score. Per soon realizes that if he is unlucky with the scrambling, it is impossible to beat Gunnar&#39;s score.</span><br />\r\n	<span class="Apple-style-span" style="font-family: ''Times New Roman''; font-size: 14px; ">Per quickly writes a program to find out the probability that he can beat Gunnar&#39;s score (assuming that all scrambled pictures are equally probable) if he plays optimally.</span><br />\r\n	<span class="Apple-style-span" style="font-family: ''Times New Roman''; font-size: 14px; ">But he is not sure whether his program is correct and wants to verify its correctness by challenging you to write the same program.</span></p>\r\n', 'IDI Open 2009', '<p>\r\n	<span class="Apple-style-span" style="font-family: ''Times New Roman''; font-size: 14px; ">The first line of the input consists of a single number T, the number of scenarios. Each scenario is given by a line with three integers W, H and S, where S is Gunnar&#39;s last score.</span></p>\r\n', '<p>\r\n	<span class="Apple-style-span" style="font-family: ''Times New Roman''; font-size: 14px; ">For each scenario, output a line with the probability that Per beats Gunnar&#39;s score. Format the probability as an irreducible fraction where the numerator and the denominator are separated by /. Output only the numerator if the answer is an integer.</span><br />\r\n	<span class="Apple-style-span" style="font-family: ''Times New Roman''; font-size: 14px; ">Notes and Constraints</span><br />\r\n	<span class="Apple-style-span" style="font-family: ''Times New Roman''; font-size: 14px; ">0 &lt; T &lt;= 150</span><br />\r\n	<span class="Apple-style-span" style="font-family: ''Times New Roman''; font-size: 14px; ">0 &lt; W &lt;= 5</span><br />\r\n	<span class="Apple-style-span" style="font-family: ''Times New Roman''; font-size: 14px; ">0 &lt; H &lt;= 4</span><br />\r\n	<span class="Apple-style-span" style="font-family: ''Times New Roman''; font-size: 14px; ">0 &lt;= S &lt;= W * H</span><br />\r\n	<span class="Apple-style-span" style="font-family: ''Times New Roman''; font-size: 14px; ">When comparing two scores, the lowest one is best.</span></p>\r\n', '3\r\n1 1 1\r\n1 2 1\r\n3 1 2\r\n', '1\r\n1/2\r\n2/3\r\n', '', 0, 0, '2010-12-04 18:33:23', '2010-12-04 18:33:23'),
(391, 6, 'Geometry Darts', 1000, 33554432, 0000000000, 0000000000, '<p>\r\n	<span class="Apple-style-span" style="font-family: ''Times New Roman''; font-size: 14px; ">Bob and Hannah like to play darts. They are not very good at it, however, so finishing a round of 501 Darts will take an eternity. They therefore decide to throw away the dartboard completely and put geometric shapes on the wall instead, awarding points according to the number of shapes the dart penetrates. To reduce the complexity of scoring, they only use circles, triangles and rectangles.</span></p>\r\n<br />\r\n<br />\r\n<center style="font-family: ''Times New Roman''; font-size: 14px; ">\r\n	<img src="http://acm.hdu.edu.cn/data/images/con211-1003-1.jpg" style="border-top-style: none; border-right-style: none; border-bottom-style: none; border-left-style: none; border-width: initial; border-color: initial; " /></center>\r\n<br />\r\n<p>\r\n	<span class="Apple-style-span" style="font-family: ''Times New Roman''; font-size: 14px; ">A game consists of each person throwing 3 darts each, and your job is to find the winner of the game, given the shapes and the throws.</span></p>\r\n', 'IDI Open 2009', '<p>\r\n	<span class="Apple-style-span" style="font-family: ''Times New Roman''; font-size: 14px; ">The input will start with a line giving the total number of shapes, S. Then follow S lines describing the shapes, in either of the following formats:</span><br />\r\n	<br />\r\n	<span class="Apple-style-span" style="font-family: ''Times New Roman''; font-size: 14px; ">1. C x y r, where (x, y) is the center of the circle, and r is the radius.</span><br />\r\n	<br />\r\n	<span class="Apple-style-span" style="font-family: ''Times New Roman''; font-size: 14px; ">2. R x1 y1 x2 y2, where (x1, y1) and (x2, y2) are two corners of the rectangle with x1 &lt; x2 and y1 &lt; y2.</span><br />\r\n	<br />\r\n	<span class="Apple-style-span" style="font-family: ''Times New Roman''; font-size: 14px; ">3. T x1 y1 x2 y2 x3 y3, where (xi, yi) are the three corners of the triangle.</span><br />\r\n	<br />\r\n	<span class="Apple-style-span" style="font-family: ''Times New Roman''; font-size: 14px; ">Then follows a line with N, the number of games Bob and Hannah play. Each game is described with six lines giving the x and y coordinates of the 6 throws, the first three by Bob and the last three by Hannah.</span></p>\r\n', '<p>\r\n	<font class="Apple-style-span" face="''Times New Roman''"><span class="Apple-style-span" style="font-size: 14px;">Output the name of the winner on a separate line for each game, or Tied if there is a tie.&nbsp;<br />\r\n	Notes and Constraints<br />\r\n	0 &lt; S &lt;= 1000<br />\r\n	0 &lt; N &lt;= 1000<br />\r\n	<br />\r\n	All rectangles have sides parallell to the x- and y-axis.<br />\r\n	<br />\r\n	For triangle specifications, the three points will never be collinear.<br />\r\n	<br />\r\n	All coordinates are given with double precision, with up to 6 decimals after the<br />\r\n	decimal points.<br />\r\n	<br />\r\n	All shapes are bounded by the rectangle defined by the two points (-1000,-1000)<br />\r\n	and (1000, 1000).<br />\r\n	<br />\r\n	All throws are guaranteed to be at least 10^-6 away from any shape boundary.</span></font></p>\r\n', '3\r\nC 0.0 0.0 5.0\r\nR -1.0 -1.0 7.0 7.0\r\nT 0.0 0.0 -3.0 0.0 0.0 -8.0\r\n1\r\n0.0 4.1\r\n0.0 6.2\r\n0.0 8.1\r\n-0.5 -0.5\r\n-0.5 -2.0\r\n-0.5 -5.1', 'Hannah', '', 0, 0, '2010-12-04 18:35:30', '2010-12-06 21:26:15'),
(402, 1, 'A + B Problem II', 1000, 33554432, 0000000000, 0000000000, '<p>\r\n	I have a very simple problem for you. Given two integers A and B, your job is to calculate the Sum of A + B.</p>\r\n', 'Ignatius.L', '<div class="panel_content">\r\n	The first line of the input contains an integer T(1&lt;=T&lt;=20) which means the number of test cases. Then T lines follow, each line consists of two positive integers, A and B. Notice that the integers are very large, that means you should not process them by using 32-bit integer. You may assume the length of each integer will not exceed 2000.</div>\r\n', '<p>\r\n	For each test case, you should output two lines. The first line is &quot;Case #:&quot;, # means the number of the test case. The second line is the an equation &quot;A + B = Sum&quot;, Sum means the result of A + B. Note there are some spaces int the equation. Output a blank line between two test cases.</p>\r\n', '2\r\n1 2\r\n112233445566778899 998877665544332211', 'Case 1:\r\n1 + 2 = 3\r\n\r\nCase 2:\r\n112233445566778899 + 998877665544332211 = 1111111111111111110', '', 0, 0, '2010-12-08 22:09:45', '2010-12-09 09:06:31');
INSERT INTO `tbl_problems` (`id`, `user_id`, `title`, `time_limit`, `memory_limit`, `submission_no`, `accepted_no`, `description`, `source`, `input`, `output`, `input_sample`, `output_sample`, `hint`, `flag`, `visibility`, `created`, `modified`) VALUES
(392, 6, 'Train Tickets', 1000, 33554432, 0000000000, 0000000000, '<p>\r\n	<font class="Apple-style-span" face="''Times New Roman''"><span class="Apple-style-span" style="font-size: 14px;">Tor Gunnar is a huge fan of trains. All his life, he&#39;s been running around at home yelling &quot;Toot Toot&quot;. So when he recently found out about a job opening at a local train company, he immediately applied. Tor Gunnar, having studied really hard to reach such opportunities, got the job.&nbsp;</span></font></p>\r\n<br />\r\n<center>\r\n	<font class="Apple-style-span" face="''Times New Roman''"><span class="Apple-style-span" style="font-size: 14px;"><img src="http://acm.hdu.edu.cn/data/images/con211-1006-1.jpg" style="border-top-style: none; border-right-style: none; border-bottom-style: none; border-left-style: none; border-width: initial; border-color: initial; " /></span></font></center>\r\n<br />\r\n<p>\r\n	<font class="Apple-style-span" face="''Times New Roman''"><span class="Apple-style-span" style="font-size: 14px;">It was the happiest moment of his life! To his great dissappointment, though, he discovered that the contract said nothing about riding trains all day. He is now assigned to the IT department, and is supposed to help write a new ticket management system. The part he is supposed to write, is an algorithm for distributing tickets among the difierent possible travels along a train route.<br />\r\n	<br />\r\n	<br />\r\n	Tor Gunnar comes from a strange country. In addition to speaking a language even he himself doesn&#39;t understand, the countrys government has pushed through some weird laws that influences how train tickets are sold. This means that the price for travelling from station A to station B is predetermined. Also, everytime you sell tickets for a given trip, you&#39;ll know the exact demand for travelling between each pair of cities. What more, the government is allowed to set aside some tickets for their own usage (these are free of<br />\r\n	charge).<br />\r\n	<br />\r\n	<br />\r\n	<br />\r\n	One train trip consists of a series of stations. It is possible to travel from station A to B as long as A precedes B in the station list. Each train has a given capacity, and there can never be more than this amount of passengers in between two adjacent stations.<br />\r\n	<br />\r\n	<br />\r\n	Tor Gunnar is completely puzzled, and desperately needs your help. Write a program that helps him figure out the best ticket distribution.</span></font></p>\r\n', 'IDI Open 2009', '<p>\r\n	<font class="Apple-style-span" face="''Times New Roman''"><span class="Apple-style-span" style="font-size: 14px;">The first line of input contains a single number T, the number of test cases to follow.<br />\r\n	<br />\r\n	<br />\r\n	Each test case begins with a line containing two numbers, N and P, the number of stations in the case and the capacity of the train, respectively. Then follow N - 1 lines, giving the ticket prices, Cij . The i-th of these N lines contain N - i numbers. The j-th number of the i-th line is the cost of a ticket from station i to station i + j. The next N - 1 lines give the demand for tickets for each pair of stations, Dij , in the same format as the prices.<br />\r\n	<br />\r\n	<br />\r\n	Another N - 1 lines in the same format follow these, statin the number of tickets set aside for the government officials, Oij .</span></font></p>\r\n', '<p>\r\n	<font class="Apple-style-span" face="''Times New Roman''"><span class="Apple-style-span" style="font-size: 14px;">For each test case, output a single number on a line by itself. The number should equal the maximum possible income from the train trip.<br />\r\n	<br />\r\n	Notes and Constraints<br />\r\n	0 &lt; T &lt;= 100<br />\r\n	3 &lt;= N &lt;= 16<br />\r\n	0 &lt; P &lt;= 200<br />\r\n	0 &lt; Cij &lt;= 1000<br />\r\n	0 &lt;= Dij &lt;= 250<br />\r\n	0 &lt;= Oij &lt;= 20<br />\r\n	A train trip goes from station 1 to station N.<br />\r\n	<br />\r\n	Keep in mind that the passenger count including the government officials cannot be more than the capacity.<br />\r\n	You are not allowed to overbook the train. The government will never overbook your train using their &quot;free&quot; tickets.<br />\r\n	<br />\r\n	Keep in mind that the passenger count including the government officials cannot be more than the capacity.<br />\r\n	You are not allowed to overbook the train. The government will never overbook your train using their &quot;free&quot; tickets.</span></font></p>\r\n', '1\r\n3 1\r\n3 4\r\n2\r\n0 0\r\n0\r\n0 0\r\n0\r\n', '0', '', 0, 0, '2010-12-04 21:40:50', '2010-12-06 17:34:53'),
(393, 6, 'Counting Sheep', 1000, 33554432, 0000000000, 0000000000, '<p>\r\n	<font class="Apple-style-span" face="''Times New Roman''"><span class="Apple-style-span" style="font-size: 14px;">A while ago I had trouble sleeping. I used to lie awake, staring at the ceiling, for hours and hours. Then one day my grandmother suggested I tried counting sheep after I&#39;d gone to bed. As always when my grandmother suggests things, I decided to try it out. The only problem was, there were no sheep around to be counted when I went to bed.</span></font></p>\r\n<br />\r\n<center>\r\n	<font class="Apple-style-span" face="''Times New Roman''"><span class="Apple-style-span" style="font-size: 14px;"><img src="http://acm.hdu.edu.cn/data/images/con211-1007-1.jpg" style="border-top-style: none; border-right-style: none; border-bottom-style: none; border-left-style: none; border-width: initial; border-color: initial; " /></span></font></center>\r\n<br />\r\n<br />\r\n<p>\r\n	<font class="Apple-style-span" face="''Times New Roman''"><span class="Apple-style-span" style="font-size: 14px;">Creative as I am, that wasn&#39;t going to stop me. I sat down and wrote a computer program that made a grid of characters, where # represents a sheep, while . is grass (or whatever you like, just not sheep). To make the counting a little more interesting, I also decided I wanted to count flocks of sheep instead of single sheep. Two sheep are in the same flock if they share a common side (up, down, right or left). Also, if sheep A is in the same flock as sheep B, and sheep B is in the same flock as sheep C, then sheeps A and C are in the same flock.<br />\r\n	<br />\r\n	<br />\r\n	Now, I&#39;ve got a new problem. Though counting these sheep actually helps me fall asleep, I find that it is extremely boring. To solve this, I&#39;ve decided I need another computer program that does the counting for me. Then I&#39;ll be able to just start both these programs before I go to bed, and I&#39;ll sleep tight until the morning without any disturbances. I need you to write this program for me.</span></font></p>\r\n', 'IDI Open 2009', '<p>\r\n	<font class="Apple-style-span" face="''Times New Roman''"><span class="Apple-style-span" style="font-size: 14px;">The first line of input contains a single number T, the number of test cases to follow.<br />\r\n	<br />\r\n	Each test case begins with a line containing two numbers, H and W, the height and width of the sheep grid. Then follows H lines, each containing W characters (either # or .), describing that part of the grid.</span></font></p>\r\n', '<p>\r\n	<font class="Apple-style-span" face="''Times New Roman''"><span class="Apple-style-span" style="font-size: 14px;">For each test case, output a line containing a single number, the amount of sheep flock son that grid according to the rules stated in the problem description.<br />\r\n	<br />\r\n	Notes and Constraints<br />\r\n	0 &lt; T &lt;= 100<br />\r\n	0 &lt; H,W &lt;= 100</span></font></p>\r\n', '2\r\n4 4\r\n#.#.\r\n.#.#\r\n#.##\r\n.#.#\r\n3 5\r\n###.#\r\n..#..\r\n#.###', '6\r\n3', '', 0, 0, '2010-12-04 21:41:30', '2010-12-06 17:36:20'),
(397, 6, 'Robberies', 1000, 33554432, 0000000000, 0000000000, '<p>\r\n	The aspiring Roy the Robber has seen a lot of American movies, and knows that the bad guys usually gets caught in the end, often because they become too greedy. He has decided to work in the lucrative business of bank robbery only for a short while, before retiring to a comfortable job at a university.</p>\r\n<br />\r\n<br />\r\n<center>\r\n	<img src="http://acm.hdu.edu.cn/data/images/con211-1010-1.jpg" style="border-top-style: none; border-right-style: none; border-bottom-style: none; border-left-style: none; border-width: initial; border-color: initial; " /></center>\r\n<br />\r\n<p>\r\n	For a few months now, Roy has been assessing the security of various banks and the amount of cash they hold. He wants to make a calculated risk, and grab as much money as possible.<br />\r\n	<br />\r\n	<br />\r\n	His mother, Ola, has decided upon a tolerable probability of getting caught. She feels that he is safe enough if the banks he robs together give a probability less than this.</p>\r\n', 'IDI Open 2009', '<p>\r\n	The first line of input gives T, the number of cases. For each scenario, the first line of input gives a floating point number P, the probability Roy needs to be below, and an integer N, the number of banks he has plans for. Then follow N lines, where line j gives an integer Mj and a floating point number Pj .&nbsp;<br />\r\n	Bank j contains Mj millions, and the probability of getting caught from robbing it is Pj .</p>\r\n', '<p>\r\n	For each test case, output a line with the maximum number of millions he can expect to get while the probability of getting caught is less than the limit set.<br />\r\n	<br />\r\n	Notes and Constraints<br />\r\n	0 &lt; T &lt;= 100<br />\r\n	0.0 &lt;= P &lt;= 1.0<br />\r\n	0 &lt; N &lt;= 100<br />\r\n	0 &lt; Mj &lt;= 100<br />\r\n	0.0 &lt;= Pj &lt;= 1.0<br />\r\n	A bank goes bankrupt if it is robbed, and you may assume that all probabilities are independent as the police have very low funds.</p>\r\n', '3\r\n0.04 3\r\n1 0.02\r\n2 0.03\r\n3 0.05\r\n0.06 3\r\n2 0.03\r\n2 0.03\r\n3 0.05\r\n0.10 3\r\n1 0.03\r\n2 0.02\r\n3 0.05', '2\r\n4\r\n6\r\n', '', 0, 0, '2010-12-06 17:40:38', '2010-12-06 17:40:38'),
(394, 6, 'Rubiks Cube', 1000, 33554432, 0000000000, 0000000000, '<p>\r\n	<font class="Apple-style-span" face="''Times New Roman''"><span class="Apple-style-span" style="font-size: 14px;">Following the hype generated by Rubiks Cube Norwegian Open Championship arranged at NTNU this year, each and every student at NTNU has bought such a cube. The professors, however, are dismayed, because the students rather play with their cube instead of listening to the professors lectures.</span></font></p>\r\n<br />\r\n<br />\r\n<center>\r\n	<font class="Apple-style-span" face="''Times New Roman''"><span class="Apple-style-span" style="font-size: 14px;"><img src="http://acm.hdu.edu.cn/data/images/con211-1008-1.jpg" style="border-top-style: none; border-right-style: none; border-bottom-style: none; border-left-style: none; border-width: initial; border-color: initial; " /></span></font></center>\r\n<br />\r\n<p>\r\n	<font class="Apple-style-span" face="''Times New Roman''"><span class="Apple-style-span" style="font-size: 14px;">One professor suddenly gets the idea that if he gives the students a program to solve their cubes they may lose interest in it, so that it will be possible to start teaching again. Of course, the professor don&#39;t want to do the grunt work of programming, and you are the lucky assignee of this task.&nbsp;<br />\r\n	<br />\r\n	<br />\r\n	The professor takes away your cube, locks you in a faraway laboratory and says that you won&#39;t get out until you have written a program to solve Rubiks cube.<br />\r\n	<br />\r\n	<br />\r\n	Luckily, the professor did not specify the size of the cube, so you decide to make the work slightly easier by solving the Rubiks 2  2  2 cube.</span></font></p>\r\n', 'IDI Open 2009', '<p>\r\n	<font class="Apple-style-span" face="''Times New Roman''"><span class="Apple-style-span" style="font-size: 14px;">The first line of the input consists of a single number T, the number of test cases. Each test case consists of six lines describing the initial configuration of a cube, formatted exactly as in the example input. The characters used for colors are G, R, O, B, Y and W.<br />\r\n	<br />\r\n	Each test case is followed by an empty line.</span></font></p>\r\n', '<p>\r\n	<font class="Apple-style-span" face="''Times New Roman''"><span class="Apple-style-span" style="font-size: 14px;">For each scenario, output a line with the minimum number of moves that is necessecary to solve the cube. A move is turning one face of the cube 90 degrees clockwise or counter-clockwise. (A turn of 180 degrees is considered to be two moves.)<br />\r\n	<br />\r\n	Notes and Constraints<br />\r\n	0 &lt; T &lt;= 100<br />\r\n	You may assume that all input cubes are scrambled versions of originally solved cubes with six diffierent colors. (Which means there are exactly four occurrences of each color and that it is possible to get the cube to a solved state using moves as described above.)</span></font></p>\r\n', '2\r\nOO\r\nOO\r\nRR GG BB WW\r\nRR GG BB WW\r\nYY\r\nYY\r\nRR\r\nRR\r\nYY OO GG BB\r\nOO GG BB YY\r\nWW\r\nWW', '0\r\n1', '', 0, 0, '2010-12-04 21:41:51', '2010-12-06 17:37:36'),
(396, 6, 'Marble Madness', 1000, 33554432, 0000000000, 0000000000, '<p>\r\n	oyvind likes to test his future employees, especially with funny games.<br />\r\n	<br />\r\n	This time he has invented a game where you start out with B black marbles and W white ones in a bag.</p>\r\n<br />\r\n<center>\r\n	<img src="http://acm.hdu.edu.cn/data/images/con211-1009-1.jpg" style="border-top-style: none; border-right-style: none; border-bottom-style: none; border-left-style: none; border-width: initial; border-color: initial; " /></center>\r\n<br />\r\n<p>\r\n	You also have endless supplies of both kinds of marbles outside the bag. The game proceeds in rounds. In each round, you take two marbles at random out of the bag, and put one marble back in (possibly another color than any of the two you took out), obeying the following rules:<br />\r\n	<br />\r\n	1. When you take out two white marbles, you put a black one back in.<br />\r\n	<br />\r\n	2. When you take out one black and one white, you put a white marble back in.<br />\r\n	<br />\r\n	3. When you take out two black marbles, you put a black one back in.<br />\r\n	<br />\r\n	At the end of this game, there will only be one marble in the bag. This marble may be white with a probability and black with a probability given the number of marbles of each colour you start with. Your job is to find these probabilities.</p>\r\n', 'IDI Open 2009', '<p>\r\n	The input will start with a line giving the number of test cases, T. Each test case will be presented at one line with two integers, B and W, separated by a single space, representing the number of black and white marbles respectively.</p>\r\n', '<p>\r\n	There should be one line of output for each test case with two floating point numbers separated by a single space. The first number should represent the probability that the last marble is black, and the second the probability that the last marble is white.<br />\r\n	<br />\r\n	Notes and Constraints<br />\r\n	0 &lt; T &lt;= 100<br />\r\n	0 &lt;= B,W &lt;= 50000<br />\r\n	0 &lt; B +W<br />\r\n	Any answer within 10^-6 of the correct one will be accepted.</p>\r\n', '2\r\n1 1\r\n3 0', '0.00 1.00\r\n1.00 0.00', '', 0, 0, '2010-12-06 17:39:10', '2010-12-06 17:39:10'),
(395, 6, 'Communication Channels', 1000, 33554432, 0000000000, 0000000000, '<div>\r\n	<font class="Apple-style-span" face="''Times New Roman''"><span class="Apple-style-span" style="font-size: 14px;">Classical information theory is based on the concept of a communication channel.</span></font><br />\r\n	<center>\r\n		<font class="Apple-style-span" face="''Times New Roman''"><span class="Apple-style-span" style="font-size: 14px;"><img src="http://acm.hdu.edu.cn/data/images/con211-1005-1.jpg" style="border-top-style: none; border-right-style: none; border-bottom-style: none; border-left-style: none; border-width: initial; border-color: initial; " /></span></font></center>\r\n	<br />\r\n	<br />\r\n	<font class="Apple-style-span" face="''Times New Roman''"><span class="Apple-style-span" style="font-size: 14px;">Information theory is generally considered to have been founded in 1948 by Claude Shan-non in his seminal work, \\A Mathemati-cal Theory of Communication.&quot; The cen-tral paradigm of classical information theory is the engineering problem of the transmis-sion of information over a noisy channel. http://en.wikipedia.org/wiki/Information theory<br />\r\n	<br />\r\n	<br />\r\n	In this problem, we will specifically consider one of the simplest possible noisy channels, namely the binary symmetric channel (BSC). A BSC transmits a sequence of bits, but each transmitted bit has a probability p of being fiipped to the wrong bit. This is called the crossover probability, as can be understood from the figure. We assume independent behaviour on difierent bits, so a communication of l bits has probability (1 - p)^l of being transmitted<br />\r\n	correctly. Note that one can always assume that p &lt; 1/2, since a channel with p = 1/2 is totally useless, and a channel with p &gt; 1/2 can easily be transformed to a new channel having crossover probability 1 - p by just flipping all bits of the output.<br />\r\n	<br />\r\n	<br />\r\n	Of course, it is still possible to communicate over a noisy channel. (In fact, you are doing it all the time!) To be able to do this, one has to add extra bits in order for the receiver to detect or even possibly correct errors. Example implementations of such a feature are parity bits, Cyclic Redundancy Checks (CRC) and Golay codes.&nbsp;<br />\r\n	<br />\r\n	These are not relevant to this problem, however, so they will not be discussed here.<br />\r\n	<br />\r\n	In this problem you must investigate the behaviour of a binary symmetric channel.</span></font></div>\r\n', 'IDI Open 2009', '<p>\r\n	<span class="Apple-style-span" style="font-family: ''Times New Roman''; font-size: 14px; ">The first line of the input consists of a single number T, the number of transmissions.</span><br />\r\n	<span class="Apple-style-span" style="font-family: ''Times New Roman''; font-size: 14px; ">Then follow T lines with the input and the output of each transmission as binary strings, separated by a single space.</span></p>\r\n', '<p>\r\n	<span class="Apple-style-span" style="font-family: ''Times New Roman''; font-size: 14px; ">For each transmission, output OK if the communication was transmitted correctly, or ERROR if it was transmitted incorrectly.</span><br />\r\n	<span class="Apple-style-span" style="font-family: ''Times New Roman''; font-size: 14px; ">Notes and Constraints</span><br />\r\n	<span class="Apple-style-span" style="font-family: ''Times New Roman''; font-size: 14px; ">0 &lt; T &lt;= 100</span><br />\r\n	<span class="Apple-style-span" style="font-family: ''Times New Roman''; font-size: 14px; ">All inputs and outputs has length less than 120.</span><br />\r\n	<span class="Apple-style-span" style="font-family: ''Times New Roman''; font-size: 14px; ">T is encoded in decimal.</span></p>\r\n', '2\r\n10 10\r\n10 11\r\n', 'OK\r\nERROR', '', 0, 0, '2010-12-04 21:42:29', '2010-12-04 21:42:29'),
(403, 1, 'N的阶乘', 1500, 33554432, 0000000000, 0000000000, '<p>\r\n	现在想知道1000!</p>\r\n', '', '<p>\r\n	输入文件包含多行 每行是一个非负整数n</p>\r\n', '<p>\r\n	输出n!</p>\r\n', '1\r\n2\r\n5\r\n', '1\r\n2\r\n120\r\n', '<br />\r\n', 0, 0, '2010-12-09 01:35:30', '2010-12-09 08:01:05'),
(404, 1, '4×4的矩阵乘法', 300, 33554432, 0000000000, 0000000000, '<p>\r\n	2011快要到了</p>\r\n<p>\r\n	既然我们讲了矩阵乘法的优化 那就算一下整数矩阵求模的乘法</p>\r\n<p>\r\n	把矩阵反复自乘2011次 即是计算矩阵A^2011</p>\r\n<p>\r\n	矩阵的每个元素对2011求模</p>\r\n', '', '<p>\r\n	输入文件第一行为n</p>\r\n<p>\r\n	接下来为 4X4的矩阵</p>\r\n<p>\r\n	然后有个空行</p>\r\n', '<p>\r\n	输出一个矩阵后空一行</p>\r\n', '2\r\n672 527 2009 539\r\n59 453 1257 1365\r\n621 262 965 1644\r\n885 294 132 941\r\n\r\n1851 510 1972 745\r\n61 1927 212 1303\r\n1789 260 622 1555\r\n1634 1393 685 1206\r\n', '893 1214 97 1248\r\n1335 1359 428 1564\r\n1 1036 1607 1336\r\n1037 585 1882 1183\r\n\r\n1454 136 640 1496\r\n767 1179 1885 527\r\n1701 1932 349 1130\r\n1737 1078 152 613', '<p>\r\n	<br />\r\n	&nbsp;</p>\r\n', 0, 0, '2010-12-23 00:59:55', '2010-12-30 00:36:20');

-- --------------------------------------------------------

--
-- 表的结构 `tbl_profiles`
--

DROP TABLE IF EXISTS `tbl_profiles`;
CREATE TABLE IF NOT EXISTS `tbl_profiles` (
  `user_id` int(11) NOT NULL,
  `lastname` varchar(50) NOT NULL DEFAULT '',
  `firstname` varchar(50) NOT NULL DEFAULT '',
  `birthday` date NOT NULL DEFAULT '0000-00-00',
  `nickname` varchar(50) NOT NULL DEFAULT '',
  `identitynumber` varchar(40) NOT NULL DEFAULT '',
  PRIMARY KEY (`user_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

--
-- 转存表中的数据 `tbl_profiles`
--

INSERT INTO `tbl_profiles` (`user_id`, `lastname`, `firstname`, `birthday`, `nickname`, `identitynumber`) VALUES
(1, 'c', 'asper', '0000-00-00', 'administrator', ''),
(2, '陈', '双平', '0000-00-00', '陈老师', '2007359'),
(3, '无', '名', '0000-00-00', '韩国谦', ''),
(4, '无', '名', '0000-00-00', 'li', ''),
(5, '无', '名', '0000-00-00', 'Mountain', ''),
(6, '廖', '家赵', '0000-00-00', 'ljz1989', '2008051662'),
(7, '陈', '俊杰', '0000-00-00', 'mwkfeng', '2007052312'),
(8, '无', '名', '0000-00-00', 'test', ''),
(9, '岑', '江斌', '0000-00-00', 'ray', '2008051584'),
(10, '陈', '铨', '0000-00-00', '陈铨', '2008051650'),
(11, '郭', '培', '0000-00-00', '郭培', '2008052506'),
(12, '罗', '海铭', '0000-00-00', '我不勤奋', '2008051586'),
(13, '李', '阳', '0000-00-00', 'yang', '2008051585'),
(14, '祝', '嘉声', '0000-00-00', '声仔', '2008051656'),
(15, '吴', '铁印', '0000-00-00', 'Tinsy', '2008052460'),
(16, '李', '振旺', '0000-00-00', '李', '2008051666'),
(17, '钟', '宇航', '0000-00-00', '奥科查', '2008051667'),
(18, '陈', '一帆', '0000-00-00', 'xiaofan', '2008052864'),
(19, '孟', '思繁', '0000-00-00', '小七', '2008052496'),
(20, '陈', '梦勋', '0000-00-00', '梦勋', '2008052867'),
(21, '陈', '安兴', '0000-00-00', 'nick312', '2008051370'),
(22, '高', '阳', '0000-00-00', '上帝', '2008051640'),
(23, '刘', '辉', '0000-00-00', '刘辉', '2008052503'),
(24, '吴', '浩', '0000-00-00', '小浩', '2007052401'),
(25, '李', '飞', '0000-00-00', 'AC_Crush', '2008052501'),
(26, '梁', '海瑞', '0000-00-00', '小海', '2008051645'),
(27, '吴', '豪波', '0000-00-00', '波仔', '2008051664'),
(28, '罗', '海铭', '0000-00-00', '我不勤奋', '2008051586'),
(29, '林', '晓端', '0000-00-00', 'lion', '2008051658'),
(30, '孟', '思繁', '0000-00-00', '小七', '2008052496'),
(31, '商', '修', '0000-00-00', '商修', '2008052505'),
(32, '无', '名', '0000-00-00', 'jnu405', ''),
(33, '无', '名', '0000-00-00', 'jnu123', ''),
(34, '无', '名', '0000-00-00', 'Cololabis saira', ''),
(35, '汪', '茜', '0000-00-00', 'QQ', '2008052861'),
(36, '黄', '晓波', '0000-00-00', '秒杀菜鸟', '2008051652'),
(37, '无', '名', '0000-00-00', 'water', '2010052812'),
(38, '梁', '海瑞', '0000-00-00', '小海', '2008051645'),
(39, '林', '嘉宇', '0000-00-00', 'yuyu', '2007052328');

-- --------------------------------------------------------

--
-- 表的结构 `tbl_profiles_fields`
--

DROP TABLE IF EXISTS `tbl_profiles_fields`;
CREATE TABLE IF NOT EXISTS `tbl_profiles_fields` (
  `id` int(10) NOT NULL AUTO_INCREMENT,
  `varname` varchar(50) NOT NULL,
  `title` varchar(255) NOT NULL,
  `field_type` varchar(50) NOT NULL,
  `field_size` int(3) NOT NULL DEFAULT '0',
  `field_size_min` int(3) NOT NULL DEFAULT '0',
  `required` int(1) NOT NULL DEFAULT '0',
  `match` varchar(255) NOT NULL DEFAULT '',
  `range` varchar(255) NOT NULL DEFAULT '',
  `error_message` varchar(255) NOT NULL DEFAULT '',
  `other_validator` varchar(255) NOT NULL DEFAULT '',
  `default` varchar(255) NOT NULL DEFAULT '',
  `widget` varchar(255) NOT NULL DEFAULT '',
  `widgetparams` varchar(5000) NOT NULL DEFAULT '',
  `position` int(3) NOT NULL DEFAULT '0',
  `visible` int(1) NOT NULL DEFAULT '0',
  PRIMARY KEY (`id`),
  KEY `varname` (`varname`,`widget`,`visible`)
) ENGINE=MyISAM  DEFAULT CHARSET=utf8 AUTO_INCREMENT=6 ;

--
-- 转存表中的数据 `tbl_profiles_fields`
--

INSERT INTO `tbl_profiles_fields` (`id`, `varname`, `title`, `field_type`, `field_size`, `field_size_min`, `required`, `match`, `range`, `error_message`, `other_validator`, `default`, `widget`, `widgetparams`, `position`, `visible`) VALUES
(1, 'lastname', 'Last Name', 'VARCHAR', 50, 3, 1, '', '', 'Incorrect Last Name (length between 3 and 50 characters).', '', '', '', '', 1, 1),
(2, 'firstname', 'First Name', 'VARCHAR', 50, 3, 1, '', '', 'Incorrect First Name (length between 3 and 50 characters).', '', '', '', '', 0, 1),
(3, 'birthday', 'Birthday', 'DATE', 0, 0, 2, '', '', '', '', '0000-00-00', 'UWjuidate', '{"ui-theme":"redmond"}', 4, 2),
(4, 'nickname', 'Nick Name', 'VARCHAR', 50, 1, 1, '', '', 'Incorrect Nick Name (length between 1 and 20 characters).', '', '', '', '', 2, 3),
(5, 'identitynumber', 'Student/Identity number', 'VARCHAR', 40, 0, 0, '', '', '', '', '', '', '', 3, 1);

-- --------------------------------------------------------

--
-- 表的结构 `tbl_submitions`
--

DROP TABLE IF EXISTS `tbl_submitions`;
CREATE TABLE IF NOT EXISTS `tbl_submitions` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `user_id` int(11) NOT NULL,
  `problem_id` int(11) NOT NULL,
  `exercise_id` int(11) NOT NULL DEFAULT '0',
  `source` mediumtext NOT NULL,
  `result` varchar(500) NOT NULL DEFAULT '',
  `used_time` int(11) NOT NULL DEFAULT '0',
  `used_memory` int(11) NOT NULL DEFAULT '0',
  `status` int(11) NOT NULL DEFAULT '0',
  `compiler_id` int(11) NOT NULL,
  `created` datetime NOT NULL,
  `modified` datetime NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=MyISAM  DEFAULT CHARSET=utf8 AUTO_INCREMENT=1447 ;

--
-- 转存表中的数据 `tbl_submitions`
--

INSERT INTO `tbl_submitions` (`id`, `user_id`, `problem_id`, `exercise_id`, `source`, `result`, `used_time`, `used_memory`, `status`, `compiler_id`, `created`, `modified`) VALUES
(1, 1, 1, 0, '#include<stdio.h>\r\nint main()\r\n{\r\n	int a,b;\r\n	scanf("%d%d",&a,&b);\r\n	printf("%d",a+b);\r\n	return 0;\r\n}', '', 0, 262144, 1, 1, '2010-05-02 09:14:51', '2010-05-02 09:14:51'),
(2, 1, 2, 0, '#include<stdio.h>\r\nint main()\r\n{\r\n	int a,b,i,j;\r\n	int flag[63]={0};\r\n\r\n	for(i=1,j=1;i<63;j++,i+=j)\r\n	{\r\n		flag[i]=1;\r\n	}\r\n	j=flag[62];\r\n	for(i=61;i>=1;i--)\r\n	{\r\n		if(flag[i]==1)\r\n		{\r\n			j++;\r\n		}\r\n		flag[i]=j;\r\n	}\r\n	while(scanf("%d/%d",&a,&b)==2 &&(a!=0||b!=0))\r\n	{\r\n		if(a==8)b+=31;\r\n		printf("%d\\n",flag[b]);\r\n\r\n	}\r\n	return 0;\r\n}', '', 0, 258048, 1, 1, '2010-05-06 14:42:18', '2010-05-06 14:42:18'),
(3, 1, 1, 0, '//编译出错\r\n#include<stdio.h>\r\nint main()\r\n{\r\n	int a,b;\r\n	scanf("%d%d",&a,&b);\r\n	printf("%d",a+b);\r\n//缺少大括号', 'srcfile: In function ''main'':\r\nsrcfile:7:2: error: expected declaration or statement at end of input\r\n', 0, 0, 2, 1, '2010-05-27 22:30:49', '2010-05-27 22:30:56'),
(4, 1, 1, 0, '#include<stdio.h>\r\nint main()\r\n{\r\n	int a,b;\r\n	scanf("%d%d",&a,&b);\r\n	printf("%d",a+b);\r\n        while(a>0);//死循环\r\n        return 0;\r\n}', '', 1000, 8388608, 5, 1, '2010-05-27 23:29:08', '2010-05-27 23:29:12'),
(5, 1, 1, 0, '#include<stdio.h>\r\nint main()\r\n{\r\n	int a,b;\r\n	scanf("%d %d",a,b);\r\n	printf("%d",a+b);\r\n        return 0;\r\n}', '', 1000, 8388608, 7, 1, '2010-05-28 00:54:39', '2010-08-08 10:38:02'),
(6, 1, 1, 0, '#include<stdio.h>\r\nint main()\r\n{\r\n  int a,b;\r\n  scanf("%d%d",&a,&b);\r\n  printf("%d",a+b);\r\n  return 0;\r\n}', '', 0, 262144, 1, 1, '2010-05-31 14:23:43', '2010-08-08 10:38:32'),
(10, 1, 4, 0, '// Problem   The Bottom of a Graph\r\n// Algorithm Strongly Connected Components, Topological Sort, DFS\r\n// Runtime   O(|V|+|E|)\r\n// Author    Walter Guttmann\r\n// Date      26.04.2003\r\n\r\n#include <cassert>\r\n#include <fstream>\r\n#include <iostream>\r\n#include <vector>\r\n\r\nusing namespace std;\r\n\r\n//ifstream in("bottom.in");\r\n\r\ntypedef vector<bool> vb;\r\ntypedef vector<int> vi;\r\ntypedef vector<vi> vvi;\r\ntypedef vi::iterator vit;\r\n\r\nvoid dfs_topsort(vvi &adj, vb &used, vi &topsort, int node)\r\n{\r\n  used[node] = true;\r\n  for (vit it = adj[node].begin() ; it != adj[node].end() ; ++it)\r\n    if (!used[*it])\r\n      dfs_topsort(adj, used, topsort, *it);\r\n  topsort.push_back(node);\r\n}\r\n\r\nvoid dfs_scc(vvi &adj, vb &used, vi &scc, int node)\r\n{\r\n  used[node] = true;\r\n  for (vit it = adj[node].begin() ; it != adj[node].end() ; ++it)\r\n    if (!used[*it])\r\n    {\r\n      scc[*it] = scc[node];\r\n      dfs_scc(adj, used, scc, *it);\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n  while (1)\r\n  {\r\n    int v, e;\r\n    cin >> v;\r\n    if (v == 0) break;\r\n    assert(1 <= v && v <= 10000);\r\n    vvi adj(v);\r\n    cin >> e;\r\n    assert(0 <= e);\r\n    for (int i=0 ; i<e ; i++)\r\n    {\r\n      int from, to;\r\n      cin >> from >> to;\r\n      assert(1 <= from && from <= v);\r\n      assert(1 <= to && to <= v);\r\n      adj[from-1].push_back(to-1);\r\n    }\r\n    // Transpose the graph.\r\n    vvi transpose(v);\r\n    for (int i=0 ; i<v ; i++)\r\n      for (vit it = adj[i].begin() ; it != adj[i].end() ; ++it)\r\n        transpose[*it].push_back(i);\r\n    // Sort the nodes in reverse topological order (not a DAG yet).\r\n    vi topsort;\r\n    {\r\n      vb used(v, false);\r\n      for (int i=0 ; i<v ; i++)\r\n        if (!used[i])\r\n          dfs_topsort(adj, used, topsort, i);\r\n      assert((int)topsort.size() == v);\r\n    }\r\n    // Calculate the SCCs.\r\n    vi scc(v);\r\n    {\r\n      vb used(v, false);\r\n      for (int j=v-1 ; j>=0 ; j--)\r\n      {\r\n        int i = topsort[j];\r\n        if (!used[i])\r\n        {\r\n          scc[i] = i;\r\n          dfs_scc(transpose, used, scc, i);\r\n        }\r\n      }\r\n    }\r\n    // Node i represents a strongly connected component if scc[i] == i.\r\n    // The edges between the SCCs in their DAG are not directly available.\r\n    // If an edge leave the SCC, its source is not a sink.\r\n    vb sink(v, true);\r\n    for (int i=0 ; i<v ; i++)\r\n      for (vit it = adj[i].begin() ; it != adj[i].end() ; ++it)\r\n        if (scc[i] != scc[*it])\r\n          sink[scc[i]] = false;\r\n    bool first = true;\r\n    for (int i=0 ; i<v ; i++)\r\n      if (sink[scc[i]])\r\n        if (first)\r\n          first = false, cout << i+1;\r\n        else\r\n          cout << " " << i+1;\r\n    cout << endl;\r\n  }\r\n  return 0;\r\n}\r\n\r\n', '', 202, 1081344, 1, 2, '2010-08-07 02:06:08', '2010-08-07 02:06:08'),
(7, 1, 1, 0, '1', 'srcfile:1:1: error: expected identifier or ''('' before numeric constant\r\n', 0, 0, 2, 1, '2010-05-31 15:12:44', '2010-08-08 10:38:45'),
(8, 1, 1, 0, '#include<iostream>\r\nusing namespace std;\r\nint main()\r\n{\r\n   int i,j;\r\n   while(cin>>i>>j)\r\n   {\r\n       cout<<i+j<<endl;\r\n   } \r\n    return 0;\r\n}', '', 0, 368640, 3, 2, '2010-06-01 14:48:58', '2010-08-08 10:38:38'),
(9, 1, 3, 0, '// Problem   Assistance Required\r\n// Algorithm Precalculation\r\n// Runtime   O(n*l[n])\r\n// Author    Walter Guttmann\r\n// Date      16.07.2000\r\n\r\n#include <fstream>\r\n#include <iostream>\r\n\r\nusing namespace std;\r\n\r\n//ifstream in ("assist.in");\r\n\r\nconst int maxl = 33810;\r\n\r\nint l[4096];\r\nbool b[maxl];\r\n\r\nint main ()\r\n{\r\n  // precalculate all lucky numbers (the 3000th one is 33809) by simulation\r\n  // this would also suit the "Freiburg Method" for larger values of n\r\n  for (int i=0 ; i<maxl ; i++)\r\n    b[i] = true;\r\n  for (int n=1,start=1 ; n<=3000; n++)\r\n  {\r\n    ++start;\r\n    while (!b[start]) ++start;\r\n    l[n] = start;\r\n    for (int m=start ; m<maxl ; )\r\n    {\r\n      b[m] = false;\r\n      for (int i=0 ; i<start ; i++)\r\n      {\r\n        ++m;\r\n        while (m<maxl && !b[m]) ++m;\r\n      }\r\n    }\r\n  }\r\n  while (1)\r\n  {\r\n    int n;\r\n    cin >> n;\r\n    if (n == 0) break;\r\n    cout << l[n] << endl;\r\n  }\r\n  return 0;\r\n}\r\n\r\n', '', 343, 417792, 1, 2, '2010-08-06 08:03:47', '2010-08-06 08:03:47'),
(11, 1, 5, 0, '// Problem   Fixed Partition Contest Management\r\n// Algorithm Brute Force\r\n// Runtime   O(m^n*n^2)\r\n// Author    Walter Guttmann\r\n// Date      22.02.2003\r\n\r\n#include <cassert>\r\n#include <cmath>\r\n#include <fstream>\r\n#include <iostream>\r\n\r\nusing namespace std;\r\n\r\n//ifstream in ("contest.in");\r\n\r\nint main ()\r\n{\r\n  cout.setf(ios::fixed);\r\n  cout.precision(2);\r\n  for (int kase=1 ; ; kase++)\r\n  {\r\n    int m, n;\r\n    cin >> m >> n;\r\n    if (n == 0 && m == 0) break;\r\n    assert(1 <= m && m <= 3);\r\n    assert(1 <= n && n <= 10);\r\n    int bright[16];\r\n    for (int h=1 ; h<=m ; h++)\r\n    {\r\n      cin >> bright[h];\r\n      assert(1 <= bright[h]);\r\n    }\r\n    // IF soltime[j][h] == 0 THEN problem j cannot be solved by member h\r\n    // ELSE problem j requires time soltime[j][h] if solved by member h\r\n    int soltime[64][16];\r\n    for (int j=1 ; j<=n ; j++)\r\n    {\r\n      int k;\r\n      cin >> k;\r\n      assert(1 <= k && k <= 10);\r\n      int s[16], t[16];\r\n      for (int i=1 ; i<=k ; i++)\r\n      {\r\n        cin >> s[i] >> t[i];\r\n        assert(1 <= s[i]);\r\n        assert(1 <= t[i]);\r\n      }\r\n      for (int i=1 ; i<=k-1 ; i++)\r\n        assert(s[i] < s[i+1]);\r\n      for (int h=1 ; h<=m ; h++)\r\n      {\r\n        soltime[j][h] = 0;\r\n        for (int i=1 ; i<=k-1 ; i++)\r\n          if (s[i] <= bright[h] && bright[h] < s[i+1])\r\n            soltime[j][h] = t[i];\r\n        if (s[k] <= bright[h])\r\n          soltime[j][h] = t[k];\r\n      }\r\n    }\r\n    int minsumtime = 0, minassign[64], minptime[64];\r\n    // try all m^n assignments of problems to team members\r\n    int mn = 1;\r\n    for (int j=1 ; j<=n ; j++)\r\n      mn *= m;\r\n    for (int q=0 ; q<mn ; q++)\r\n    {\r\n      // in this assignment problem j is assigned to member assign[j]\r\n      int assign[64];\r\n      for (int j=1,qq=q ; j<=n ; j++,qq/=m)\r\n        assign[j] = 1 + qq%m;\r\n      // all problems must be solvable by the assigned members\r\n      bool valid = true;\r\n      for (int j=1 ; j<=n ; j++)\r\n        if (soltime[j][assign[j]] == 0)\r\n          valid = false;\r\n      if (!valid)\r\n        continue;\r\n      // for each member, problems with shorter solution times are solved first\r\n      int sumtime = 0;\r\n      int ptime[64];\r\n      for (int j1=1 ; j1<=n ; j1++)\r\n      {\r\n        int h = assign[j1];\r\n        ptime[j1] = 0;\r\n        for (int j2=1 ; j2<=n ; j2++)\r\n          if (assign[j2] == h)\r\n            if (soltime[j2][h] < soltime[j1][h] ||\r\n                soltime[j2][h] == soltime[j1][h] && j2 <= j1)\r\n              ptime[j1] += soltime[j2][h];\r\n        sumtime += ptime[j1];\r\n      }\r\n      if (minsumtime == 0 || sumtime < minsumtime)\r\n      {\r\n        minsumtime = sumtime;\r\n        for (int j=1 ; j<=n ; j++)\r\n        {\r\n          minassign[j] = assign[j];\r\n          minptime[j] = ptime[j];\r\n        }\r\n      }\r\n    }\r\n    double avgtime = (double) minsumtime / n;\r\n    avgtime = floor(avgtime * 100.0 + 0.5) / 100.0;\r\n    cout << "Case " << kase << endl;\r\n    cout << "Average solution time = " << avgtime << endl;\r\n    for (int j=1 ; j<=n ; j++)\r\n      cout << "Problem " << j << " is solved by member " << minassign[j]\r\n           << " from " << minptime[j]-soltime[j][minassign[j]]\r\n           << " to " << minptime[j] << endl;\r\n    cout << endl;\r\n  }\r\n  return 0;\r\n}\r\n\r\n', '', 249, 364544, 1, 2, '2010-08-07 02:08:58', '2010-08-07 02:08:58'),
(12, 1, 6, 0, '// Problem   Drink\r\n// Algorithm Simulation\r\n// Runtime   O(1)\r\n// Author    Walter Guttmann\r\n// Date      24.01.2003\r\n\r\n#include <cassert>\r\n#include <fstream>\r\n#include <iostream>\r\n\r\nusing namespace std;\r\n\r\n//ifstream in ("drink.in");\r\n\r\nconst double cw = 4.19;\r\nconst double ci = 2.09;\r\nconst double em = 335.0;\r\n\r\nint main ()\r\n{\r\n  cout.setf(ios::fixed);\r\n  cout.precision(1);\r\n  while (1)\r\n  {\r\n    double mw, mi, tw, ti;\r\n    cin >> mw >> mi >> tw >> ti;\r\n    if (mw == 0.0 && mi == 0.0 && tw == 0.0 && ti == 0.0)\r\n      break;\r\n    assert(mw >= 0.0 && mi >= 0.0 && mw + mi > 0.0);\r\n    assert(0.0 <= tw && tw < 100.0 && -30.0 < ti && ti <= 0.0);\r\n\r\n    double water0 = cw * mw * tw;\r\n    double ice0 = ci * mi * (- ti);\r\n    if (water0 <= ice0)\r\n    {\r\n      // cool water to zero\r\n      ice0 -= water0;\r\n      tw = 0.0;\r\n      ti = (- ice0) / (ci * mi);\r\n      // freeze some water\r\n      water0 = em * mw;\r\n      if (water0 <= ice0)\r\n      {\r\n        // freeze all water\r\n        ice0 -= water0;\r\n        ti = (- ice0) / (ci * mi);\r\n        // mw now denotes ice of temperature 0\r\n        // find equilibrium at temperature t where mi * t = mw * (tw - t)\r\n        ti = mi * ti / (mi + mw);\r\n        mi += mw;\r\n        mw = 0.0;\r\n      }\r\n      else\r\n      {\r\n        // heat ice to zero\r\n        ti = 0.0;\r\n        mw -= ice0 / em;\r\n        mi += ice0 / em;\r\n      }\r\n    }\r\n    else\r\n    {\r\n      // heat ice to zero\r\n      water0 -= ice0;\r\n      tw = water0 / (cw * mw);\r\n      ti = 0.0;\r\n      // melt some ice\r\n      ice0 = em * mi;\r\n      if (water0 <= ice0)\r\n      {\r\n        // cool water to zero\r\n        tw = 0.0;\r\n        mw += water0 / em;\r\n        mi -= water0 / em;\r\n      }\r\n      else\r\n      {\r\n        // melt all ice\r\n        water0 -= ice0;\r\n        tw = water0 / (cw * mw);\r\n        // mi now denotes water of temperature 0\r\n        // find equilibrium at temperature t where mi * t = mw * (tw - t)\r\n        tw = mw * tw / (mw + mi);\r\n        mw += mi;\r\n        mi = 0.0;\r\n      }\r\n    }\r\n\r\n    cout << mi << " g of ice and "\r\n         << mw << " g of water at "\r\n         << ti+tw << " C" << endl;\r\n  }\r\n  return 0;\r\n}\r\n', '', 0, 368640, 1, 2, '2010-08-07 02:13:50', '2010-08-07 02:13:50'),
(13, 1, 7, 0, '// Problem   Edge\r\n// Algorithm Straight-Forward\r\n// Runtime   O(n)\r\n// Author    Walter Guttmann\r\n// Date      05.01.2003\r\n\r\n#include <complex>\r\n#include <fstream>\r\n#include <iostream>\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\ntypedef complex<double> comp;\r\n\r\n//ifstream in ("edge.in");\r\n\r\nint main ()\r\n{\r\n  string s;\r\n  while (cin >> s)\r\n  {\r\n    cout << "300 420 moveto" << endl;\r\n    cout << "310 420 lineto" << endl;\r\n    comp pos(310, 420), d(10, 0);\r\n    for (string::iterator it = s.begin() ; it != s.end() ; ++it)\r\n    {\r\n      switch (*it)\r\n      {\r\n        case ''A'': pos += (d *= comp(0, -1)); break;\r\n        case ''V'': pos += (d *= comp(0, 1)); break;\r\n        default: throw;\r\n      }\r\n      cout << pos.real() << " " << pos.imag() << " lineto" << endl;\r\n    }\r\n    cout << "stroke" << endl;\r\n    cout << "showpage" << endl;\r\n  }\r\n  return 0;\r\n}\r\n', '', 31, 364544, 1, 2, '2010-08-07 02:17:02', '2010-08-07 02:17:02'),
(14, 1, 8, 0, '// Problem   Fold\r\n// Algorithm Dynamic Programming\r\n// Runtime   O(n^3)\r\n// Author    Walter Guttmann\r\n// Date      21.04.2003\r\n\r\n#include <cassert>\r\n#include <fstream>\r\n#include <iostream>\r\n#include <string>\r\n#include <vector>\r\n\r\nusing namespace std;\r\n\r\n//ifstream in("fold.in");\r\n\r\ntypedef vector<int> vi;\r\ntypedef vector<vi> vvi;\r\n\r\nbool av(char c1, char c2)\r\n{\r\n  return c1==''A'' && c2==''V'' || c1==''V'' && c2==''A'';\r\n}\r\n\r\nint main()\r\n{\r\n  string s;\r\n  while (cin >> s)\r\n  {\r\n    int n = s.size();\r\n    vi match(n, 0);\r\n    // match[i] is the maximal d such that s[i-d..i-1] and s[i+1..i+d]\r\n    // are reverse complementary, i.e., the 2*(d+1) stripes i-d..i\r\n    // and i+1..i+d+1 can be folded upon each other.\r\n    for (int k=0 ; k<n ; k++)\r\n      for (int i=k-1,j=k+1 ; 0<=i && j<n && av(s[i], s[j]) ; i--,j++)\r\n        ++match[k];\r\n    ++n;\r\n    vvi dp(n, vi(n, 0));\r\n    // dp[i][j], where i<=j, is the minimum number of folding steps\r\n    // required to produce the turns between stripes i and j,\r\n    // inclusively, i.e., those described in s[i..j-1].\r\n    for (int d=1 ; d<n ; d++)\r\n      for (int i=0,j=i+d ; j<n ; i++,j++)\r\n      {\r\n        dp[i][j] = n;\r\n        for (int k=i,l=k+1 ; k<j ; k++,l++)\r\n          if (match[k] >= min(k-i, j-l))\r\n            dp[i][j] = min(dp[i][j], 1+max(dp[i][k], dp[l][j]));\r\n        assert(dp[i][j] < n);\r\n      }\r\n    cout << dp[0][n-1] << endl;\r\n  }\r\n  return 0;\r\n}\r\n', '', 31, 659456, 1, 2, '2010-08-07 02:19:34', '2010-08-07 02:19:34'),
(15, 1, 9, 0, '// Problem   Genetic Code\r\n// Algorithm Backtracking\r\n// Runtime   O(3^n)\r\n// Author    Walter Guttmann\r\n// Date      12.03.2003\r\n\r\n#include <cassert>\r\n#include <cstring>\r\n#include <fstream>\r\n#include <iostream>\r\n\r\nusing namespace std;\r\n\r\n//ifstream in("genetic.in");\r\n\r\nchar s[8192], *end=s, *target=s+5000;\r\n\r\nbool isThue()\r\n{\r\n  for (int len=1 ; end-len-len>=s ; len++)\r\n    if (strncmp(end-len-len, end-len, len) == 0)\r\n      return false;\r\n  return true;\r\n}\r\n\r\nbool backtrack()\r\n{\r\n  if (end == target)\r\n    return true;\r\n  ++end;\r\n  for (end[-1]=''N'' ; end[-1]<=''P'' ; end[-1]++)\r\n    if (isThue() && backtrack())\r\n      return true;\r\n  --end;\r\n  return false;\r\n}\r\n\r\nint main()\r\n{\r\n  backtrack();\r\n  int n;\r\n  while (cin >> n)\r\n  {\r\n    if (n == 0) break;\r\n    assert(1 <= n && n <= 5000);\r\n    printf("%.*s\\n", n, s);\r\n  }\r\n  return 0;\r\n}\r\n\r\n', '', 124, 413696, 1, 2, '2010-08-07 02:21:34', '2010-08-07 02:21:34'),
(16, 1, 10, 0, '// Problem   Histogram\r\n// Algorithm Recursive\r\n// Runtime   O(n)\r\n// Author    Walter Guttmann\r\n// Date      12.01.2003\r\n\r\n#include <algorithm>\r\n#include <cassert>\r\n#include <fstream>\r\n#include <iostream>\r\n\r\nusing namespace std;\r\n\r\n//ifstream in("histogram.in");\r\n\r\ndouble h[1048576], max_area;\r\nint n;\r\n\r\n// Let r'' be the right-most rectangle such that for all r<=i<=r'': low<=h[i].\r\n// Then a call calc_max_area(r, left, low) updates max_area by considering\r\n// the largest rectangles in the histogram in the intervals\r\n// (1) [i..j] where r<=i<=j<=r'', and\r\n// (2) [left..j] where r<=j<=r'',\r\n// assuming that for all left<=i<=r: h[r]<=h[i], i.e., we can extend any\r\n// rectangle in the interval [r..j] to the interval [left..j] for r<=j<=r''\r\n// without lowering its height. The return value is 1+r''.\r\n\r\nint calc_max_area(int r, int left, double low)\r\n{\r\n  assert(left <= r);\r\n  assert(low <= h[r]);\r\n  int next = r+1;\r\n  if (next < n && h[r] < h[next])\r\n    next = calc_max_area(next, next, h[r]+1);\r\n  assert(next == n || h[next] <= h[r]);\r\n  max_area = max(max_area, (next-left)*h[r]);\r\n  return (next == n || h[next] < low) ? next : calc_max_area(next, left, low);\r\n}\r\n\r\nint main()\r\n{\r\n  cout.setf(ios::fixed);\r\n  cout.precision(0);\r\n  while (cin >> n)\r\n  {\r\n    if (n == 0) break;\r\n    assert(1 <= n && n <= 100000);\r\n    for (int i=0 ; i<n ; i++)\r\n     cin >> h[i];\r\n    max_area = 0;\r\n    assert(calc_max_area(0, 0, 0) == n);\r\n    cout << max_area << endl;\r\n  }\r\n  return 0;\r\n}\r\n', '', 1000, 33554432, 5, 2, '2010-08-07 02:27:40', '2010-08-07 02:27:40'),
(17, 1, 10, 0, '#include <stdio.h>\r\n\r\n#define MAXVAL 0x100000\r\n\r\n#define LONG long long int\r\n#define MAX(x, y) (((x)<=(y))?(y):(x))\r\n#define MIN(x, y) (((x)>(y))?(y):(x))\r\n\r\nint n;\r\nint h[2*MAXVAL];\r\nint minp, maxp, l;\r\nFILE *in;\r\nLONG maxres;\r\n\r\nvoid left(int p)\r\n{\r\n  if (p>=MAXVAL) { minp=p+1; return;}\r\n  if (h[2*p+1]<l) left(p*2+1);\r\n  else left(p*2);\r\n}\r\n\r\nvoid right(int p)\r\n{\r\n  if (p>=MAXVAL) { maxp=p; return;}\r\n  if (h[2*p]<l) right(p*2);\r\n  else right(p*2+1);\r\n}\r\n\r\nvoid leftup(int p)\r\n{\r\n  if (p==1) { minp=MAXVAL; return;}\r\n  if (!(p&(p-1))) { minp=MAXVAL; return;}\r\n  if (h[p-1]<l) {left(p-1); return;}\r\n  leftup(p/2);\r\n}\r\n\r\nvoid rightup(int p)\r\n{\r\n  if (p==1) { maxp=n+MAXVAL; return;}\r\n  if (!((p+1)&(p))) { maxp=n+MAXVAL; return;}\r\n  if (h[p+1]<l) {right(p+1); return;}\r\n  rightup(p/2);\r\n}\r\n\r\nint main()\r\n{\r\n	in=stdin;//fopen("f:/temp/histogram.in", "r");\r\n  while(1)\r\n    {\r\n      int i;\r\n      fscanf(in, " %d ", &n);\r\n      if (n==0) break;\r\n      if (n>=MAXVAL) {printf("Error\\n"); break;}\r\n      maxres=0;\r\n      for(i=MAXVAL; i<MAXVAL+n; i++) fscanf(in, " %d ", &h[i]);\r\n      for(i=MAXVAL+n; i<2*MAXVAL; i++) h[i]=2000000000;\r\n      for(i=MAXVAL-1; i>0; i--) h[i]=MIN(h[2*i], h[2*i+1]);\r\n      for(i=0; i<n; i++)\r\n        {\r\n          l=h[i+MAXVAL];\r\n          leftup(i+MAXVAL);\r\n          rightup(i+MAXVAL);\r\n          maxres=MAX(maxres, ((LONG)(maxp-minp))*((LONG)(h[i+MAXVAL])));\r\n	  // printf("* %lld %d %d\\n", ((LONG)(maxp-minp))*((LONG)(h[i+MAXVAL])), minp-MAXVAL, maxp-MAXVAL);\r\n        }\r\n      printf("%lld\\n", maxres);\r\n    }\r\n  return 0;\r\n}\r\n', '', 608, 8667136, 1, 1, '2010-08-07 02:54:30', '2010-08-07 02:54:30'),
(18, 1, 11, 0, '#include <stdio.h>\r\n#include <string.h>\r\n#include <stdlib.h>\r\n#include <math.h>\r\ntypedef struct\r\n{\r\n	int i,j,chaseNum;\r\n}chaseType;\r\nchaseType chase[10000];\r\nint cmp(const void *a,const void *b)\r\n{\r\n	chaseType *x=(chaseType *)a;\r\n	chaseType *y=(chaseType *)b;\r\n	if(x->chaseNum==y->chaseNum)\r\n		if(x->i==y->i) return x->j-y->j;\r\n		else return y->i-y->i;\r\n	return x->chaseNum-y->chaseNum;\r\n}\r\nint main()\r\n{\r\n	//freopen("Fat.in","r",stdin);\r\n	//freopen("Fat.out","w",stdout);\r\n	int n,k,i,index,j,temp;\r\n	long Opt[10000],maxNum;\r\n	scanf("%d%d",&n,&k);\r\n	while(n!=-1||k!=-1)\r\n	{\r\n		for(i=0;i<n;i++)\r\n			for(j=0;j<n;j++)\r\n			{\r\n				scanf("%d",&temp);\r\n				chase[i*n+j].chaseNum=temp;\r\n				chase[i*n+j].i=i;chase[i*n+j].j=j;\r\n			}\r\n		qsort(chase,n*n,sizeof(chaseType),cmp);\r\n		index=0;\r\n		while(chase[index].i!=0||chase[index].j!=0) index++;\r\n//		for(i=index;i<n*n;i++) printf("%d %d %d\\n",chase[i].i,chase[i].j,chase[i].chaseNum);\r\n		memset(Opt,0,sizeof(Opt));\r\n		Opt[index]=maxNum=chase[index].chaseNum;\r\n		for(i=index+1;i<n*n;i++)\r\n		{\r\n			for(j=i-1;j>=index;j--)\r\n				if(chase[j].chaseNum<chase[i].chaseNum&&((chase[j].i==chase[i].i&&abs(chase[j].j-chase[i].j)<=k)||(\r\n					chase[j].j==chase[i].j&&abs(chase[j].i-chase[i].i)<=k)))\r\n					if(Opt[i]<Opt[j]+chase[i].chaseNum&&Opt[j])\r\n						Opt[i]=Opt[j]+chase[i].chaseNum;\r\n			if(maxNum<Opt[i]) maxNum=Opt[i];\r\n		}\r\n		printf("%d\\n",maxNum);\r\n		scanf("%d%d",&n,&k);\r\n	}\r\n	return 0;\r\n}\r\n', '', 92, 380928, 1, 1, '2010-08-07 03:38:00', '2010-08-07 04:47:45'),
(19, 1, 12, 0, '#include <iostream>\r\nusing namespace std;\r\n//ifstream fin("Conductor.in");\r\n//ofstream fout("Conductor.out");\r\n//#define cout fout\r\n//#define cin fin\r\nint main()\r\n{\r\n	double p,q,min,max;\r\n	while(cin>>p>>q)\r\n	{\r\n		long num=1;\r\n		long a=0,b=0;\r\n		while(a>=b)\r\n		{\r\n			min=num*p/100;\r\n			max=num*q/100;\r\n			a=(long)min;\r\n			b=(long)max;\r\n			if(max-b==0) b--;\r\n			num++;\r\n		}\r\n		cout<<num-1<<endl;\r\n	}\r\n	return 0;\r\n}', '', 0, 364544, 1, 2, '2010-08-07 04:51:33', '2010-08-07 04:53:30'),
(20, 1, 13, 0, '#include <iostream>\r\nusing namespace std;\r\nint main()\r\n{\r\n	int a,b,c,d;\r\n	int N,i;\r\n	cin>>N;\r\n	for(i=0;i<N;i++)\r\n	{\r\n		cin>>a>>b>>c>>d;\r\n		cout<<"Scenario #"<<i+1<<":"<<endl;\r\n		if((a+b-c-d)%2==1)\r\n			cout<<"1"<<endl;\r\n		else \r\n			cout<<"0"<<endl;\r\n		cout<<endl;\r\n	}\r\n	return 0;\r\n}', '', 15, 368640, 1, 2, '2010-08-07 04:56:45', '2010-08-07 04:56:45'),
(21, 1, 14, 0, '#include <iostream>\r\nusing namespace std;\r\nlong n,m,p[50001],s[50001];\r\nlong Find(long k)\r\n{\r\n	if(p[k])\r\n	{\r\n		p[k]=Find(p[k]);\r\n		return p[k];\r\n	}\r\n	return k;\r\n}\r\nvoid Merge(long a,long b)\r\n{\r\n	long x,y;\r\n	x=Find(a);y=Find(b);\r\n	if(x!=y)\r\n		if(s[x]>=s[y])\r\n		{\r\n			p[y]=x;	s[x]=s[x]+s[y];\r\n		}\r\n		else\r\n		{\r\n			p[x]=y;	s[y]=s[x]+s[y];\r\n		}\r\n}\r\nint main()\r\n{\r\n	long i,a,b,count,k=1;;\r\n	cin>>n>>m;\r\n	while(n!=0||m!=0)\r\n	{\r\n		for(i=1;i<=n;i++) {p[i]=0;s[i]=1;}\r\n		for(i=0;i<m;i++)\r\n		{\r\n			cin>>a>>b;\r\n			Merge(a,b);\r\n		}\r\n		for(i=1,count=0;i<=n;i++)\r\n			if(!p[i]) count++;\r\n		cout<<"Case "<<k++<<": "<<count<<endl;\r\n		cin>>n>>m;\r\n	}\r\n	return 0;\r\n}', '', 15, 765952, 1, 2, '2010-08-07 04:59:20', '2010-08-08 10:38:39'),
(22, 1, 15, 0, '#include <stdio.h>\r\n#include <stack>\r\nusing namespace std;\r\nint main()\r\n{\r\n	//freopen("your.in","r",stdin);\r\n	//freopen("your.out","w",stdout);\r\n	char str[260],ch;\r\n	int T,i,len,pre,j,tmp;\r\n	stack<int> sPre;\r\n	scanf("%d",&T);getchar();\r\n	for(i=0;i<T;i++)\r\n	{\r\n		ch=getchar();\r\n		len=1;\r\n		while(ch!=''\\n'')\r\n		{\r\n			if(ch==''('')\r\n			{\r\n				sPre.push(len);\r\n				str[len++]=ch;\r\n			}\r\n			else if(ch=='')'')\r\n			{\r\n				pre=sPre.top()-1;\r\n				sPre.pop();\r\n				if(!pre||str[pre]==''(''||str[pre]=='' ''||str[pre]==''+'')\r\n					str[pre+1]='' '';\r\n				else if(str[pre]==''-'')\r\n				{\r\n					for(j=pre+2,tmp=0;j<len;j++)\r\n						if(str[j]>=''A''&&str[j]<=''Z'') tmp++;\r\n					if(tmp==1)\r\n						str[pre+1]='' '';\r\n					else str[len++]=ch;\r\n				}\r\n				else str[len++]=ch;\r\n			}\r\n			else if((ch>=''A''&&ch<=''Z'')||ch==''-''||ch==''+'')\r\n				str[len++]=ch;\r\n			ch=getchar();\r\n		}\r\n		for(j=1;j<len;j++)\r\n			if(str[j]!='' '') printf("%c",str[j]);\r\n		printf("\\n");\r\n	}\r\n	return 0;\r\n}\r\n\r\n', '', 15, 299008, 1, 2, '2010-08-07 05:01:19', '2010-08-07 05:01:19'),
(23, 1, 16, 0, '#include <string.h> \r\n#include <stdio.h>\r\n#include <queue> \r\nusing namespace std;\r\ntypedef struct{ \r\n   char ptr[500]; \r\n   int r; \r\n}NodeType;\r\nqueue <NodeType> q; \r\nint n;                 \r\nbool digit[10],r[5000];      \r\nchar str[500];\r\nvoid BFS() \r\n{ \r\n	int i; \r\n	NodeType temp,t; \r\n	for( i=1; i<10; i++) \r\n		if(digit[i])\r\n		{ \r\n			temp.r=i%n; \r\n			sprintf(temp.ptr,"%d",i);\r\n			q.push(temp); \r\n			r[temp.r]=true;\r\n			if(temp.r==0) sprintf(str,"%d",i);\r\n		}\r\n	while(!q.empty()&&!r[0])\r\n	{ \r\n		temp=q.front(); \r\n		q.pop(); \r\n		for(i=0; i<10; i++) \r\n			if(digit[i]&&r[(temp.r*10+i)%n]==false )\r\n			{\r\n				strcpy(t.ptr,temp.ptr); \r\n				sprintf(t.ptr+strlen(temp.ptr),"%d",i); \r\n				t.r=(temp.r*10+i)%n;\r\n				r[t.r]=true;\r\n				if(r[0])\r\n				{  \r\n					strcpy(str,t.ptr); \r\n					break; \r\n				}\r\n				q.push(t); \r\n			} \r\n    }\r\n	if(r[0])		\r\n		while(!q.empty())\r\n			q.pop(); \r\n} \r\n\r\nint main() \r\n{   \r\n	//freopen("Mul.in","r",stdin);\r\n	//freopen("Mul.out","w",stdout);\r\n	int digits,i,temp; \r\n	bool flag; \r\n	while(scanf("%d",&n)!=EOF)\r\n	{\r\n		scanf("%d",&digits);\r\n		memset(digit,false,sizeof(digit));\r\n		for(i=0; i<digits; i++)\r\n		{ \r\n			scanf("%d",&temp);\r\n			digit[temp]=true; \r\n		} \r\n		memset(r,false,sizeof(r));\r\n		flag=false;\r\n		if(n%2==0)\r\n		{\r\n			flag=true;\r\n			for(i=0;i<=8; i+=2) \r\n				if(digit[i]) flag=false;\r\n		}\r\n		if(flag) printf("0\\n");\r\n		else if(n==0)\r\n			printf("0\\n");\r\n		else\r\n		{\r\n			strcpy(str,"0");\r\n			BFS();\r\n			printf("%s\\n",str);\r\n		}\r\n	} \r\n    return 0; \r\n} \r\n\r\n', '', 0, 3010560, 1, 2, '2010-08-07 05:06:11', '2010-08-07 05:07:03'),
(24, 1, 17, 0, '#include <iostream>\r\n#include <string.h>\r\nusing namespace std;\r\n\r\nchar s[30][50];\r\ndouble D[30][30];\r\nint n;\r\nint FindIndex(char *str)\r\n{\r\n	int i=0;\r\n	while(i<n&&strcmp(s[i],str)!=0) i++;\r\n	return i;\r\n}\r\nint main()\r\n{\r\n	int m=1,i,j,k,edge;\r\n	double p;\r\n	cin>>n;\r\n	char str1[50],str2[50];\r\n	while(n!=0)\r\n	{\r\n		for(i=0;i<n;i++)\r\n			cin>>s[i];\r\n		memset(D,0,sizeof(D));\r\n		cin>>edge;\r\n		for(i=0;i<edge;i++)\r\n		{\r\n			cin>>str1>>p>>str2;\r\n			D[FindIndex(str1)][FindIndex(str2)]=p;\r\n		}\r\n		for(k=0;k<n;k++)\r\n			for(i=0;i<n;i++)\r\n				for(j=0;j<n;j++)\r\n					if(D[i][k]>0&&D[k][j]>0&&D[i][k]*D[k][j]>D[i][j])\r\n						 D[i][j]=D[i][k]*D[k][j];\r\n		cout<<"Case "<<m<<":";\r\n		bool flag=false;\r\n		for(i=0;i<n;i++)\r\n			if(D[i][i]>1)	\r\n			{\r\n				cout<<" Yes"<<endl;\r\n				flag=true;\r\n				break;\r\n\r\n			}\r\n		if(!flag) cout<<" No"<<endl;\r\n		m++;\r\n		cin>>n;\r\n	}\r\n	return 0;\r\n}', '', 233, 372736, 1, 2, '2010-08-07 05:12:19', '2010-08-10 08:28:06'),
(25, 1, 18, 0, '#include <iostream>\r\n#include <math.h>\r\nusing namespace std;\r\nint main()\r\n{\r\n	long N,i,m;\r\n	double y1,y2,temp,k;\r\n	while(cin>>N)\r\n	{\r\n		cin>>y1>>y2;\r\n		k=fabs(y1-y2);\r\n		m=1;i=3;\r\n		while(i<=N)\r\n		{\r\n			y1=y2;\r\n			cin>>y2;\r\n			temp=fabs(y1-y2);\r\n			if(temp>k)\r\n			{\r\n				k=temp;m=i-1;\r\n			}\r\n			i++;\r\n		}\r\n		cout<<m<<" "<<m+1<<endl;\r\n	}\r\n	return 0;\r\n}', '', 109, 364544, 1, 2, '2010-08-07 05:16:48', '2010-08-07 06:05:57'),
(26, 1, 19, 0, '#include<stdio.h>\r\n#include<string.h>\r\n#include<conio.h>\r\nint S;\r\n    \r\nvoid show(char *F)//用于输出数组，查看DP过程\r\n{\r\n    int i;\r\n    for( i=0;i<=S;i++)\r\n    {\r\n        printf("%-3d",i);\r\n    }\r\n    printf("\\n");\r\n    for(i=0;i<=S;i++)\r\n    {\r\n        printf("%-3d",F[i]);\r\n    }\r\n    printf("\\n");\r\n}\r\n\r\n//DP\r\nchar f(long total,long *a)\r\n{\r\n    int i;\r\n    char *F=new char[total+2];\r\n    char *F1=new char[total+2];//辅助数组\r\n\r\n    F[0]=1;    \r\n    long k1;\r\n\r\n    for(k1=1;k1<=total;k1++)\r\n    {\r\n        *(F+k1)=''0'';\r\n    }\r\n    F[total+1]=''\\0'';\r\n\r\n    for(i=0;i<6;i++) //价值从1-6\r\n    {\r\n        int j;\r\n        strcpy(F1,F);\r\n        //printf("1\\n");\r\n        //show(F);\r\n        //getch();\r\n        for(j=0;j<=total;j++)//背包的容量\r\n        {\r\n            int k;\r\n            if(F[j]==''0'') continue;\r\n            if(a[i]==0) break;\r\n            \r\n            for(k=1;k<=a[i];k++)//取k个价值为i的\r\n            {\r\n                //printf("2\\n");\r\n                //show(F1);\r\n                //getch();\r\n                if(j+(i+1)*k>total||F[j+(i+1)*k]==1) break;//优化的地方\r\n                else\r\n                {\r\n                    F1[j+(i+1)*k]=1;\r\n                    if(F1[total]==1) return 1;\r\n                }    \r\n            }    \r\n        }\r\n        strcpy(F,F1);\r\n        //printf("3\\n");\r\n        //show(F);\r\n        //getch();\r\n        if(F[total]==1) return 1;    \r\n    }\r\n    if(F[total]==1) return 1;\r\n    else return 0;    \r\n}    \r\nint main()\r\n{\r\n    long a[6];\r\n    int count=0,i;\r\n    while(1)\r\n    {\r\n        long total=0;\r\n        for(i=0;i<6;i++)\r\n        {\r\n            scanf("%ld",a+i);\r\n            total+=(i+1)*a[i];\r\n        }\r\n        if(a[0]==0&&a[1]==0&&a[2]==0&&a[3]==0&&a[4]==0&&a[5]==0) break;\r\n        printf("Collection #%d:\\n",++count);\r\n        int flag=-1;\r\n        if(total%2==0)\r\n        {\r\n            total=total/2;\r\n            S=total;\r\n            flag=f(total,a);\r\n        }    \r\n        else\r\n        {\r\n            flag=0;\r\n        }\r\n        if(flag==0){\r\n            printf("Can''t be divided.\\n");\r\n        }\r\n        else if(flag==1){\r\n            printf("Can be divided.\\n");\r\n        }\r\n        printf("\\n");      \r\n    }\r\n    //getch();    \r\n}    \r\n', '', 15, 409600, 1, 2, '2010-08-07 06:10:04', '2010-08-07 06:18:59'),
(27, 1, 20, 0, '#include<stdio.h>\r\n#define max 200\r\n#define infinity 32767\r\nint arcs[max][max];\r\nstruct tvexs{\r\n	int U;\r\n	int C;\r\n}vexs[max];\r\nint n,p,index=0;\r\nint T[max];\r\nint S[max];\r\nint wi[max];\r\nint layer[max];\r\nint main()\r\n{\r\n	while(scanf("%d%d",&n,&p)!=EOF)\r\n	{\r\n		int i;\r\n		int maxlayer=0;\r\n		for(i=0;i<max;i++)\r\n		{\r\n			layer[i]=0;\r\n		}\r\n		for(i=0;i<n;i++)\r\n		{\r\n			scanf("%d%d",&vexs[i].C,&vexs[i].U);\r\n		}\r\n		int v1,v2,w;\r\n		for(i=0;i<p;i++)\r\n		{\r\n			scanf("%d%d%d",&v1,&v2,&w);\r\n			v1--;v2--;\r\n			T[i]=v2;\r\n			S[i]=v1;\r\n			layer[v2]=layer[v1]+1;\r\n			if(maxlayer<layer[v2]) maxlayer=layer[v2];\r\n			wi[i]=w;\r\n		}\r\n		for(i=1;i<=maxlayer;i++)\r\n		{\r\n			for(int j=0;j<n;j++)\r\n			{\r\n				if(layer[j]==i)\r\n				{\r\n					for(int k=0;k<p;k++)\r\n					{\r\n						if(T[k]==j&&vexs[S[k]].C>0)\r\n						{\r\n							vexs[j].C+=vexs[S[k]].C*wi[k];							\r\n						}\r\n					}\r\n					vexs[j].C=vexs[j].C-vexs[j].U;\r\n				}\r\n			}\r\n		}\r\n		int count=0;\r\n		int temp[max];\r\n		int index=0;\r\n		for(i=0;i<n;i++)\r\n		{\r\n			if(layer[i]==maxlayer)\r\n			{\r\n				temp[index]=i;\r\n				index++;\r\n				if(vexs[i].C<=0) count++;\r\n			}\r\n		}\r\n		if(index==count) printf("NULL\\n");\r\n		else\r\n		{\r\n			for(i=0;i<index;i++)\r\n			{\r\n				if(vexs[temp[i]].C>0) printf("%d %d\\n",temp[i]+1,vexs[temp[i]].C);\r\n			}\r\n		}\r\n\r\n	}\r\n	return 0;\r\n}', '', 0, 425984, 1, 2, '2010-08-07 06:25:22', '2010-08-07 06:26:31'),
(28, 1, 21, 0, '#include <stdio.h>\r\nint main()\r\n{\r\n  long long n,N,i,j,sum;\r\n  while(scanf("%I64d",&n)==1){\r\n     switch(n)\r\n    {\r\n      case 6:\r\n      case 28:\r\n      case 496:\r\n      case 8128:\r\n      case 33550336:\r\n      case (long long)8589869056:\r\n      case (long long)137438691328:\r\n      case (long long)2305843008139952128:\r\n            printf("Yes!\\n"); break;\r\n      default:printf("No!\\n");break;\r\n    }\r\n  }\r\n} ', '', 0, 262144, 1, 2, '2010-08-07 07:04:51', '2010-08-07 07:21:06'),
(29, 1, 22, 0, '#include<stdio.h>\r\n/*#include<conio.h>*/\r\n\r\nint main()\r\n{\r\n    char c;\r\n    int i;\r\n    int t;\r\n	//freopen("letter_in.txt","r",stdin);\r\n    for(c=getchar();c!=-1;c=getchar())\r\n    {\r\n        if(c==''%''){\r\n            scanf("%d",&t);\r\n            for(i=0;i<t;i++) printf(" ");\r\n        }    \r\n        else if(c==''#''){\r\n            scanf("%d",&t);\r\n            for(i=0;i<t;i++) printf("\\n");\r\n        }    \r\n        else if(c==''@'') printf("\\n");\r\n        else if(c==''\\n''||c=='' '') break;\r\n        else printf("%c",c);\r\n    }\r\n    return 0;\r\n}    \r\n', '', 109, 258048, 1, 2, '2010-08-07 07:27:15', '2010-08-07 07:27:15'),
(30, 1, 23, 0, '#include<stdio.h>\r\n#include<stdlib.h>\r\nstruct xxb{\r\n	int x;\r\n	int y;\r\n}blank[4][4];\r\nchar a[5][5];\r\nint count;\r\nvoid run1(int i,int j,int n)\r\n{\r\n	int k;\r\n	for(k=0;k<n;k++)\r\n	{\r\n		blank[i][k].x=0;\r\n		blank[k][j].y=0;\r\n	}\r\n}\r\nvoid run2(int i,int j,int n)\r\n{\r\n	int k;\r\n	if(blank[i][j].x==0&&blank[i][j].y==0)\r\n	{\r\n		count++;\r\n		for(k=0;k<n;k++)\r\n		{\r\n			blank[i][k].x=1;\r\n			blank[k][j].y=1;\r\n		}\r\n	}\r\n}\r\n\r\nvoid run3(int i,int j,int n)\r\n{\r\n	int k;\r\n	if(i-1>=0&&a[i-1][j]==''.'')\r\n	{\r\n		if(blank[i-1][j].x==0&&blank[i-1][j].y==0)\r\n		{\r\n			count++;\r\n			a[i-1][j]=''+'';\r\n			for(k=0;k<n;k++) blank[i-1][k].x=1;\r\n			for(k=0;k<i;k++) blank[k][j].y=1;\r\n		}\r\n	}\r\n	if(i+1<n&&a[i+1][j]==''.'')\r\n	{\r\n		if(blank[i+1][j].x==0&&blank[i+1][j].y==0)\r\n		{\r\n			count++;\r\n			a[i+1][j]=''+'';\r\n			for(k=0;k<n;k++) blank[i+1][k].x=1;\r\n			for(k=i+1;k<n;k++) blank[k][j].y=1;\r\n		}\r\n	}\r\n	if(j-1>=0&&a[i][j-1]==''.'')\r\n	{\r\n		if(blank[i][j-1].x==0&&blank[i][j-1].y==0)\r\n		{\r\n			count++;\r\n			a[i][j-1]=''+'';\r\n			for(k=0;k<j;k++) blank[i][k].x=1;\r\n			for(k=0;k<n;k++) blank[k][j-1].y=1;\r\n		}\r\n	}\r\n	if(j+1<n&&a[i][j+1]==''.'')\r\n	{\r\n		if(blank[i][j+1].x==0&&blank[i][j+1].y==0)\r\n		{\r\n			count++;\r\n			a[i][j+1]=''+'';\r\n			for(k=j+1;k<n;k++) blank[i][k].x=1;\r\n			for(k=0;k<n;k++) blank[k][j+1].y=1;\r\n		}\r\n	}\r\n}\r\nint main()\r\n{\r\n	int n;\r\n	//freopen("fire_in.txt","r",stdin);\r\n	//freopen("fire_out.txt","w",stdout);\r\n	for(scanf("%d",&n);n!=0;scanf("%d",&n))\r\n	{\r\n		int i,j;\r\n		count=0;\r\n		for(i=0;i<n;i++)\r\n		{\r\n			for(j=0;j<n;j++)\r\n			{\r\n				blank[i][j].x=0;\r\n				blank[i][j].y=0;\r\n			}\r\n		}\r\n		for(i=0;i<n;i++) scanf("%s",a+i);\r\n		for(i=0;i<n;i++)\r\n		{\r\n			for(j=0;j<n;j++)\r\n			{\r\n				if(a[i][j]==''X'')\r\n				{\r\n					run1(i,j,n);\r\n					run3(i,j,n);\r\n				}\r\n			}\r\n		}\r\n		for(i=0;i<n;i++)\r\n		{\r\n			for(j=0;j<n;j++)\r\n			{\r\n				if(a[i][j]==''.'')\r\n				{\r\n					run2(i,j,n);\r\n				}\r\n			}\r\n		}\r\n		printf("%d\\n",count);\r\n	}\r\n	return 0;\r\n}', '', 171, 258048, 4, 2, '2010-08-07 07:32:59', '0001-01-01 00:00:00'),
(31, 1, 24, 0, '#include<stdio.h>\r\n#include<string.h>\r\nchar a[1024];\r\nint main()\r\n{\r\n	char str[11];\r\n	int flag=1;\r\n	int count=1;\r\n	//freopen("code_in.txt","r",stdin);\r\n	//freopen("code_out.txt","w",stdout);\r\n	while(scanf("%s",str)!=EOF)\r\n	{\r\n		if(strcmp(str,"9")==0)\r\n		{\r\n			for(int i=0;i<1025;i++)\r\n			{\r\n				a[i]=''0'';\r\n			}\r\n			if(flag)\r\n			{\r\n				printf("Set %d is immediately decodable\\n",count++);\r\n			}\r\n			else\r\n			{\r\n				printf("Set %d is not immediately decodable\\n",count++);\r\n			}\r\n			flag=1;\r\n		}\r\n		else if(flag)\r\n		{\r\n			int len=strlen(str);\r\n			int p=0;\r\n			for(int i=0;i<len;i++)\r\n			{\r\n				if(str[i]==''1'')\r\n				{\r\n					p=(p+1)*2;\r\n					if(a[p]==''1'')\r\n					{						\r\n						flag=0;\r\n						break;\r\n					}\r\n					else if(i==len-1)a[p]=''1'';\r\n				}\r\n				else if(str[i]==''0'')\r\n				{\r\n					p=2*(p+1)-1;\r\n					if(a[p]==''1'')\r\n					{\r\n						flag=0;\r\n						break;\r\n					}\r\n					else if(i==len-1)a[p]=''1'';\r\n				}\r\n			}\r\n		}\r\n\r\n	}\r\n	return 0;\r\n}', '', 0, 258048, 1, 2, '2010-08-07 07:38:28', '2010-08-07 07:38:28'),
(32, 1, 25, 0, '# include<iostream>\r\nusing namespace std;\r\n\r\n//ifstream fin("max.in");\r\n\r\n//# define cin fin\r\nconst int N=100;\r\nint array[N][N];\r\n\r\nint maxsum(int *b,int n)\r\n{\r\n	int max=0;\r\n	int a=0;\r\n	for(int i=0;i<n;i++)\r\n	{\r\n		if(a>0)\r\n			a+=*(b+i);\r\n		else\r\n			a=*(b+i);\r\n		if(a>max)\r\n			max=a;\r\n	}\r\n	return max;\r\n}\r\n\r\nvoid between(int i,int j,int *b,int n)\r\n{\r\n	int k=0;\r\n	int p;\r\n	for(k=0;k<n;k++)\r\n		*(b+k)=array[i][k];\r\n	for(p=i+1;p<=j;p++)\r\n		for(k=0;k<n;k++)\r\n			*(b+k)+=array[p][k];\r\n}\r\nint main()\r\n{\r\n	int n;\r\n	cin>>n;\r\n	\r\n		int i,j;\r\n		for(i=0;i<n;i++)\r\n			for(j=0;j<n;j++)\r\n				cin>>array[i][j];\r\n		int *b=new int[n]; \r\n		int sum=0;int max;\r\n		for(i=0;i<n;i++)\r\n		{\r\n			for(j=i+1;j<n;j++)\r\n			{\r\n				between(i,j,b,n);\r\n			    max=maxsum(b,n);\r\n			    if(max>sum)\r\n				   sum=max;\r\n			}\r\n		}\r\n		cout<<sum<<endl;\r\n	return 0;\r\n}\r\n', '', 0, 405504, 1, 2, '2010-08-07 07:44:53', '2010-08-07 07:48:07'),
(33, 1, 26, 0, '# include<iostream>\r\nusing namespace std;\r\n\r\nint res[6];\r\n\r\nint c=0;\r\nvoid f(int *a,int count,int start,int n)\r\n{\r\n	if(count==6)\r\n	{\r\n		cout<<res[0];\r\n		for(int i=1;i<6;i++)\r\n			cout<<" "<<res[i];\r\n		cout<<endl;\r\n		c++;\r\n		return;\r\n	}\r\n	if(start>=n)\r\n		return;\r\n	res[count]=a[start];\r\n	f(a,count+1,start+1,n);	\r\n	f(a,count,start+1,n);\r\n}\r\n	\r\nint main()\r\n{\r\n	int n,i;\r\n	bool flag=true;\r\n	while(cin>>n)\r\n	{\r\n		c=0;\r\n		if(n==0)\r\n			return 0;\r\n		int *a=new int[n];\r\n		for(i=0;i<n;i++)\r\n			cin>>a[i];\r\n	if(flag)\r\n		flag=false;\r\n	else\r\n		cout<<endl;\r\n		f(a,0,0,n);\r\n	cout<<c<<endl;\r\n	}\r\n	return 0;\r\n}', '', 15, 368640, 1, 2, '2010-08-07 07:50:47', '2010-08-10 09:01:52'),
(34, 1, 27, 0, '\r\n#include <stdlib.h>\r\n\r\n\r\n# include<iostream>\r\nusing namespace std;\r\nstruct Mouse{\r\n	int weight;\r\n	int speed;\r\n	int k;\r\n}Mouse;\r\n\r\nint d[1000][5];\r\n\r\nint compare(const void *a,const void *b)\r\n{\r\n    struct Mouse *x,*y;	\r\n     x=(struct Mouse *)a;\r\n    y=(struct Mouse *)b;\r\n    if(x->weight!=y->weight)\r\n      return  x->weight-y->weight;\r\n    else \r\n       return y->speed-x->speed;\r\n} \r\n\r\n\r\nint main()\r\n{\r\n   struct Mouse f[1000];\r\n   int n=0;\r\n   int w,s,i,j;\r\n   while(cin>>w>>s)\r\n   {\r\n       f[n].speed=s;\r\n	   f[n].weight=w;\r\n	   f[n].k=n+1;\r\n	   n++;\r\n   }\r\n   qsort(f,n,sizeof(Mouse),compare);\r\n   for(i=0;i<n;i++)\r\n   {\r\n	   d[i][0]=f[i].speed;\r\n	   d[i][1]=1;\r\n	   d[i][2]=0;\r\n	   d[i][3]=f[i].k;\r\n	   d[i][4]=f[i].weight;\r\n   }\r\n  for(i=n-2;i>=0;i--)\r\n  {\r\n	  int len=0,pos=0;\r\n	  for(j=i+1;j<n;j++)\r\n	  {\r\n		  if(d[i][0]>d[j][0]&&d[j][1]>len&&d[i][4]!=d[j][4])            //DP\r\n		  {\r\n			  len=d[j][1];\r\n			  pos=j;\r\n		  }\r\n	  }\r\n	  if(len>0)\r\n	  {\r\n		  d[i][1]=len+1;\r\n		  d[i][2]=pos;\r\n	  }\r\n  }\r\n  int max=d[0][1];\r\n  int p=0;\r\n  for(i=0;i<n;i++)\r\n  {\r\n	  if(d[i][1]>max)\r\n	  {\r\n		  max=d[i][1];\r\n		  p=i;\r\n	  }\r\n  }\r\n  cout<<max<<endl;\r\n/*  while(p!=0)\r\n  {\r\n	  cout<<d[p][3]<<endl;\r\n	  p=d[p][2];\r\n  } */\r\n  return 0;  \r\n}\r\n\r\n\r\n\r\n\r\n\r\n	   \r\n', '', 0, 385024, 1, 2, '2010-08-07 08:03:52', '2010-08-07 08:03:52'),
(35, 1, 28, 0, '# include<stdio.h>\r\nint main()\r\n{\r\n   double n=2;\r\n   double e=2.5;\r\n   int i;\r\n   printf("n e\\n"); \r\n   printf("- -----------\\n"); \r\n   printf("0 1\\n1 2\\n2 2.5\\n");\r\n   for(i=3;i<10;i++)\r\n   {\r\n	   n*=i;\r\n	   e+=1/n;\r\n	   printf("%d %.9lf\\n",i,e);\r\n   }\r\n   return 0;\r\n}', '', 0, 262144, 1, 2, '2010-08-07 08:10:10', '2010-08-07 08:10:10'),
(36, 1, 29, 0, '# include<iostream>\r\nusing namespace std;\r\nconst int MAX=32767;\r\nint score[5][5]={5,-1,-2,-1,-3,-1,5,-3,-2,-4,-2,-3,5,-2,-2,-1,-2,-2,5,-1,-3,-4,-2,-1,MAX};\r\n\r\nchar s1[100];\r\nchar s2[100];\r\n\r\nint f[200][200];\r\n\r\nint index(char s)\r\n{\r\n	if(s==''A'')\r\n		return 0;\r\n	if(s==''C'')\r\n		return 1;\r\n	if(s==''G'')\r\n		return 2;\r\n	if(s==''T'')\r\n		return 3;\r\n	if(s==''-'')\r\n		return 4;\r\n	return -1;\r\n}\r\nvoid doit()\r\n{\r\n	int len1,len2,i,j;\r\n	cin>>len1;\r\n	cin>>s1;\r\n	cin>>len2;\r\n	cin>>s2;\r\n	f[0][0]=0;\r\n	for(j=1;j<=len2;j++)\r\n		f[0][j]=f[0][j-1]+score[4][index(s2[j-1])];\r\n	for(i=1;i<=len1;i++)\r\n		f[i][0]=f[i-1][0]+score[index(s1[i-1])][4];\r\n	for(i=1;i<=len1;i++)\r\n		for(j=1;j<=len2;j++)\r\n		{\r\n			int a=f[i-1][j]+score[index(s1[i-1])][index(''-'')];\r\n			int b=f[i][j-1]+score[index(''-'')][index(s2[j-1])];\r\n			if(b>a)\r\n				a=b;\r\n			b=f[i-1][j-1]+score[index(s1[i-1])][index(s2[j-1])];\r\n			if(b>a)\r\n				a=b;\r\n			f[i][j]=a;\r\n		}\r\n		cout<<f[len1][len2]<<endl;\r\n}\r\n\r\nint main()\r\n{\r\n	int n;\r\n	cin>>n;\r\n	while(n--)\r\n	{\r\n		doit();\r\n	}\r\n	return 0;\r\n}\r\n\r\n\r\n\r\n', '', 0, 528384, 1, 2, '2010-08-07 08:14:08', '2010-08-07 08:14:52'),
(37, 1, 30, 0, '#include<math.h>\r\n#include<stdio.h>\r\n# include<iostream>\r\nusing namespace std;\r\n\r\n\r\nint main()\r\n{\r\ndouble x1,x2,x3,y1,y2,y3;\r\ndouble a,b,c,s,r,p;\r\n//freopen("circle.in","r",stdin);\r\nwhile(scanf("%lf %lf %lf %lf %lf %lf",&x1,&y1,&x2,&y2,&x3,&y3)!=EOF)\r\n{\r\n    a=sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));\r\n    b=sqrt((x1-x3)*(x1-x3)+(y1-y3)*(y1-y3));\r\n    c=sqrt((x2-x3)*(x2-x3)+(y2-y3)*(y2-y3));\r\n    p=(a+b+c)/2;\r\n    s=sqrt(p*(p-a)*(p-b)*(p-c));\r\n    r=a*b*c/(4*s);\r\n    p=2*3.141592653589793*r;\r\n    printf("%.2lf\\n",p);\r\n}\r\nreturn 0;\r\n}', '', 15, 368640, 1, 2, '2010-08-07 08:17:54', '2010-08-10 09:19:25'),
(38, 1, 31, 0, '#include <stdio.h>  //求解同余方程\r\n\r\nstruct container\r\n{\r\nint vol,sta;\r\n}a,b;\r\n\r\nvoid extended_euclid(int a,int b,int &x0, int &y0)  //a*x0+b*y0=gcd(a,b)    //b>a \r\n{\r\nint t;\r\n\r\nif(b==0)\r\n{\r\nx0 = 1; y0 = 0;\r\n}\r\nelse\r\n{\r\nextended_euclid(b,b%a,x0,y0);\r\nt = x0;\r\nx0 = y0;\r\ny0 = t-(a/b)*y0;\r\n}\r\n}\r\n\r\nvoid modular(int a,int b,int d,int &x,int &y) // a*x + b*y = d\r\n{\r\nint x0,y0;\r\n\r\nextended_euclid(a,b,x0,y0);\r\nx = x0*d%b;                        //x=(d/gcd)*x0+b/gcd*t\r\ny = (d-a*x)/b;                     //y=(d/gcd)*y0-a/gcd*t\r\n}\r\n\r\nvoid fill(char c,container &a)\r\n{\r\nprintf("fill %c\\n",c);\r\na.sta = a.vol;\r\n}\r\n\r\nvoid empty(char c,container &a)\r\n{\r\nprintf("empty %c\\n",c);\r\na.sta = 0;\r\n}\r\n\r\nvoid pour(char c1,char c2,container &a, container &b)\r\n{\r\nprintf("pour %c %c\\n",c1,c2);\r\nif(a.sta < b.vol-b.sta)\r\n{\r\nb.sta += a.sta;\r\na.sta = 0;\r\n}\r\nelse\r\n{\r\na.sta -= (b.vol-b.sta);\r\nb.sta = b.vol;\r\n}\r\n} \r\n\r\nint main()\r\n{\r\nint d,x,y;\r\n//freopen("jug.in","r",stdin);\r\nwhile(scanf("%d%d%d", &a.vol,&b.vol,&d)!=EOF)\r\n{\r\nmodular(a.vol,b.vol,d,x,y);\r\na.sta = b.sta = 0;\r\n\r\nif(x>0)\r\n{\r\ndo\r\n{\r\nif(a.sta==0)\r\nfill(''A'',a);\r\nelse\r\n{\r\nif(b.sta==b.vol)\r\nempty(''B'',b);\r\npour(''A'',''B'',a,b);\r\n} \r\n}while(a.sta!=d && b.sta!=d);\r\n} \r\nelse\r\n{\r\ndo\r\n{\r\nif(b.sta==0)\r\nfill(''B'',b);\r\nelse\r\n{\r\nif(a.sta==a.vol)\r\nempty(''A'',a);\r\npour(''B'',''A'',b,a);\r\n}\r\n}while(a.sta!=d && b.sta!=d);\r\n}\r\n\r\nprintf("success\\n"); \r\n}\r\nreturn 0;\r\n}\r\n', '', 0, 262144, 1, 2, '2010-08-07 08:20:19', '2010-08-07 08:20:19'),
(39, 1, 32, 0, '# include<stdio.h>\r\n# include<iostream>\r\nusing namespace std;\r\n\r\n\r\nint derect[8][2]={{-1,-2},{-2,-1},{-2,1},{-1,2},{1,2},{2,1},{2,-1},{1,-2}};\r\nchar D[64][64];\r\nconst int MAX=10;\r\nvoid init()\r\n{\r\n	int i,j,k,x,y,xx,yy;\r\n	for(i=0;i<64;i++)\r\n	  for(j=0;j<64;j++)\r\n	  {\r\n		  if(i==j)\r\n			  D[i][j]=0;\r\n		  else \r\n		      D[i][j]=MAX;\r\n	  }\r\n	for(i=0;i<64;i++)\r\n	{\r\n		x=i/8;\r\n		y=i%8;\r\n		for(j=0;j<8;j++)\r\n		{\r\n			xx=x+derect[j][0];\r\n			yy=y+derect[j][1];\r\n			if(xx>=0&&xx<8&&yy>=0&&yy<8)\r\n				D[i][xx*8+yy]=1;\r\n		}\r\n	}\r\n	for(k=0;k<64;k++)\r\n		for(i=0;i<64;i++)\r\n			for(j=0;j<64;j++)\r\n	          	if(D[i][j]>D[i][k]+D[k][j])\r\n				{\r\n					D[i][j]=D[i][k]+D[k][j];\r\n				}\r\n}\r\nint main()\r\n{\r\n   // freopen("knight.in","r",stdin);\r\n	char s[8];\r\n	int t1,t2;\r\n	init();\r\n   while(gets(s)!=NULL) \r\n   { \r\n     t1=(s[0]-''a'')*8+s[1]-''1''; \r\n     t2=(s[3]-''a'')*8+s[4]-''1''; \r\n     cout<<"To get from "<<s[0]<<s[1]<<" to "<<s[3]<<s[4]<<" takes "<<D[t1][t2]-0<<" knight moves."<<endl;\r\n//     printf("To get from %c%c to %c%c takes %d knight moves.\\n",s[0],s[1],s[3],s[4],D[t1][t2]); \r\n   }\r\n	return 0;\r\n\r\n}\r\n\r\n\r\n\r\n', '', 46, 372736, 1, 2, '2010-08-07 08:23:07', '2010-08-10 09:15:18'),
(40, 1, 33, 0, '# include<iostream>\r\nusing namespace std;\r\ntypedef struct point{\r\n	double x;\r\n	double y;\r\n	int flag;\r\n}point;\r\n\r\npoint P[151];\r\n\r\ndouble a,b,c;\r\ndouble x0,y0,r;\r\nvoid line(int i)\r\n{\r\n	if(x0==P[i].x)\r\n	{\r\n		a=1;\r\n		b=0;\r\n		c=x0;\r\n		return;\r\n	}\r\n	if(y0==P[i].y)\r\n	{\r\n		a=0;\r\n		b=1;\r\n		c=y0;\r\n		return;\r\n	}\r\n	a=-(P[i].y-y0)/(P[i].x-x0);\r\n	b=1;\r\n	c=a*x0+b*y0;\r\n}\r\nint main()\r\n{\r\n\r\n	int i,j;\r\n	while(cin>>x0>>y0>>r)\r\n	{\r\n		if(r<0)\r\n			return 0;\r\n		int n;\r\n		cin>>n;\r\n		for(i=0;i<n;i++)\r\n		{\r\n			cin>>P[i].x;\r\n			cin>>P[i].y;\r\n			if((P[i].x-x0)*(P[i].x-x0)+(P[i].y-y0)*(P[i].y-y0)>r*r)\r\n				P[i].flag=0;\r\n			else\r\n				P[i].flag=1;\r\n		}\r\n		int sum1,sum2;\r\n		int final=0;\r\n		for(i=0;i<n;i++)\r\n		{\r\n		\r\n			if(P[i].flag)\r\n			{\r\n			    line(i);\r\n		        sum1=0;\r\n		        sum2=0;\r\n		     	for(j=0;j<n;j++)\r\n				{\r\n				    if(a*P[j].x+b*P[j].y>=c&&P[j].flag)\r\n					  sum1++;\r\n			    	if(a*P[j].x+b*P[j].y<=c&&P[j].flag)\r\n					  sum2++;\r\n				}\r\n			 if(sum2>sum1)\r\n			    sum1=sum2;\r\n		     if(sum1>final)\r\n				final=sum1;\r\n			}\r\n		}\r\n		cout<<final<<endl;\r\n	}\r\n	return 0;\r\n}\r\n\r\n\r\n	\r\n\r\n\r\n		\r\n\r\n\r\n', '', 0, 368640, 1, 2, '2010-08-07 08:28:16', '2010-08-07 08:28:16'),
(41, 1, 34, 0, '#include<stdio.h>\r\n#include<string.h>\r\n#define MAX 100000\r\n\r\nchar s1[MAX],s2[MAX];\r\nlong len1,len2;\r\n\r\nint find(char *s1,char *s2,long p2);\r\n\r\nint main()\r\n{\r\n    while(scanf("%s%s",s1,s2)!=EOF)\r\n    {\r\n        len2=strlen(s1);\r\n        len1=strlen(s2);\r\n        if(find(s2,s1,0))\r\n            printf("Yes\\n");\r\n        else\r\n            printf("No\\n");\r\n    }\r\n    return 0;\r\n}\r\n\r\nint find(char *s1,char *s2,long p2){\r\n    //p2 from 0\r\n    char *p=strchr(s1,s2[p2]);\r\n    if(p)\r\n    {\r\n        if(p2==len2-1)\r\n            return 1;\r\n        if(strlen(p)<len2-p2)\r\n            return 0;\r\n        return find(p+1,s2,p2+1);\r\n    }\r\n    else\r\n        return 0;    \r\n}\r\n', '', 0, 458752, 1, 1, '2010-08-07 08:36:17', '2010-08-07 08:36:17'),
(42, 1, 35, 0, '#include<stdio.h>\r\n#include<math.h>\r\n#define PI 3.1415926\r\n\r\nint main()\r\n{\r\n    double g,c;\r\n    double g2,g22;\r\n    while(scanf("%lf%lf",&g,&c)!=EOF)\r\n    {\r\n        g2=0.5*g;\r\n        g22=sqrt(0.5*g*g);\r\n        if(c<=g2)\r\n            printf("%.3lf\\n",PI*c*c);\r\n        else if(c>=g22)\r\n            printf("%.3lf\\n",g*g);\r\n        else\r\n            printf("%.3lf\\n",PI*c*c+4*g2*sqrt(c*c-g2*g2)-4*c*c*acos(g2/c));\r\n    }\r\n    return 0;\r\n}\r\n', '', 15, 262144, 4, 1, '2010-08-07 08:38:09', '0001-01-01 00:00:00'),
(43, 1, 36, 0, '#include<stdio.h>\r\n#define N 1500\r\n\r\nlong U[N];\r\n\r\nlong min(long a,long b,long c);\r\nvoid getugly();\r\n\r\nint main()\r\n{\r\n    getugly();\r\n    printf("The %d''th ugly number is %ld.\\n",N,U[N-1]);\r\n    return 0;\r\n}\r\n\r\nlong min(long a,long b,long c)\r\n{\r\n    long temp=a<b?a:b;\r\n    temp=temp<c?temp:c;\r\n    return temp;\r\n}\r\n\r\nvoid getugly()\r\n{\r\n    int i=0;\r\n    U[i++]=1;\r\n    long tw=1,th=1,fi=1;\r\n    int ptw=0,pth=0,pfi=0;\r\n    for(;i<N;i++)\r\n    {\r\n        U[i]=min(2*tw,3*th,5*fi);\r\n        if(U[i]%2==0)\r\n            tw=U[++ptw];\r\n        if(U[i]%3==0)\r\n            th=U[++pth];\r\n        if(U[i]%5==0)\r\n            fi=U[++pfi];\r\n    }\r\n}\r\n', '', 0, 266240, 1, 1, '2010-08-07 08:42:46', '2010-08-07 08:49:15'),
(44, 1, 36, 0, '#include<stdio.h>\r\n\r\nint main()\r\n{\r\n    printf("The 1500''th ugly number is 859963392.\\n");\r\n    return 0;\r\n}\r\n', '', 0, 262144, 1, 1, '2010-08-07 08:43:06', '2010-08-07 08:48:50'),
(45, 1, 37, 0, '#include<stdio.h>\r\n#include<stdlib.h>\r\n\r\nstruct value{\r\n    int id;\r\n    double vv;\r\n};\r\n\r\nint comp(const void *a,const void *b);\r\n\r\nint main()\r\n{\r\n    int m,n;\r\n    int JF[1000][2];\r\n    struct value v[1000];\r\n    double mx;\r\n    int i;\r\n    while(1)\r\n    {\r\n        scanf("%d%d",&m,&n);\r\n        if(m==-1&&n==-1)\r\n            break;    \r\n        for(i=0;i<n;i++)\r\n        {\r\n           scanf("%d%d",&JF[i][0],&JF[i][1]);\r\n           v[i].id=i;\r\n           v[i].vv=1.0*JF[i][0]/JF[i][1];\r\n        }\r\n        if(m==0||n==0)\r\n        {\r\n            printf("0.000\\n");\r\n            continue;\r\n        }\r\n        \r\n        qsort(v,n,sizeof(value),comp);\r\n        mx=0;\r\n        for(i=0;i<n;i++)\r\n        {\r\n            if(m>JF[v[i].id][1])\r\n            {\r\n                mx+=JF[v[i].id][0];\r\n                m-=JF[v[i].id][1];\r\n            }\r\n            else\r\n            {\r\n                mx=mx+1.0*JF[v[i].id][0]*m/JF[v[i].id][1];\r\n                break;\r\n            }\r\n        }\r\n        printf("%.3lf\\n",mx);\r\n    }\r\n    return 0;\r\n}\r\n\r\nint comp(const void *a,const void *b){\r\n    value *x=(value *)a;\r\n    value *y=(value *)b;\r\n    return x->vv<y->vv;\r\n}\r\n\r\n\r\n//in\r\n//10 1\r\n//10 1\r\n//0 1\r\n//1 1\r\n//out\r\n//10.000\r\n//0.000\r\n', '', 0, 258048, 1, 2, '2010-08-07 08:45:35', '2010-08-07 08:47:45');
INSERT INTO `tbl_submitions` (`id`, `user_id`, `problem_id`, `exercise_id`, `source`, `result`, `used_time`, `used_memory`, `status`, `compiler_id`, `created`, `modified`) VALUES
(46, 1, 39, 0, '#include<stdio.h>\r\n#define MAX 1001\r\n#define INFINITY 4000\r\n\r\nint arcs[MAX][MAX];\r\nstruct node{\r\n    int adj;  //顶点 \r\n    int lowcost;  //权值 \r\n};\r\nnode closedge[MAX];\r\n\r\nint n;\r\nint p[MAX];\r\nlong total;\r\n\r\nvoid init();\r\nint minimum();\r\nvoid prim();\r\n\r\nint main()\r\n{\r\n    int t;\r\n    int k;\r\n    scanf("%d",&t);    \r\n    for(k=0;k<t;k++)\r\n    {\r\n        init();\r\n        prim();\r\n    }    \r\n    return 0;\r\n}\r\n\r\nvoid init()\r\n{\r\n    int i,j;\r\n    scanf("%d",&n);\r\n    for(i=1;i<=n;i++)\r\n        scanf("%d",&p[i]);\r\n    for(i=1;i<=n;i++)\r\n        for(j=1;j<=n;j++)\r\n        {\r\n            scanf("%d",&arcs[i][j]);\r\n            arcs[i][j]+=p[i]+p[j];\r\n        }\r\n    /*\r\n    for(i=1;i<=n;i++)\r\n    {\r\n        for(j=1;j<=n;j++)\r\n        {\r\n            printf("%d ",arcs[i][j]);\r\n            //arcs[i][j]+=p[i]+p[j];\r\n        }\r\n        printf("\\n");\r\n    }    \r\n    */\r\n    total=0;\r\n}\r\n\r\nint minimum()\r\n{\r\n    int min=INFINITY;\r\n    int k=0;\r\n    for(int i=1;i<=n;i++)\r\n        if(closedge[i].lowcost>0&&closedge[i].lowcost<min)\r\n            min=closedge[i].lowcost,k=i;\r\n    return k;\r\n}\r\n\r\nvoid prim()\r\n{\r\n    int i,j,k=1;\r\n    for(i=2;i<=n;i++)\r\n        closedge[i].adj=k,closedge[i].lowcost=arcs[k][i];  //{adjvex,lowcost}\r\n    closedge[k].lowcost=0;  //0表示已经进入最小生成树U\r\n    /*\r\n    for(i=1;i<=n;i++)\r\n        printf("closedge[%d]:%d %d\\n",i,closedge[i].adj,closedge[i].lowcost);\r\n    */\r\n    for(i=1;i<n;i++){  //选择其余n-1个点进入最小生成树 \r\n        k=minimum();\r\n        /*  k\r\n        printf("k:%d\\n",k);\r\n        */\r\n        total+=closedge[k].lowcost;\r\n        closedge[k].lowcost=0;\r\n        for(j=1;j<=n;j++)\r\n            if(closedge[j].lowcost>0&&closedge[j].lowcost>arcs[k][j])\r\n                closedge[j].adj=k,closedge[j].lowcost=arcs[k][j];\r\n    }//fori\r\n    printf("%ld\\n",total);\r\n}\r\n', '', 140, 4288512, 1, 2, '2010-08-07 08:53:23', '2010-08-07 08:53:23'),
(47, 1, 40, 0, '#include<stdio.h>\r\n#include<math.h>\r\n#define N 49\r\n\r\nint gcd(int,int);\r\n\r\nint main()\r\n{\r\n    int n;\r\n    int a[N];  //存储set\r\n    int s,c;  //数对个数 质数对个数\r\n    int i,j;\r\n    while(1)\r\n    {\r\n        scanf("%d",&n);\r\n        if(n==0)\r\n            break;\r\n        for(i=0;i<n;i++)\r\n            scanf("%d",&a[i]);\r\n        s=n*(n-1)/2;\r\n        c=0;\r\n        for(i=1;i<=n-1;i++)\r\n            for(j=0;j<i;j++)\r\n               if(gcd(a[i],a[j])==1)\r\n                  c++;\r\n        if(c==0)\r\n           printf("No estimate for this data set.\\n");\r\n        else\r\n           printf("%.6lf\\n",sqrt(6.0*s/c));\r\n    }\r\n    return 0;\r\n}\r\n\r\nint gcd(int u,int v)\r\n{\r\n    int r;\r\n    while(v!=0)\r\n    {\r\n        r=u%v;\r\n        u=v;\r\n        v=r;\r\n    }\r\n    return u;\r\n}\r\n', '', 0, 258048, 1, 1, '2010-08-07 08:55:05', '2010-08-07 08:55:05'),
(48, 1, 41, 0, '#include<stdio.h>\r\n#include<math.h>\r\n#define E0 1E-6\r\n\r\ndouble solve(int C);\r\n\r\nint main()\r\n{\r\n    int C;\r\n    while(scanf("%d",&C)!=EOF)\r\n        printf("%.3lf\\n",solve(C));\r\n    return 0;\r\n}\r\n\r\ndouble solve(int C){  //  牛顿迭代法\r\n    double x=1.0*C;\r\n    while(fabs(x*x*x+C*x-100)>E0)\r\n        x=(2*x*x*x+100)/(3*x*x+C);\r\n    return x;\r\n}\r\n', '', 0, 262144, 1, 1, '2010-08-07 08:56:58', '2010-08-07 08:56:58'),
(49, 1, 42, 0, '#include<stdio.h>\r\nmain(){\r\nprintf("**************************\\n");\r\nprintf("         Very    Good!\\n");\r\nprintf("**************************");\r\n\r\n}\r\n', '', 0, 258048, 1, 1, '2010-08-07 10:03:11', '2010-08-07 10:03:11'),
(50, 1, 43, 0, '#include<stdio.h>\r\nint max(int a,int b){\r\n return a>b?a:b;\r\n}\r\n\r\nint main(){\r\n int a,b,c;\r\n scanf("%d%d%d",&a,&b,&c);\r\n printf("%d",max(a,max(b,c)));\r\n return 0;\r\n}\r\n\r\n', '', 0, 258048, 1, 1, '2010-08-07 10:46:55', '2010-08-07 10:46:55'),
(51, 1, 44, 0, '#include <stdio.h>  \r\nmain()   \r\n{\r\nchar c1=''C'',c2=''h'',c3=''i'',c4=''n'',c5=''a'';  \r\n  c1+=4;  \r\n  c2+=4;  \r\n  c3+=4;  \r\n  c4+=4;  \r\n  c5+=4;  \r\n  printf("%c%c%c%c%c",c1,c2,c3,c4,c5);  \r\n}\r\n', '', 0, 258048, 1, 1, '2010-08-07 10:49:51', '2010-08-07 10:50:26'),
(52, 1, 45, 0, '#include <stdio.h>\r\nmain()  \r\n{float r,h,C1,Sa,Sb,Va,Vb;  \r\nscanf("%f %f",&r,&h);  \r\nC1=2*3.14*r;  \r\nSa=3.14*r*r;  \r\nSb=4*Sa;  \r\nVa=4*3.14*r*r*r/3;  \r\nVb=Sa*h;  \r\nprintf("C1=%.2f\\n",C1);  \r\nprintf("Sa=%.2f\\nSb=%.2f\\nVa=%.2f\\nVb=%.2f\\n",Sa,Sb,Va,Vb);  \r\n}\r\n', '', 0, 258048, 1, 1, '2010-08-07 10:53:15', '2010-08-07 10:53:15'),
(53, 1, 46, 0, '#include<stdio.h>\r\nmain()  \r\n{float F,c;  \r\nscanf("%f",&F);  \r\nc=5*(F-32)/9;  \r\nprintf("c=%.2f",c);  \r\n}\r\n', '', 0, 258048, 1, 1, '2010-08-07 10:56:39', '0001-01-01 00:00:00'),
(54, 4, 1, 0, '#include<stdio.h>\r\nmain(){int a,b;while(scanf("%d%d",&a,&b)==2)printf("%d\\n",a+b);}', '', 0, 262144, 3, 1, '2010-08-07 11:40:27', '2010-08-08 10:37:30'),
(55, 4, 1, 0, 'main()\r\n{int a,b;scanf("%d%d",&a,&b);printf("%d",a+b);}', '', 0, 262144, 1, 1, '2010-08-07 11:41:37', '2010-08-08 10:37:27'),
(60, 1, 47, 0, '#include<stdio.h>\r\nint max(int a,int b){\r\n return a>b?a:b;\r\n}\r\n\r\nint main(){\r\n int a,b,c;\r\n scanf("%d%d%d",&a,&b,&c);\r\n printf("%d",max(a,max(b,c)));\r\n return 0;\r\n}\r\n\r\n', '', 0, 258048, 1, 1, '2010-08-07 14:43:30', '2010-08-08 10:37:16'),
(56, 4, 1, 0, '#include<stdio.h>\r\nmain()\r\n{int a,b;scanf("%d%d",&a,&b);printf("%d",a+b);}', '', 0, 262144, 1, 1, '2010-08-07 11:42:34', '2010-08-08 10:37:19'),
(57, 4, 1, 0, '#include<stdio.h>\r\nint main()\r\n{\r\n  int a,b;\r\n  scanf("%d%d",&a,&b);\r\n  printf("%d",a+b);\r\n  return 0;\r\n}', '', 0, 262144, 1, 1, '2010-08-07 11:44:22', '2010-08-08 10:37:19'),
(58, 4, 1, 0, '#include<stdio.h>\r\nint main()\r\n{\r\n  int a,b;\r\n  scanf("%d%d",&a,&b);\r\n  printf("%d",a+b);\r\n  return 0;\r\n}', '', 0, 262144, 1, 2, '2010-08-07 11:44:50', '2010-08-08 10:37:18'),
(59, 4, 1, 0, 'int main()\r\n{\r\n  int a,b;\r\n  scanf("%d%d",&a,&b);\r\n  printf("%d",a+b);\r\n  return 0;\r\n}', '', 0, 262144, 1, 1, '2010-08-07 11:45:18', '2010-08-08 10:37:17'),
(61, 1, 48, 0, '#include<stdio.h>\r\nint f(int x){\r\n  if(x<1) return x;\r\n  if(x>=1&&x<10) return x*2-1;\r\n  return x*3-11;\r\n}\r\nint main(){\r\n  int a;\r\n  scanf("%d",&a);\r\n  printf("%d",f(a));\r\n  return 0;\r\n}\r\n\r\n', '', 0, 258048, 1, 1, '2010-08-07 14:47:55', '2010-08-08 10:37:16'),
(62, 1, 49, 0, '#include<stdio.h>\r\nchar f(int x){\r\n  if(x<60) return ''E'';\r\n  if(x>=60&&x<70) return ''D'';\r\n  if(x>=70&&x<80) return ''C'';\r\n  if(x>=80&&x<90) return ''B'';\r\n  return ''A'';\r\n}\r\nint main(){\r\n  int a;\r\n  scanf("%d",&a);\r\n  printf("%c",f(a));\r\n  return 0;\r\n}\r\n\r\n', '', 30, 262144, 1, 1, '2010-08-07 14:52:10', '2010-08-08 10:37:14'),
(63, 1, 50, 0, '#include <stdio.h>\r\n#include <string.h>\r\nint main(){\r\n  char a[10];\r\n  int i,l;\r\n  scanf("%s",a);\r\n  l=strlen(a);\r\n  printf("%d\\n",l);\r\n  for(i=0;i<l-1;i++)\r\n  printf("%c ",a[i]);\r\n  printf("%c\\n",a[i]);\r\n  for(i=l-1;i>=0;i--)\r\n  printf("%c",a[i]);\r\n  \r\n  \r\n  return 0;\r\n}\r\n\r\n', '', 0, 262144, 1, 1, '2010-08-07 14:56:04', '2010-08-08 10:37:12'),
(64, 1, 51, 0, '#include <stdio.h>\r\nint main()\r\n{\r\n	int n;\r\n	double m=0;\r\n	scanf("%d",&n);\r\n\r\n	if(n>1000000)\r\n	{\r\n		m += (n-1000000)*0.01;\r\n		n = 1000000;\r\n	}\r\n	if(n>600000)\r\n	{\r\n		m += (n-600000)*0.015;\r\n		n = 600000;\r\n	}\r\n	if(n>400000)\r\n	{\r\n		m += (n-400000)*0.03;\r\n		n = 400000;\r\n	}\r\n	if(n>200000)\r\n	{\r\n		m += (n-200000)*0.05;\r\n		n = 200000;\r\n	}\r\n	if(n>100000)\r\n	{\r\n		m += (n-100000)*0.075;\r\n		n = 100000;\r\n	}\r\n	m += n*0.1;\r\n	printf("%d",(int)m);\r\n	return 0;\r\n}\r\n', '', 0, 258048, 1, 1, '2010-08-07 14:58:34', '2010-08-08 10:37:10'),
(65, 1, 52, 0, '#include<stdio.h>\r\nint main()\r\n{\r\n	int p,r,n,m,temp;\r\n	scanf("%d %d",&m,&n);\r\n	if(n<m)\r\n	{\r\n		temp=n;\r\n		n=m;\r\n		m=temp;\r\n	}\r\n	p=n*m;\r\n	while(m!=0)\r\n	{\r\n		r=n%m;\r\n		n=m;\r\n		m=r;\r\n	}\r\n	printf("%d %d",n,p/n);\r\nreturn 0;\r\n}\r\n', '', 0, 262144, 1, 1, '2010-08-07 15:09:11', '2010-08-07 15:09:11'),
(66, 1, 53, 0, '#include"stdio.h"  \r\nmain()  \r\n{char c;int i=0,j=0,k=0,l=0;  \r\nwhile((c=getchar())!=''\\n'')  \r\n{if(c>=65&&c<=90||c>=97&&c<=122) i++;  \r\nelse if(c>=48&&c<=57) j++;  \r\nelse if(c==32) k++;  \r\nelse l++;}  \r\nprintf("%d %d %d %d",i,j,k,l);  \r\n}\r\n', '', 0, 258048, 1, 1, '2010-08-07 15:11:47', '2010-08-07 15:11:47'),
(67, 1, 54, 0, '#include"stdio.h"  \r\n#include"math.h"  \r\nmain()  \r\n{int n,sum=0,i=1,s=2;  \r\nscanf("%d",&n);  \r\nwhile(i<=n)  \r\n{sum=sum+s;s=s+2*pow(10,i);  \r\ni++;}  \r\nprintf("%d",sum);  \r\n}\r\n ', '', 0, 258048, 1, 1, '2010-08-07 15:13:21', '2010-08-07 15:13:21'),
(68, 1, 55, 0, '#include"stdio.h"  \r\nmain()  \r\n{long n,i=1;long long sum=0,s=1;  \r\nscanf("%d",&n);  \r\nwhile(i<=n) {s=s*i;sum=sum+s;i++;}  \r\nprintf("%lld",sum);  \r\n}\r\n ', '', 0, 262144, 1, 1, '2010-08-07 15:14:57', '2010-08-07 15:15:11'),
(69, 1, 56, 0, '#include<stdio.h>\r\nmain()  \r\n{double i=1,j=1,k=1,s1=0,s2=0,s3=0,sum; \r\nint a,b,c;\r\nscanf("%d%d%d",&a,&b,&c);\r\nfor(;i<=a;i++) s1=s1+i;  \r\nfor(;j<=b;j++) s2=s2+j*j;  \r\nfor(;k<=c;k++) s3=s3+1/k;  \r\nsum=s1+s2+s3;  \r\nprintf("%.2f",sum);  \r\n}\r\n', '', 0, 258048, 1, 1, '2010-08-07 15:19:52', '2010-08-07 15:19:52'),
(70, 1, 57, 0, '#include"stdio.h"  \r\n#include"math.h"  \r\nmain()  \r\n{int x=100,a,b,c;  \r\nwhile(x>=100&&x<1000) {a=x/100;b=(x-a*100)/10;c=x%10;  \r\nif(x==(a*a*a+b*b*b+c*c*c)) printf("%d\\n",x);x++;}  \r\n}\r\n', '', 0, 258048, 1, 1, '2010-08-07 15:21:59', '2010-08-07 15:23:46'),
(71, 1, 58, 0, '#include<stdio.h>\r\nmain()  \r\n{int m,i,j,s;\r\nint N;\r\nscanf("%d",&N);  \r\nfor(m=6;m<N;m++)  \r\n{s=1;  \r\nfor(i=2;i<m;i++)  \r\nif(m%i==0) s=s+i;  \r\nif(m-s==0)  \r\n{printf("%d its fastors are 1 ",m);for(j=2;j<m;j++) if(m%j==0)  \r\nprintf("%d ",j);printf("\\n");}  \r\n}  \r\n}\r\n', '', 733, 258048, 1, 1, '2010-08-07 15:26:07', '2010-08-07 15:26:07'),
(72, 1, 59, 0, '#include<stdio.h>\r\nmain()  \r\n{int i=1,n;double t,x=1,y=2,s,sum=0;  \r\nscanf("%ld",&n);  \r\nwhile(i<=n) {s=y/x;sum=sum+s;t=y;y=y+x;x=t;i++;}  \r\nprintf("%.2f",sum);  \r\n}', '', 0, 258048, 1, 1, '2010-08-07 15:27:46', '2010-08-07 15:27:58'),
(73, 1, 60, 0, '#include"stdio.h"  \r\n#include"math.h"\r\nmain()  \r\n{int i,n;\r\nfloat h,s;  \r\nscanf("%f%d",&s,&n);\r\nh=s/2;\r\nfor(i=2;i<=n;i++)  \r\n{s+=2*h;h/=2;}  \r\nprintf("%.2f %.2f",h,s);  \r\n}\r\n ', '', 15, 262144, 1, 1, '2010-08-07 15:30:04', '2010-08-07 15:32:41'),
(74, 1, 61, 0, '#include <stdio.h>\r\nmain()  \r\n{int i=1,sum=1;  \r\nint n;\r\nscanf("%d",&n);\r\nfor(;i<n;sum=2*(sum+1),i++);  \r\nprintf("%d",sum);  \r\n}\r\n ', '', 0, 262144, 1, 1, '2010-08-07 15:34:04', '2010-08-07 15:34:14'),
(75, 1, 62, 0, '#include"stdio.h"  \r\n#include"math.h"\r\n \r\nmain()  \r\n{float x0,x1,a;  \r\nscanf("%f",&a);  \r\nx1=a/2;  \r\ndo  \r\n{x0=x1;x1=(x0+a/x0)/2;}  \r\nwhile(fabs(x0-x1)>=0.00001);  \r\nprintf("%.3f",x1);  \r\n}\r\n', '', 0, 258048, 1, 1, '2010-08-07 15:35:54', '2010-08-07 15:35:54'),
(76, 5, 1, 0, '#include <stdio.h>\r\nmain()\r\n{\r\n  int a,b;\r\n  scanf("%d%d",&a,&b);\r\n  printf("%d",a+b);\r\n  return 0 ;\r\n}', '', 0, 262144, 1, 1, '2010-08-07 15:36:25', '2010-08-07 15:36:25'),
(77, 1, 63, 0, '#include <stdio.h>\r\nvoid prim(int n){\r\n	int i,j,a[n];  \r\n	for(i=2;i<n;i++)  \r\n	{ 	a[i]=i;  \r\n		for(j=2;j<=i;j++)  \r\n		{\r\n			if(j<i)  \r\n			 if(a[i]%j==0)  \r\n			 break;  \r\n			if(a[i]-j==0)  \r\n			 printf("%d\\n",a[i]);  \r\n		}  \r\n	} 	\r\n}\r\nmain()  \r\n{  \r\n	int  a;\r\n	scanf("%d",&a);\r\n	prim(a);\r\n}\r\n', '', 0, 262144, 1, 1, '2010-08-07 15:38:23', '2010-08-07 15:38:23'),
(78, 1, 64, 0, '#include<stdio.h>\r\nmain()  \r\n{ int i,j,a[10],t;  \r\nfor(i=0;i<10;i++)  \r\nscanf("%d",&a[i]);  \r\nfor(j=1;j<10;j++)  \r\nfor(i=0;i<=9-j;i++)  \r\nif(a[i]>a[i+1])   \r\n{t=a[i+1];a[i+1]=a[i];a[i]=t;}  \r\nfor(i=0;i<10;i++)  \r\nprintf("%d\\n",a[i]);  \r\n}\r\n ', '', 0, 262144, 1, 1, '2010-08-07 15:41:18', '2010-08-07 15:41:18'),
(79, 1, 65, 0, '#include<stdio.h>\r\nmain()  \r\n{int i=0,j=0,a[3][3],s1,s2;  \r\nfor(i=0;i<3;i++)  \r\nfor(j=0;j<3;j++)  \r\nscanf("%d",&a[i][j]);  \r\ns1=a[0][0]+a[1][1]+a[2][2];  \r\ns2=a[0][2]+a[1][1]+a[2][0];  \r\nprintf("%d %d",s1,s2);  \r\n}\r\n', '', 0, 258048, 1, 1, '2010-08-07 15:42:47', '2010-08-07 15:42:47'),
(80, 1, 66, 0, '#include<stdio.h>\r\nmain()  \r\n{\r\n	int a[10]={1,5,8,17,23,24,60,62,101};\r\n	int i,j,t;  \r\n	for(i=0;i<10;i++)\r\n		scanf("%d",&a[i]);  \r\n	for(i=9;i>0;i--)  \r\n	if(a[i]<a[i-1])  \r\n	{t=a[i-1];a[i-1]=a[i];a[i]=t;}  \r\n	for(i=0;i<10;i++)  \r\n	printf("%d\\n",a[i]); \r\n}\r\n  ', '', 0, 258048, 1, 1, '2010-08-07 15:44:47', '2010-08-07 15:44:47'),
(81, 1, 67, 0, '#include <string.h>\r\n#include <stdlib.h>\r\n#include <stdio.h>\r\nint main(){	\r\n	int iInput = 0;\r\n	int aInput[10] = {0};\r\n	int i = 0;\r\n	while(scanf(" %d", &iInput) != EOF)\r\n	{\r\n		aInput[i++] = iInput;\r\n		if (i == 10)\r\n		{\r\n			break;\r\n		}\r\n	}\r\n	i--;\r\n	for(; i != 0; --i)\r\n	{\r\n		printf("%d ",aInput[i]);\r\n	}\r\n	printf("%d",aInput[i]);\r\n	return 0;\r\n}', '', 0, 262144, 1, 1, '2010-08-07 15:46:40', '2010-08-07 15:47:44'),
(82, 1, 68, 0, '#include<stdio.h>\r\nint maxyueshu(int m,int n)  \r\n \r\n{  int i=1,t;  \r\nfor(;i<=m&&i<=n;i++)  \r\n{if(m%i==0&&n%i==0)  \r\n t=i;  \r\n}  \r\nreturn(t);  \r\n}  \r\nint minbeishu(int m,int n)  \r\n\r\n{int j;  \r\nif(m>=n) j=m;  \r\nelse j=n;  \r\nfor(;!(j%m==0&&j%n==0);j++);  \r\nreturn j;  \r\n}  \r\nint main()  \r\n{int a,b,max,min;  \r\n//printf("enter two number is: ");  \r\nscanf("%d%d",&a,&b);  \r\nmax=maxyueshu(a,b);  \r\nmin=minbeishu(a,b);  \r\nprintf("%d %d",max,min);  \r\nreturn 0;\r\n}\r\n ', '', 15, 262144, 1, 1, '2010-08-07 15:50:09', '2010-08-07 15:50:09'),
(83, 1, 69, 0, '#include<stdio.h>\r\n#include"math.h"  \r\nfloat yishigen(m,n,k)  \r\nfloat m,n,k;  \r\n{float x1,x2;  \r\nx1=(-n+sqrt(k))/(2*m);  \r\nx2=(-n-sqrt(k))/(2*m);  \r\nprintf("x1=%.3f x2=%.3f",x1,x2);  \r\n}  \r\nfloat denggen(m,n)  \r\nfloat m,n;  \r\n{float x;  \r\nx=-n/(2*m);  \r\nprintf("x1=%.3f x2=%.3f",x,x);  \r\n}  \r\nfloat xugen(m,n,k)  \r\nfloat m,n,k;  \r\n{float x,y;  \r\nx=-n/(2*m);  \r\ny=sqrt(-k)/(2*m);  \r\nprintf("x1=%.3f+%.3fi x2=%.3f-%.3fi",x,y,x,y);  \r\n}  \r\nmain()  \r\n{float a,b,c,q;  \r\n//printf("input a b c is ");  \r\nscanf("%f%f%f",&a,&b,&c);  \r\n//printf("\\n");  \r\nq=b*b-4*a*c;  \r\nif(q>0) yishigen(a,b,q);  \r\nelse if(q==0) denggen(a,b);  \r\nelse xugen(a,b,q);  \r\n}\r\n', '', 0, 258048, 1, 1, '2010-08-07 15:52:59', '2010-08-07 15:52:59'),
(84, 1, 70, 0, 'psushu(m)  \r\nint m;  \r\n{\r\n	int i=2,t;  \r\n	for(;i<=m;i++)  \r\n		if(m%i==0&&i<m) break;  \r\n	if(i==m+1) t=1;  \r\n		else t=0;  \r\n	return t;  \r\n}  \r\nmain()  \r\n{int a,s;  \r\n//printf("enter sushu is \\n");  \r\nscanf("%d",&a);  \r\nif(a==1){printf("not prime"); return 0;}\r\ns=psushu(a);  \r\nif(s==1) printf("prime");  \r\nelse printf("not prime");  \r\n}\r\n', '', 0, 262144, 1, 1, '2010-08-07 15:56:23', '2010-08-07 15:56:23'),
(85, 1, 71, 0, 'int zhuangzhi(b)  \r\nint b[3][3];  \r\n{int i,j,t;  \r\nfor(i=0;i<3;i++)  \r\nfor(j=0;j<=i;j++)  \r\n{t=b[i][j];b[i][j]=b[j][i];b[j][i]=t;}  \r\n}  \r\nint main()  \r\n{int a[3][3];int i,j;  \r\nfor(i=0;i<3;i++)  \r\nfor(j=0;j<3;j++)  \r\nscanf("%d",&a[i][j]);  \r\n\r\nzhuangzhi(a);  \r\nfor(i=0;i<3;i++)  \r\n{for(j=0;j<3;j++)  \r\nprintf("%d ",a[i][j]);  \r\nprintf("\\n");}  \r\nreturn 0;\r\n}\r\n ', '', 0, 262144, 1, 1, '2010-08-07 15:58:06', '2010-08-07 15:58:55'),
(86, 1, 72, 0, 'fanxu(str1)  \r\nchar str1[100];  \r\n{int i,t,j;  \r\nchar str2[100];strcpy(str2,str1);  \r\nt=strlen(str1);  \r\nfor(i=0,j=t-1;j>-1;i++,j--)  \r\nstr1[i]=str2[j];\r\nstr1[i--]=0;\r\n}  \r\n\r\nint main()  \r\n{char str0[100];  \r\nscanf("%s",str0);  \r\nfanxu(str0);  \r\nprintf("%s",str0);  \r\n return 0;\r\n}\r\n ', '', 0, 262144, 1, 1, '2010-08-07 16:00:15', '2010-08-07 16:00:15'),
(87, 1, 73, 0, 'lianjie(a,b)  \r\nchar a[100],b[100];  \r\n{strcat(a,b);  \r\n}  \r\nint main()  \r\n{char str1[100],str2[100];  \r\nscanf("%s%s",str1,str2); \r\nlianjie(str1,str2);  \r\nprintf("%s",str1);  \r\n return 0;\r\n}\r\n', '', 0, 258048, 1, 1, '2010-08-07 16:01:42', '2010-08-07 16:02:51'),
(88, 1, 74, 0, 'fuzhi(a,b)\r\nchar a[100],b[100];\r\n{int i,j=0;\r\nfor(i=0;a[i]!=''\\0'';i++)\r\nif(a[i]==97||a[i]==101||a[i]==105||a[i]==111||a[i]==117||a[i]==65||\r\na[i]==69||a[i]==73||a[i]==85) {b[j]=a[i];j++;}\r\n\r\nb[j]=0;\r\n}\r\nint main()\r\n{char str1[100],str2[100];\r\nscanf("%s",str1);\r\nfuzhi(str1,str2);\r\nprintf("%s",str2);\r\n}\r\n', '', 0, 262144, 1, 1, '2010-08-07 16:04:18', '2010-08-07 16:04:18'),
(89, 1, 75, 0, 'char f(b)  \r\nchar b[4];  \r\n{int i=0;  \r\nfor(;i<4;i++)  \r\n{  \r\nif(i<3)printf("%c ",b[i]);else printf("%c",b[i]);}  \r\n}  \r\nmain()  \r\n{int a,u,v,w,t;char c[4];  \r\nscanf("%4d",&a);  \r\nu=a*0.001;v=0.01*(a-1000*u);w=(a-1000*u-100*v)*0.1;t=a-1000*u-100*v-10*w;  \r\nc[0]=u+48;  \r\nc[1]=v+48;  \r\nc[2]=w+48;  \r\nc[3]=t+48;  \r\nf(c);  \r\n}\r\n ', '', 0, 262144, 1, 1, '2010-08-07 16:06:24', '2010-08-07 16:06:52'),
(90, 1, 76, 0, 'char tongji(str0,b)\r\nchar str0[100];\r\nint b[4];\r\n{int i;\r\nfor(i=0;str0[i]!=''\\0'';i++)\r\n{if(str0[i]>=65&&str0[i]<=90||str0[i]>=97&&str0[i]<=122) b[0]++;\r\nelse if(str0[i]>=48&&str0[i]<=57) b[1]++;\r\nelse if(str0[i]==32) b[2]++;\r\nelse b[3]++;}\r\n}\r\nint main()\r\n{char str1[100];static int i,a[4];\r\ngets(str1);\r\ntongji(str1,a);\r\nfor(i=0;i<4;i++)\r\nprintf(i<3?"%d ":"%d",a[i]);\r\nreturn 0;\r\n}\r\n', '', 0, 262144, 1, 1, '2010-08-07 16:09:21', '2010-08-07 16:09:21'),
(91, 1, 77, 0, '#define CHANGE(a,b,t) t=a;a=b;b=t;  \r\nmain()  \r\n{int c,d,s;  \r\nscanf("%d%d",&c,&d);  \r\nCHANGE(c,d,s);  \r\nprintf("%d %d",c,d);  \r\n}\r\n', '', 0, 262144, 1, 1, '2010-08-07 16:17:37', '2010-08-07 16:17:37'),
(92, 1, 78, 0, '#define Q(a,b) a%b  \r\nmain()  \r\n{int c,d,t;  \r\nscanf("%d%d",&c,&d);  \r\nt=Q(c,d);  \r\nprintf("%d",t);  \r\n}\r\n', '', 0, 262144, 1, 1, '2010-08-07 16:19:11', '2010-08-07 16:19:26'),
(93, 1, 79, 0, '#include"math.h"  \r\n#define SSS(m,n,k) (m+n+k)/2  \r\n#define AQRT(m,n,k) sqrt(SSS(m,n,k)*(SSS(m,n,k)-m)*(SSS(m,n,k)-n)*(SSS(m,n,k)-k))  \r\nmain()  \r\n{float a,b,c,s,area;  \r\nscanf("%f%f%f",&a,&b,&c);  \r\ns=SSS(a,b,c);  \r\narea=AQRT(a,b,c);  \r\nprintf("%.3f",area);  \r\n}\r\n', '', 0, 262144, 1, 1, '2010-08-07 16:20:57', '2010-08-07 16:21:16'),
(94, 1, 80, 0, '#define LEAPYEAR(y) !(y%4)&&((y%100)||!(y%400))  \r\nmain()  \r\n{int y;  \r\nscanf("%d",&y);  \r\nif(LEAPYEAR(y)) printf("L");  \r\nelse printf("N");  \r\n}\r\n', '', 0, 262144, 1, 1, '2010-08-07 16:22:52', '2010-08-07 16:22:52'),
(95, 1, 81, 0, '#include<stdio.h>\r\n#define PR1(x) printf("%6.2f\\n",x)  \r\n#define PR2(x) printf("%6.2f %6.2f\\n",x,x)  \r\n#define PR3(x) printf("%6.2f %6.2f %6.2f",x,x,x)  \r\nmain()  \r\n{float a;scanf("%f",&a);  \r\nPR1(a);PR2(a);PR3(a);  \r\n}\r\n', '', 0, 262144, 1, 1, '2010-08-07 16:25:29', '2010-08-07 16:33:58'),
(96, 1, 82, 0, '#define MAX(a,b,c) (a>((b>c)? b:c))? a:((b>c)? b:c)  \r\nmain()  \r\n{float x,y,z,t;  \r\nscanf("%f%f%f",&x,&y,&z);  \r\nt=MAX(x,y,z);  \r\nprintf("%.3f\\n",t);  \r\nprintf("%.3f\\n",t);  \r\n}\r\n ', '', 0, 262144, 1, 1, '2010-08-07 16:39:19', '2010-08-07 16:39:35'),
(97, 1, 83, 0, '#define CHANGE 1\r\nmain()\r\n{char str[80],c;int i=0;\r\ngets(str);\r\nwhile(str[i]!=''\\0'')\r\n{\r\n#if CHANGE\r\nif(str[i]==90||str[i]==122) str[i]=str[i]-25;\r\nelse if(str[i]>=65&&str[i]<90||str[i]>=97&&str[i]<122) str[i]=str[i]+1;\r\n#endif\r\ni++;\r\n}\r\nputs(str);\r\n}\r\n', '', 0, 258048, 1, 1, '2010-08-07 16:44:03', '2010-08-07 16:44:03'),
(98, 1, 84, 0, 'main()  \r\n{ int a,b,c,*p1,*p2,*p3,t;  \r\nscanf("%d%d%d",&a,&b,&c);  \r\np1=&a;p2=&b;p3=&c;  \r\nif(*p1>*p2)   \r\n{t=p1;p1=p2;p2=t;}  \r\nif(*p1>*p3)  \r\n{t=p1;p1=p3;p3=t;}  \r\nif(*p2>*p3)   \r\n{t=p2;p2=p3;p3=t;}  \r\nprintf("%d %d %d ",*p1,*p2,*p3);  \r\n}\r\n ', '', 0, 258048, 1, 1, '2010-08-07 16:46:43', '2010-08-07 16:46:43'),
(99, 1, 85, 0, '#include<stdio.h>\r\n#include<string.h>\r\n\r\nvoid Swap(char **q1, char**q2);\r\n\r\nint main()\r\n{    \r\n    int i=0;\r\n    char *p1,*p2,*p3, str1[80],str2[80],str3[80];\r\n p1=str1; p2=str2; p3=str3;\r\n    gets(str1);\r\n	gets(str2);\r\n	gets(str3);\r\nif (strcmp(p1, p2)>0)\r\n        Swap(&p1, &p2);  \r\nif (strcmp(p1, p3)>0)\r\n        Swap(&p1, &p3);\r\nif (strcmp(p2, p3)>0)\r\n        Swap(&p2, &p3);\r\n printf("%s\\n%s\\n%s\\n",p1,p2,p3);\r\n return(0);\r\n}\r\n\r\nvoid Swap(char **q1, char* *q2)\r\n{char *t;\r\n t= *q1;\r\n *q1 = *q2;\r\n *q2 = t;\r\n}\r\n', '', 0, 258048, 1, 1, '2010-08-07 16:50:10', '2010-08-07 16:50:10'),
(100, 1, 86, 0, '#include<stdio.h>\r\nint main()\r\n{\r\n	int array[11];\r\n	int n=10;\r\n	//scanf("%d",&n);\r\n	int temp;\r\n	int i;\r\n	for(i=0;i<n;i++)\r\n		scanf("%d",&array[i]);\r\n	temp=0;\r\n	for(i=0;i<n;i++)\r\n		if(array[temp] > array[i])\r\n			temp = i;\r\n		int t = array[temp];\r\n		array[temp] = array[0];\r\n		array[0] = t;\r\n	temp = 0;\r\n	for(i=0;i<n;i++)\r\n		if(array[temp] < array[i])\r\n			temp = i;\r\n		t = array[temp];\r\n		array[temp] = array[n-1];\r\n		array[n-1] = t;\r\n	for(i=0;i<n;i++)\r\n	{\r\n		\r\n		printf("%d ",array[i]);\r\n	}\r\n	printf("\\n");\r\n	return 0;\r\n}\r\n', '', 0, 262144, 1, 1, '2010-08-07 16:54:08', '2010-08-07 16:55:28'),
(101, 1, 87, 0, '#include <stdio.h>\r\nvoid mv(int *p,int n,int m)\r\n{\r\n    int *h, t,i;\r\n    h=p+n-m-1; \r\n    for(;h>=p;h--)\r\n    {\r\n         for(i=0;i<m;i++) \r\n         {\r\n                     t=*(h+i);\r\n                     *(h+i)=*(h+i+1);\r\n                     *(h+i+1)=t;\r\n          }\r\n   }\r\n}\r\n\r\n\r\nint main()\r\n{\r\n    int a[80];\r\n     int m,i,n;\r\n	 scanf("%d",&n);\r\n for(i=0;i<n;i++) \r\n	 scanf("%d",&a[i]);\r\n   scanf("%d",&m);\r\n  mv(a,n,m); \r\n for(i=0;i<n;i++) \r\n	 printf("%d ",a[i]);\r\n \r\n  return 0;\r\n}\r\n', '', 0, 258048, 1, 1, '2010-08-07 16:58:25', '2010-08-07 17:07:15'),
(102, 1, 88, 0, '#include <stdio.h> \r\n\r\nconst int M = 3; \r\n\r\nint main() \r\n{ \r\n    int i,n, s = 0; \r\n    scanf("%d", &n); \r\n    for (i = 2; i <= n; ++i) \r\n        s = (s+M)%i; \r\n    printf("%d", s+1); \r\n    return 0; \r\n}\r\n', '', 0, 262144, 1, 1, '2010-08-07 17:08:36', '2010-08-07 17:08:59'),
(103, 1, 89, 0, '#include <stdio.h>\r\n#include <string.h>\r\n#define N 80\r\nvoid fun(char a[N],int m)\r\n{char *p1,b[N];int i,l;\r\np1=a;i=1;l=0;\r\nwhile(i<m){i++;p1++;}\r\nwhile(*p1!=''\\0'')\r\n{b[l]=*p1;\r\n p1++;\r\n l++;\r\n}\r\nb[l]=''\\0'';\r\nprintf("%s",b);\r\n}\r\nint main()\r\n{char a[N];int m,n;\r\nscanf("%d",&n);\r\ngets(a);\r\ngets(a);\r\nscanf("%d",&m);\r\nprintf("%s",a+m-1);\r\nreturn 0;\r\n}\r\n ', '', 0, 262144, 1, 1, '2010-08-07 17:11:01', '2010-08-07 17:14:32'),
(104, 1, 90, 0, 'struct  \r\n{int year;  \r\n int month;  \r\n int day;  \r\n}date;  \r\nmain()  \r\n{int days;\r\n//printf("Input  year,month,day:");\r\nscanf("%d%d%d",&date.year,&date.month,&date.day);\r\nswitch(date.month)  \r\n {case 1: days=date.day;    break;  \r\n case 2: days=date.day+31; break;  \r\n case 3: days=date.day+59; break;  \r\n case 4: days=date.day+90; break;  \r\n case 5: days=date.day+120;break;  \r\ncase 6: days=date.day+31; break;  \r\n   case 7: days=date.day+181; break;  \r\n   case 8: days=date.day+212; break;  \r\ncase 9: days=date.day+243; break;  \r\ncase 10: days=date.day+273; break;  \r\ncase 11: days=date.day+304; break;  \r\ncase 12: days=date.day+334; break;  \r\n}  \r\nif((date.year%4==0&&date.year%100!=0||date.year%400==0)&&date.month>=3)days+=1;  \r\nprintf("%d",days);  \r\n}\r\n  ', '', 15, 258048, 1, 1, '2010-08-07 17:16:24', '2010-08-07 17:16:24'),
(105, 1, 91, 0, ' int N=100;\r\nstruct student  \r\n{char num[6];  \r\n   char name[8];  \r\n   int score[3];  \r\n}stu[100]; \r\nvoid print(struct student st)  \r\n{	 int i,j;  \r\n     printf("%s,%s",st.num,st.name);  \r\n     for(j=0;j<3;j++)  \r\n     printf(",%d",st.score[j]);  \r\n     printf("\\n");  \r\n} \r\nmain()  \r\n{int i,j ;  \r\n   scanf ("%d",&N);\r\n   for(i=0;i<N;i++)  \r\n{\r\n	//printf("Input score of student %d:\\n",i+1);  \r\n     //printf("no.:");  \r\n     scanf("%s",stu[i].num);  \r\n     ///printf("name:");  \r\n     scanf("%s",stu[i].name);  \r\n     for(j=0;j<3;j++)  \r\n     {//printf("score%d:",j+1);  \r\n      scanf("%d",&stu[i].score[j]);  \r\n}  \r\n \r\n print(stu[i]);  \r\n}  \r\n\r\n\r\n}\r\n', '', 0, 258048, 1, 1, '2010-08-07 17:18:04', '2010-08-07 17:18:04'),
(106, 1, 92, 0, '#include<stdio.h>\r\n#define N 100 \r\nstruct student\r\n{\r\nchar num[6];\r\nchar name[8];\r\nint score[4];\r\nint avr;\r\n}stu[N];\r\nint r;\r\n\r\nint main()\r\n{\r\n  int sum3=0,sum1=0,sum2=0,maxi;\r\n  int sum;\r\n  int max;\r\n  scanf("%d",&r);\r\n  int i,j;\r\n  for(i=0;i<r;i++)\r\n  {\r\n   scanf("%s%s",stu[i].num,stu[i].name);\r\n   for(j=0;j<3;j++)\r\n   {\r\n    scanf("%d",&stu[i].score[j]);\r\n   }\r\n\r\n}\r\n\r\nmax=0;\r\nmaxi=0;\r\n for(i=0;i<r;i++)\r\n {\r\n  sum=0;\r\n  sum1+=stu[i].score[0];\r\n  sum2+=stu[i].score[1];\r\n  sum3+=stu[i].score[2];\r\n  for(j=0;j<3;j++)\r\n    sum+=stu[i].score[j];\r\n  stu[i].avr=sum/3;\r\n  \r\n  if(sum>max)\r\n  {\r\n  max=sum;\r\n  maxi=i;\r\n  }\r\n\r\n }\r\nprintf("%d %d %d",sum1/r,sum2/r,sum3/r);\r\nputchar(''\\n'');\r\n\r\nprintf("%s %s %d %d %d",stu[maxi].num,stu[maxi].name,stu[maxi].score[0],stu[maxi].score[1],stu[maxi].score[2]);\r\n\r\n\r\nreturn 0;\r\n}\r\n ', '', 0, 258048, 1, 1, '2010-08-07 17:19:53', '2010-08-07 17:19:53'),
(107, 1, 94, 0, '#include<iostream>\r\nusing namespace std;\r\n#include<algorithm>\r\n#include<cstdio>\r\n#include<memory.h>\r\n//#include<fstream>\r\n#include<cmath>\r\ntypedef long long lld;\r\nconst double eps=1e-10;\r\nconst int MaxP=20000;\r\nint parent[MaxP];//记得初始化为-1 \r\nint father(int p)\r\n{\r\n    int i=p,temp;\r\n    while(parent[i]!=-1)\r\n         i=parent[i];\r\n    while(i!=p)\r\n    {\r\n         temp=parent[p];\r\n         parent[p]=i;\r\n         p=temp;\r\n    }\r\n    return i;\r\n}\r\nvoid connect(int a,int b)\r\n{\r\n     int p=father(a),q=father(b);\r\n     if(p!=q)\r\n       parent[p]=q;\r\n}\r\ndouble up[MaxP],down[MaxP];\r\nint cntUp,cntDown;\r\ninline double dis(lld n,lld x[],lld y[],double px,double py)//the sum of the distance all n points to (px,py)\r\n{\r\n       double res=0.0;\r\n       for(int i=0;i<n;++i)\r\n          res=res+sqrt((double)(((double)x[i]-px)*((double)x[i]-px)\r\n              +((double)y[i]-py)*((double)y[i]-py)));\r\n       return res;\r\n}\r\ninline void fourth_search(lld n,lld x[],lld y[],double yline,double &rx,double &ry)\r\n{\r\n     double left=(double)*min_element(x,x+n);\r\n     double right=(double)*max_element(x,x+n);\r\n     while(right>left)//while(right-left>eps)\r\n     {\r\n          double d=(right-left)/4.0;\r\n          double a=left+d,b=a+d,c=b+d;\r\n          double ra=dis(n,x,y,a,yline);\r\n          double rb=dis(n,x,y,b,yline);\r\n          double rc=dis(n,x,y,c,yline);\r\n          if(ra>rb&&rb>rc)\r\n             left=b;\r\n          else if(ra<rb&&rb<rc)\r\n             right=b;\r\n          else if(ra>=rb&&rb<=rc)\r\n          {\r\n               left=a;\r\n               right=c;\r\n          }\r\n          else\r\n            break;\r\n     }\r\n     rx=right;\r\n     ry=yline;\r\n}\r\nstruct edge\r\n{\r\n       int u,v;\r\n       double d;\r\n       bool operator<(const edge &other)const\r\n       {\r\n            return d<other.d;\r\n       }\r\n};\r\nedge ed[5*MaxP];\r\nint cntEd;\r\nint main()\r\n{\r\n    int m;\r\n    //ifstream cin("cost.in");\r\n    //ofstream cout("cost.out");\r\n    //freopen("cost.in","r",stdin);\r\n    //freopen("cost.out","w",stdout);\r\n    while(EOF!=scanf("%d",&m))\r\n    {\r\n         double totalRes=0.0;\r\n         cntUp=cntDown=0;\r\n         for(int i=1;i<=m;++i)\r\n         {\r\n             int n;\r\n             //cin>>n;\r\n             scanf("%d",&n);\r\n             lld x[10],y[10];\r\n             for(int j=0;j<n;++j) \r\n                 scanf("%I64d%I64d",x+j,y+j);\r\n                //cin>>x[j]>>y[j];\r\n             double rx,ry;\r\n             if(1==i%2)//数上边\r\n             {\r\n                fourth_search(n,x,y,1,rx,ry);\r\n                double res=dis(n,x,y,rx,ry);\r\n                up[cntUp++]=rx;\r\n                totalRes+=res;\r\n             }\r\n             else\r\n             {\r\n                fourth_search(n,x,y,-1,rx,ry);\r\n                double res=dis(n,x,y,rx,ry);\r\n                down[cntDown++]=rx;\r\n                totalRes+=res;\r\n             }\r\n         }\r\n         printf("%.0f\\n",floor(totalRes));\r\n         //cout<<(lld)totalRes<<endl;\r\n         sort(up,up+cntUp);\r\n         cntUp=unique(up,up+cntUp)-up;\r\n         sort(down,down+cntDown);\r\n         cntDown=unique(down,down+cntDown)-down;\r\n         cntEd=0;\r\n         for(int i=0;i<cntUp;++i)\r\n         {\r\n             edge tmp;\r\n             if(i!=0)//left\r\n             {\r\n                tmp.u=i;\r\n                tmp.v=i-1;\r\n                tmp.d=(double)(up[i]-up[i-1]);\r\n                ed[cntEd++]=tmp;\r\n             }\r\n             if(i!=cntUp-1)//right\r\n             {\r\n                tmp.u=i;\r\n                tmp.v=i+1;\r\n                tmp.d=(double)(up[i+1]-up[i]);\r\n                ed[cntEd++]=tmp;\r\n             }\r\n             if(binary_search(down,down+cntDown,up[i]))//down\r\n             {\r\n                tmp.u=i;\r\n                tmp.v=lower_bound(down,down+cntDown,up[i])-down+cntUp;\r\n                tmp.d=2.0;\r\n                ed[cntEd++]=tmp;\r\n             }\r\n             int j=lower_bound(down,down+cntDown,up[i])-down;\r\n             if(j>0)\r\n             {\r\n                tmp.u=i;\r\n                tmp.v=j-1+cntUp;\r\n                tmp.d=sqrt((double)((up[i]-down[j-1])*(up[i]-down[j-1]))+4.0);\r\n                ed[cntEd++]=tmp;\r\n             }\r\n             j=upper_bound(down,down+cntDown,up[i])-down;\r\n             if(j!=cntDown)\r\n             {\r\n                tmp.u=i;\r\n                tmp.v=j+cntUp;\r\n                tmp.d=sqrt((double)((down[j]-up[i])*(down[j]-up[i]))+4.0);\r\n                ed[cntEd++]=tmp;\r\n             }\r\n         }\r\n         for(int i=0;i<cntDown;++i)\r\n         {\r\n             edge tmp;\r\n             if(i!=0)//left\r\n             {\r\n                tmp.u=i+cntUp;\r\n                tmp.v=i-1+cntUp;\r\n                tmp.d=(double)(down[i]-down[i-1]);\r\n                ed[cntEd++]=tmp;\r\n             }\r\n             if(i!=cntDown-1)//right\r\n             {\r\n                tmp.u=i+cntUp;\r\n                tmp.v=i+1+cntUp;\r\n                tmp.d=(double)(down[i+1]-down[i]);\r\n                ed[cntEd++]=tmp;\r\n             }\r\n             if(binary_search(up,up+cntUp,down[i]))//up\r\n             {\r\n                tmp.u=i+cntUp;\r\n                tmp.v=lower_bound(up,up+cntUp,down[i])-up;\r\n                tmp.d=2.0;\r\n                ed[cntEd++]=tmp;\r\n             }\r\n             int j=lower_bound(up,up+cntUp,down[i])-up;//left up\r\n             if(j>0)\r\n             {\r\n                tmp.u=i+cntUp;\r\n                tmp.v=j-1;\r\n                tmp.d=sqrt((double)((down[i]-up[j-1])*(down[i]-up[j-1]))+4.0);\r\n                ed[cntEd++]=tmp;\r\n             }\r\n             j=upper_bound(up,up+cntUp,down[i])-up;\r\n             if(j!=cntUp)\r\n             {\r\n                tmp.u=i+cntUp;\r\n                tmp.v=j;\r\n                tmp.d=sqrt((double)((up[j]-down[i])*(up[j]-down[i]))+4.0);\r\n                ed[cntEd++]=tmp;\r\n             }\r\n         }\r\n         sort(ed,ed+cntEd);\r\n         memset(parent,-1,sizeof(parent));\r\n         double res2=0.0;\r\n         for(int i=0;i<cntEd;++i)\r\n         {\r\n             if(father(ed[i].u)!=father(ed[i].v))\r\n             {\r\n                connect(ed[i].u,ed[i].v);\r\n                res2+=ed[i].d;\r\n             }\r\n         }\r\n         printf("%.0f\\n",floor(res2));\r\n         //cout<<(lld)res2<<endl;\r\n        /* if(128689==(lld)res2)\r\n         {\r\n              cout<<"m="<<m<<endl;\r\n              cout<<"res2="<<res2<<endl;\r\n              system("pause");\r\n         }*/\r\n    }\r\n		//system(''pause'');\r\n    return 0;\r\n}\r\n', '', 1011, 2379776, 1, 2, '2010-08-07 18:45:29', '2010-08-07 19:33:53'),
(108, 1, 95, 0, '#include<iostream>\r\nusing namespace std;\r\n#include<fstream>\r\n#include<cstring>\r\n\r\nint main()\r\n{\r\n    //ifstream cin("matrix.in");\r\n    //ofstream cout("matrix.out");\r\n    int M,N;\r\n    int T;\r\n    cin>>T;\r\n    for(int test=1;test<=T;++test)//while(cin>>M>>N)\r\n    {\r\n          cin>>M>>N;\r\n          int res[4][4]={{1,0,0,0},\r\n                       {0,1,0,0},\r\n                       {0,0,1,0},\r\n                       {0,0,0,1}};\r\n          int A[4][4],tmp[4][4];\r\n          int i,j;\r\n          for(i=0;i<M;++i)\r\n              for(j=0;j<M;++j)\r\n                 cin>>A[i][j];\r\n          for(int t=0;t<N;++t)\r\n          {\r\n              int k;\r\n              memset(tmp,0,sizeof(tmp));\r\n              for(i=0;i<M;++i)\r\n                 for(j=0;j<M;++j)\r\n                    for(k=0;k<M;++k)\r\n                       tmp[i][j]+=res[i][k]*A[k][j];\r\n              for(i=0;i<M;++i)\r\n                 for(j=0;j<M;++j)\r\n                    res[i][j]=tmp[i][j];\r\n          }\r\n          cout<<"Case "<<test<<":"<<endl;\r\n          for(i=0;i<M;++i)\r\n          {\r\n              for(j=0;j<M;++j)\r\n              {\r\n                  cout<<res[i][j];\r\n                  if(j!=M-1)\r\n                    cout<<" ";\r\n              }\r\n              cout<<endl;\r\n          }\r\n    }\r\n    //system("pause");\r\n    return 0;\r\n}\r\n', '', 0, 368640, 1, 2, '2010-08-07 19:36:56', '2010-08-07 19:36:56'),
(109, 1, 96, 0, '#include<iostream>\r\nusing namespace std;\r\n#include<fstream>\r\n#include<cstring>\r\n#include<cstdlib>\r\n#include<ctime>\r\nconst int maxN = 24;\r\nint tri[maxN][maxN];\r\nint main()\r\n{\r\n    int N,value,row,col,dir,i,j;\r\n    while(cin>>N)\r\n    {\r\n         memset(tri,0,sizeof(tri));\r\n         row=col=1;\r\n         for(value=1;value<=N;++value)\r\n            tri[row++][col]=value;\r\n         row=N,col=2;\r\n         for(value=N+1;value<=2*N-1;++value)\r\n             tri[row][col++]=value;\r\n         row=N-1,col=N-1;\r\n         for(value=2*N;value<=3*N-3;++value)\r\n             tri[row--][col--]=value;\r\n         row=2,col=2;\r\n         value=3*N-2;\r\n         dir=1;\r\n         while(value<=N*(N+1)/2)\r\n         {\r\n              if(1==dir)/*down one line*/\r\n              {\r\n                 if((0==tri[row+1][col]))\r\n                   tri[++row][col]=value;\r\n                 else\r\n                 {\r\n                     dir=2;\r\n                     tri[row][++col]=value;\r\n                 }\r\n              }\r\n              else if(2==dir)/*right one line*/\r\n              {\r\n                   if((0==tri[row][col+1]))\r\n                     tri[row][++col]=value;\r\n                   else\r\n                   {\r\n                       dir=3;\r\n                       tri[--row][--col]=value;\r\n                   }\r\n              }\r\n              else\r\n              {\r\n                    if((0==tri[row-1][col-1]))\r\n                      tri[--row][--col]=value;\r\n                    else\r\n                    {\r\n                        dir=1;\r\n                        tri[++row][col]=value;\r\n                    }\r\n              }\r\n              ++value;\r\n         }\r\n         for(row=1;row<=N;++row)\r\n         {\r\n            for(col=1;col<=row;++col)\r\n            {   \r\n                cout<<tri[row][col];\r\n                if(!(row==N&&col==row))\r\n                  cout<<" ";\r\n            }\r\n         }\r\n         cout<<endl;\r\n    }\r\n    return 0;\r\n}\r\n', '', 0, 372736, 1, 2, '2010-08-07 19:38:53', '2010-08-07 19:38:53'),
(110, 1, 97, 0, '#include<iostream>\r\nusing namespace std;\r\n\r\nint a[2][2];\r\nint m, n, p;\r\n\r\nvoid Init( )\r\n{\r\n    a[0][0] = 1;\r\n    a[0][1] = 1;\r\n    a[1][0] = 1;\r\n    a[1][1] = 0; \r\n}\r\n\r\nvoid Solve( )\r\n{\r\n    int r[2][2] = { { 1, 1 }, { 1, 0 } };\r\n    int b[2][2];\r\n    while( m )\r\n    {\r\n        if( m & 1 )\r\n        {\r\n            b[0][0] = a[0][0] * r[0][0] + a[0][1] * r[1][0];\r\n            b[0][1] = a[0][0] * r[0][1] + a[0][1] * r[1][1];\r\n            b[1][0] = a[1][0] * r[0][0] + a[1][1] * r[1][0];\r\n            b[1][1] = a[1][0] * r[0][1] + a[1][1] * r[1][1];\r\n            r[0][0] = b[0][0] % p;\r\n            r[0][1] = b[0][1] % p;\r\n            r[1][0] = b[1][0] % p;\r\n            r[1][1] = b[1][1] % p;\r\n        }\r\n        m >>= 1;\r\n        b[0][0] = a[0][0] * a[0][0] + a[0][1] * a[1][0];\r\n        b[0][1] = a[0][0] * a[0][1] + a[0][1] * a[1][1];\r\n        b[1][0] = a[1][0] * a[0][0] + a[1][1] * a[1][0];\r\n        b[1][1] = a[1][0] * a[0][1] + a[1][1] * a[1][1];\r\n        a[0][0] = b[0][0] % p;\r\n        a[0][1] = b[0][1] % p;\r\n        a[1][0] = b[1][0] % p;\r\n        a[1][1] = b[1][1] % p;\r\n    } \r\n    cout<<r[0][1]<<endl;\r\n}\r\n\r\n\r\nint main( )\r\n{\r\n    cin>>n;\r\n    while( n-- )\r\n    {\r\n        Init( );\r\n        cin>>m>>p;\r\n        Solve( );\r\n    }\r\n    return 0;\r\n}\r\n', '', 0, 364544, 1, 2, '2010-08-07 19:40:33', '2010-08-07 19:40:33'),
(111, 1, 98, 0, '#include<iostream>\r\nusing namespace std;\r\n#include<algorithm>\r\n#include<fstream>\r\n#include<memory.h>\r\n//cards先按数量由大到小存，数量相等时由牌的大小由小到大存 \r\n//3到A用3-14 2用16 小王用18 大王用19\r\nconst int MaxN=25;\r\nconst int A=14,KingTwo=16,small=18,big=19; \r\nstruct card\r\n{\r\n       int id,num;\r\n       bool operator<(const card &other)const\r\n       {\r\n            if(num==other.num)\r\n               return id<other.id;\r\n            return num>other.num;\r\n       }\r\n};\r\nbool isZero(card cards[],int n,int &start,int &end)//passed \r\n{\r\n     if(0==n)\r\n     {\r\n        start=end=0;\r\n        return true;\r\n     }\r\n     return false;\r\n}\r\nbool isRocket(card cards[],int n,int &start,int &end)//天王炸 \r\n{\r\n     if(2==n&&small==cards[0].id&&big==cards[1].id)\r\n       return true;\r\n     return false;\r\n}\r\nbool isBomb(card cards[],int n,int &start,int &end)//炸弹 \r\n{\r\n     if(4==n&&4==cards[0].num)\r\n     {\r\n        start=end=cards[0].id;\r\n        return true;\r\n     }\r\n     return false;\r\n}\r\nbool isOne(card cards[],int n,int &start,int &end)//一张牌 \r\n{\r\n     if(1==n)\r\n     {\r\n        start=end=cards[0].id;\r\n        return true;\r\n     }\r\n     return false;\r\n}\r\nbool isTwo(card cards[],int n,int &start,int &end)//一对牌 \r\n{\r\n     if(2==n&&2==cards[0].num)\r\n     {\r\n        start=end=cards[0].id;\r\n        return true;\r\n     }\r\n     return false;\r\n}\r\nbool isThreeSame(card cards[],int n,int &start,int &end)//一到多个3顺 \r\n{\r\n     if(n%3!=0)\r\n       return false;\r\n     int id=cards[0].id;\r\n     for(int i=0;i<n/3;++i)\r\n     {\r\n        if(3!=cards[i].num||cards[i].id!=id)\r\n          return false;\r\n        ++id;\r\n     }\r\n     start=cards[0].id;\r\n     end=cards[n/3-1].id;\r\n     return true;\r\n}\r\nbool is3plus1(card cards[],int n,int &start,int &end)//一到多个3带1 \r\n{\r\n     if(n%4!=0)\r\n       return false;\r\n     int s3=n/4,id=cards[0].id;\r\n     for(int i=0;i<s3;++i)\r\n     {\r\n         if(3!=cards[i].num||cards[i].id!=id)\r\n           return false;\r\n         ++id;\r\n     }\r\n     for(int i=s3;i<s3+s3;++i)\r\n        if(1!=cards[i].num)\r\n          return false;\r\n     start=cards[0].id;\r\n     end=cards[n/4-1].id;\r\n     return true;\r\n}\r\nbool is3plus2(card cards[],int n,int &start,int &end)//一到多个3事2 \r\n{\r\n     if(n%5!=0)\r\n       return false;\r\n     int s3=n/5,id=cards[0].id;\r\n     for(int i=0;i<s3;++i)\r\n     {\r\n         if(3!=cards[i].num||cards[i].id!=id)\r\n           return false;\r\n         ++id;\r\n     }\r\n     for(int i=s3;i<s3+s3;++i)\r\n        if(2!=cards[i].num)\r\n          return false;\r\n     start=cards[0].id;\r\n     end=cards[n/5-1].id;\r\n     return true;\r\n}\r\nbool is1n(card cards[],int n,int &start,int &end)//顺子 \r\n{\r\n     if(n<5)\r\n       return false;\r\n     for(int i=0;i<n;++i)\r\n        if(1!=cards[i].num)\r\n          return false;\r\n     int id=cards[0].id;\r\n     for(int i=0;i<n;++i)\r\n     {\r\n         if(cards[i].id!=id)\r\n           return false;\r\n         ++id;\r\n     }\r\n     start=cards[0].id;\r\n     end=cards[n-1].id;\r\n     return true;\r\n}\r\nbool is2n(card cards[],int n,int &start,int &end)\r\n{\r\n     if(n<6||n%2!=0)\r\n       return false;\r\n     for(int i=0;i<n/2;++i)\r\n        if(2!=cards[i].num)\r\n          return false;\r\n     int id=cards[0].id;\r\n     for(int i=0;i<n/2;++i)\r\n     {\r\n         if(cards[i].id!=id)\r\n           return false;\r\n         ++id;\r\n     }\r\n     start=cards[0].id;\r\n     end=cards[n/2-1].id;\r\n     return true;\r\n}\r\nbool is4plus2(card cards[],int n,int &start,int &end)\r\n{\r\n     if(6!=n)\r\n       return false;\r\n     if(4!=cards[0].num||1!=cards[1].num||1!=cards[2].num)\r\n       return false;\r\n     start=cards[0].id;\r\n     end=cards[0].id;\r\n     return true;\r\n}\r\nbool is4plus4(card cards[],int n,int &start,int &end)\r\n{\r\n     if(8!=n)\r\n       return false;\r\n     if(4!=cards[0].num||2!=cards[1].num||2!=cards[2].num)\r\n       return false;\r\n     start=cards[0].id;\r\n     end=cards[0].id;\r\n     return true;\r\n}\r\ntypedef bool (*CmpFunc)(card cards[],int n,int &start,int &end);\r\nconst int cardsType=12;\r\nCmpFunc cmp[]={isZero,isRocket,isBomb,isOne,isTwo,isThreeSame,\r\n               is3plus1,is3plus2,is1n,is2n,is4plus2,is4plus4};\r\nconst int zero=0,rocket=1,bomb=2,one=3,two=4,threesame=5,\r\n          plus31=6,plus32=7,n1=8,n2=9,plus42=10,plus44=11;\r\ntypedef bool (*FindFunc)(int bob[],int start,int end);\r\nbool findZero(int bob[],int start,int end)\r\n{\r\n     return true;\r\n}\r\nbool findRocket(int bob[],int start,int end)\r\n{\r\n     return false;\r\n}\r\nbool findBomb(int bob[],int start,int end)//天王炸已考虑 \r\n{\r\n     for(int i=start+1;i<MaxN;++i)\r\n        if(4==bob[i])\r\n          return true;\r\n     return false;\r\n}\r\nbool findOne(int bob[],int start,int end)\r\n{\r\n     for(int i=start+1;i<MaxN;++i)\r\n        if(bob[i]>=1)\r\n          return true;\r\n     return false;\r\n}\r\nbool findTwo(int bob[],int start,int end)\r\n{\r\n     for(int i=start+1;i<MaxN;++i)\r\n        if(bob[i]>=2)\r\n          return true;\r\n     return false;\r\n}\r\nbool findThreeSame(int bob[],int start,int end)\r\n{\r\n     bool hasAns=false;\r\n     for(int s=start+1;s<MaxN-(end-start);++s)\r\n     {\r\n         int e=s+end-start;\r\n         hasAns=true;\r\n         for(int i=s;i<=e;++i)\r\n         {\r\n             if(bob[i]<3)\r\n             {\r\n                hasAns=false;\r\n                break;\r\n             }\r\n         }\r\n         if(hasAns)\r\n            return true;\r\n     }\r\n     return false;\r\n}\r\nbool find3plus1(int bob[],int start,int end)\r\n{\r\n     bool has3=false;\r\n     for(int s=start+1;s<MaxN-(end-start);++s)\r\n     {\r\n         int e=s+end-start;\r\n         has3=true;\r\n         for(int i=s;i<=e;++i)\r\n         {\r\n             if(bob[i]<3)\r\n             {\r\n                has3=false;\r\n                break;\r\n             }\r\n         }\r\n         if(has3)\r\n         {\r\n            int n=0;\r\n            for(int i=0;i<start;++i)\r\n               if(bob[i]>=1)\r\n                 ++n;\r\n            for(int i=end+1;i<MaxN;++i)\r\n               if(bob[i]>=1)\r\n                 ++n;\r\n            if(n>=end-start+1)\r\n              return true;\r\n         }\r\n     }\r\n     return false;\r\n}\r\nbool find3plus2(int bob[],int start,int end)\r\n{\r\n     bool has3=false;\r\n     for(int s=start+1;s<MaxN-(end-start);++s)\r\n     {\r\n         int e=s+end-start;\r\n         has3=true;\r\n         for(int i=s;i<=e;++i)\r\n         {\r\n             if(bob[i]<3)\r\n             {\r\n                has3=false;\r\n                break;\r\n             }\r\n         }\r\n         if(has3)\r\n         {\r\n            int n=0;\r\n            for(int i=0;i<start;++i)\r\n               if(bob[i]>=2)\r\n                 ++n;\r\n            for(int i=end+1;i<MaxN;++i)\r\n               if(bob[i]>=2)\r\n                 ++n;\r\n            if(n>=end-start+1)\r\n              return true;\r\n         }\r\n     }\r\n     return false;\r\n}\r\nbool find1n(int bob[],int start,int end)\r\n{\r\n     bool hasAns=false;\r\n     for(int s=start+1;s<MaxN-(end-start);++s)\r\n     {\r\n         hasAns=true;\r\n         int e=s+(end-start);\r\n         for(int i=s;i<=e;++i)\r\n         {\r\n             if(bob[i]<1)\r\n             {\r\n                hasAns=false;\r\n                break;\r\n             }\r\n         }\r\n         if(hasAns)\r\n           return true;\r\n     }\r\n     return false;\r\n}\r\nbool find2n(int bob[],int start,int end)\r\n{\r\n     bool hasAns=false;\r\n     for(int s=start+1;s<MaxN-(end-start);++s)\r\n     {\r\n         hasAns=true;\r\n         int e=s+(end-start);\r\n         for(int i=s;i<=e;++i)\r\n         {\r\n             if(bob[i]<2)\r\n             {\r\n                hasAns=false;\r\n                break;\r\n             }\r\n         }\r\n         if(hasAns)\r\n           return true;\r\n     }\r\n     return false;\r\n}\r\nbool find4plus2(int bob[],int start,int end)\r\n{\r\n     for(int i=start+1;i<MaxN;++i)\r\n     {\r\n          if(4==bob[i])\r\n          {\r\n             int n=0;\r\n             for(int s=0;s<i;++s)\r\n                if(bob[s]>0)\r\n                  ++n;\r\n             for(int s=i+1;i<MaxN;++i)\r\n                if(bob[s]>0)\r\n                  ++n;\r\n             if(n>=2)\r\n               return true;\r\n          }\r\n     }\r\n     return false;\r\n}\r\nbool find4plus4(int bob[],int start,int end)\r\n{\r\n     for(int i=start+1;i<MaxN;++i)\r\n     {\r\n          if(4==bob[i])\r\n          {\r\n             int n=0;\r\n             for(int s=0;s<i;++s)\r\n                if(bob[s]>1)\r\n                  ++n;\r\n             for(int s=i+1;i<MaxN;++i)\r\n                if(bob[s]>1)\r\n                  ++n;\r\n             if(n>=2)\r\n               return true;\r\n          }\r\n     }\r\n     return false;\r\n}\r\nFindFunc findGreater[]={findZero,findRocket,findBomb,findOne,findTwo,findThreeSame,\r\n               find3plus1,find3plus2,find1n,find2n,find4plus2,find4plus4};\r\nbool hasBomb(int bob[])\r\n{\r\n     for(int i=0;i<MaxN;++i)\r\n        if(4==bob[i])\r\n          return true;\r\n     return false;\r\n}\r\ninline void doC(int &c)\r\n{\r\n       if(-2==c)\r\n         c=big;\r\n       else if(-1==c)\r\n         c=small;\r\n       else if(1==c)\r\n         c=A;\r\n       else if(2==c)\r\n         c=KingTwo;\r\n       else\r\n          ;\r\n}\r\nint main()\r\n{\r\n    //ifstream cin("doudezhu.in");\r\n    //ofstream cout("doudezhu.out");\r\n    int Alice[MaxN],Bob[MaxN];\r\n    card cards[MaxN];\r\n    int c;\r\n    int n=0;\r\n    while(cin>>c)\r\n    {\r\n         memset(Alice,0,sizeof(Alice));\r\n         memset(Bob,0,sizeof(Bob));\r\n         int na=0,nb=0;\r\n         while(c!=0)\r\n         {\r\n            doC(c);\r\n            ++Alice[c];\r\n            ++na;\r\n            cin>>c;\r\n         }++n;\r\n         memset(cards,0,sizeof(cards));\r\n         for(int i=0;i<MaxN;++i)\r\n         {\r\n             cards[i].id=i;\r\n             cards[i].num=Alice[i];\r\n         }\r\n         sort(cards,cards+MaxN);\r\n         while(cin>>c&&c!=0)\r\n         {\r\n             doC(c);\r\n             ++Bob[c];\r\n             ++nb;\r\n         }++n;\r\n         int start,end;\r\n         int type;\r\n         for(type=0;type<cardsType;++type)\r\n         {\r\n             if(cmp[type](cards,na,start,end))\r\n               break;\r\n         }\r\n         if(cardsType==type)\r\n         {\r\n            cout<<"Wrong"<<endl;\r\n            continue;\r\n         }\r\n         else if(zero==type||(1==Bob[big]&&1==Bob[small]))\r\n         {\r\n             cout<<"Yes"<<endl;\r\n             continue;\r\n         }\r\n         else if(rocket==type)\r\n         {\r\n             cout<<"No"<<endl;\r\n             continue;\r\n         }\r\n         else if(bomb==type)\r\n         {\r\n            if(findBomb(Bob,start,end))\r\n              cout<<"Yes"<<endl;\r\n            else\r\n              cout<<"No"<<endl;\r\n            continue;\r\n         }\r\n         else\r\n         {\r\n             if(hasBomb(Bob))\r\n             {\r\n                cout<<"Yes"<<endl;\r\n                continue;\r\n             }\r\n             else\r\n             {\r\n                 if(findGreater[type](Bob,start,end))\r\n                   cout<<"Yes"<<endl;\r\n                 else\r\n                   cout<<"No"<<endl;\r\n             }\r\n         }\r\n    }\r\n    //system("pause");\r\n    return 0;\r\n}\r\n', '', 0, 368640, 1, 2, '2010-08-07 19:42:14', '2010-08-07 19:42:42');
INSERT INTO `tbl_submitions` (`id`, `user_id`, `problem_id`, `exercise_id`, `source`, `result`, `used_time`, `used_memory`, `status`, `compiler_id`, `created`, `modified`) VALUES
(112, 1, 99, 0, '#include <cstdio>\r\n#include <string>\r\n#include <memory.h>\r\nusing namespace std;\r\n\r\nconst int MAXN = 32;\r\nint p[MAXN][MAXN], dis[MAXN][MAXN];\r\nint n;\r\n\r\nint check_cycle() {\r\n	int i, j, ind[MAXN], vis[MAXN], cc = 0;\r\n	memset(ind, 0, sizeof(ind));\r\n	memset(vis, 0, sizeof(vis));\r\n	for (i = 0 ; i < n ; i++)\r\n		for (j = 0 ; j < n ; j++)\r\n			if (p[i][j] > 0) {\r\n				++ind[j];\r\n			}\r\n	while (1) {\r\n		for (i = 0 ; i < n ; i++) {\r\n			if (vis[i]) continue;\r\n			if (ind[i] == 0) break;\r\n		}\r\n		if (i == n) break;\r\n		vis[i] = 1;\r\n		++cc;\r\n		for (j = 0 ; j < n ; j++)\r\n			if (p[i][j] > 0) --ind[j];\r\n	}\r\n	return cc < n;\r\n}\r\n\r\ndouble calc(int v) {\r\n	if (v == n-1) return 0;\r\n	int i;\r\n	double ans = 0;\r\n	for (i = 0 ; i < n ; i++)\r\n		if (p[v][i] > 0) {\r\n			double tmp = calc(i);\r\n			ans += (tmp + dis[v][i]) * ((double)p[v][i] / 100);\r\n		}\r\n	return ans;\r\n}\r\n\r\nint main() {\r\n	//freopen("distance.in","r",stdin);\r\n	//freopen("roba.out","w",stdout);\r\n	int T, i, j;\r\n	scanf("%d",&T);\r\n	while (T--) {\r\n		memset(p, 0, sizeof(p));\r\n		memset(dis, 0, sizeof(dis));\r\n		scanf("%d",&n);\r\n		for (i = 0 ; i < n ; i++)\r\n			for (j = 0 ; j < n ; j++)\r\n				scanf("%d",&p[i][j]);\r\n		for (i = 0 ; i < n ; i++) {\r\n			p[i][n] = p[i][0];\r\n			p[i][0] = 0;\r\n		}\r\n		for (i = 0 ; i < n ; i++)\r\n			for (j = 0 ; j < n ; j++)\r\n				scanf("%d",&dis[i][j]);\r\n		for (i = 0 ; i < n ; i++) {\r\n			dis[i][n] = dis[i][0];\r\n			dis[i][0] = 0;\r\n		}\r\n		++n;\r\n		if (check_cycle()) printf("No solution.\\n");\r\n		else {\r\n			printf("%.5lf\\n",calc(0));\r\n		}\r\n	}\r\n	return 0;\r\n}\r\n', '', 0, 266240, 1, 2, '2010-08-07 19:44:25', '2010-08-07 19:46:02'),
(113, 1, 100, 0, '#include<iostream>\r\nusing namespace std;\r\n#include<cmath>\r\ntypedef long long lld;\r\nconst double eps=1e-5;\r\ninline int sign(double v)\r\n{\r\n    if(v>eps)\r\n      return 1;\r\n    else if(v<-eps)\r\n      return -1;\r\n    return 0;\r\n}\r\nlld a,b,c,d,det,counts;\r\ninline double f(double x)\r\n{\r\n       return a*x*x*x+b*x*x+c*x+d;\r\n}\r\nint main()\r\n{\r\n    while(cin>>a>>b>>c>>d)\r\n    {\r\n         counts=0;\r\n         --c;\r\n         if(0==a&&0==b&&0==c)\r\n         {\r\n           if(0==d)\r\n             counts=4;\r\n           else\r\n             counts=0;\r\n         }\r\n         else if(0==a&&0==b&&0!=c)\r\n           counts=1;\r\n         else if(0==a&&0!=b)\r\n         {\r\n             det=c*c-4*b*d;\r\n             if(det<0)\r\n               counts=0;\r\n             else if(0==det)\r\n               counts=1;\r\n             else\r\n               counts=2; \r\n         }\r\n         else\r\n         {\r\n             if(a<0)\r\n             {\r\n                a=-a;\r\n                b=-b;\r\n                c=-c;\r\n                d=-d;\r\n             }\r\n             det=4*b*b-12*a*c;\r\n             if(det<=0)\r\n               counts=1;\r\n             else\r\n             {\r\n                double dd=sqrt((double)det);\r\n                double x1=(-2.0*b-dd)/(6.0*a),x2=(-2.0*b+dd)/(6.0*a);\r\n                if(-1==sign(f(x1)))\r\n                  counts=1;\r\n                else if(0==sign(f(x1)))\r\n                  counts=2;\r\n                else if(1==sign(f(x2)))\r\n                  counts=1;\r\n                else if(0==sign(f(x2)))\r\n                  counts=2;\r\n                else\r\n                  counts=3;\r\n             }\r\n          }\r\n          cout<<counts<<endl;\r\n     }\r\n    return 0;\r\n}\r\n', '', 327, 364544, 1, 2, '2010-08-07 19:47:52', '2010-08-07 19:47:52'),
(114, 1, 101, 0, '#include<iostream>\r\nusing namespace std;\r\n#include<fstream>\r\n#include<algorithm>\r\ninline bool equals(char a,char b)\r\n{\r\n     return a==b;\r\n}\r\ninline bool notLessThan(char a,char b)\r\n{\r\n     if(''r''==a)\r\n       return true;\r\n     return a==b;\r\n}\r\nvoid getNext(char *str,int len,int next[]);\r\ntemplate<typename cmp>\r\nbool comparekmp(char *line,char *str,int len,int next[],cmp cmpfunc);\r\nint getLength(char line[],int lw[],int lb[],int rw[],int rb[],int len);\r\nconst int MaxLen=200010;\r\nchar line1[MaxLen],line2[MaxLen],str1[MaxLen],str2[MaxLen];\r\nint len,next1[MaxLen],next2[MaxLen];\r\nint lw1[MaxLen],lb1[MaxLen],rw1[MaxLen],rb1[MaxLen];\r\nint lw2[MaxLen],lb2[MaxLen],rw2[MaxLen],rb2[MaxLen];\r\nint main()\r\n{\r\n    //ifstream cin("necklace_09.in");\r\n    //ofstream cout("necklace_09.out");\r\n    while(cin>>len)\r\n    {\r\n          cin>>str1>>str2;\r\n          int i;\r\n          for(i=0;i<len;++i)\r\n          {\r\n              line1[i]=str1[i];\r\n              line2[i]=str2[i];\r\n          }\r\n          for(i=len;i<=2*len;++i)\r\n          {\r\n              line1[i]=str1[i-len];\r\n              line2[i]=str2[i-len];\r\n          }\r\n          int kmpRes=0;\r\n          getNext(str1,len,next1);\r\n          getNext(str2,len,next2);\r\n          if(comparekmp(line1,str2,len,next2,equals))\r\n             kmpRes=1;\r\n          else if(comparekmp(line1,str2,len,next2,notLessThan))\r\n             kmpRes=2;\r\n          else if(comparekmp(line2,str1,len,next1,notLessThan))\r\n             kmpRes=3;\r\n          else\r\n             kmpRes=4;\r\n          string cmpRes[]={"","same","first","second","other"};\r\n          cout<<cmpRes[kmpRes]<<endl;\r\n          len=len+len;\r\n          int lenRes1=getLength(line1,lw1,lb1,rw1,rb1,len);\r\n          int lenRes2=getLength(line2,lw2,lb2,rw2,rb2,len);\r\n          cout<<lenRes1<<endl<<lenRes2<<endl;\r\n    }\r\n    return 0;\r\n}\r\nvoid getNext(char *str,int len,int next[])\r\n{\r\n     int i=0,j=-1;\r\n     next[0]=-1;\r\n     while(i<len)\r\n     {\r\n          if(-1==j||str[i]==str[j])\r\n          {\r\n             ++i;\r\n             ++j;\r\n             next[i]=j;\r\n          }\r\n          else\r\n            j=next[j];\r\n     }\r\n}\r\ntemplate<typename cmp>\r\nbool comparekmp(char *line,char *str,int len,int next[],cmp cmpfunc)\r\n{\r\n     int i=0,j=0;\r\n     while(i<2*len&&j<len)\r\n     {  \r\n          if(-1==j||cmpfunc(line[i],str[j]))\r\n          {\r\n             ++i;\r\n             ++j;\r\n          }\r\n          else\r\n            j=next[j];\r\n     }\r\n     if(j>=len)\r\n       return true;\r\n     return false;\r\n}\r\nint getLength(char line[],int lw[],int lb[],int rw[],int rb[],int len)\r\n{\r\n     int i;\r\n     lw[0]=lb[0]=rw[len]=rb[len]=0;\r\n     for(i=0;i<len;++i)\r\n     {\r\n              if(''w''==line[i])\r\n              {\r\n                  lb[i+1]=0;\r\n                  lw[i+1]=lw[i]+1;\r\n              }\r\n              else if(''b''==line[i])\r\n              {\r\n                   lb[i+1]=lb[i]+1;\r\n                   lw[i+1]=0;\r\n              }\r\n              else\r\n              {\r\n                  lb[i+1]=lb[i]+1;\r\n                  lw[i+1]=lw[i]+1;\r\n              }\r\n     }     \r\n     for(i=len-1;i>=0;--i)\r\n     {\r\n              if(''w''==line[i])\r\n              {\r\n                  rb[i]=0;\r\n                  rw[i]=rw[i+1]+1;\r\n              }\r\n              else if(''b''==line[i])\r\n              {\r\n                   rb[i]=rb[i+1]+1;\r\n                   rw[i]=0;\r\n              }\r\n              else\r\n              {\r\n                  rb[i]=rb[i+1]+1;\r\n                  rw[i]=rw[i+1]+1;\r\n              }\r\n     }  \r\n     int res=0;\r\n     for(i=0;i<=len;++i)\r\n        res=max(res,max(lb[i]+rb[i],lw[i]+rw[i]));\r\n     res=min(res,len/2);\r\n     return res;\r\n}\r\n', '', 513, 9183232, 1, 2, '2010-08-07 19:49:44', '2010-08-07 19:50:07'),
(115, 1, 102, 0, '#include<iostream>\r\n#include<fstream>\r\n#include<algorithm>\r\nusing namespace std;\r\ninline int cross(int x1,int y1,int x2,int y2)\r\n{\r\n       return x1*y2-x2*y1;\r\n}\r\nint main()\r\n{\r\n    //ifstream cin("intersect.in");\r\n    //ofstream cout("intersect.out");\r\n    int x1,y1,x2,y2,x3,y3,x4,y4;\r\n    int res1,res2,res3,res4;\r\n    while(cin>>x1>>y1>>x2>>y2>>x3>>y3>>x4>>y4)\r\n    {\r\n         if(x1>x2)\r\n         {\r\n            swap(x1,x2);\r\n            swap(y1,y2);\r\n         }\r\n         if(x3>x4)\r\n         {\r\n            swap(x3,x4);\r\n            swap(y3,y4);\r\n         }\r\n         res1=cross(x2-x1,y2-y1,x3-x1,y3-y1);//AB*AC\r\n         res2=cross(x2-x1,y2-y1,x4-x1,y4-y1);//AB*AD\r\n         res3=cross(x4-x3,y4-y3,x1-x3,y1-y3);//CD*CA\r\n         res4=cross(x4-x3,y4-y3,x2-x3,y2-y3);//CD*CB\r\n         if(0==res1&&0==res2&&0==res3&&0==res4)\r\n         {\r\n            if(x1==x2&&x1==x3&&x1==x4)\r\n            {\r\n               if(y1>y2)\r\n               {\r\n                  swap(x1,x2);\r\n                  swap(y1,y2);\r\n               }\r\n               if(y3>y4)\r\n               {\r\n                  swap(x3,x4);\r\n                  swap(y3,y4);\r\n               }\r\n               if(y3>y2||y1>y4)\r\n                 cout<<"None"<<endl;\r\n               else if(y3==y2||y1==y4)\r\n                 cout<<"One"<<endl;\r\n               else\r\n                 cout<<"Many"<<endl;\r\n            }\r\n            else\r\n            {\r\n               if(x3>x2||x1>x4)\r\n                 cout<<"None"<<endl;\r\n               else if(x3==x2||x1==x4)\r\n                 cout<<"One"<<endl;\r\n               else\r\n                 cout<<"Many"<<endl;                \r\n            }\r\n         }\r\n         else\r\n         {\r\n             if(res1*res2<=0&&res3*res4<=0)\r\n               cout<<"One"<<endl;\r\n             else\r\n               cout<<"None"<<endl;\r\n         }\r\n    }\r\n    return 0;\r\n}\r\n', '', 748, 364544, 1, 2, '2010-08-07 19:53:45', '2010-08-07 19:53:45'),
(116, 1, 103, 0, '#include<iostream>\r\n#include<cstdio>\r\n#include<cstdlib>\r\n#include<ctime>\r\n#include<cmath>\r\n#include<memory.h>\r\nusing namespace std;\r\n#include<fstream>\r\n#include<algorithm>\r\ntypedef long long lld;\r\nconst int maxP=1000006;\r\nlld times[maxP];\r\nvoid getCircle(lld a,lld n,lld &start,lld &len)//求出a^x%n的循环节\r\n{\r\n     memset(times,-1,sizeof(times));\r\n     lld t=0,res=1%n;\r\n     len=-1;\r\n     while(-1==len)\r\n     {     \r\n          if(-1==times[res])\r\n            times[res]=t;\r\n          else\r\n          {\r\n              len=t-times[res];\r\n              start=times[res];\r\n          }\r\n          res=res*a%n;\r\n          ++t;\r\n     }\r\n} \r\nlld mul_mod(lld a,lld b,lld n)// a*b%n\r\n{\r\n    lld res=0;\r\n    a=a%n,b=b%n;\r\n    while(b>0)\r\n    {\r\n        if(b&0x01)\r\n          res=(res+a)%n;\r\n        a=(a+a)%n;\r\n        b>>=1;\r\n    }\r\n    return res;\r\n}\r\nlld exp_mod(lld a,lld b,lld n)// a^b%n\r\n{\r\n    lld res=1%n;\r\n    while(b>0)\r\n    {\r\n         if(b&0x01)\r\n           res=mul_mod(res,a,n);\r\n         a=mul_mod(a,a,n);\r\n         b>>=1;\r\n    }\r\n    return res;\r\n}\r\nvoid get(lld n,lld &t,lld &u)\r\n{\r\n     u=n;\r\n     t=0;\r\n     while(0==(u&0x01))\r\n     {\r\n           ++t;\r\n           u>>=1;\r\n          // cout<<t<<endl;\r\n     }\r\n}\r\nint witness(lld n)//composite return 1\r\n{\r\n    lld t,u;\r\n    if(0==(n&0x01)&&2!=n)\r\n      return 1;\r\n    get(n-1,t,u);\r\n   // cout<<"t="<<t<<endl;\r\n    lld a=rand()%(n-1)+1;\r\n    lld x=exp_mod(a,u,n);\r\n /*   cout<<"a="<<a<<endl;\r\n    cout<<"u="<<u<<endl;\r\n    cout<<"t="<<t<<endl;\r\n    cout<<"x="<<x<<endl;*/\r\n    for(lld i=1;i<=t;++i)\r\n    {\r\n        lld tmp=x;\r\n        x=mul_mod(x,x,n);\r\n        //cout<<x<<endl;\r\n        if(1==x&&1!=tmp&&(n-1)!=tmp)\r\n          return 1;\r\n    }\r\n   // cout<<x<<endl;\r\n    if(1!=x)\r\n      return 1;\r\n    return 0;\r\n}\r\nint miller_rabin(lld n,int times)//return 1 if it must be a composite number,\r\n                                 //otherwise,it may be a prime number.\r\n{\r\n    for(int i=0;i<times;++i)\r\n       if(1==witness(n))\r\n         return 1;\r\n    return 0;\r\n}\r\nlld gcd(lld a,lld b)\r\n{\r\n    if(a<b)\r\n    {\r\n       lld tmp=a;\r\n       a=b;\r\n       b=tmp;\r\n    }\r\n    while(b!=0)\r\n    {\r\n         lld tmp=b;\r\n         b=a%b;\r\n         a=tmp;\r\n    }\r\n    return a;\r\n}\r\nlld pollard_rho(lld n,lld c)\r\n{//cout<<"here"<<endl;\r\n    lld i=1;\r\n    lld x=rand()%n;\r\n    lld y=x;\r\n    lld k=2;\r\n    while(true)\r\n    {\r\n         ++i;\r\n         x=mul_mod(x,x,n);\r\n         x=(x+n-c)%n;\r\n         if(y==x)\r\n           return 0;\r\n         lld d=gcd(y-x>0?y-x:x-y,n);\r\n         if(1<d&&d<n)\r\n           return d;\r\n         if(i==k)\r\n         {\r\n            y=x;\r\n            k=k+k;\r\n         }\r\n    }\r\n}\r\nlld factorRes;\r\nvoid getFactor(lld n)\r\n{\r\n    lld factor=0,c=3;\r\n    if(0==miller_rabin(n,10))\r\n      return;\r\n    while(0==factor)\r\n         factor=pollard_rho(n,c++);\r\n    if(factor<factorRes)\r\n      factorRes=factor;\r\n    if(n/factor<factorRes)\r\n      factorRes=n/factor;\r\n    getFactor(factor);\r\n    getFactor(n/factor);\r\n}\r\nstruct hash\r\n{\r\n       lld j,xj;\r\n       bool operator<(const hash &other)const\r\n       {\r\n            if(xj==other.xj)\r\n              return j>other.j;\r\n            return xj<other.xj;\r\n       }\r\n};\r\nhash table[100000];\r\ninline bool cmp2(const hash &h1,const hash &h2)\r\n{\r\n       return h1.xj<h2.xj;\r\n}\r\nint main()\r\n{\r\n    int T;\r\n    lld n,x,z,k,b;\r\n    //ifstream cin("jiyanmoyu.in");\r\n    //ofstream cout("jiyanmoyu.out");\r\n    while(cin>>n>>x>>z>>k>>b)\r\n    {\r\n           lld nc=n,xc=x;\r\n             if(0==miller_rabin(n,20))\r\n               cout<<1<<" ";\r\n             else\r\n             {\r\n                 factorRes=(1<<30);\r\n                 getFactor(n);\r\n                 cout<<n/factorRes<<" ";\r\n             }\r\n          x=x%z;\r\n          k=k%z;\r\n          lld m=(lld)ceil(sqrt((double)z))+1;\r\n          lld xj=k%z;\r\n          lld j;\r\n          for(j=0;j<=m;++j)\r\n          {\r\n              table[j].j=j;\r\n              table[j].xj=xj;\r\n              xj=xj*x%z;\r\n              //cout<<"j,xj="<<j<<" "<<xj<<endl;\r\n          }\r\n          sort(table,table+m+1);\r\n          lld xm=exp_mod(x,m,z);\r\n          lld i;\r\n          lld left=xm%z;\r\n          bool getAns=false;\r\n          //cout<<"xm="<<xm<<endl;\r\n          for(i=1;i<=m;++i)\r\n          {\r\n              //left=left*xm%z;\r\n              hash tmp;\r\n              tmp.xj=left;\r\n              hash *p=lower_bound(table,table+m+1,tmp,cmp2);\r\n              if(p!=table+m+1&&(*p).xj==left)\r\n              {\r\n                 j=(*p).j;\r\n                 while((*p).xj==left&&k!=exp_mod(x,i*m-j,z)&&p!=table+m+1)\r\n                 {\r\n                      j=(*p).j;\r\n                      ++p;\r\n                 }\r\n                 if(k!=exp_mod(x,i*m-j,z))\r\n                   continue;\r\n                 //cout<<"left,i,j="<<left<<" "<<i<<" "<<j<<endl;\r\n                 getAns=true;\r\n                 break;\r\n              }\r\n              left=left*xm%z;\r\n          }\r\n          if(getAns&&k==exp_mod(x,i*m-j,z))\r\n            cout<<i*m-j<<" ";\r\n          else\r\n             cout<<z<<" ";\r\n         n=nc;\r\n         x=xc; \r\n         lld a=n,c=n+1;\r\n         if(a%2==0)\r\n           a=(a>>1);\r\n         else\r\n           c=(c>>1);\r\n         lld tmp1=exp_mod(x,a,b);\r\n         lld tmp2=exp_mod(tmp1,c,b);\r\n         cout<<tmp2<<endl;\r\n        /* lld start,len;\r\n         getCircle(x,b,start,len);\r\n      //   system("pause");\r\n         lld tmp;\r\n         if(0==n%2)\r\n         {\r\n            if((n+1)>start)\r\n              tmp=start+((n+1)-start)%len;\r\n            else\r\n              tmp=n+1;\r\n            n=n/2;\r\n            if(n>start)\r\n               n=start+(n-start)%len;\r\n            tmp=tmp*n;\r\n         }\r\n         else\r\n         {\r\n            if(n>start)\r\n              tmp=start+(n-start)%len;\r\n            else\r\n              tmp=n;\r\n            n=(n+1)/2;\r\n            if(n>start)\r\n               n=start+(n-start)%len;\r\n            tmp=tmp*n;\r\n         }\r\n         if(tmp>start)\r\n           tmp=start+(tmp-start)%len;\r\n         //cout<<endl<<x<<" "<<tmp<<" "<<b<<endl;\r\n         //system("pause");\r\n         lld res=exp_mod(x,tmp,b);\r\n         cout<<res<<endl;*/\r\n    }\r\n    return 0;\r\n}\r\n', '', 120, 9990144, 1, 2, '2010-08-07 20:01:01', '2010-08-07 20:02:24'),
(117, 1, 104, 0, '#define maxn 20020\r\n#include <stdio.h>\r\n#include <string.h>\r\n#include <iostream>\r\nusing namespace std;\r\nint n, k, l, a[maxn], s[maxn], opt[maxn][2];\r\nvoid init(){\r\n	scanf("%d%d%d", &n, &k, &l);\r\n	s[0] = 0;\r\n	for (int i=1; i<=n; i++) {\r\n		scanf("%d", &a[i]);\r\n		s[i] = s[i-1] + a[i];\r\n	}\r\n}\r\n\r\nvoid solve(){\r\n	memset(opt, 0x7f, sizeof opt);\r\n	for (int i=l; i<=n; i++) opt[i][0] = s[i];\r\n	int ans = s[n];\r\n	for (int K=2; K<=k; K++){\r\n		int tmp = 0x7f7f7f7f, t2;\r\n		for (int j=K-1; j<=K-l-1; j++){\r\n			if (opt[j][K%2] == 0x7f7f7f7f) continue;\r\n			tmp = min(tmp, opt[j][K%2] - K*s[j]);\r\n		}\r\n		for (int i=K; i<=n; i++){\r\n			if (i-l>=0 && opt[i-l][K%2]!=0x7f7f7f7f) tmp = min(tmp, opt[i-l][K%2] - K*s[i-l]);\r\n			if (tmp!=0x7f7f7f7f) t2=tmp+K*s[i]; else t2=tmp;\r\n			opt[i][1-K%2]=t2;\r\n			if (i==n) ans = min(ans, opt[i][1-K%2]);\r\n		}\r\n	}\r\n	printf("%d\\n", ans);\r\n}\r\n\r\nint main(){\r\n	int test; scanf("%d", &test);\r\n	while (test--){\r\n		init();\r\n		solve();\r\n	}\r\n	return 0;\r\n}\r\n', '', 296, 688128, 1, 2, '2010-08-08 01:21:08', '2010-08-08 01:32:48'),
(118, 1, 105, 0, '#include <stdio.h>\r\n#include <cstring>\r\n#include <set>\r\n#include <algorithm>\r\nusing namespace std;\r\n#define maxl 200010\r\n\r\nset< pair<int, int> > st;\r\nset< pair<int, int> > :: iterator it;\r\nchar S[maxl];\r\nint head[maxl], next[maxl], rank[maxl], b[maxl], L[maxl], list[maxl], height[maxl];\r\nint f[maxl][20];\r\nint n, k, tot;\r\nbool vis[maxl];\r\nlong long ans;\r\n\r\nbool cmp(int i, int j){ return S[i] < S[j]; }\r\n\r\nvoid suffix_sort(int n)\r\n{\r\n	for(int i=0; i<n; ++i) list[i] = i;\r\n	sort(list, list+n, cmp);\r\n	b[list[0]] = 0;\r\n	for(int i=1; i<n; ++i)\r\n	{\r\n		if(S[list[i]]==S[list[i-1]]) b[list[i]] = b[list[i-1]];\r\n		else b[list[i]] = i;\r\n	}\r\n\r\n	int j;\r\n	for(int h=1; h<n; h<<=1)\r\n	{\r\n		for(int i=0; i<n; ++i) head[i] = next[i] = -1;\r\n		for(int i=n-1; i>=0; --i)\r\n		{\r\n			if(list[i])\r\n			{\r\n				j = list[i] - h; if(j < 0)  j += n;\r\n				next[j] = head[b[j]]; head[b[j]] = j;\r\n			}\r\n		}\r\n		j = n - h; next[j] = head[b[j]]; head[b[j]] = j;\r\n		for(int i=0, k=0; i<n; ++i)\r\n		{\r\n			if(head[i] >= 0) for(j=head[i]; j>=0; j=next[j]) list[k++] = j;\r\n		}\r\n		for(int i=0; i<n; ++i)\r\n		{\r\n			if(i>0 && list[i]+h<n && list[i-1]+h<n && b[list[i]]==b[list[i-1]] && b[list[i]+h]==b[list[i-1]+h])\r\n				rank[list[i]] = rank[list[i-1]];\r\n			else rank[list[i]] = i;\r\n		}\r\n		for(int i=0; i<n; ++i) b[i] = rank[i];\r\n	}\r\n}\r\n\r\nvoid get_height(int n)\r\n{\r\n	height[0] = 0;\r\n	for(int i=0; i<n; ++i) rank[list[i]] = i;\r\n	for(int h=0, i=0; i<n; ++i)\r\n	{\r\n		if(rank[i] > 0)\r\n		{\r\n			int j = list[rank[i] - 1];\r\n			while(S[i+h]==S[j+h] && S[i+h]!=''$'') ++h;\r\n			height[rank[i]] = h;\r\n			if(h > 0) --h;\r\n		}\r\n	}\r\n}\r\n\r\nint rmq_ready(int n)\r\n{\r\n	for(int i=0; i<n; ++i) f[i][0] = i;\r\n	for(int j=1; (1<<j)<=n; ++j)\r\n	{\r\n		for(int i=0; (i+(1<<j)-1)<n; ++i)\r\n		{\r\n			int k = i + (1<<(j-1));\r\n			if(height[f[i][j-1]] < height[f[k][j-1]])\r\n				f[i][j] = f[i][j-1];\r\n			else f[i][j] = f[k][j-1];\r\n		}\r\n	}\r\n}\r\n\r\nint LCP(int i, int j)\r\n{\r\n	if(i==j) return tot - list[i];\r\n\r\n	if(i > j)\r\n	{\r\n		i ^= j; j ^= i; i ^= j;\r\n	}\r\n\r\n	int log = L[j - i];\r\n	int k = j - (1<<log) + 1;\r\n	return min(height[f[i+1][log]], height[f[k][log]]);\r\n}\r\n\r\nvoid init()\r\n{\r\n\r\n	strcat(S, "$");\r\n	for(int i=0; i<n; ++i) S[i + n + 1] = S[n - 1 - i];\r\n	S[2 * n + 1] = ''$'';\r\n	S[2 * n + 2] = 0;\r\n\r\n	tot = 2 * n + 2;\r\n	n = n + 1;\r\n\r\n	for(int i=1; i<=tot; ++i)\r\n	{\r\n		int j = 0;\r\n		while((1<<j) <= i) ++j;\r\n		j--;\r\n		L[i] = j;\r\n	}\r\n\r\n	suffix_sort(tot);\r\n	get_height(tot);\r\n	rmq_ready(tot);\r\n\r\n}\r\n\r\nlong long solve()\r\n{\r\n	ans = 0;\r\n\r\n	if(k == 1) return (long long)(n - 1) * n / 2;\r\n\r\n	//puts(S);\r\n\r\n	st.clear();\r\n	for(int l=1; l<n; ++l)\r\n	{\r\n		for(int i=0; i+l<n-1; i+=l)\r\n		{\r\n			int j = i + l;\r\n\r\n\r\n			if(S[i] != S[j]) continue;\r\n\r\n			int right = i + LCP(rank[i], rank[j]) - 1;\r\n			int left = i - LCP(rank[n + n - 2 - i], rank[n + n - 2 - j]) + 1;\r\n\r\n			if(left <= i - l) continue;\r\n\r\n			if(st.find(make_pair(left, right + l)) != st.end()) continue;\r\n\r\n			int len = right - left + 1 + l;\r\n			int d = len / l;\r\n\r\n			if(d >= k)\r\n			{\r\n				st.insert(make_pair(left, right + l));\r\n				long long tmp = ( (long long)(len + 1) * (d - k + 1) - ((long long)l * (k + d) * (d - k + 1) / 2) );\r\n				ans += tmp;\r\n				//printf("n %d %d %d %d %d %d %lld\\n", i, j, left, right, len, l, tmp);\r\n\r\n				/*\r\n				for(int x=left; x<=right+l; ++x) printf("%c", S[x]);\r\n				printf(" %d %d %d %lld\\n", l, left, right + l, tmp);\r\n				*/\r\n			}\r\n		}\r\n	}\r\n\r\n	return ans;\r\n}\r\n\r\nint main()\r\n{\r\n	while(scanf("%s%d", S, &k) != EOF)\r\n	{\r\n		n = strlen(S);\r\n		if(k == 1) printf("%lld\\n", (long long)(n + 1) * n / 2);\r\n		else\r\n		{\r\n			init();\r\n			printf("%lld\\n", solve());\r\n		}\r\n	}\r\n	return 0;\r\n}\r\n\r\n', '', 699, 22446080, 1, 2, '2010-08-08 01:34:35', '2010-08-08 01:35:00'),
(119, 1, 106, 0, '#include<iostream>\r\n#include<stdio.h>\r\n#include<cstring>\r\n#include<cstdlib>\r\n#include<cmath>\r\nusing namespace std;\r\nint f[105],used[105];\r\nint n;\r\nint minus1;\r\nint min1;\r\nint t;\r\nint ans;\r\nint main()\r\n{\r\n//freopen("Dartboard.in","r",stdin);\r\n//freopen("Dartboard.out","w",stdout);\r\ncin >> t;\r\nfor (int cases = 0; cases < t; ++cases)\r\n{\r\n 	cin >> n;\r\n    memset(f,0,sizeof(f));\r\n    f[n+1] = 1000;\r\n    f[0]   = 1000;\r\n    ans = 0;\r\n    memset(used,0,sizeof(used));\r\nif (n % 4 != 0)\r\n {\r\n  	f[1] = 2;\r\n  	f[2] = n-1;\r\n    used[n-1] = 1;\r\n    used[2] = 1;\r\n}\r\nif(n % 4 == 0)\r\n{\r\n	f[1]      = n;\r\n  	f[2]      =  1;\r\n  	f[n-1]    = 2;\r\n  	f[n]      = n-1;\r\n    used[n]   = 1;\r\n    used[n-1] = 1;\r\n    used[2]   = 1;\r\n    used[1]   = 1;\r\n}\r\n\r\nif (n%4!=0) \r\n{\r\n  for (int i = 3; i <= n ; i++)\r\n   {\r\n   	if (i % 2 == 0) continue;\r\n	for (int j = 1 ; j <= n ;j++)		  \r\n	{\r\n  		if (used[j] == 1) continue;\r\n		if(((f[i-2]+j == n-1) && (f[i-1]+n+1-j == n+3)) ||  ((f[i-2]+j == n+3) &&( f[i-1]+n+1-j == n-1)))\r\n		{\r\n			used[j]  = 1;\r\n			used[n+1-j] = 1; \r\n			f[i] = j; \r\n			f[i+1] = n+1-j; \r\n			break;\r\n		}\r\n		\r\n 	}	    \r\n   }		 \r\n} \r\n   \r\nif (n % 4 == 0) \r\n{\r\n	for (int i = 3; i <= n ; i++)\r\n    {\r\n    	minus1 = 1000;\r\n    	min1   =   -1;\r\n    	if (i % 2 == 0) continue;\r\n     		for (int k = 2;k <= n-1;k++ )\r\n      		{\r\n	   	 		if (f[k] == 0) continue;\r\n		 		if ((abs(f[k]-n/2) > min1)&&((f[k-2] == 0) && (f[k-1] == 0) || (f[k+2] == 0)&& (f[k+1] == 0)))\r\n		  		{\r\n		   			min1   = f[k];\r\n		   			minus1 = k;	\r\n		  		}	  \r\n 	  		}\r\n 	    if (minus1 == 1000) continue; \r\n  		for (int j = 1 ; j <= n ;j++)\r\n		{\r\n		   	if (used[j] == 1) continue;	\r\n		    if (f[minus1+2] == 0) \r\n			{\r\n				if (abs(f[minus1]-j) == 2)\r\n			 	{\r\n 	          		used[j]     = 1; \r\n					used[n+1-j] = 1; \r\n					f[minus1+1] = j; \r\n					f[minus1+2] = n+1-j;  	\r\n					break;					 \r\n			 	} 	    \r\n			}\r\n			else \r\n			{\r\n	  	  		if (abs(f[minus1]-j) == 2)\r\n			 	{\r\n 	          		used[j]     = 1; \r\n					used[n+1-j] = 1; \r\n					f[minus1-1] = j; \r\n					f[minus1-2] = n+1-j; \r\n					break;					 \r\n			 	} 	 \r\n			}\r\n		}\r\n   }		\r\n} \r\nfor (int i = 1; i <= n-2 ; i++)\r\n{\r\n	ans += (f[i]-f[i+2])*(f[i]-f[i+2]);\r\n}\r\nans += (f[n-1]-f[1])*(f[n-1]-f[1]);\r\nans += (f[n]-f[2])*(f[n]-f[2]);\r\nfor (int i = 1; i <= n/2 ; i++)\r\n{\r\n	ans += (f[2*i-1]-f[2*i])*(f[2*i-1]-f[2*i]);\r\n}\r\n/*for (int i = 1; i <= n;i++)\r\n{\r\n   	cout << f[i] << " ";  	\r\n} */\r\ncout<<ans<<endl;\r\n}\r\n   return 0;\r\n}\r\n', '', 0, 368640, 1, 2, '2010-08-08 01:43:26', '2010-08-08 01:43:49'),
(120, 1, 107, 0, '#include<stdio.h>\r\n#include<string.h>\r\n#include<stdlib.h>\r\n#include<time.h>\r\n#include<algorithm>\r\nusing namespace std;\r\n\r\n#define maxn 1010\r\n#define LEN 10010\r\n\r\nstruct node{\r\n	int p,v,g;\r\n};\r\nnode nd[maxn];\r\nint n,m;\r\nint g;\r\nint gn[maxn];\r\nint gv[maxn];\r\nint gp[maxn];\r\nchar f[2][LEN];\r\nint v[2][LEN];\r\n\r\nbool cmp(const node &a, const node &b){\r\n	return a.g < b.g;\r\n}\r\nvoid solve(){\r\n	int i,j,k;\r\n	int tmp;\r\n	int res;\r\n	int last;\r\n	for(i=0;i<n;++i) scanf("%d",&nd[i].p);\r\n	for(i=0;i<n;++i) scanf("%d",&nd[i].v);\r\n	for(i=0;i<n;++i) nd[i].g=0;\r\n	scanf("%d",&g);\r\n	for(i=0,j=1;i<g;++i){\r\n		scanf("%d",gn+j);\r\n		if(gn[j]!=1){\r\n			gp[j]=0;\r\n			gv[j]=0;\r\n			for(k=0;k<gn[j];++k){\r\n				scanf("%d",&tmp);\r\n				gp[j]+=nd[tmp-1].p;\r\n				gv[j]+=nd[tmp-1].v;\r\n				nd[tmp-1].g=j;\r\n			}\r\n			scanf("%d",&tmp);\r\n			gv[j]+=tmp;\r\n			++j;\r\n		}else{\r\n			scanf("%d",&k);\r\n			scanf("%d",&tmp);\r\n			nd[k-1].v+=tmp;\r\n		}\r\n	}\r\n	g=j-1;\r\n	gv[0]=0;gp[0]=LEN;gn[0]=maxn;\r\n	sort(nd,nd+n,cmp);\r\n	nd[n].g=maxn; nd[n].p=LEN; nd[n].v=0;\r\n	memset(f[0],0,sizeof(f[0][0])*(m+1));\r\n	memset(f[1],0,sizeof(f[1][0])*(m+1));\r\n	memset(v[0],0,sizeof(v[0][0])*(m+1));\r\n	memset(v[1],0,sizeof(v[1][0])*(m+1));\r\n	f[0][0]=f[1][0]=1;\r\n	//v[0][0]=v[1][0]=0;\r\n	last=0;\r\n//	for(i=0;i<n;++i) printf("%d %d %d\\n",nd[i].p,nd[i].v,nd[i].g);\r\n	for(i=0;i<=n;++i){\r\n		if(nd[i].g>last){\r\n			for(j=m;j>=gp[last];--j){\r\n				k=j-gp[last];\r\n				if(f[1][k] && v[1][k]+gv[last]> v[1][j]){\r\n					v[1][j]=v[1][k]+gv[last];\r\n				}\r\n			}\r\n			memcpy(f[1],f[0],sizeof(f[0][0])*(m+1));\r\n			for(j=0;j<=m;++j){\r\n				if(v[1][j]>=v[0][j]) v[0][j]=v[1][j];\r\n				else v[1][j]=v[0][j];\r\n			}\r\n			++last;\r\n			//last=nd[i].g;\r\n		}\r\n		for(j=m;j>=nd[i].p;--j){\r\n			k=j-nd[i].p;\r\n			if(f[0][k]){\r\n				if(!f[0][j]){\r\n					f[0][j]=1;\r\n					v[0][j]=v[0][k]+nd[i].v;\r\n				}else{\r\n					if(v[0][k]+ nd[i].v > v[0][j]){\r\n						v[0][j]=v[0][k]+ nd[i].v;\r\n					}\r\n				}\r\n			}\r\n		}\r\n	}\r\n	res=0;\r\n	for(i=0;i<=m;++i) if(f[0][i] && v[0][i]>res) res=v[0][i];\r\n	printf("%d\\n",res);\r\n}\r\nint main(){\r\n	while(EOF!=scanf("%d%d", &n,&m)) solve();\r\n	return 0;\r\n}\r\n', '', 249, 380928, 1, 2, '2010-08-08 01:45:59', '2010-08-08 01:45:59'),
(121, 1, 108, 0, '#include <cstdio>\r\n#include <cstring>\r\n#define Max(a,b) ((a)>(b)?(a):(b))\r\n#define M 3001\r\nint a[M],dp[M];\r\n\r\nint main()\r\n{\r\n//    freopen("input.in", "r", stdin);\r\n//    freopen("output.out", "w", stdout);\r\n    int n;\r\n    while(scanf("%d", &n) != EOF) {\r\n        int x;\r\n        for(int i = 1; i <= n; i ++) {\r\n            scanf("%d%d", a + i, &x);\r\n            a[i] = (a[i] << 1) + x;\r\n        }\r\n        memset(dp, 0, sizeof(dp));\r\n        int maxleft = 0;\r\n        for(int i = n; i; i --) {\r\n            for(int j = 1, k = 0; j <= i; j ++){\r\n                if(a[i] >> 1 > a[j] >> 1 && k < dp[j]) {\r\n                    k = dp[j];\r\n                }\r\n                else if(a[i] == a[j] && dp[j] < k + 1){\r\n                    dp[j] = k +1;\r\n                    maxleft = Max(maxleft, dp[j] * 2 - (i == j));\r\n                }\r\n            }\r\n        }\r\n        printf("%d\\n", maxleft);\r\n    }\r\n}\r\n', '', 702, 282624, 1, 2, '2010-08-08 01:47:43', '2010-08-08 01:47:43'),
(122, 1, 109, 0, '#include<stdio.h>\r\n#include<math.h>\r\n#include<algorithm>\r\n#include<vector>\r\n#include<string>\r\n#define MAXV 2000\r\n#define PI 3.14159265358979323846\r\n#define eps 1e-8\r\n#define zero(x) (fabs(x)<eps)\r\n#define _sign(x) ((x)>eps?1:((x)<-eps?2:0))\r\nusing namespace std;\r\n\r\n\r\n//二维点\r\nstruct pt\r\n{\r\n	double x, y;\r\n	pt(){}\r\n	pt(double _x, double _y)\r\n	{\r\n		x = _x;\r\n		y = _y;\r\n	}\r\n	pt operator - (const pt p1){return pt(x - p1.x, y - p1.y);}\r\n	pt operator + (const pt p1){return pt(x + p1.x, y + p1.y);}\r\n	pt operator / (double r){return pt(x / r, y / r);}\r\n	pt operator * (double r){return pt(x * r, y * r);}\r\n	bool operator == (const pt p1)const{return fabs(x-p1.x)<eps && fabs(y-p1.y)<eps;}\r\n	bool operator != (const pt p1)const{return fabs(x-p1.x)>eps || fabs(y-p1.y)>eps;}\r\n	bool operator < (const pt p1)const{return y < p1.y-eps || y < p1.y+eps && x < p1.x;}\r\n	\r\n	void read(){\r\n		scanf("%lf %lf", &x, &y);\r\n	}\r\n};\r\n\r\ndouble dis(const pt &a, const pt &b){return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));}\r\ndouble cpr(const pt &a,const pt &b,const pt &c){return (b.x-a.x)*(c.y-a.y)-(b.y-a.y)*(c.x-a.x);}\r\n\r\n//求直线ab和直线cd的交点\r\npt its(const pt &a, const pt &b, const pt &c, const pt &d)\r\n{\r\n	pt ret = a;\r\n	double t =  ((c.x - a.x)*(d.y - c.y) - (c.y - a.y)*(d.x - c.x))/\r\n				((b.x - a.x)*(d.y - c.y) - (b.y - a.y)*(d.x - c.x));\r\n	ret.x += (b.x - a.x) * t;\r\n	ret.y += (b.y - a.y) * t;\r\n	return ret;\r\n}\r\n\r\n//计算直线与圆的交点,保证直线与圆有交点\r\n//计算线段与圆的交点可用这个函数后判点是否在线段上\r\nvoid intersection_line_circle(pt c, double r, pt l1, pt l2, pt &p1, pt &p2)\r\n{\r\n	pt p = c;\r\n	p.x += l1.y - l2.y;\r\n	p.y += l2.x - l1.x;\r\n	p = its(p, c, l1, l2);\r\n	double d = dis(p,c), t = sqrt(r*r - d*d) / dis(l1,l2);\r\n	p2.x = p.x + (l2.x-l1.x)*t;\r\n	p2.y = p.y + (l2.y-l1.y)*t;\r\n	p1.x = p.x - (l2.x-l1.x)*t;\r\n	p1.y = p.y - (l2.y-l1.y)*t;\r\n}\r\n\r\n////////////////////////////////////////////////////\r\n\r\ndouble R, angA, angB;\r\npt S, A, B, T;\r\n\r\ndouble arcLength(double s, double t)\r\n{\r\n	double res = t - s;\r\n	while (res < -eps)\r\n		res += 2*PI;\r\n	while (res - 2*PI > -eps)\r\n		res -= 2*PI;\r\n	return res * R;\r\n}\r\n\r\ndouble mid_length(pt A, pt B, double a, double b)\r\n{\r\n	pt L1 = A + pt(-sin(a), cos(a)) * R;\r\n	pt L2 = B + pt(-sin(b), cos(b)) * R;\r\n	pt R1 = A + pt(sin(a), -cos(a)) * R;\r\n	pt R2 = B + pt(sin(b), -cos(b)) * R;\r\n	double vang, len;\r\n\r\n	vang = atan2(L2.y - L1.y, L2.x - L1.x);\r\n	len = dis(L1, L2) < eps ? arcLength(a, b) : arcLength(a, vang) + dis(L1, L2) + arcLength(vang, b);\r\n	\r\n	if (2*R <= dis(L1, R2))\r\n	{\r\n	 	vang = atan2(R2.y - L1.y, R2.x - L1.x) + asin(2*R / dis(L1, R2));\r\n		len = min(len, arcLength(a, vang) + sqrt((L1.x - R2.x)*(L1.x - R2.x) + (L1.y - R2.y)*(L1.y - R2.y) - 4 * R * R) + arcLength(b, vang));\r\n	}\r\n	\r\n	if (2*R <= dis(L2, R1))\r\n	{\r\n	 	vang = atan2(L2.y - R1.y, L2.x - R1.x) - asin(2*R / dis(L2, R1));\r\n		len = min(len, arcLength(vang, a) + sqrt((L2.x - R1.x)*(L2.x - R1.x) + (L2.y - R1.y)*(L2.y - R1.y) - 4 * R * R) + arcLength(vang, b));\r\n	}\r\n	\r\n	vang = atan2(R2.y - R1.y, R2.x - R1.x);\r\n	len = min(len, dis(R1, R2) < eps ? arcLength(b, a) : arcLength(vang, a) + dis(R1, R2) + arcLength(b, vang));\r\n	\r\n	return len;\r\n}		\r\n\r\ndouble end_length(pt O, pt A, double a)\r\n{\r\n	pt B = A + pt(cos(a), sin(a));\r\n	if (cpr(O, A, B) > 0)\r\n	{\r\n		a = PI - a;\r\n		A.x = -A.x;\r\n		O.x = -O.x;\r\n	}\r\n	pt C = A + pt(sin(a), -cos(a)) * R;\r\n	double D = dis(O, C);\r\n	\r\n	if (fabs(D - R) < eps)\r\n	{\r\n		return arcLength(a, atan2(O.y - C.y, O.x - C.x) - PI / 2.0);\r\n	}\r\n	else if (D - R > eps)\r\n	{\r\n		return sqrt(D*D - R*R) + arcLength(a, atan2(C.y - O.y, C.x - O.x) + asin(R / D));\r\n	}\r\n	else\r\n	{\r\n		intersection_line_circle(C, R, O, O + pt(cos(a), sin(a)), B, B);\r\n		double D1 = 2 * PI * R + dis(B, O) - arcLength(atan2(B.y - C.y, B.x - C.x) - PI / 2.0, a);\r\n		C = A + A - C;\r\n		D = dis(O, C);\r\n		double D2 = sqrt(D*D - R*R) + arcLength(atan2(C.y - O.y, C.x - O.x) - asin(R / D), a);\r\n		if (D1 > D2) while (1);\r\n		return min(D1, D2);\r\n	}\r\n}\r\n\r\n\r\ndouble solve()\r\n{\r\n	double ans1 = end_length(S, A, angA) + mid_length(A, B, angA, angB) + end_length(T, B, angB + PI);\r\n	double ans2 = end_length(S, B, angB) + mid_length(B, A, angB, angA) + end_length(T, A, angA + PI);\r\n//	printf("%lf %lf %lf\\n", end_length(S, A, angA), mid_length(A, B, angA, angB), end_length(T, B, angB + PI));\r\n//	printf("%lf %lf %lf\\n", end_length(S, B, angB), mid_length(B, A, angB, angA), end_length(T, A, angA + PI));\r\n//	printf("%lf %lf\\n", ans1, ans2);\r\n	return min(ans1, ans2);\r\n}\r\n\r\nint main()\r\n{\r\n	double dx, dy;\r\n	while (~scanf("%lf", &R))\r\n	{\r\n		S.read();\r\n		A.read();\r\n		scanf("%lf %lf", &dx, &dy);\r\n		angA = atan2(dy, dx);\r\n		B.read();\r\n		scanf("%lf %lf", &dx, &dy);\r\n		angB = atan2(dy, dx);\r\n		T.read();\r\n		printf("%.2lf\\n", solve());\r\n	}\r\n	return 0;\r\n}\r\n', '', 0, 262144, 1, 2, '2010-08-08 01:55:08', '2010-08-08 01:55:08'),
(123, 1, 110, 0, '#include <iostream>\r\n#include <cstdio>\r\n#include <cstdlib>\r\n#include <algorithm>\r\n#include <map>\r\n#include <climits>\r\n#include <queue>\r\n#include <cassert>\r\n\r\nusing namespace std;\r\n\r\ntypedef map<string, int>                 place_type;\r\ntypedef map<string, pair<int, string> >  student_type;\r\ntypedef place_type::iterator             place_iter;\r\ntypedef student_type::iterator           student_iter;\r\n\r\nint solve( int __r )\r\n{\r\n    int n, k, t;\r\n    \r\n    if( scanf( "%d%d%d", &n, &k, &t ) == EOF )\r\n	return 0;\r\n    printf( "Case #%d:\\n", __r );\r\n\r\n    char __cmd[ 20 ], __id[ 1000 ], __buf[ 1000 ];\r\n    int ts;\r\n    place_type   pla;\r\n    student_type stu;\r\n    place_iter   pla_it;\r\n    student_iter stu_it;\r\n    queue<pair<int, string> > que;\r\n    \r\n    for( int i = 0; i < n; ++i )\r\n    {\r\n	scanf( "%d%s%s", &ts, __cmd, __id );\r\n\r\n	while( !que.empty( ) && que.front( ).first <= ts )\r\n	{\r\n	    stu_it = stu.find( que.front( ).second );\r\n	    if( stu_it->second.first != 3 )\r\n	    {\r\n		stu_it->second.first = 1;\r\n		pla_it = pla.find( stu_it->second.second );\r\n		pla_it->second--;\r\n	    }\r\n	    que.pop( );\r\n	}\r\n\r\n	string id( __id ), cmd( __cmd );\r\n	\r\n	if( cmd == "GET" )\r\n	{\r\n	    scanf( "%s", __buf );\r\n	    string place( __buf );\r\n	    \r\n	    stu_it = stu.find( id );\r\n	    if( stu_it->second.first == 1 )\r\n	    {\r\n		pla.insert( make_pair( place, 0 ) );\r\n		pla_it = pla.find( place );\r\n		\r\n		assert( pla_it != pla.end( ) );\r\n		\r\n		if( pla_it->second < k )\r\n		{\r\n		    stu_it->second.first = 2;\r\n		    stu_it->second.second = place;\r\n		    pla_it->second++;\r\n		    que.push( make_pair( ts + t, id ) );\r\n		}\r\n	    }\r\n	}\r\n	else if( cmd == "REG" ) stu[id].first = 1;\r\n	else if( cmd == "PAY" ) {\r\n	    stu_it = stu.find( id );\r\n	    if( stu_it->second.first == 2 )\r\n		stu_it->second.first =  3;\r\n	}\r\n	else if( cmd == "CAL" )\r\n	{\r\n	    stu_it = stu.find( id );\r\n	    if( stu_it->second.first == 2 )\r\n	    {\r\n		stu_it->second.first = 1;\r\n		pla_it = pla.find( id );\r\n		pla_it->second--;\r\n	    }\r\n	}\r\n    }\r\n\r\n    for( stu_it = stu.begin( ); stu_it != stu.end( ); ++stu_it )\r\n    {\r\n	if( stu_it->second.first != 3 ) continue;\r\n	printf( "%s %s\\n", stu_it->first.c_str( ), stu_it->second.second.c_str( ) );\r\n    }\r\n    \r\n    putchar( ''\\n'' );\r\n    return 1;\r\n}\r\n\r\n\r\nint main( void )\r\n{\r\n    for( int i = 1; solve( i ); ++i );\r\n    return 0;\r\n}\r\n', '', 249, 3506176, 1, 2, '2010-08-08 01:57:05', '2010-08-08 01:57:05'),
(124, 1, 111, 0, '#include<stdio.h>\r\n\r\nint t[30] = {12, 22, 9, 24, 0, 11, 25, 21, 4, 15, 18, 5, 14, 1, 23, 16, 6, 3, 20, 17, 8, 19, 13, 10, 2, 7};\r\nint s[30];\r\nchar st[100];\r\n\r\nint main()\r\n{\r\n	for (int i = 0; i < 26; i++)\r\n	{\r\n		s[t[i]] = i;\r\n	} \r\n	while (gets(st))\r\n	{\r\n		for (int i = 0; st[i]; i++)\r\n		{\r\n			if (st[i] >= ''A'' && st[i] <= ''Z'')\r\n			{\r\n				st[i] = s[st[i] - ''A''] + ''A'';\r\n			}\r\n			else if (st[i] >= ''a'' && st[i] <= ''z'')\r\n			{\r\n				st[i] = s[st[i] - ''a''] + ''a'';\r\n			}\r\n		}\r\n		puts(st);\r\n	}\r\n	return 0;\r\n}\r\n', '', 0, 262144, 1, 2, '2010-08-08 01:58:54', '2010-08-08 01:58:54'),
(125, 1, 112, 0, '/*\r\n * Author: momodi\r\n * Created Time:  2009/9/5 15:47:36\r\n * File Name: Arbiter.cpp\r\n * Description:\r\n */\r\n#include <cstdio>\r\n#include <cstring>\r\n#include <cmath>\r\n#include <vector>\r\n#include <cstdlib>\r\n#include <algorithm>\r\nusing namespace std;\r\n#define out(x) fprintf(stderr, "%s: %I64d\\n", #x, (long long)(x))\r\n#define SZ(v) ((int)(v).size())\r\nconst int maxint=-1u>>1;\r\ntemplate <class T> bool get_max(T& a, const T &b) {return b > a? a = b, 1: 0;}\r\ntemplate <class T> bool get_min(T& a, const T &b) {return b < a? a = b, 1: 0;}\r\n#define move(v) (1 << (v))\r\n#define take(a, b) (((a) >> (b)) & 1)\r\nint main() {\r\n    int ca;\r\n    scanf("%d", &ca);\r\n    while (ca--) {\r\n        int n, m;\r\n        scanf("%d %d", &n, &m);\r\n        vector<pair<int, int> > edge;\r\n        for (int i = 0; i < m; ++i) {\r\n            int a, b;\r\n            scanf("%d %d", &a, &b);\r\n            edge.push_back(make_pair(a, b));\r\n        }\r\n        int ans = maxint;\r\n        for (int i = 0; i < move(n); ++i) {\r\n            int cnt = 0;\r\n            for (int j = 0; j < m; ++j) {\r\n                cnt += (take(i, edge[j].first) == take(i, edge[j].second));\r\n            }\r\n            get_min(ans, cnt);\r\n        }\r\n        printf("%d\\n", ans);\r\n    }\r\n    return 0;\r\n}\r\n\r\n', '', 124, 299008, 1, 2, '2010-08-08 02:30:26', '2010-08-08 02:30:26'),
(126, 1, 113, 0, '/**\r\n * File Name: ChaeYeon.cpp\r\n * Created Time:  7/4/2009 5:04:19 PM\r\n * Author: momodi\r\n * Description: \r\n */\r\n#include <cstdio>\r\n#include <cstring>\r\n#include <cmath>\r\n#include <cstdlib>\r\n#include <algorithm>\r\n#include <vector>\r\nusing namespace std;\r\n#define NEXT(v, n) (((v) == (n))? 0 : (v))\r\n#define SZ(x) ((int) x.size())\r\ntemplate <class T> bool get_max(T& a, const T &b) {return b > a? a = b, 1: 0;}\r\ntemplate <class T> bool get_min(T& a, const T &b) {return b < a? a = b, 1: 0;}\r\n#define SQR(v) ((v) * (v))\r\nconst double eps = 1e-9;\r\nconst double pi = acos(-1.0);\r\n\r\nint sgn(const double &a) {\r\n    return (a > eps) - (a < -eps);\r\n}\r\n\r\nconst int zx[] = {\r\n    0, 1, 0, -1\r\n};\r\nconst int zy[] = {\r\n    1, 0, -1, 0\r\n};\r\n\r\nstruct P {\r\n    double x, y;\r\n    P(const double &_x, const double &_y)\r\n        :x(_x), y(_y) {}\r\n    P() {}\r\n    bool operator == (const P &a) const {\r\n        return sgn(x - a.x) == 0 && sgn(y - a.y) == 0;\r\n    }\r\n    P operator + (const P &a) const {\r\n        return P(x + a.x, y + a.y);\r\n    }\r\n    P operator - (const P &a) const {\r\n        return P(x - a.x, y - a.y);\r\n    }\r\n    P operator * (const double &a) const {\r\n        return P(x * a, y * a);\r\n    }\r\n    P operator / (const double &a) const {\r\n        return P(x / a, y / a);\r\n    }\r\n    P trunc(double a) const {\r\n        a /= sqrt(SQR(x) + SQR(y));\r\n        return P(x * a, y * a);\r\n    }\r\n    P turn_left() const {\r\n        return P(-y, x);\r\n    }\r\n    P turn_right() const {\r\n        return P(y, -x);\r\n    }\r\n    const P& input() {\r\n        scanf("%lf %lf", &x, &y);\r\n        return *this;\r\n    }\r\n    const P& output() const {\r\n        printf("P: %.12lf %.12lf\\n", x, y);\r\n        return *this;\r\n    }\r\n};\r\n\r\ndouble dist2(const P &a, const P &b) {\r\n    return SQR(a.x - b.x) + SQR(a.y - b.y);\r\n}\r\ndouble dist(const P &a, const P &b) {\r\n    return sqrt(SQR(a.x - b.x) + SQR(a.y - b.y));\r\n}\r\ndouble cross(const P &a, const P &b, const P &c) {\r\n    return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);\r\n}\r\ndouble dmul(const P &a, const P &b, const P &c) {\r\n    return (b.x - a.x) * (c.x - a.x) + (b.y - a.y) * (c.y - a.y);\r\n}\r\n\r\nstruct C {\r\n    P mid;\r\n    double r;\r\n    C(const P &_mid, const double &_r)\r\n        :mid(_mid), r(_r) {}\r\n    C() {}\r\n    bool operator == (const C &a) const {\r\n        return mid == a.mid && sgn(r - a.r) == 0;\r\n    }\r\n    bool in(const C &a) const {\r\n        return sgn(r + dist(mid, a.mid) - a.r) <= 0;\r\n    }\r\n    const C &input() {\r\n        mid.input();\r\n        scanf("%lf", &r);\r\n        return *this;\r\n    }\r\n    const C &output() const {\r\n        printf("P: %.12lf %.12lf R: %.12lf\\n", mid.x, mid.y, r);\r\n    }\r\n};\r\n\r\ndouble cal_angle(const C &c, const P &a, const P &b) {\r\n    double k = dmul(c.mid, a, b) / SQR(c.r);\r\n    get_min(k, 1.0);\r\n    get_max(k, -1.0);\r\n    return acos(k);\r\n}\r\n\r\ndouble cal_area(const C &c, const P &a, const P &b) {\r\n    return SQR(c.r) * cal_angle(c, a, b) / 2 - cross(c.mid, a, b) / 2;\r\n}\r\n\r\nstruct cmp {\r\n    P mid;\r\n    cmp(const P &_mid)\r\n        :mid(_mid) {}\r\n    bool operator () (const P &a, const P &b) {\r\n        return atan2(a.y - mid.y, a.x - mid.x) < atan2(b.y - mid.y, b.x - mid.x);\r\n    }\r\n};\r\n\r\nbool circles_intersection(const C &a, const C &b, P &c1, P &c2) {\r\n    double dd = dist(a.mid, b.mid);\r\n    if (sgn(dd - (a.r + b.r)) >= 0) {\r\n        return false;\r\n    }\r\n    double l = (dd + (SQR(a.r) - SQR(b.r)) / dd) / 2;\r\n    double h = sqrt(SQR(a.r) - SQR(l));\r\n    c1 = a.mid + (b.mid - a.mid).trunc(l) + (b.mid - a.mid).turn_left().trunc(h);\r\n    c2 = a.mid + (b.mid - a.mid).trunc(l) + (b.mid - a.mid).turn_right().trunc(h);\r\n    return true;\r\n}\r\n\r\nbool cover(const C &c, const P &a, const P &b, const vector<C> &cir) {\r\n    P p = c.mid + ((a + b) / 2 - c.mid).trunc(c.r);\r\n    for (vector<C>::const_iterator it = cir.begin(); it != cir.end(); ++it) {\r\n        if (sgn(dist2(p, it->mid) - SQR(it->r)) < 0) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\ndouble cal_area(const vector<C> &in) {\r\n    vector<C> cir;\r\n    for (int i = 0; i < SZ(in); ++i) {\r\n        if (sgn(in[i].r) == 0) {\r\n            continue;\r\n        }\r\n        bool flag = false;\r\n        for (int j = i + 1; j < SZ(in); ++j) {\r\n            if (in[i] == in[j]) {\r\n                flag = true;\r\n                break;\r\n            }\r\n        }\r\n        if (flag) {\r\n            continue;\r\n        }\r\n        for (int j = 0; j < SZ(in); ++j) {\r\n            if (!(in[i] == in[j]) && in[i].in(in[j])) {\r\n                flag = true;\r\n                break;\r\n            }\r\n        }\r\n        if (flag) {\r\n            continue;\r\n        }\r\n        cir.push_back(in[i]);\r\n    }\r\n    vector<vector<P> > point_on_circle(SZ(cir));\r\n    for (int i = 0; i < SZ(cir); ++i) {\r\n        for (int z = 0; z < 4; ++z) {\r\n            point_on_circle[i].push_back(cir[i].mid + P(zx[z], zy[z]).trunc(cir[i].r));\r\n        }\r\n    }\r\n    for (int i = 0; i < SZ(cir); ++i) {\r\n        for (int j = i + 1; j < SZ(cir); ++j) {\r\n            P a, b;\r\n            if (circles_intersection(cir[i], cir[j], a, b)) {\r\n                point_on_circle[i].push_back(a);\r\n                point_on_circle[i].push_back(b);\r\n                point_on_circle[j].push_back(a);\r\n                point_on_circle[j].push_back(b);\r\n            }\r\n        }\r\n    }\r\n    for (int i = 0; i < SZ(cir); ++i) {\r\n        sort(point_on_circle[i].begin(), point_on_circle[i].end(), cmp(cir[i].mid));\r\n        point_on_circle[i].erase(unique(point_on_circle[i].begin(), point_on_circle[i].end()), point_on_circle[i].end());\r\n    }\r\n    double ans = 0;\r\n    for (int i = 0; i < SZ(cir); ++i) {\r\n        for (int j = 0; j < SZ(point_on_circle[i]); ++j) {\r\n            const P &a = point_on_circle[i][j];\r\n            const P &b = point_on_circle[i][NEXT(j + 1, SZ(point_on_circle[i]))];\r\n            if (!cover(cir[i], a, b, cir)) {\r\n                ans += cross(P(0, 0), a, b) / 2;\r\n                ans += cal_area(cir[i], a, b);\r\n            }\r\n        }\r\n    }\r\n    return ans;\r\n}\r\ndouble mabs(double a) {\r\n    return a + eps;\r\n}\r\n\r\nint main() {\r\n    int ca;\r\n    scanf("%d", &ca);\r\n    while (ca--) {\r\n        int R, G, B;\r\n        scanf("%d %d %d", &R, &G, &B);\r\n        vector<C> r, g, b, rg, rb, gb, rgb;\r\n        for (int i = 0; i < R; ++i) {\r\n            C tmp;\r\n            tmp.input();\r\n            r.push_back(tmp);\r\n            rg.push_back(tmp);\r\n            rb.push_back(tmp);\r\n            rgb.push_back(tmp);\r\n        }\r\n        for (int i = 0; i < G; ++i) {\r\n            C tmp;\r\n            tmp.input();\r\n            g.push_back(tmp);\r\n            rg.push_back(tmp);\r\n            gb.push_back(tmp);\r\n            rgb.push_back(tmp);\r\n        }\r\n        for (int i = 0; i < B; ++i) {\r\n            C tmp;\r\n            tmp.input();\r\n            b.push_back(tmp);\r\n            rb.push_back(tmp);\r\n            gb.push_back(tmp);\r\n            rgb.push_back(tmp);\r\n        }\r\n        double rs = cal_area(r);\r\n        double gs = cal_area(g);\r\n        double bs = cal_area(b);\r\n        double rgs = rs + gs - cal_area(rg);\r\n        double rbs = rs + bs - cal_area(rb);\r\n        double gbs = gs + bs - cal_area(gb);\r\n        double rgbs = cal_area(rgb) - rs - gs - bs + rgs + rbs + gbs;\r\n        printf("%.2f %.2f %.2f %.2f %.2f %.2f %.2f\\n", \r\n                mabs(rs - rgs - rbs + rgbs), \r\n                mabs(gs - rgs - gbs + rgbs),\r\n                mabs(bs - rbs - gbs + rgbs),\r\n                mabs(rgbs),\r\n                mabs(rgs - rgbs),\r\n                mabs(rbs - rgbs),\r\n                mabs(gbs - rgbs));\r\n    }\r\n    return 0;\r\n}\r\n\r\n\r\n', '', 296, 933888, 1, 2, '2010-08-08 02:35:48', '2010-08-08 02:35:55');
INSERT INTO `tbl_submitions` (`id`, `user_id`, `problem_id`, `exercise_id`, `source`, `result`, `used_time`, `used_memory`, `status`, `compiler_id`, `created`, `modified`) VALUES
(127, 1, 114, 0, '/*\r\n * Author: momodi\r\n * Created Time:  2009/9/5 16:57:35\r\n * File Name: Dolphin.cpp\r\n * Description: \r\n */\r\n#include <cstdio>\r\n#include <cstring>\r\n#include <cmath>\r\n#include <vector>\r\n#include <cstdlib>\r\n#include <queue>\r\n#include <algorithm>\r\nusing namespace std;\r\n#define out(x) fprintf(stderr, "%s: %I64d\\n", #x, (long long)(x))\r\n#define SZ(v) ((int)(v).size())\r\nconst int maxint=-1u>>1;\r\ntemplate <class T> bool get_max(T& a, const T &b) {return b > a? a = b, 1: 0;}\r\ntemplate <class T> bool get_min(T& a, const T &b) {return b < a? a = b, 1: 0;}\r\nconst int maxn = 1100;\r\nint n, m, S, T;\r\nint edge[maxn][maxn];\r\nint type[maxn];\r\nint dist[maxn];\r\nvoid build_dist() {\r\n    fill(dist, dist + n, maxint);\r\n    dist[T] = 0;\r\n    queue<int> Q;\r\n    Q.push(T);\r\n    while (!Q.empty()) {\r\n        int v = Q.front();\r\n        Q.pop();\r\n        for (int i = 0; i < n; ++i) {\r\n            if (edge[v][i] < maxint && dist[v] + edge[v][i] < dist[i]) {\r\n                dist[i] = dist[v] + edge[v][i];\r\n                Q.push(i);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nint mmin[maxn];\r\nint cc[1010];\r\n\r\nint find_dist(int now) {\r\n    static int Q[1024];\r\n    Q[0] = now;\r\n    static bool hash[maxn];\r\n    fill(hash, hash + n, false);\r\n    hash[now] = true;\r\n    static int dist[maxn];\r\n    fill(dist, dist + n, maxint);\r\n    dist[now] = 0;\r\n    for (int s = 0, t = 1; s != t; ) {\r\n        int v = Q[s];\r\n        hash[v] = false;\r\n        s = (s + 1) & 1023;\r\n        for (int i = 0; i < n; ++i) {\r\n            if (cc[type[i]] == 0 && edge[v][i] < maxint && dist[v] + edge[v][i] < dist[i]) {\r\n                dist[i] = dist[v] + edge[v][i];\r\n                if (hash[i] == false) {\r\n                    hash[i] = true;\r\n                    if (dist[i] <= dist[Q[s]]) {\r\n                        s = (s - 1) & 1023;\r\n                        Q[s] = i;\r\n                    } else {\r\n                        Q[t] = i;\r\n                        t = (t + 1) & 1023;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return dist[T];\r\n}\r\n\r\n\r\nbool dfs(int now, int tot, int lim) {\r\n    if (dist[now] == maxint || dist[now] + tot > lim) {\r\n        return false;\r\n    }\r\n    int tmp = find_dist(now);\r\n    if (tmp == maxint || tmp + tot > lim) {\r\n        return false;\r\n    }\r\n    if (now == T) {\r\n        return true;\r\n    }\r\n    for (int i = 0; i < n; ++i) {\r\n        if (edge[now][i] < maxint && cc[type[i]] == 0) {\r\n            ++cc[type[now]];\r\n            if (dfs(i, tot + edge[now][i], lim)) {\r\n                return true;\r\n            }\r\n            --cc[type[now]];\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\nint solve() {\r\n    int s = 0, t = 0;\r\n    for (int i = 0; i < n; ++i) {\r\n        for (int j = i + 1; j < n; ++j) {\r\n            if (edge[i][j] < maxint) {\r\n                t += edge[i][j];\r\n            }\r\n        }\r\n    }\r\n    build_dist();\r\n    int ans = -1;\r\n    while (s <= t) {\r\n        int mid = (s + t) / 2;\r\n        fill(mmin, mmin + n, maxint);\r\n        memset(cc, 0, sizeof(cc));\r\n        ++cc[type[S]];\r\n        if (dfs(S, 0, mid)) {\r\n            ans = mid;\r\n            t = mid - 1;\r\n        } else {\r\n            s = mid + 1;\r\n        }\r\n    }\r\n    return ans;\r\n}\r\n\r\nint main() {\r\n    int ca;\r\n    scanf("%d", &ca);\r\n    while (ca--) {\r\n        scanf("%d %d %d %d", &n, &m, &S, &T);\r\n        for (int i = 0; i < n; ++i) {\r\n            for (int j = 0; j < n; ++j) {\r\n                edge[i][j] = maxint;\r\n            }\r\n        }\r\n        for (int i = 0; i < m; ++i) {\r\n            int u, v, c;\r\n            scanf("%d %d %d", &u, &v, &c);\r\n            get_min(edge[u][v], c);\r\n            edge[v][u] = edge[u][v];\r\n        }\r\n        for (int i = 0; i < n; ++i) {\r\n            scanf("%d", type + i);\r\n        }\r\n        printf("%d\\n", solve());\r\n    }\r\n    return 0;\r\n}\r\n\r\n', '', 452, 5173248, 1, 2, '2010-08-08 02:37:26', '2010-08-08 02:37:26'),
(128, 1, 115, 0, '/*\r\n * Author: momodi\r\n * Created Time:  2009/9/6 0:42:44\r\n * File Name: FreeOpen.cpp\r\n * Description: \r\n */\r\n#include <cstdio>\r\n#include <cstring>\r\n#include <cmath>\r\n#include <vector>\r\n#include <cstdlib>\r\n#include <algorithm>\r\n#include <set>\r\nusing namespace std;\r\n#define out(x) fprintf(stderr, "%s: %I64d\\n", #x, (long long)(x))\r\n#define SZ(v) ((int)(v).size())\r\nconst int maxint=-1u>>1;\r\ntemplate <class T> bool get_max(T& a, const T &b) {return b > a? a = b, 1: 0;}\r\ntemplate <class T> bool get_min(T& a, const T &b) {return b < a? a = b, 1: 0;}\r\n#define move(v) (1 << (v))\r\n#define take(a, b) (((a) >> (b)) & 1)\r\nconst int maxn = 20;\r\n\r\nstruct Graph {\r\n     int adj[maxn][maxn];\r\n     int n, m;\r\n     int a[maxn], b[maxn];\r\n     int mat[maxn];\r\n     int flag[maxn];\r\n     int match(int _adj[maxn][maxn], int A[maxn][maxn], int B[maxn][maxn], int _n, int _m, int c, int fa, int fb, int fc) {\r\n         n = _n;\r\n         m = _m;\r\n         for (int i = 0; i < n; ++i) {\r\n             for (int j = 0; j < m; ++j) {\r\n                 if (_adj[i][j]) {\r\n                     bool have = false;\r\n                     for (int k = 0; k < c; ++k) {\r\n                         if (A[i][k] && B[j][k] && take(fc, k) == 0) {\r\n                             have = true;\r\n                             break;\r\n                         }\r\n                     }\r\n                     adj[i][j] = have;\r\n                 } else {\r\n                     adj[i][j] = 0;\r\n                 }\r\n             }\r\n         }\r\n         for (int i = 0; i < n; ++i) {\r\n             a[i] = take(fa, i);\r\n         }\r\n         for (int j = 0; j < m; ++j) {\r\n             b[j] = take(fb, j);\r\n         }\r\n         memset(mat, -1, sizeof(mat));\r\n         int ans = 0;\r\n         for (int i = 0; i < n; ++i) {\r\n             if (a[i]) {\r\n                 continue;\r\n             }\r\n             memset(flag, 0, sizeof(flag));\r\n             ans += dfs(i);\r\n         }\r\n         return ans;\r\n     }\r\n     bool dfs(int v) {\r\n         for (int i = 0; i < m; ++i) {\r\n             if (b[i] == 0 && adj[v][i] && flag[i] == false) {\r\n                 flag[i] = true;\r\n                 if (mat[i] == -1 || dfs(mat[i])) {\r\n                     mat[i] = v;\r\n                     return true;\r\n                 }\r\n             }\r\n         }\r\n         return false;\r\n     }\r\n} g;\r\n\r\nint gb[maxn][maxn];\r\nint bg[maxn][maxn];\r\nint gp[maxn][maxn];\r\nint pg[maxn][maxn];\r\nint bp[maxn][maxn];\r\nint pb[maxn][maxn];\r\nint G, B, P;\r\nint min(int a, int b, int c) {\r\n    return min(min(a, b), c);\r\n}\r\nint cnt[move(maxn)];\r\n\r\nbool dfs(int now, int fa, int fb, int ans) {\r\n    if (cnt[fa] == ans) {\r\n        return true;\r\n    }\r\n    if (cnt[now] == G) {\r\n        return false;\r\n    }\r\n    if (cnt[fa] + g.match(gb, gp, bp, G, B, P, now, fa, fb) < ans || \r\n            cnt[fa] + g.match(gp, gb, pb, G, P, B, now, fb, fa) < ans ||\r\n            cnt[fa] + g.match(bp, bg, pg, B, P, G, fa, fb, now) < ans) {\r\n        return false;\r\n    }\r\n    int v = cnt[now];\r\n    for (int i = 0; i < B; ++i) {\r\n        if (gb[v][i] && take(fa, i) == 0) {\r\n            for (int j = 0; j < P; ++j) {\r\n                if (gp[v][j] && bp[i][j] && take(fb, j) == 0) {\r\n                    if (dfs(now | move(v), fa | move(i), fb | move(j), ans)) {\r\n                        return true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (dfs(now | move(v), fa, fb, ans)) {\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n\r\nint solve() {\r\n    int mmaxans = min(g.match(gb, gp, bp, G, B, P, 0, 0, 0), g.match(gp, gb, pb, G, P, B, 0, 0, 0), g.match(bp, bg, pg, B, P, G, 0, 0, 0));\r\n    int ans = 1;\r\n    while (ans <= mmaxans) {\r\n        if (!dfs(0, 0, 0, ans)) {\r\n            break;\r\n        }\r\n        ++ans;\r\n    }\r\n    return ans - 1;\r\n}\r\n\r\nvoid mysort(int ab[maxn][maxn], int ac[maxn][maxn], int ba[maxn][maxn], int ca[maxn][maxn], int A, int B, int C) {\r\n    int degab[maxn] = {};\r\n    int degac[maxn] = {};\r\n    int deg[maxn];\r\n    for (int i = 0; i < A; ++i) {\r\n        for (int j = 0; j < B; ++j) {\r\n            degab[i] += ab[i][j];\r\n        }\r\n    }\r\n    for (int i = 0; i < A; ++i) {\r\n        for (int j = 0; j < C; ++j) {\r\n            degac[i] += ac[i][j];\r\n        }\r\n    }\r\n    for (int i = 0; i < A; ++i) {\r\n        deg[i] = min(degab[i], degac[i]);\r\n    }\r\n    for (int i = 0; i < A; ++i) {\r\n        for (int j = i + 1; j < A; ++j) {\r\n            if (deg[j] < deg[i]) {\r\n                swap(deg[i], deg[j]);\r\n                for (int k = 0; k < B; ++k) {\r\n                    swap(ab[i][k], ab[j][k]);\r\n                }\r\n                for (int k = 0; k < C; ++k) {\r\n                    swap(ac[i][k], ac[j][k]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    for (int i = 0; i < A; ++i) {\r\n        for (int j = 0; j < B; ++j) {\r\n            ba[j][i] = ab[i][j];\r\n        }\r\n    }\r\n    for (int i = 0; i < A; ++i) {\r\n        for (int j = 0; j < C; ++j) {\r\n            ca[j][i] = ac[i][j];\r\n        }\r\n    }\r\n}\r\n\r\nint main() {\r\n    for (int i = 0; i < move(maxn); ++i) {\r\n        int k = i;\r\n        while (k) {\r\n            cnt[i] += k & 1;\r\n            k >>= 1;\r\n        }\r\n    }\r\n    int ca;\r\n    scanf("%d", &ca);\r\n    while (ca--) {\r\n        scanf("%d %d %d", &G, &B, &P);\r\n        for (int i = 0; i < G; ++i) {\r\n            for (int j = 0; j < B; ++j) {\r\n                scanf("%d", gb[i] + j);\r\n                bg[j][i] = gb[i][j];\r\n            }\r\n        }\r\n        for (int i = 0; i < G; ++i) {\r\n            for (int j = 0; j < P; ++j) {\r\n                scanf("%d", gp[i] + j);\r\n                pg[j][i] = gp[i][j];\r\n            }\r\n        }\r\n        for (int i = 0; i < B; ++i) {\r\n            for (int j = 0; j < P; ++j) {\r\n                scanf("%d", bp[i] + j);\r\n                pb[j][i] = bp[i][j];\r\n            }\r\n        }\r\n        mysort(gb, gp, bg, pg, G, B, P);\r\n        mysort(bp, bg, pb, gb, B, P, G);\r\n        mysort(pg, pb, gp, bp, P, G, B);\r\n        printf("%d\\n", solve());\r\n    }\r\n    return 0;\r\n}\r\n\r\n', '', 187, 4472832, 1, 2, '2010-08-08 02:38:44', '2010-08-08 02:38:44'),
(129, 1, 116, 0, '/**\r\n * File Name: FreeRadiant.cpp\r\n * Created Time:  9/7/2009 3:57:55 PM\r\n * Author: momodi\r\n * Description: \r\n */\r\n#include <cstdio>\r\n#include <cstring>\r\n#include <cmath>\r\n#include <cstdlib>\r\n#include <algorithm>\r\n#include <vector>\r\nusing namespace std;\r\n#define NEXT(v, n) (((v) == (n))? 0 : (v))\r\n#define SZ(x) ((int) x.size())\r\n#define out(v) printf("%s: %lld", #v, (long long)v)\r\ntemplate <class T> bool get_max(T& a, const T &b) {return b > a? a = b, 1: 0;}\r\ntemplate <class T> bool get_min(T& a, const T &b) {return b < a? a = b, 1: 0;}\r\n#define SQR(v) ((v) * (v))\r\nconst int maxint = -1u>>1;\r\nconst double eps = 1e-6;\r\nint sgn(const double &a) {\r\n    return (a > eps) - (a < -eps);\r\n}\r\nstruct P {\r\n    double x, y;\r\n    P(double _x, double _y)\r\n        :x(_x), y(_y) {}\r\n    P() {}\r\n    bool operator == (const P &a) const {\r\n        return sgn(x - a.x) == 0 && sgn(y - a.y) == 0;\r\n    }\r\n    bool operator != (const P &a) const {\r\n        return sgn(x - a.x) != 0 || sgn(y - a.y) != 0;\r\n    }\r\n    bool operator < (const P &a) const {\r\n        return sgn(x - a.x) < 0 || sgn(x - a.x) == 0 && sgn(y - a.y) < 0;\r\n    }\r\n    P operator + (const P &a) const {\r\n        return P(x + a.x, y + a.y);\r\n    }\r\n    P operator - (const P &a) const {\r\n        return P(x - a.x, y - a.y);\r\n    }\r\n    P operator * (const double &a) const {\r\n        return P(x * a, y * a);\r\n    }\r\n    P operator / (const double &a) const {\r\n        return P(x / a, y / a);\r\n    }\r\n    P turn_left() const {\r\n        return P(-y, x);\r\n    }\r\n    P trunc(double a) const {\r\n        a /= sqrt(SQR(x) + SQR(y));\r\n        return P(x * a, y * a);\r\n    }\r\n    void input() {\r\n        scanf("%lf %lf", &x, &y);\r\n    }\r\n    void output() const {\r\n        printf("%lf %lf\\n", x, y);\r\n    }\r\n};\r\ndouble dist(const P &a, const P &b) {\r\n    return sqrt(SQR(a.x - b.x) + SQR(a.y - b.y));\r\n}\r\n\r\nstruct Simplex {\r\n    static const int maxn = 2500 + 100;\r\n    double A[maxn][maxn], b[maxn], c[maxn], v;\r\n    int Nsets[maxn], Bsets[maxn], Nsize, Bsize;\r\n    void clear(int n, int m, int *T) {\r\n        Nsize = n, Bsize = m;\r\n        memset(c, 0, sizeof(c));\r\n        for (int i = 0; i < Nsize; ++i) {\r\n            c[i] = -1;\r\n        }\r\n        for (int i = 0; i < Bsize; ++i) {\r\n            b[Nsize + i] = -T[i];\r\n        }\r\n        for (int i = 0; i < Bsize; ++i) {\r\n            Bsets[i] = Nsize + i;\r\n        }\r\n        for (int i = 0; i < Nsize; ++i) {\r\n            Nsets[i] = i;\r\n        }\r\n        v = 0;\r\n        memset(A, 0, sizeof(A));\r\n    }\r\n    void insert(int u, int v, double c) {\r\n        A[u + Nsize][v] = c;\r\n    }\r\n    void del() {\r\n        for (int i = 0; i < Bsize; ++i) {\r\n            if (Bsets[i] == Nsize + Bsize - 1) {\r\n                pivot(Nsize + Bsize - 1, Nsets[0]);\r\n            }\r\n        }\r\n        for (int i = 0; i < Nsize; ++i) {\r\n            if (Nsets[i] == Nsize + Bsize - 1) {\r\n                Nsets[i] = Nsets[--Nsize];\r\n                return ;\r\n            }\r\n        }\r\n        while (1);\r\n    }\r\n    void init() {\r\n        int l = Bsets[0];\r\n        for (int i = 0; i < Bsize; ++i) {\r\n            if (b[Bsets[i]] < b[l]) {\r\n                l = Bsets[i];\r\n            }\r\n        }\r\n        if (sgn(b[l]) >= 0) {\r\n            return ;\r\n        }\r\n        double remc[maxn];\r\n        copy(c, c + Nsize + Bsize + 1, remc);\r\n        Nsets[Nsize] = Nsize + Bsize;\r\n        ++Nsize;\r\n        for (int i = 0; i < Bsize; ++i) {\r\n            A[Bsets[i]][Nsize + Bsize - 1] = -1;\r\n        }\r\n        memset(c, 0, sizeof(c));\r\n        c[Nsize + Bsize - 1] = -1;\r\n        pivot(l, Nsize + Bsize - 1);\r\n        if (sgn(optimize()) < 0) {\r\n            printf("error: nosolution\\n");\r\n            return ;\r\n        }\r\n        del();\r\n        copy(remc, remc + Nsize + Bsize + 1, c);\r\n        for (int a = 0; a < Bsize; ++a) {\r\n            int i = Bsets[a];\r\n            if (sgn(c[i]) != 0) {\r\n                v += c[i] * b[i];\r\n                for (int j = 0; j < Nsize; ++j) {\r\n                    c[Nsets[j]] -= A[i][Nsets[j]] * c[i];\r\n                }\r\n                c[i] = 0;\r\n            }\r\n        }\r\n    }\r\n    double find() {\r\n        init();\r\n        optimize();\r\n        return v;\r\n    }\r\n    double optimize() {\r\n        while (1) {\r\n            int l, e;\r\n            double mmax = -1;\r\n            for (int i = 0; i < Nsize; ++i) {\r\n                int tmpe = Nsets[i];\r\n                if (sgn(c[tmpe]) <= 0) {\r\n                    continue;\r\n                }\r\n                int tmpl = maxint;\r\n                double mmin = 1e100;\r\n                for (int i = 0; i < Bsize; ++i) {\r\n                    int u = Bsets[i];\r\n                    if (sgn(A[u][tmpe]) > 0 && (b[u] / A[u][tmpe] < mmin || sgn(b[u] / A[u][tmpe] - mmin) == 0 && u < tmpl)) {\r\n                        mmin = b[u] / A[u][tmpe];\r\n                        tmpl = u;\r\n                    }\r\n                }\r\n                if (tmpl == maxint) {\r\n                    return mmin;\r\n                }\r\n                if (mmin * c[tmpe] > mmax) {\r\n                    mmax = mmin * c[tmpe];\r\n                    l = tmpl;\r\n                    e = tmpe;\r\n                }\r\n            }\r\n            if (mmax == -1) {\r\n                return v;\r\n            }\r\n            pivot(l, e);\r\n        }\r\n    }\r\n    void pivot(int l, int e) {\r\n        b[e] = b[l] / A[l][e];\r\n        A[e][l] = 1 / A[l][e];\r\n        for (int i = 0; i < Nsize; ++i) {\r\n            int u = Nsets[i];\r\n            if (u != e) {\r\n                A[e][u] = A[l][u] / A[l][e];\r\n            }\r\n        }\r\n        for (int i = 0; i < Bsize; ++i) {\r\n            int u = Bsets[i];\r\n            if (u != l) {\r\n                b[u] -= A[u][e] * b[e];\r\n                A[u][l] = -A[u][e] * A[e][l];\r\n                for (int j = 0; j < Nsize; ++j) {\r\n                    int v = Nsets[j];\r\n                    if (v != e) {\r\n                        A[u][v] -= A[u][e] * A[e][v];\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        v += b[e] * c[e];\r\n        c[l] = -A[e][l] * c[e];\r\n        for (int i = 0; i < Nsize; ++i) {\r\n            int u = Nsets[i];\r\n            if (u != e) {\r\n                c[u] -= c[e] * A[e][u];\r\n            }\r\n        }\r\n        for (int i = 0; i < Nsize; ++i) {\r\n            if (Nsets[i] == e) {\r\n                Nsets[i] = l;\r\n                break;\r\n            }\r\n        }\r\n        for (int i = 0; i < Bsize; ++i) {\r\n            if (Bsets[i] == l) {\r\n                Bsets[i] = e;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n} simplex;\r\nstruct Graph {\r\n    static const int maxn = 100 * 100;\r\n    static const int maxm = 100;\r\n    int n, m;\r\n    int adj[maxn][maxm];\r\n    void init() {\r\n        n = m = 0;\r\n        memset(adj, 0, sizeof(adj));\r\n    }\r\n    void insert(int u, int v) {\r\n        get_max(n, u + 1);\r\n        get_max(m, v + 1);\r\n        adj[u][v] = 1;\r\n    }\r\n    double find_ans(int *T) {\r\n        simplex.clear(n, m, T);\r\n        for (int i = 0; i < n; ++i) {\r\n            for (int j = 0; j < m; ++j) {\r\n                if (adj[i][j]) {\r\n                    simplex.insert(j, i, -1);\r\n                }\r\n            }\r\n        }\r\n        double ans = simplex.find() * -1;\r\n        return ans;\r\n    }\r\n};\r\nGraph g;\r\nint main() {\r\n    int ca;\r\n    scanf("%d", &ca);\r\n    while (ca--) {\r\n        int n, r;\r\n        scanf("%d %d", &n, &r);\r\n        P dt[n];\r\n        int T[n];\r\n        for (int i = 0; i < n; ++i) {\r\n            dt[i].input();\r\n            scanf("%d", T + i);\r\n        }\r\n        vector<P> cir;\r\n        bool visited[n];\r\n        for (int i = 0; i < n; ++i) {\r\n            visited[i] = false;\r\n        }\r\n        for (int i = 0; i < n; ++i) {\r\n            for (int j = 0; j < n; ++j) {\r\n                if (dt[i] != dt[j]) {\r\n                    double d = dist(dt[i], dt[j]);\r\n                    if (sgn(d - r * 2) == 0) {\r\n                        cir.push_back((dt[i] + dt[j]) / 2);\r\n                        visited[i] = visited[j] = true;\r\n                    } else if (sgn(d - r * 2) < 0) {\r\n                        cir.push_back((dt[i] + dt[j]) / 2 + (dt[j] - dt[i]).turn_left().trunc(sqrt(SQR(r) - SQR(d / 2))));\r\n                        visited[i] = visited[j] = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        sort(cir.begin(), cir.end());\r\n        cir.erase(unique(cir.begin(), cir.end()), cir.end());\r\n        g.init();\r\n        double ans = 0;\r\n        for (int i = 0; i < n; ++i) {\r\n            if (visited[i] == false) {\r\n                ans += T[i];\r\n                T[i] = -116;\r\n            }\r\n        }\r\n        for (int i = 0; i < SZ(cir); ++i) {\r\n            for (int j = 0; j < n; ++j) {\r\n                if (sgn(dist(cir[i], dt[j]) - r) <= 0) {\r\n                    g.insert(i, j);\r\n                }\r\n            }\r\n        }\r\n        printf("%.2lf\\n", ans + g.find_ans(T));\r\n    }\r\n    return 0;\r\n}\r\n\r\n', '', 717, 58687488, 1, 2, '2010-08-08 02:40:17', '2010-08-08 02:41:54'),
(130, 1, 117, 0, '/*\r\n * Author: momodi\r\n * Created Time:  2009/10/2 19:14:20\r\n * File Name: GCC.cpp\r\n * Description: \r\n */\r\n#include <cstdio>\r\n#include <cstring>\r\n#include <cmath>\r\n#include <vector>\r\n#include <cstdlib>\r\n#include <algorithm>\r\nusing namespace std;\r\n#define out(x) fprintf(stderr, "%s: %I64d\\n", #x, (long long)(x))\r\n#define SZ(v) ((int)(v).size())\r\nconst int maxint=-1u>>1;\r\ntemplate <class T> bool get_max(T& a, const T &b) {return b > a? a = b, 1: 0;}\r\ntemplate <class T> bool get_min(T& a, const T &b) {return b < a? a = b, 1: 0;}\r\nint solve(int a, int b) {\r\n    if (b == 1) {\r\n        return 0;\r\n    }\r\n    if (a == 0) {\r\n        return 1;\r\n    }\r\n    int now = 1;\r\n    int ans = 1;\r\n    for (int i = 1; i <= a; ++i) {\r\n        now = (long long)now * i % b;\r\n        ans = (ans + now) % b;\r\n    }\r\n    return ans;\r\n}\r\nint main() {\r\n    int ca;\r\n    scanf("%d", &ca);\r\n    while (ca--) {\r\n        char s[110];\r\n        int m;\r\n        scanf("%s %d", s, &m);\r\n        int a;\r\n        if (strlen(s) > 6) {\r\n            a = m - 1;\r\n        } else {\r\n            sscanf(s, "%d", &a);\r\n        }\r\n        printf("%d\\n", solve(a, m));\r\n        \r\n    }\r\n    return 0;\r\n}\r\n\r\n', '', 140, 262144, 1, 2, '2010-08-08 02:43:46', '2010-08-08 02:43:46'),
(131, 1, 118, 0, '/*\r\n * Author: momodi\r\n * Created Time:  2009/6/30 21:16:48\r\n * File Name: circle.cpp\r\n * Description: \r\n */\r\n#include <cstdio>\r\n#include <cstring>\r\n#include <cmath>\r\n#include <vector>\r\n#include <cstdlib>\r\n#include <algorithm>\r\n#include <set>\r\nusing namespace std;\r\n#define out(x) fprintf(stderr, "%s: %I64d\\n", #x, (long long)(x))\r\n#define SZ(v) ((int)(v).size())\r\nconst int maxint=-1u>>1;\r\ntemplate <class T> bool get_max(T& a, const T &b) {return b > a? a = b, 1: 0;}\r\ntemplate <class T> bool get_min(T& a, const T &b) {return b < a? a = b, 1: 0;}\r\n#define SQR(v) ((double)(v) * (v))\r\nconst int maxn = 101000;\r\nconst double eps = 1e-10;\r\nint sgn(double a) {\r\n    return (a > eps) - (a < -eps);\r\n}\r\nint n;\r\nint X[maxn], Y[maxn], R[maxn];\r\nint LL[maxn], RR[maxn];\r\nint num[maxn];\r\nset<int> tree;\r\nint tmp[maxn];\r\ndouble mid;\r\nbool collid(int a, int b) {\r\n    a = tmp[a];\r\n    b = tmp[b];\r\n    if (SQR(X[a] - X[b]) + SQR(Y[a] - Y[b]) - SQR(R[a] + R[b] + mid + mid) <= 0) {\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\nbool insert(int v) {\r\n    set<int>::iterator it = tree.insert(v).first;\r\n    if (it != tree.begin()) {\r\n        if (collid(v, *--it)) {\r\n            return false;\r\n        }\r\n        ++it;\r\n    }\r\n    if (++it != tree.end()) {\r\n        if (collid(v, *it)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nbool remove(int v) {\r\n    set<int>::iterator it = tree.find(v);\r\n    if (it == tree.end()) {\r\n        printf("error\\n");\r\n    }\r\n    if (it != tree.begin() && it != --tree.end()) {\r\n        int a = *--it;\r\n        ++it;\r\n        int b = *++it;\r\n        if (collid(a, b)) {\r\n            return false;\r\n        }\r\n    }\r\n    tree.erase(v);\r\n    return true;\r\n}\r\n\r\nbool ok(double mid) {\r\n    ::mid = mid;\r\n    tree.clear();\r\n    int l = 0, r = 0;\r\n    while (l < n || r < n) {\r\n        if (l == n) {\r\n            if (!remove(num[RR[r++]])) {\r\n                return false;\r\n            }\r\n        } else if (r == n) {\r\n            if (!insert(num[LL[l++]])) {\r\n                return false;\r\n            }\r\n        } else if (sgn(X[LL[l]] - R[LL[l]] - mid - X[RR[r]] - R[RR[r]] - mid) <= 0){\r\n            if (!insert(num[LL[l++]])) {\r\n                return false;\r\n            }\r\n        } else {\r\n            if (!remove(num[RR[r++]])) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}\r\nbool cmpy(int a, int b) {\r\n    if (Y[a] == Y[b]) {\r\n        return X[a] < X[b];\r\n    }\r\n    return Y[a] < Y[b];\r\n}\r\nbool cmpl(int a, int b) {\r\n    return X[a] - R[a] < X[b] - R[b];\r\n}\r\nbool cmpr(int a, int b) {\r\n    return X[a] + R[a] < X[b] + R[b];\r\n}\r\ndouble solve() {\r\n    for (int i = 0; i < n; ++i) {\r\n        tmp[i] = LL[i] = RR[i] = i;\r\n    }\r\n    sort(tmp, tmp + n, cmpy);\r\n    for (int i = 0; i < n; ++i) {\r\n        num[tmp[i]] = i;\r\n    }\r\n    sort(LL, LL + n, cmpl);\r\n    sort(RR, RR + n, cmpr);\r\n    double s = 0, t = SQR(sqrt(SQR(X[0] - X[1]) + SQR(Y[0] - Y[1])) - R[0] - R[1]);\r\n    while (t - s > 1e-8) {\r\n        double mid = (s + t) / 2;\r\n        if (ok(mid)) {\r\n            s = mid;\r\n        } else {\r\n            t = mid;\r\n        }\r\n    }\r\n    return s + t;\r\n}\r\nint main() {\r\n    int ca;\r\n    scanf("%d", &ca);\r\n    while (ca--) {\r\n        scanf("%d", &n);\r\n        for (int i = 0; i < n; ++i) {\r\n            scanf("%d %d %d", X + i, Y + i, R + i);\r\n        }\r\n        printf("%.6lf\\n", solve());\r\n    }\r\n    return 0;\r\n}\r\n\r\n', '', 99, 4947968, 1, 2, '2010-08-08 02:45:26', '2010-08-08 02:47:57'),
(132, 1, 119, 0, '/*\r\n * Author: momodi\r\n * Created Time:  2009/9/5 22:31:02\r\n * File Name: Nova.cpp\r\n * Description: \r\n */\r\n#include <cstdio>\r\n#include <cstring>\r\n#include <cmath>\r\n#include <vector>\r\n#include <cstdlib>\r\n#include <algorithm>\r\nusing namespace std;\r\n#define out(x) fprintf(stderr, "%s: %I64d\\n", #x, (long long)(x))\r\n#define SZ(v) ((int)(v).size())\r\nconst int maxint=-1u>>1;\r\ntemplate <class T> bool get_max(T& a, const T &b) {return b > a? a = b, 1: 0;}\r\ntemplate <class T> bool get_min(T& a, const T &b) {return b < a? a = b, 1: 0;}\r\n#define SQR(v) ((long long)(v) * (v))\r\nconst int maxn = 310;\r\nint n, m, t;\r\nint lichx[maxn], lichy[maxn], lichr[maxn], licht[maxn];\r\nint wispx[maxn], wispy[maxn];\r\nint treex[maxn], treey[maxn], treer[maxn];\r\nbool adj[maxn][maxn];\r\nint now[maxn];\r\n\r\nlong long sqr(long long a) {\r\n    return a * a;\r\n}\r\nlong long dist2(int ax, int ay, int bx, int by) {\r\n    return SQR(ax - bx) + SQR(ay - by);\r\n}\r\nint cross(int ax, int ay, int bx, int by, int cx, int cy) {\r\n    return (bx - ax) * (cy - ay) - (by - ay) * (cx - ax);\r\n}\r\nint mul(int  ax, int ay, int bx, int by, int cx, int cy) {\r\n    return (bx - ax) * (cx - ax) + (by - ay) * (cy - ay);\r\n}\r\n\r\nbool block(int a, int b, int c) {\r\n    if (sqr(cross(lichx[a], lichy[a], wispx[b], wispy[b], treex[c], treey[c])) > SQR(treer[c]) * dist2(lichx[a], lichy[a], wispx[b], wispy[b])) {\r\n        return false;\r\n    }\r\n    return mul(lichx[a], lichy[a], wispx[b], wispy[b], treex[c], treey[c]) >= 0 &&\r\n        mul(wispx[b], wispy[b], lichx[a], lichy[a], treex[c], treey[c]) >= 0;\r\n}\r\n\r\nbool can_see(int a, int b) {\r\n    int d2 = SQR(lichx[a] - wispx[b]) + SQR(lichy[a] - wispy[b]);\r\n    if (d2 > SQR(lichr[a])) {\r\n        return false;\r\n    }\r\n    for (int i = 0; i < t; ++i) {\r\n        if (block(a, b, i)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nint match[maxn], flag[maxn];\r\nbool dfs(int v) {\r\n    for (int i = 0; i < m; ++i) {\r\n        if (adj[v][i] && flag[i] == false) {\r\n            flag[i] = true;\r\n            if (match[i] == -1 || dfs(match[i])) {\r\n                match[i] = v;\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}\r\nint main() {\r\n    int ca;\r\n    scanf("%d", &ca);\r\n    while (ca--) {\r\n        scanf("%d %d %d", &n, &m, &t);\r\n        for (int i = 0; i < n; ++i) {\r\n            scanf("%d %d %d %d", lichx + i, lichy + i, lichr + i, licht + i);\r\n        }\r\n        for (int i = 0; i < m; ++i) {\r\n            scanf("%d %d", wispx + i, wispy + i);\r\n        }\r\n        for (int i = 0; i < t; ++i) {\r\n            scanf("%d %d %d", treex + i, treey + i, treer + i);\r\n        }\r\n        \r\n        for (int i = 0; i < n; ++i) {\r\n            for (int j = 0; j < m; ++j) {\r\n                adj[i][j] = can_see(i, j);\r\n            }\r\n        }\r\n        int tot = 0;\r\n        int ans = 0;\r\n        memset(match, -1, sizeof(match));\r\n        memset(now, 0, sizeof(now));\r\n        while (tot < m) {\r\n            int mmin = maxint;\r\n            int v = -1;\r\n            for (int i = 0; i < n; ++i) {\r\n                if (get_min(mmin, now[i])) {\r\n                    v = i;\r\n                }\r\n            }\r\n            if (v == -1) {\r\n                break;\r\n            }\r\n            memset(flag, 0, sizeof(flag));\r\n            if (dfs(v)) {\r\n                ans = now[v];\r\n                now[v] += licht[v];\r\n                ++tot;\r\n            } else {\r\n                now[v] = maxint;\r\n            }\r\n        }\r\n        if (tot == m) {\r\n            printf("%d\\n", ans);\r\n        } else {\r\n            printf("-1\\n");\r\n        }\r\n    }\r\n    return 0;\r\n}\r\n\r\n', '', 124, 368640, 1, 2, '2010-08-08 02:50:07', '2010-08-08 02:50:07'),
(133, 1, 120, 0, '/*\r\n * Author: momodi\r\n * Created Time:  2009/9/6 0:21:18\r\n * File Name: Slash.cpp\r\n * Description: \r\n */\r\n#include <cstdio>\r\n#include <cstring>\r\n#include <cmath>\r\n#include <vector>\r\n#include <cstdlib>\r\n#include <algorithm>\r\nusing namespace std;\r\n#define out(x) fprintf(stderr, "%s: %I64d\\n", #x, (long long)(x))\r\n#define SZ(v) ((int)(v).size())\r\nconst int maxint=-1u>>1;\r\ntemplate <class T> bool get_max(T& a, const T &b) {return b > a? a = b, 1: 0;}\r\ntemplate <class T> bool get_min(T& a, const T &b) {return b < a? a = b, 1: 0;}\r\nchar buf[1000];\r\nvoid change(char *s, char a, char b) {\r\n    while (*s) {\r\n        if (*s == a) {\r\n            *s = b;\r\n        }\r\n        ++s;\r\n    }\r\n}\r\nvoid solve(char *s) {\r\n    if (buf[0] == ''\\\\'' || buf[0] == ''/'') {\r\n        puts("It''s a path in Unix-like systems!");\r\n        change(s, ''\\\\'', ''/'');\r\n        puts(s);\r\n        return ;\r\n    } else {\r\n        for (char *p = s; *p; ++p) {\r\n            if (*p == '':'') {\r\n                if (*(p + 2) == ''\\\\'' || *(p + 2) == ''/'') {\r\n                    puts("It''s a URL!");\r\n                    change(s, ''\\\\'', ''/'');\r\n                    puts(s);\r\n                    return ;\r\n                } else {\r\n                    puts("It''s a path in Windows system!");\r\n                    change(s, ''/'', ''\\\\'');\r\n                    puts(s);\r\n                    return ;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    puts("data error\\n");\r\n    while (1);\r\n}\r\nint main() {\r\n    int ca;\r\n    scanf("%d", &ca);\r\n    while (ca--) {\r\n        scanf("%s", buf);\r\n        solve(buf);\r\n    }\r\n    return 0;\r\n}\r\n\r\n', '', 0, 262144, 1, 2, '2010-08-08 02:52:05', '2010-08-08 02:52:05'),
(134, 1, 121, 0, '/*\r\n * Author: momodi\r\n * Created Time:  2009/9/6 0:05:51\r\n * File Name: WHUgirls.cpp\r\n * Description: \r\n */\r\n#include <cstdio>\r\n#include <cstring>\r\n#include <cmath>\r\n#include <vector>\r\n#include <cstdlib>\r\n#include <algorithm>\r\nusing namespace std;\r\n#define out(x) fprintf(stderr, "%s: %I64d\\n", #x, (long long)(x))\r\n#define SZ(v) ((int)(v).size())\r\nconst int maxint=-1u>>1;\r\ntemplate <class T> bool get_max(T& a, const T &b) {return b > a? a = b, 1: 0;}\r\ntemplate <class T> bool get_min(T& a, const T &b) {return b < a? a = b, 1: 0;}\r\nconst int maxn = 1010;\r\nint x[maxn], y[maxn], c[maxn];\r\nint f[maxn][maxn];\r\nint n, X, Y;\r\n\r\nint main() {\r\n    int ca;\r\n    scanf("%d", &ca);\r\n    while (ca--) {\r\n        scanf("%d %d %d", &n, &X, &Y);\r\n        for (int i = 0; i < n; ++i) {\r\n            scanf("%d %d %d", x + i, y + i, c + i);\r\n        }\r\n        for (int i = 0; i <= X; ++i) {\r\n            for (int j = 0; j <= Y; ++j) {\r\n                int &ans = f[i][j];\r\n                ans = 0;\r\n                for (int k = 0; k < n; ++k) {\r\n                    if (x[k] <= i && y[k] <= j) {\r\n                        get_max(ans, c[k] + f[i - x[k]][j] + f[x[k]][j - y[k]]);\r\n                        get_max(ans, c[k] + f[i][j - y[k]] + f[i - x[k]][y[k]]);\r\n                    }\r\n                    swap(x[k], y[k]);\r\n                    if (x[k] <= i && y[k] <= j) {\r\n                        get_max(ans, c[k] + f[i - x[k]][j] + f[x[k]][j - y[k]]);\r\n                        get_max(ans, c[k] + f[i][j - y[k]] + f[i - x[k]][y[k]]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        printf("%d\\n", f[X][Y]);\r\n    }\r\n    return 0;\r\n}\r\n\r\n', '', 1822, 4354048, 1, 2, '2010-08-08 02:53:58', '2010-08-08 02:59:43'),
(135, 1, 123, 0, '/*\r\n * Author: ChaeYeon\r\n * Created Time:  2/17/2009 4:22:46 PM\r\n * File Name: cup.cpp\r\n * Description: \r\n To solve this problem, you should know that the volume of one cup is pi * (r * r + R * R + r * R) * h / 3.\r\n If you don''t know this formula, you could find by this formula: s * h / 3.\r\n It''s the formula to calculte the volume of taper.\r\n The next step after you know the formula is to calculate the high of the water.\r\n */\r\n#include <cstdio>\r\n#include <cstring>\r\n#include <cmath>\r\n#include <vector>\r\n#include <cstdlib>\r\n#include <algorithm>\r\nusing namespace std;\r\n#define out(x) fprintf(stderr, "%s: %I64d\\n", #x, (long long)(x))\r\n#define SZ(v) ((int)(v).size())\r\nconst int maxint=-1u>>1;\r\ntemplate <class T> bool get_max(T& a, const T &b) {return b > a? a = b, 1: 0;}\r\ntemplate <class T> bool get_min(T& a, const T &b) {return b < a? a = b, 1: 0;}\r\nconst double pi = acos(-1.0);\r\ndouble V(double r, double R, double h, double mid) {\r\n    double rr = r + (R - r) * mid / h;\r\n    return pi * (r * r + rr * rr + r * rr) * mid / 3;\r\n}\r\n\r\ndouble find(double r, double R, double h, double v) {\r\n    double ans = 0, s = 0, t = h;\r\n    while (t - s > 1e-9) {\r\n        double mid = (s + t) / 2;\r\n        if (V(r, R, h, mid) <= v) {\r\n            s = mid;\r\n            get_max(ans, mid);\r\n        } else {\r\n            t = mid;\r\n        }\r\n    }\r\n    return ans;\r\n}\r\n\r\nint main() {\r\n    int ca;\r\n    scanf("%d", &ca);\r\n    while (ca--) {\r\n        double r, R, h, v;\r\n        scanf("%lf %lf %lf %lf", &r, &R, &h, &v);\r\n        printf("%.6lf\\n", find(r, R, h, v));\r\n    }\r\n    return 0;\r\n}\r\n\r\n', '', 0, 258048, 1, 2, '2010-08-08 03:03:28', '2010-08-08 03:03:28'),
(136, 1, 124, 0, '/*\r\n * Author: gaoyunxiang.cpp@gmail.com\r\n * Created Time:  2/17/2009 2:37:09 PM\r\n * File Name: FindThePath.cpp\r\n * Description: \r\n What you need to know before you read this code is the real process of floyd.\r\n Why we call it as a DP algorithm?\r\n If you understand that algorithm, I think you could solved this problem quackly.\r\n */\r\n#include <cstdio>\r\n#include <cstring>\r\n#include <cmath>\r\n#include <vector>\r\n#include <cstdlib>\r\n#include <algorithm>\r\nusing namespace std;\r\n#define out(x) fprintf(stderr, "%s: %lld\\n", #x, (long long)(x))\r\n#define SZ(v) ((int)(v).size())\r\nconst int maxint=-1u>>1;\r\ntemplate <class T> bool get_max(T& a, const T &b) {return b > a? a = b, 1: 0;}\r\ntemplate <class T> bool get_min(T& a, const T &b) {return b < a? a = b, 1: 0;}\r\nint point[210];\r\nint adj[210][210];\r\nint dp[210][210][210];\r\nbool cmp(int a, int b) {\r\n    return point[a] < point[b];\r\n}\r\nint main() {\r\n    int ca;\r\n    scanf("%d", &ca);\r\n    while (ca--) {\r\n        int n, m;\r\n        scanf("%d %d", &n, &m);\r\n        for (int i = 0; i < n; ++i) {\r\n            scanf("%d", point + i);\r\n        }\r\n        for (int i = 0; i < n; ++i) {\r\n            for (int j = 0; j < n; ++j) {\r\n                adj[i][j] = maxint;\r\n            }\r\n        }\r\n        int tmp[200];\r\n        for (int i = 0; i < n; ++i) {\r\n            tmp[i] = i;\r\n        }\r\n        sort(tmp, tmp + n, cmp);\r\n        while (m--) {\r\n            int u, v, c;\r\n            scanf("%d %d %d", &u, &v, &c);\r\n            adj[u][v] = adj[v][u] = c;\r\n        }\r\n        for (int i = 0; i < n; ++i) {\r\n            for (int j = 0; j < n; ++j) {\r\n                dp[0][i][j] = adj[i][j];\r\n            }\r\n        }\r\n        for (int k = 0; k < n; ++k) {\r\n            int v = tmp[k];\r\n            for (int i = 0; i < n; ++i) {\r\n                for (int j = 0; j < n; ++j) {\r\n                    dp[k + 1][i][j] = dp[k][i][j];\r\n                }\r\n            }\r\n            for (int i = 0; i < n; ++i) {\r\n                if (dp[k][i][v] < maxint) {\r\n                    for (int j = 0; j < n; ++j) {\r\n                        if (dp[k][v][j] < maxint) {\r\n                            get_min(dp[k + 1][i][j], dp[k][i][v] + dp[k][v][j]);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        int Q;\r\n        scanf("%d", &Q);\r\n        sort(point, point + n);\r\n        while (Q--) {\r\n            int u, v, k;\r\n            scanf("%d %d %d", &u, &v, &k);\r\n            int ans = adj[u][v];\r\n            int tmp = upper_bound(point, point + n, k) - point;\r\n            get_min(ans, dp[tmp][u][v]);\r\n            if (ans == maxint) {\r\n                printf("-1\\n");\r\n            } else {\r\n                printf("%d\\n", ans);\r\n            }\r\n        }\r\n        puts("");\r\n    }\r\n    return 0;\r\n}\r\n\r\n', '', 310, 37548032, 1, 2, '2010-08-08 03:05:38', '2010-08-08 03:06:29'),
(137, 1, 125, 0, '/**********************************************************************\r\nAuthor: Sherlock\r\nCreated Time:  2009-02-18 20:12:29\r\nFile Name: \r\nDescription: \r\n**********************************************************************/\r\n#include <cstdio>\r\n#include <cstring>\r\n#include <cstdlib>\r\n#include <algorithm>\r\n#include <vector>\r\n\r\nusing namespace std;\r\n\r\nconst int   maxSize     =   15;\r\nconst int   maxScore    =   12 * 10 + 10;\r\n\r\nint         n;\r\nint         exp[maxSize][maxSize], score[maxSize][maxSize], que[maxSize], pows[maxSize], f[maxScore][1 << 15];\r\n\r\nvoid            init_power()\r\n{\r\n    pows[0] = 1;\r\n    for (int i = 1; i < 15; i ++)\r\n        pows[i] = pows[i - 1] * 2;\r\n}\r\n\r\nvoid            init()\r\n{\r\n    for (int i = 0; i < n; i ++)  \r\n        for (int j = 0; j < n; j ++)\r\n            scanf("%d", &exp[i][j]);\r\n    for (int i = 0; i < n; i ++)\r\n        for (int j = 0; j < n; j ++)\r\n            scanf("%d", &score[i][j]);\r\n    for (int i = 0; i < n; i ++)\r\n        scanf("%d", &que[i]);\r\n}\r\n\r\nvoid            solve()\r\n{\r\n    if (n == 1)\r\n    {\r\n        printf("0\\n");\r\n        return ;\r\n    }\r\n    \r\n    memset(f, -1, sizeof(f));\r\n    f[0][0] = 0;\r\n    for (int p = 0; p < pows[n - 1]; p ++)\r\n    {\r\n        int sum = 0;\r\n        for (int i = 1; i < n; i ++)\r\n            if ((p & pows[i - 1]) != 0)\r\n                sum += score[0][i];\r\n        for (int i = 0; i <= sum; i ++)\r\n            if (f[i][p] >= 0)\r\n            {\r\n                for (int j = 1; j < n; j ++)\r\n                    if ((p & pows[j - 1]) == 0)\r\n                    {\r\n                        if (que[0] + f[i][p] > que[j])\r\n                            f[i + score[0][j]][p + pows[j - 1]] = max(f[i + score[0][j]][p + pows[j - 1]], f[i][p] + exp[0][j]);\r\n                        else\r\n                            f[i][p + pows[j - 1]] = max(f[i][p + pows[j - 1]], f[i][p] + exp[0][j]);\r\n                    }\r\n            }\r\n    }\r\n    \r\n    int sum = 0;\r\n    for (int i = 1; i < n; i ++)\r\n        sum += score[0][i];\r\n    for (int i = sum; i >= 0; i --)\r\n        if (f[i][pows[n - 1] - 1] != -1)\r\n        {\r\n            printf("%d\\n", i);\r\n            break;\r\n        }\r\n}\r\n\r\nint             main()\r\n{\r\n//    freopen("gobang.in", "r", stdin);\r\n//    freopen("gobang.out", "w", stdout);\r\n    int test_num;\r\n    scanf("%d", &test_num);\r\n    init_power();\r\n    while (test_num > 0)\r\n    {\r\n        test_num --;\r\n        scanf("%d", &n);\r\n        init();\r\n        solve();\r\n    }\r\n    return 0;\r\n}\r\n\r\n', '', 62, 17334272, 1, 2, '2010-08-08 03:08:52', '2010-08-08 03:08:52'),
(138, 1, 126, 0, '/**********************************************************************\r\nAuthor: Felicia\r\nCreated Time:  2009-2-19 14:13:28\r\nFile Name: whu09_3.cpp\r\nDescription: \r\n**********************************************************************/\r\n#include <cstdio>\r\n#include <cstring>\r\n#include <cstdlib>\r\n#include <algorithm>\r\n#include <vector>\r\n\r\nusing namespace std;\r\n\r\ntypedef long long int64;\r\nconst int maxint = 0x7FFFFFFF;\r\nconst int64 maxint64 = 0x7FFFFFFFFFFFFFFFLL;\r\n\r\nconst int maxn = 1010;\r\nint M;\r\n\r\nint c[maxn][maxn];\r\nint f[maxn];\r\n\r\nvoid calc_c() {\r\n    for (int i = 0; i < maxn; i++) {\r\n        c[i][0] = c[i][i] = 1;\r\n        for (int j = 1; j < i; j++) {\r\n            c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % M;\r\n        }\r\n    }\r\n}\r\n\r\nint dp(int n, int depth) {\r\n    if (f[n] != -1)\r\n        return f[n];\r\n    if (n == 1 || n == 0)\r\n        return 1;\r\n    int t = 1;\r\n    while (t <= n) t = t * 2 + 1;\r\n    t = (t - 1) / 2;\r\n    t = (t - 1) / 2;\r\n    int right = t;\r\n    int left = n - 1 - t;\r\n    if (left > 2 * t + 1) {\r\n        left = 2 * t + 1;\r\n        right = n - 1 - left;\r\n    }\r\n\r\n    return f[n] = (long long)dp(left, depth+1) * dp(right, depth+1) % M * (long long)c[n - 1][left] % M;\r\n}\r\n\r\nint main() {\r\n    int n;\r\n    int ca;\r\n    scanf("%d", &ca);\r\n    for (int t = 0; t < ca; t++) {\r\n        scanf("%d%d", &n, &M);\r\n        memset(c, 0, sizeof(c));\r\n        calc_c();\r\n        memset(f, -1, sizeof(f));\r\n        printf("%d\\n", dp(n, 0));\r\n    }\r\n    return 0;\r\n}\r\n', '', 62, 4354048, 1, 2, '2010-08-08 03:11:21', '2010-08-08 03:11:21'),
(139, 1, 127, 0, '/**********************************************************************\r\nAuthor: WHU_dzs\r\nCreated Time:  2009-2-15 15:32:43\r\nFile Name: pro2.cpp\r\nDescription: \r\n**********************************************************************/\r\n#include <iostream>\r\n#include <cstring>\r\n#include <cstdio>\r\n\r\nusing namespace std;\r\n\r\nchar s1[1010], s2[1010];\r\nint hp1, str1, spd1;\r\nint hp2, str2, spd2;\r\n\r\nvoid calc (char *s, int &hp, int &str, int &spd) {\r\n	int len = strlen(s);\r\n\r\n	hp = 0;\r\n	for (int i = 0; i < len; i++)\r\n		hp = (hp + (83 - s[i]) * (83 - s[i])) % 97;\r\n	hp = 300 - hp;\r\n\r\n	str = 1;\r\n	for (int i = 0; i < len; i++)\r\n		str = (str * s[i]) % 79;\r\n	str = 22 + str;\r\n\r\n	spd = 0;\r\n	for (int i = 0; i < len - 1; i++)\r\n		for (int j = i + 1; j < len; j++)\r\n			spd = (spd + s[i] * s[j]) % 11;\r\n}\r\n\r\nint main () {\r\n//    freopen("namepk.out", "w", stdout);\r\n    int ca;\r\n    scanf("%d", &ca);\r\n    while (ca--) {\r\n	    scanf ("%s %s", s1, s2);\r\n		calc (s1, hp1, str1, spd1);\r\n		calc (s2, hp2, str2, spd2);\r\n		\r\n		bool done = false;\r\n		int time = 0;\r\n		while (!done) {\r\n			time++;\r\n			if (time % (20 - spd1) == 0)\r\n				hp2 -= str1;\r\n			if (time % (20 - spd2) == 0)\r\n				hp1 -= str2;\r\n			if (hp1 <= 0 || hp2 <= 0)\r\n				done = true;\r\n		}\r\n		if (hp1 <= 0 && hp2 > 0)\r\n			printf ("lose\\n");\r\n		else if (hp1 > 0 && hp2 <= 0)\r\n			printf ("win\\n");\r\n		else\r\n			printf ("tie\\n");\r\n	}\r\n	return 0;\r\n}\r\n\r\n', '', 0, 372736, 1, 2, '2010-08-08 03:14:07', '2010-08-08 03:14:39'),
(140, 1, 128, 0, '/**********************************************************************\r\nAuthor: Sherlock\r\nCreated Time:  2009-03-24 19:51:46\r\nFile Name: necklace.cpp\r\nDescription: \r\n**********************************************************************/\r\n#include <cstdio>\r\n#include <cstring>\r\n#include <cstdlib>\r\n#include <algorithm>\r\n#include <vector>\r\n\r\n#define int64 long long\r\n\r\nconst   int     mod =   1234567891;\r\n\r\nint     n, m;\r\nint     a[31][31], b[31][31], c[31][31], d[31][31], z[31][31];\r\n\r\nvoid        mul(int x[31][31], int y[31][31])\r\n{\r\n    for (int i = 0; i <= m; i ++)\r\n        for (int j = 0; j <= m; j ++)\r\n        {\r\n            z[i][j] = 0;\r\n            for (int k = 0; k <= m; k ++)\r\n                z[i][j] = ((int64) z[i][j] + ((int64) x[i][k] * y[k][j]) % mod) % mod;\r\n        }\r\n    for (int i = 0; i <= m; i ++)\r\n        for (int j = 0; j <= m; j ++)\r\n            x[i][j] = z[i][j];\r\n}\r\n\r\nvoid        make(int p)\r\n{\r\n    if (p == 0)\r\n        return ;\r\n    make(p / 2);\r\n    for (int i = 0; i <= m; i ++)\r\n        for (int j = 0; j <= m; j ++)\r\n            d[i][j] = b[i][j];\r\n    for (int i = 0; i <= m; i ++)\r\n        d[i][i] = (d[i][i] + 1) % mod;\r\n    mul(c, d);\r\n    mul(b, b);\r\n    if (p % 2 == 1)\r\n    {\r\n        mul(b, a);\r\n        for (int i = 0; i <= m; i ++)\r\n            for (int j = 0; j <= m; j ++)\r\n                c[i][j] = ((int64) c[i][j] + b[i][j]) % mod;\r\n    }\r\n}\r\n\r\nvoid        solve()        \r\n{ \r\n    memset(a, 0, sizeof(a));\r\n    memset(b, 0, sizeof(b));\r\n    memset(c, 0, sizeof(c));\r\n    for (int i = 0; i <= m; i ++)\r\n        b[i][i] = 1;\r\n    for (int i = 1; i <= m; i ++)\r\n    {\r\n        a[i - 1][i] = m - i + 1;\r\n        a[i][i] = i;\r\n    }\r\n    make(n);\r\n    printf("%d\\n", c[0][m]);\r\n} \r\n\r\nint         main()\r\n{\r\n    int test_num;\r\n    scanf("%d", &test_num);\r\n    while (test_num > 0)\r\n    {\r\n        test_num --;\r\n        scanf("%d%d", &n, &m);\r\n        solve();\r\n    }\r\n}\r\n\r\n\r\n', '', 312, 278528, 1, 2, '2010-08-08 03:16:23', '2010-08-08 03:16:23');
INSERT INTO `tbl_submitions` (`id`, `user_id`, `problem_id`, `exercise_id`, `source`, `result`, `used_time`, `used_memory`, `status`, `compiler_id`, `created`, `modified`) VALUES
(141, 1, 129, 0, '/*\r\n * Author: ChaeYeon\r\n * Created Time:  2009/3/24 21:56:53\r\n * File Name: radar.cpp\r\n * Description: \r\n */\r\n#include <cstdio>\r\n#include <cstring>\r\n#include <cmath>\r\n#include <vector>\r\n#include <cstdlib>\r\n#include <algorithm>\r\nusing namespace std;\r\n#define out(x) fprintf(stderr, "%s: %I64d\\n", #x, (long long)(x))\r\n#define SZ(v) ((int)(v).size())\r\nconst int maxint=-1u>>1;\r\ntemplate <class T> bool get_max(T& a, const T &b) {return b > a? a = b, 1: 0;}\r\ntemplate <class T> bool get_min(T& a, const T &b) {return b < a? a = b, 1: 0;}\r\n\r\nclass Graph {\r\n    public:\r\n        static const int maxn = 100;\r\n        static const int maxm = 201;\r\n        static const int mmax = maxn * maxm + maxn + maxm + 100;\r\n        int n, m;\r\n        int adj[maxn][maxm];\r\n        void clear() {\r\n            n = m = 0;\r\n            memset(adj, 0, sizeof(adj));\r\n        }\r\n        void insert(int u, int v) {\r\n            get_max(n, u + 1);\r\n            get_max(m, v + 1);\r\n            adj[u][v] = 1;\r\n        }\r\n        bool ok(int k) {\r\n            build_dlx();\r\n            return dfs(0, k);\r\n            for (int i = 1; i <= k; ++i) {\r\n                if (dfs(0, i)) {\r\n                    return true;\r\n                }\r\n            }\r\n            return false;\r\n        }\r\n    private:\r\n        int head;\r\n        int U[mmax], D[mmax], L[mmax], R[mmax], \r\n            CN[mmax], RN[mmax];\r\n        void addUD(const int &a, const int &h) {\r\n            U[a] = h;\r\n            D[a] = D[h];\r\n            U[D[h]] = a;\r\n            D[h] = a;\r\n            CN[a] = h;\r\n        }\r\n        void addLR(const int &a, const int &h) {\r\n            L[a] = h;\r\n            R[a] = R[h];\r\n            L[R[h]] = a;\r\n            R[h] = a;\r\n            RN[a] = h;\r\n        }\r\n        void add(const int &k, const int &r, const int &c) {\r\n            addUD(k, c);\r\n            addLR(k, r);\r\n        }\r\n        void remove(const int &k) {\r\n            for (int j = R[k]; j != k; j = R[j]) {\r\n                for (int i = D[j]; i != j; i = D[i]) {\r\n                    L[R[i]] = L[i];\r\n                    R[L[i]] = R[i];\r\n                }\r\n                D[U[j]] = D[j];\r\n                U[D[j]] = U[j];\r\n            }\r\n        }\r\n        void unremove(const int &k) {\r\n            for (int j = L[k]; j != k; j = L[j]) {\r\n                D[U[j]] = j;\r\n                U[D[j]] = j;\r\n                for (int i = U[j]; i != j; i = U[i]) {\r\n                    L[R[i]] = i;\r\n                    R[L[i]] = i;\r\n                }\r\n            }\r\n        }\r\n        void build_dlx() {\r\n            head = mmax - 1;\r\n            U[head] = D[head] = L[head] = R[head] = head;\r\n            int cnt = 0;\r\n            for (int i = 0; i < m; ++i) {\r\n                U[cnt] = D[cnt] = cnt;\r\n                addLR(cnt++, head);\r\n            }\r\n            for (int i = 0; i < n; ++i) {\r\n                L[cnt] = R[cnt] = cnt;\r\n                addUD(cnt++, head);\r\n            }\r\n            for (int i = 0; i < n; ++i) {\r\n                for (int j = 0; j < m; ++j) {\r\n                    if (adj[i][j]) {\r\n                        addLR(cnt, m + i);\r\n                        addUD(cnt, j);\r\n                        cnt++;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        int h() {\r\n            int hash[maxm] = {};\r\n            int ans = 0;\r\n            for (int c = R[head]; c != head; c = R[c]) {\r\n                if (hash[c] == 0) {\r\n                    hash[c] = 1;\r\n                    ++ans;\r\n                    for (int j = D[c]; j != c; j = D[j]) {\r\n                        for (int i = R[j]; i != j; i = R[i]) {\r\n                            if (CN[i] != head) {\r\n                                hash[CN[i]] = 1;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return ans;\r\n        }\r\n        bool dfs(int k, int lim) {\r\n            if (k + h() > lim) {\r\n                return false;\r\n            }\r\n            if (R[head] == head) {\r\n                return true;\r\n            }\r\n            int c;\r\n            c = R[head];\r\n            L[R[c]] = L[c];\r\n            R[L[c]] = R[c];\r\n            for (int i = D[c]; i != c; i = D[i]) {\r\n                L[R[i]] = L[i];\r\n                R[L[i]] = R[i];\r\n            }\r\n            for (int i = D[c]; i != c; i = D[i]) {\r\n                remove(RN[i]);\r\n                if (dfs(k + 1, lim)) {\r\n                    return true;\r\n                }\r\n                unremove(RN[i]);\r\n            }\r\n            for (int i = U[c]; i != c; i = U[i]) {\r\n                L[R[i]] = i;\r\n                R[L[i]] = i;\r\n            }\r\n            L[R[c]] = c;\r\n            R[L[c]] = c;\r\n            return false;\r\n        }\r\n};\r\nGraph g;\r\n\r\nstruct P {\r\n    int x, y;\r\n    P (int _x, int _y)\r\n        :x(_x), y(_y) {}\r\n    P () {}\r\n    void input() {\r\n        scanf("%d %d", &x, &y);\r\n    }\r\n};\r\nP dt[210];\r\nP base[210];\r\nint n, m, k;\r\nint dist2(P a, P b) {\r\n    return (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);\r\n}\r\nbool ok(int lim) {\r\n    bool f[210] = {};\r\n    int cnt[210];\r\n    for (int i = 0; i < k; ++i) {\r\n        int v = 0;\r\n        memset(cnt, 0, sizeof(cnt));\r\n        for (int i = 0; i < m; ++i) {\r\n            for (int j = 0; j < n; ++j) {\r\n                if (f[j] == 0 && dist2(base[i], dt[j]) <= lim) {\r\n                    ++cnt[i];\r\n                }\r\n            }\r\n            if (v == -1 || cnt[i] > cnt[v]) {\r\n                v = i;\r\n            }\r\n        }\r\n        for (int j = 0; j < n; ++j) {\r\n            if (f[j] == 0 && dist2(base[v], dt[j]) <= lim) {\r\n                f[j] = 1;\r\n            }\r\n        }\r\n    }\r\n    bool ok = true;\r\n    for (int i = 0; i < n; ++i) {\r\n        if (f[i] == 0) {\r\n            ok = false;\r\n            break;\r\n        }\r\n    }\r\n    if (ok) {\r\n        return true;\r\n    }\r\n    g.clear();\r\n    bool flag[210] = {};\r\n    for (int i = 0; i < m; ++i) {\r\n        for (int j = 0; j < n; ++j) {\r\n            if (dist2(base[i], dt[j]) <= lim) {\r\n                flag[j] = true;\r\n                g.insert(i, j);\r\n            }\r\n        }\r\n    }\r\n    for (int i = 0; i < n; ++i) {\r\n        if (flag[i] == false) {\r\n            return false;\r\n        }\r\n    }\r\n    return g.ok(k);\r\n}\r\n\r\ndouble solve() {\r\n//    printf("%d %d %d\\n", n, m, k);\r\n    vector<int> hash;\r\n    for (int i = 0; i < n; ++i) {\r\n        for (int j = 0; j < m; ++j) {\r\n            hash.push_back(dist2(dt[i], base[j]));\r\n        }\r\n    }\r\n    sort(hash.begin(), hash.end());\r\n    hash.erase(unique(hash.begin(), hash.end()), hash.end());\r\n    int ans = maxint;\r\n    int s = 0, t = SZ(hash) - 1;\r\n    while (s <= t) {\r\n        int mid = (s + t) / 2;\r\n        if (ok(hash[mid])) {\r\n            get_min(ans, hash[mid]);\r\n            t = mid - 1;\r\n        } else {\r\n            s = mid + 1;\r\n        }\r\n    }\r\n    return sqrt(ans + 0.0);\r\n}\r\n\r\nint main() {\r\n    int ca;\r\n    scanf("%d", &ca);\r\n    while (ca--) {\r\n        scanf("%d %d %d", &n, &m, &k);\r\n        for (int i = 0; i < n; ++i) {\r\n            dt[i].input();\r\n        }\r\n        for (int i = 0; i < m; ++i) {\r\n            base[i].input();\r\n        }\r\n        printf("%.6lf\\n", solve());\r\n    }\r\n    return 0;\r\n}\r\n\r\n', '', 202, 872448, 1, 2, '2010-08-08 03:17:56', '2010-08-08 03:17:56'),
(142, 1, 130, 0, '/**********************************************************************\r\nAuthor: Sherlock\r\nCreated Time:  2008-10-28 16:24:47\r\nFile Name: \r\nDescription: \r\n**********************************************************************/\r\n#include <cstdio>\r\n#include <cstring>\r\n#include <cstdlib>\r\n#include <algorithm>\r\n#include <set>\r\n#include <vector>\r\n\r\nusing namespace std;\r\n\r\nconst int   maxint  =   0x7FFFFFFF;\r\nconst int   maxSize =   10000 + 10;\r\nconst int   maxN    =   50 + 3;\r\nconst int   maxM    =   100;\r\n\r\nint         n, m, len, num, total;\r\nint         fail[maxSize], que[maxSize], edge[maxSize][26], w[maxM], f[maxN][maxSize], pre[maxN][maxSize], str[maxN], ch[maxN][maxSize];\r\nchar        s[maxSize];\r\nbool        hash[maxSize];\r\n\r\nstruct      list_type\r\n{\r\n    char    s[maxN];\r\n}   list[50];\r\n\r\nvector  <int>   g[maxSize];\r\n\r\nbool            cmp(int c, int k, int x, int y)\r\n{\r\n    if (c != ch[k + 1][y])\r\n        return (c < ch[k + 1][y]);\r\n    y = pre[k + 1][y];\r\n    for (int i = k; i > 0; i --)\r\n    {\r\n        if (ch[i][x] != ch[i][y])\r\n            return ch[i][x] < ch[i][y];\r\n        y = pre[i][y];\r\n        x = pre[i][x];\r\n    }\r\n    return false;\r\n}\r\n\r\nvoid            add_node()\r\n{\r\n    g[total].clear();\r\n    for (int i = 0; i < 26; i ++)\r\n        edge[total][i] = -1;\r\n    total ++;\r\n}\r\n\r\nvoid            insert_trie(int now, int k)\r\n{\r\n    if (k == len)\r\n    {\r\n        g[now].push_back(num ++);\r\n        return ; \r\n    }\r\n    if (edge[now][s[k] - ''a''] == -1)\r\n    {\r\n        edge[now][s[k] - ''a''] = total;\r\n        add_node();\r\n    }\r\n    insert_trie(edge[now][s[k] - ''a''], k + 1);\r\n}\r\n\r\nvoid            init()\r\n{\r\n    scanf("%d%d", &n, &m);\r\n    num = total = 0;\r\n    add_node();\r\n    for (int i = 0; i < m; i ++)\r\n    {\r\n        scanf("%s", s);\r\n        len = strlen(s);\r\n        for (int j = 0; j < len / 2; j ++)\r\n            swap(s[j], s[len - 1 - j]);\r\n        insert_trie(0, 0);\r\n    }\r\n    for (int i = 0; i < m; i ++)\r\n        scanf("%d", &w[i]);\r\n}\r\n\r\nvoid            make()\r\n{\r\n    int t = 0;\r\n    for (int i = 0; i < 26; i ++)\r\n        if (edge[0][i] != -1)\r\n        {\r\n            que[t] = edge[0][i];\r\n            fail[que[t]] = 0;\r\n            t ++;\r\n        }\r\n        else\r\n            edge[0][i] = 0;\r\n    \r\n    for (int h = 0; h < t; h ++)\r\n    {\r\n        int now = que[h];\r\n        for (int i = 0; i < 26; i ++)\r\n            if (edge[now][i] != -1)\r\n            {\r\n                int v = edge[now][i];\r\n                int r = fail[now];\r\n                while (edge[r][i] == -1)\r\n                    r = fail[r];\r\n                fail[v] = edge[r][i];\r\n                for (unsigned int j = 0; j < g[fail[v]].size(); j ++)\r\n                    g[v].push_back(g[fail[v]][j]);\r\n                que[t] = v;\r\n                t ++;\r\n            }\r\n    }\r\n}\r\n\r\nstruct      Q_type\r\n{\r\n    int     x, y;\r\n}   Q[maxN * maxSize];\r\n\r\nvoid            solve()\r\n{\r\n    make();\r\n    memset(f, -1, sizeof(f));\r\n    Q[0].x = 0;\r\n    Q[0].y = 0;\r\n    f[0][0] = 0;\r\n    for (int h = 0, t = 1; h < t; h ++)\r\n    {\r\n        int k = Q[h].x;\r\n        int now = Q[h].y;\r\n        for (int i = 0; i < 26; i ++)\r\n        {\r\n            int next = now;\r\n            while (edge[next][i] == -1)\r\n                next = fail[next];\r\n            next = edge[next][i];\r\n            if (next == 0 && g[now].size() == 0)\r\n                continue;\r\n            if (f[k + 1][next] == -1 && k + 1 < n)\r\n            {\r\n                Q[t].x = k + 1;\r\n                Q[t].y = next;\r\n                t ++;\r\n            }\r\n            int c = 0;\r\n            for (unsigned int x = 0; x < g[next].size(); x ++)\r\n                c += w[g[next][x]];\r\n            if (f[k + 1][next] < f[k][now] + c || f[k + 1][next] == f[k][now] + c && cmp(i, k, now, next))\r\n            {\r\n                f[k + 1][next] = f[k][now] + c;\r\n                pre[k + 1][next] = now;\r\n                ch[k + 1][next] = i;\r\n            }\r\n        }\r\n    }\r\n\r\n    int ans = -1, now = 0, l = 0;\r\n    for (int j = 1; j <= n; j ++)\r\n        for (int i = 1; i < total; i ++)\r\n            if (g[i].size() > 0)\r\n                if (f[j][i] > ans || f[j][i] == ans && j == l && cmp(ch[j][i], j - 1, pre[j][i], now))\r\n                {\r\n                    ans = f[j][i];\r\n                    now = i;\r\n                    l = j;\r\n                }\r\n    \r\n    for (int i = l; i > 0; i --)\r\n    {\r\n        str[i] = ch[i][now];\r\n        now = pre[i][now];\r\n    }\r\n    for (int i = l; i > 0; i --)    \r\n        printf("%c", ''a'' + str[i]);\r\n    printf("\\n");\r\n}\r\n\r\nint             main()\r\n{\r\n    int test_num;\r\n    scanf("%d", &test_num);\r\n    while (test_num > 0)\r\n    {\r\n        test_num --;\r\n        init();\r\n        solve();\r\n    } \r\n    return 0;\r\n}\r\n\r\n', '', 108, 12300288, 1, 2, '2010-08-08 03:20:35', '2010-08-08 03:20:35'),
(143, 1, 131, 0, '/*\r\n * Author: momodi(gaoyunxiang.cpp@gmail.com)\r\n * Created Time:  2009/3/24 12:11:47\r\n * File Name: run.cpp\r\n * Description: \r\n */\r\n#include <cstdio>\r\n#include <cstring>\r\n#include <cmath>\r\n#include <vector>\r\n#include <cstdlib>\r\n#include <algorithm>\r\nusing namespace std;\r\n#define out(x) fprintf(stderr, "%s: %I64d\\n", #x, (long long)(x))\r\n#define SZ(v) ((int)(v).size())\r\nconst int maxint=-1u>>1;\r\ntemplate <class T> bool get_max(T& a, const T &b) {return b > a? a = b, 1: 0;}\r\ntemplate <class T> bool get_min(T& a, const T &b) {return b < a? a = b, 1: 0;}\r\nconst double eps = 1e-9;\r\nint sgn(const double &a) {\r\n    return (a > eps) - (a < -eps);\r\n}\r\nint n;\r\nconst int maxn = 50001;\r\n\r\nstruct P {\r\n    double a, b;\r\n    P (const double &_a, const double &_b)\r\n        :a(_a), b(_b) {}\r\n    P () {}\r\n    bool operator < (const P &i) const {\r\n        return sgn(a - i.a) > 0;\r\n    }\r\n    bool operator == (const P &x) const {\r\n        return sgn(a - x.a) == 0;\r\n    }\r\n};\r\n\r\ndouble crossy(const P &x, const P &y) {\r\n    return x.a * (y.b - x.b) / (x.a - y.a) + x.b;\r\n}\r\ndouble crossx(const P &x, const P &y) {\r\n    return (y.b - x.b) / (x.a - y.a);\r\n}\r\n\r\nP p[maxn];\r\nP sta[maxn];\r\ndouble Y[maxn];\r\nint solve() {\r\n    sort(p, p + n);\r\n//    printf("%d %d\\n", unique(p, p + n) - p, n);\r\n    if (unique(p, p + n) - p != n) {\r\n        printf("Data Error\\n");\r\n        while (1);\r\n    }\r\n    int len = 0;\r\n    int y_len = 0;\r\n    for (int i = 0; i < n; ++i) {\r\n        if (len == 0) {\r\n            sta[len++] = p[i];\r\n        } else if (len == 1) {\r\n            sta[len++] = p[i];\r\n            Y[y_len++] = crossy(sta[0], sta[1]);\r\n        } else {\r\n            double yy = crossy(sta[len - 1], p[i]);\r\n            if (sgn(yy - Y[y_len - 1]) < 0) {\r\n                Y[y_len++] = yy;\r\n                sta[len++] = p[i];\r\n            } else {\r\n                --i;\r\n                --len;\r\n                --y_len;\r\n            }\r\n        }\r\n    }\r\n    while (len >= 2) {\r\n        double xx = crossx(sta[len - 1], sta[len - 2]);\r\n        if (sgn(xx) <= 0) {\r\n            --len;\r\n        } else {\r\n            break;\r\n        }\r\n    }\r\n    return len;\r\n}\r\n\r\n\r\nint main() {\r\n    int ca;\r\n    scanf("%d", &ca);\r\n    while (ca--) {\r\n        scanf("%d", &n);\r\n        for (int i = 0; i < n; ++i) {\r\n            double a, b;\r\n            scanf("%lf %lf", &b, &a);\r\n            p[i] = P(a, b);\r\n        }\r\n        printf("%d\\n", solve());\r\n    }\r\n    return 0;\r\n}\r\n\r\n', '', 499, 2256896, 1, 2, '2010-08-08 03:23:02', '2010-08-08 03:23:02'),
(144, 1, 132, 0, '/**********************************************************************\r\nAuthor: WHU_dzs\r\nCreated Time:  2009-2-15 15:19:13\r\nFile Name: pro3.cpp\r\nDescription: \r\n**********************************************************************/\r\n#include <iostream>\r\n#include <cmath>\r\n#include <cstdio>\r\n\r\nusing namespace std;\r\n\r\ndouble x, y, v;\r\n\r\nconst double g = 9.8;\r\nconst double eps = 1E-9;\r\nconst double pi = acos(-1.0);\r\n\r\ndouble calc (double theta) {\r\n	return x * tan(theta) - (g * x * x) / (2 * v * v * cos(theta) * cos(theta));\r\n}\r\n\r\nint main () {\r\n    int ca;\r\n    scanf("%d", &ca);\r\n    while (ca--) {\r\n	    scanf ("%lf %lf %lf", &x, &y, &v);\r\n		double low = 0.0, high = pi / 2;\r\n		while (high - low > eps) {\r\n			double mid0 = low  + (high - low) / 3;\r\n			double mid1 = high - (high - low) / 3;\r\n			if (calc(mid0) > calc(mid1))\r\n				high = mid1;\r\n			else\r\n				low  = mid0;\r\n		}\r\n		double max_theta = low;\r\n		double max_y = calc(max_theta);\r\n		if (max_y < y)\r\n			printf ("-1\\n");\r\n		else if (fabs(max_y - y) < eps)\r\n			printf ("%.6lf\\n", max_theta);\r\n		else {\r\n			low = 0.0, high = max_theta;\r\n			while (high - low > eps) {\r\n				double mid = (high + low) / 2;\r\n				if (calc(mid) > y)\r\n					high = mid;\r\n				else\r\n					low = mid;\r\n			}\r\n            double ans1 = low;\r\n			low = max_theta, high = pi / 2;\r\n			while (high - low > eps) {\r\n				double mid = (high + low) / 2;\r\n				if (calc(mid) < y)\r\n					high = mid;\r\n				else\r\n					low = mid;\r\n			}\r\n            double ans2 = low;\r\n			printf ("%.6lf\\n", min(ans1, ans2));\r\n		}\r\n	}\r\n	return 0;\r\n}\r\n\r\n', '', 15, 364544, 1, 2, '2010-08-08 03:24:49', '2010-08-08 03:25:08'),
(145, 5, 2, 0, '#include<stdio.h>\r\nmain()\r\n{\r\n  int n,x,a,b;\r\n  while(scanf("%d/%d",&a,&b)==2&&(a||b))\r\n  {\r\n         if (a<=6)\r\n         {n=10;\r\n          printf("%d\\n",n);\r\n         }\r\n         else if(a>=9)\r\n         {n=0;\r\n         printf("%d\\n",n);\r\n         } \r\n         else \r\n       {\r\n        if (a==7)\r\n          x=b;\r\n        else if (a==8)\r\n          x=b+31;\r\n        for(n=10;n>=0;n--)\r\n          if ((n*n+n)/2<=x)\r\n            {\r\n             printf("%d\\n",n);\r\n             break;\r\n            }             \r\n        }  \r\n      \r\n  } \r\n  return 0;\r\n}\r\n     ', '', 0, 258048, 4, 1, '2010-08-08 17:52:29', '2010-08-09 06:40:08'),
(146, 1, 133, 0, '/*\r\n   ACM North Central Region, 1993-94\r\n   Problem A, Factorial Frequencies\r\n\r\n   Ed Karrels, March 1996\r\n*/\r\n\r\n#include <stdio.h>\r\n\r\nint main() {\r\n   int digits[1000];\r\n   int digit_counts[10] = {0};\r\n   int n_digits, digit_no;\r\n   int i, j;\r\n   int n, overflow, prod;\r\n\r\n   \r\n   scanf("%d", &n);\r\n\r\n   while (n) {\r\n      digits[0] = 1;\r\n      n_digits = 1;\r\n      \r\n      for (i=2; i<=n; i++) {\r\n	 overflow = 0;\r\n	 for (j=0; j<n_digits || overflow; j++) {\r\n	    if (j<n_digits) {\r\n	       digits[j] = digits[j] * i + overflow;\r\n	    } else {\r\n	       digits[j] = overflow;\r\n	    }\r\n	    overflow = digits[j] / 10;\r\n	    digits[j] = digits[j] % 10;\r\n	 }\r\n	 n_digits = j;\r\n	 \r\n      }\r\n\r\n      printf("%d! --\\n", n);\r\n      for (i=0; i<n_digits; i++) {\r\n	 digit_counts[digits[i]]++;\r\n      }\r\n      for (i=0; i<10; i++) {\r\n	 printf("   (%d)%5d", i, digit_counts[i]);\r\n	 digit_counts[i] = 0;\r\n	 if (i==4 || i==9) printf("\\n");\r\n	 else printf(" "); \r\n      }\r\n\r\n/*\r\n   Just as a check, print the actual number\r\n   for (j=n_digits-1; j>=0; j--) {\r\n      putchar(''0''+digits[j]);\r\n   } putchar(''\\n'');\r\n*/\r\n\r\n\r\n\r\n      scanf("%d", &n);\r\n\r\n   }\r\n\r\n   return 0;\r\n}\r\n', '', 0, 258048, 1, 1, '2010-08-09 08:22:55', '2010-08-09 08:45:56'),
(147, 1, 134, 0, '/*\r\n   ACM North Central Region, 1993-94\r\n   Problem B, Identifying Legal Pascal Real constants\r\n\r\n   Ed Karrels, March 1996\r\n*/\r\n\r\n#include <stdio.h>\r\n\r\nint ReadThrough(char *match, int echo, char *dest) {\r\n   int c, num;\r\n\r\n   num = 0;\r\n   while (1) {\r\n      c = getchar();\r\n      if (!strchr(match, c)) {\r\n	 ungetc(c, stdin);\r\n	 if (dest) *dest = 0;\r\n	 return num;\r\n      }\r\n      if (echo) putchar(c);\r\n      if (dest) *dest++ = c;\r\n      num++;\r\n   }\r\n}\r\n\r\nint IsGood() {\r\n   int hasdec=0, hasexp=0;\r\n   int n;\r\n   char temp[1000];\r\n\r\n   ReadThrough(" \\t", 0, 0);\r\n   if (ReadThrough("*", 0,0)) return -1;\r\n   if (ReadThrough("-+",1,0) > 1) return 0;\r\n   if (ReadThrough("0123456789",1,0) == 0) return 0;\r\n\r\n   n = ReadThrough(".",1,0);\r\n   if (n>1) return 0;\r\n   if (n) {\r\n      hasdec = 1;\r\n      if (ReadThrough("0123456789",1,0) == 0) return 0;\r\n   }\r\n   n = ReadThrough("eE",1,0);\r\n   if (n>1) return 0;\r\n   if (n) {\r\n      hasexp = 1;\r\n      if (ReadThrough("+-",1,0)>1) return 0;\r\n      if (ReadThrough("0123456789",1,0) == 0) return 0;\r\n   }\r\n   ReadThrough(" \\t", 0, temp);\r\n   n = getchar();\r\n   ungetc(n, stdin);\r\n   if (n != ''\\n'') {\r\n      printf("%s", temp);\r\n      return 0;\r\n   }\r\n\r\n   if (!hasexp && !hasdec) return 0;\r\n\r\n   return 1;\r\n}\r\n\r\nvoid FinishLine() {\r\n   int c;\r\n   c = getchar();\r\n   while (c != ''\\n'') {\r\n      putchar(c);\r\n      c = getchar();\r\n   }\r\n}\r\n\r\nint main() {\r\n   int isgood;\r\n\r\n   while (-1 != (isgood = IsGood())) {\r\n      if (isgood) {\r\n	 FinishLine();\r\n	 printf(" is legal.\\n");\r\n      } else {\r\n	 FinishLine();\r\n	 printf(" is illegal.\\n");\r\n      }\r\n   }\r\n   \r\n   return 0;\r\n}\r\n\r\n\r\n', '', 0, 258048, 1, 1, '2010-08-09 08:47:54', '2010-08-09 08:58:30'),
(148, 1, 135, 0, '/*\r\n   ACM North Central Region, 1993-94\r\n   Problem C, Extrapolation Using a Difference Table\r\n\r\n   Ed Karrels, April 1996\r\n*/\r\n\r\n#include <stdio.h>\r\n\r\nint main() {\r\n   int n, i, j, k;\r\n   short a[10];     /* They apparently wrote and tested the solution\r\n		       for this problem on a 16-bit machine.  The given\r\n		       solution for the fourth sample is incorrect.\r\n		       The correct answer is -319268, but with 16 bit\r\n		       ints, it comes out 8412. */\r\n\r\n   scanf("%d", &n);\r\n   while (n) {\r\n      for (i=0; i<n; i++)\r\n	 scanf("%hd", a+i);\r\n      scanf("%d", &k);\r\n      for (j=n-1; j>0; j--)\r\n	 for (i=0; i<j; i++)\r\n	    a[i] = a[i+1] - a[i];\r\n      for (i=0; i<k; i++)\r\n	 for (j=1; j<n; j++)\r\n	    a[j] += a[j-1];\r\n      printf("Term %d of the sequence is %hd\\n", n+k, a[n-1]);\r\n      scanf("%d", &n);\r\n   }\r\n   return 0;\r\n}\r\n', '', 15, 258048, 1, 1, '2010-08-09 09:04:25', '2010-08-09 09:04:25'),
(149, 1, 136, 0, '/*\r\n   ACM North Central Region, 1993-94\r\n   Problem D, Evaluating Simple C Expressions\r\n\r\n   Ed Karrels, April 1996\r\n*/\r\n\r\n#include <stdio.h>\r\n#include <ctype.h>\r\n\r\nint Token (char s[], int *i) {\r\n   while (isspace(s[*i])) ++*i;\r\n   if (!s[*i]) return 0;\r\n   if (s[*i] == ''+'') {\r\n      if (s[*i+1] == ''+'') {\r\n	 *i += 2;\r\n	 return ''*'';\r\n      } else {\r\n	 ++*i;\r\n	 return ''+'';\r\n      }\r\n   }\r\n   \r\n   if (s[*i] == ''-'') {\r\n      if (s[*i+1] == ''-'') {\r\n	 *i += 2;\r\n	 return ''/'';\r\n      } else {\r\n	 ++*i;\r\n	 return ''-'';\r\n      }\r\n   }\r\n   \r\n   return s[(*i)++];\r\n}\r\n\r\n#define NT nt = Token(L, &p)\r\n\r\nint main() {\r\n   int v[26], i, p, pre, post[26], f=1, sum, vn, used[26];\r\n   char L[202], nt;\r\n\r\n   while (gets(L)&& strlen(L)>0) {\r\n      printf("Expression: %s\\n", L);\r\n      for (i=0; i<26; i++) {\r\n	 v[i] = i+1;\r\n	 used[i] = 0;\r\n	 post[i] = 0;\r\n      }\r\n      f = 1;\r\n      p = sum = 0;\r\n      NT;\r\n      while (1) {\r\n	 pre = 0;\r\n	 if (nt==''*'') {pre++; NT;}\r\n	 if (nt==''/'') {pre--; NT;}\r\n	 if (!isalpha(nt)) {printf("no var name\\n"); exit(1);}\r\n	 vn = nt - ''a''; v[vn] += pre; used[vn] = 1;\r\n	 sum += f*v[vn];\r\n	 NT;\r\n	 if (nt == ''*'') {post[vn]++; NT;}\r\n	 if (nt == ''/'') {post[vn]--; NT;}\r\n	 if (nt==0) break;\r\n	 f = (nt==''+'') ? 1 : -1;\r\n	 NT;\r\n      }\r\n      printf("    value = %d\\n", sum);\r\n      for (i=0; i<26; i++) \r\n	 if (used[i])\r\n	    printf("    %c = %d\\n", ''a''+i, v[i]+post[i]);\r\n   }\r\n\r\n   return 0;\r\n}      \r\n', '', 0, 262144, 1, 1, '2010-08-09 09:07:50', '2010-08-18 07:48:44'),
(150, 1, 137, 0, '/*\r\n   ACM North Central Region, 1993-94\r\n   Problem E, The Finite State Text-Processing Machine\r\n\r\n   Ed Karrels, April 1996\r\n*/\r\n\r\n#include <stdio.h>\r\n\r\ntypedef struct {\r\n   signed char *in_set, *out_str;\r\n   char st_nm[9];\r\n} Trans;\r\n\r\ntypedef struct {\r\n   char name[9];\r\n   int n_tr;\r\n   Trans *tr;\r\n} State;\r\n\r\nsigned char *CvtStr(char *str) {\r\n   char *outs, *r, *w;\r\n\r\n   outs = (char*)malloc(strlen(str)+1);\r\n\r\n   r = str;\r\n   w = outs;\r\n   while (*r) {\r\n      if (*r == ''\\\\'') {\r\n	 r++;\r\n	 switch (*r) {\r\n	    case ''b'': *w++ = '' ''; break;\r\n	    case ''n'': *w++ = ''\\n''; break;\r\n	    case ''\\\\'': *w++ = ''\\\\''; break;\r\n	    case ''0'': *w++ = 0; break;\r\n	    case ''c'': *w++ = -1;\r\n	 }\r\n	 r++;\r\n      } else {\r\n	 *w++ = *r++;\r\n      }\r\n   }\r\n   *w = 0;\r\n   return outs;\r\n}\r\n\r\n\r\nint FindSt(State *st, int n_st, char *st_nm) {\r\n   int i;\r\n   for (i=0; i<n_st; i++)\r\n      if (!strcmp(st_nm, st[i].name)) return i;\r\n\r\n   fprintf(stderr, "no state %s\\n", st_nm);\r\n   return 0;\r\n}\r\n\r\n	 \r\n\r\nint main() {\r\n   int n_st, i, j;\r\n   State *st;\r\n   char buf[1000], c, *w;\r\n   int cur_st, catch_all, tr_no, mch_no = 1;\r\n\r\n   scanf("%d", &n_st);\r\n   while (n_st) {\r\n      printf("Finite State Machine %d:\\n", mch_no++);\r\n      n_st++;\r\n      st = (State*)malloc(sizeof(State) * n_st);\r\n      strcpy(st[0].name, "END");\r\n      for (i=1; i<n_st; i++) {\r\n	 scanf("%s %d", st[i].name, &st[i].n_tr);\r\n	 st[i].tr = (Trans*)malloc(sizeof(Trans) * st[i].n_tr);\r\n\r\n	 for (j=0; j<st[i].n_tr; j++) {\r\n	    char b2[100], c2;\r\n	    scanf("%s", buf);\r\n	    st[i].tr[j].in_set = CvtStr(buf);\r\n	    scanf("%s", st[i].tr[j].st_nm);\r\n	    scanf("%s", buf);\r\n	    st[i].tr[j].out_str = CvtStr(buf);\r\n	 }\r\n      }\r\n\r\n/*\r\n      for (i=1; i<n_st; i++) {\r\n	 printf("State %d, ''%s''\\n", i, st[i].name);\r\n	 for (j=0; j<st[i].n_tr; j++) {\r\n	    printf("  %-20s %-9s %-20s\\n", st[i].tr[j].in_set,\r\n		   st[i].tr[j].st_nm, st[i].tr[j].out_str);\r\n	 }\r\n      }\r\n*/\r\n\r\n      scanf("%*[^\\n]"); getchar();\r\n\r\n      cur_st = FindSt(st, n_st, "START");\r\n      while (cur_st != 0) {\r\n	 c = getchar();\r\n/*\r\nprintf("read ''%c''\\n", c);\r\n*/\r\n	 catch_all = tr_no = -1;\r\n	 for (i=0; i<st[cur_st].n_tr; i++) {\r\n	    if (strchr(st[cur_st].tr[i].in_set, c)) {\r\n	       tr_no = i;\r\n	       break;\r\n	    } else if (strchr(st[cur_st].tr[i].in_set, -1)) {\r\n	       catch_all = i;\r\n	    }\r\n	 }\r\n	 if (tr_no == -1) tr_no = catch_all;\r\n\r\n/*\r\nprintf("  trans %d\\n", tr_no);\r\n*/\r\n\r\n	 if (tr_no != -1) {\r\n	    for (w=st[cur_st].tr[tr_no].out_str; *w; w++) {\r\n	       if (*w == -1) {\r\n		  putchar(c);\r\n	       } else {\r\n		  putchar(*w);\r\n	       }\r\n	    }\r\n	    cur_st = FindSt(st, n_st, st[cur_st].tr[tr_no].st_nm);\r\n/*\r\nprintf("  goto state %d\\n", cur_st);\r\n*/\r\n	 }\r\n      }\r\n	 \r\n      for (i=1; i<n_st; i++) {\r\n	 for (j=0; j<st[i].n_tr; j++) {\r\n	    free(st[i].tr[j].in_set);\r\n	    free(st[i].tr[j].out_str);\r\n	 }\r\n	 free(st[i].tr);\r\n      }\r\n      scanf("%d", &n_st);\r\n   }\r\n\r\n   return 0;\r\n}\r\n', '', 0, 368640, 1, 1, '2010-08-09 09:19:20', '2010-08-09 09:20:24'),
(151, 1, 138, 0, '/*\r\n   ACM North Central Region, 1993-94\r\n   Problem F, PostScript Emulation\r\n\r\n   Ed Karrels, March 1996\r\n*/\r\n\r\n#include <stdio.h>\r\n#include <math.h>\r\n\r\ntypedef float matrix[3][3];\r\n\r\nchar *cmds[7] = {"rotate", "translate", "scale", "moveto",\r\n		 "rmoveto", "lineto", "rlineto"};\r\n\r\nint ReadMove(float *x, float *y) {\r\n   char cmd[20];\r\n   int i;\r\n   \r\n   scanf("%f %f", x, y);\r\n   scanf("%s", cmd);\r\n   for (i=0; i<7; i++) {\r\n      if (!strcmp(cmd, cmds[i])) return i+1;\r\n   }\r\n   return 0;\r\n}\r\n\r\nvoid Xlate(float *x, float *y, matrix m) {\r\n   float nx, ny;\r\n\r\n   nx = m[0][0] * *x + m[0][1] * *y + m[0][2];\r\n   ny = m[1][0] * *x + m[1][1] * *y + m[1][2];\r\n\r\n   *x = nx;\r\n   *y = ny;\r\n}\r\n\r\n\r\nvoid PrintMatrix(matrix a) {\r\n   int i, j;\r\n\r\n   for (i=0; i<3; i++) {\r\n      for (j=0; j<3; j++) {\r\n	 printf("%7.2f", a[i][j]);\r\n      } putchar(''\\n'');\r\n   }\r\n   putchar(''\\n'');\r\n}\r\n\r\n\r\n/*\r\n   b <- a * b\r\n*/\r\nvoid MatrixMult(matrix a, matrix b) {\r\n   matrix c;\r\n   int i, j, k;\r\n\r\n   for (i=0; i<3; i++)\r\n      for (j=0; j<3; j++) {\r\n	 c[i][j] = 0;\r\n	 for (k=0; k<3; k++)\r\n	    c[i][j] += a[i][k] * b[k][j];\r\n      }\r\n   for (i=0; i<3; i++)\r\n      for (j=0; j<3; j++)\r\n	 a[i][j] = c[i][j];\r\n}\r\n\r\n\r\nvoid IdentMatrix(matrix a) {\r\n   int i, j;\r\n   for (i=0; i<3; i++)\r\n      for (j=0; j<3; j++)\r\n	 a[i][j] = 0;\r\n   for (i=0; i<3; i++)\r\n      a[i][i] = 1;\r\n}\r\n	    \r\n   \r\n\r\nint main() {\r\n   int movetype;\r\n   float x, y, cur_x=0, cur_y=0, tx, ty;\r\n   matrix xform_matrix, mx;\r\n   \r\n   IdentMatrix(xform_matrix);\r\n\r\n   while (movetype = ReadMove(&x, &y)) {\r\n      if (movetype < 4) {\r\n	 IdentMatrix(mx);\r\n	 switch (movetype) {\r\n	  case 1:\r\n	    x *= 3.141592653 / 180.0;\r\n	    tx    = cur_x * cos(-x) - cur_y * sin(-x);\r\n	    cur_y = cur_x * sin(-x) + cur_y * cos(-x);\r\n	    cur_x = tx;\r\n	    mx[0][0] = cos(x); mx[0][1] = -sin(x);\r\n	    mx[1][0] = sin(x); mx[1][1] =  cos(x);\r\n	    break;\r\n	  case 2:\r\n	    cur_x -= x;\r\n	    cur_y -= y;\r\n	    mx[0][2] = x;\r\n	    mx[1][2] = y;\r\n	    break;\r\n	  case 3:\r\n	    cur_x /= x;\r\n	    cur_y /= y;\r\n	    mx[0][0] = x;\r\n	    mx[1][1] = y;\r\n	    break;\r\n	 }\r\n	 MatrixMult(xform_matrix, mx);\r\n\r\n      } else {\r\n	 \r\n	 switch (movetype) {\r\n	  case 4:\r\n	    cur_x = x;\r\n	    cur_y = y;\r\n	    Xlate(&x, &y, xform_matrix);\r\n	    printf("%g %g moveto\\n", x, y);\r\n	    break;\r\n	  case 5:\r\n	    tx = cur_x; ty = cur_y;\r\n	    cur_x += x; x = cur_x;\r\n	    cur_y += y; y = cur_y;\r\n	    Xlate(&x, &y, xform_matrix);\r\n	    Xlate(&tx, &ty, xform_matrix);\r\n	    printf("%g %g rmoveto\\n", x-tx, y-ty);\r\n	    break;\r\n	  case 6:\r\n	    cur_x = x;\r\n	    cur_y = y;\r\n	    Xlate(&x, &y, xform_matrix);\r\n	    printf("%g %g lineto\\n", x, y);\r\n	    break;\r\n	  case 7:\r\n	    tx = cur_x; ty = cur_y;\r\n	    cur_x += x; x = cur_x;\r\n	    cur_y += y; y = cur_y;\r\n	    Xlate(&x, &y, xform_matrix);\r\n	    Xlate(&tx, &ty, xform_matrix);\r\n	    printf("%g %g rlineto\\n", x-tx, y-ty);\r\n	    break;\r\n	 }\r\n      }\r\n   }\r\n\r\n   return 0;\r\n}\r\n\r\n	    \r\n      \r\n\r\n\r\n', '', 0, 262144, 1, 1, '2010-08-09 09:25:57', '2010-08-09 10:19:12'),
(152, 1, 138, 0, '/*\r\n   ACM North Central Region, 1993-94\r\n   Problem F, PostScript Emulation\r\n\r\n   Ed Karrels, March 1996\r\n*/\r\n\r\n#include <stdio.h>\r\n#include <math.h>\r\n\r\ntypedef struct Trans {\r\n   int type;\r\n   float x, y;\r\n   struct Trans *next;\r\n} Trans;\r\n\r\nchar cmds[7][10] = {"rotate", "translate", "scale", "moveto",\r\n		    "rmoveto", "lineto", "rlineto"};\r\n\r\nint ReadMove(float *x, float *y) {\r\n   char cmd[20];\r\n   int i;\r\n   \r\n   scanf("%f %f", x, y);\r\n   scanf("%s", cmd);\r\n   for (i=0; i<7; i++) {\r\n      if (!strcmp(cmd, cmds[i])) return i+1;\r\n   }\r\n   return 0;\r\n}\r\n\r\nvoid Xlate(float *x, float *y, Trans *tr) {\r\n   float tx, ty;\r\n\r\n   /* printf("Tr %.2f %.2f\\n", *x, *y); */\r\n   while (tr) {\r\n      switch (tr->type) {\r\n       case 1:\r\n	 tx = *x * cos(tr->x) - *y * sin(tr->x);\r\n	 *y = *x * sin(tr->x) + *y * cos(tr->x);\r\n	 *x = tx;\r\n	 break;\r\n       case 2:\r\n	 *x += tr->x;\r\n	 *y += tr->y;\r\n	 break;\r\n       case 3:\r\n	 *x *= tr->x;\r\n	 *y *= tr->y;\r\n	 break;\r\n      }\r\n      /* printf("-> %.2f %.2f\\n", *x, *y); */\r\n      tr = tr->next;\r\n   }\r\n}\r\n\r\n\r\nint main() {\r\n   Trans *head_t = 0, *tail_t, *tr;\r\n   int movetype;\r\n   float x, y, cur_x, cur_y, tx, ty;\r\n   \r\n   while (movetype = ReadMove(&x, &y)) {\r\n      if (movetype < 4) {\r\n	 tr = (Trans*)malloc(sizeof(Trans));\r\n	 tr->type = movetype;\r\n	 tr->x = x;\r\n	 tr->y = y;\r\n	 tr->next = 0;\r\n	 if (!head_t) {\r\n	    head_t = tail_t = tr;\r\n	 } else {\r\n	    tr->next = head_t;\r\n	    head_t = tr;\r\n	 }\r\n\r\n	 switch (tr->type) {\r\n	  case 1:\r\n	    tr->x *= 3.141592653 / 180.0;\r\n	    tx    = cur_x * cos(-tr->x) - cur_y * sin(-tr->x);\r\n	    cur_y = cur_x * sin(-tr->x) + cur_y * cos(-tr->x);\r\n	    cur_x = tx;\r\n	    break;\r\n	  case 2:\r\n	    cur_x -= tr->x;\r\n	    cur_y -= tr->y;\r\n	    break;\r\n	  case 3:\r\n	    cur_x /= tr->x;\r\n	    cur_y /= tr->y;\r\n	    break;\r\n	 }\r\n\r\n      } else {\r\n	 \r\n	 switch (movetype) {\r\n	  case 4:\r\n	    cur_x = x;\r\n	    cur_y = y;\r\n	    Xlate(&x, &y, head_t);\r\n	    printf("%g %g moveto\\n", x, y);\r\n	    break;\r\n	  case 5:\r\n	    tx = cur_x; ty = cur_y;\r\n	    cur_x += x; x = cur_x;\r\n	    cur_y += y; y = cur_y;\r\n	    Xlate(&x, &y, head_t);\r\n	    Xlate(&tx, &ty, head_t);\r\n	    printf("%g %g rmoveto\\n", x-tx, y-ty);\r\n	    break;\r\n	  case 6:\r\n	    cur_x = x;\r\n	    cur_y = y;\r\n	    Xlate(&x, &y, head_t);\r\n	    printf("%g %g lineto\\n", x, y);\r\n	    break;\r\n	  case 7:\r\n	    tx = cur_x; ty = cur_y;\r\n	    cur_x += x; x = cur_x;\r\n	    cur_y += y; y = cur_y;\r\n	    Xlate(&x, &y, head_t);\r\n	    Xlate(&tx, &ty, head_t);\r\n	    printf("%g %g rlineto\\n", x-tx, y-ty);\r\n	    break;\r\n	 }\r\n      }\r\n   }\r\n\r\n   return 0;\r\n}\r\n', '', 0, 262144, 1, 1, '2010-08-09 10:19:41', '2010-08-09 10:19:41'),
(154, 1, 140, 0, '/* University of Ulm Programming Contest 1996\r\n   Problem B      : Babylon\r\n   Implementation : Mark Dettinger */\r\n\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\n#define max(a,b) ((a)>(b)?(a):(b))\r\n\r\ntypedef struct {int x; int y; int z;} block;\r\n\r\nblock b[1200];  /* array to store the dimensions of the blocks */\r\nint h[1200];    /* h[i] = height of the tallest tower with block i on top */\r\n\r\nint blockcmp (const void* a, const void* b)  /* comparison function for block sort */\r\n{\r\n  return ((block*)b)->x - ((block*)a)->x;\r\n}\r\n\r\nmain()\r\n{\r\n  FILE* input = stdin;\r\n  int i,j,n,x,y,z,height;\r\n  int set = 0;            /* number of completed test cases */\r\n\r\n  while (1)\r\n    {\r\n      /* 1. Read Input */\r\n\r\n      fscanf(input,"%d",&n);\r\n      if (n==0) break;\r\n      for (i=0; i<n; i++)\r\n	{\r\n	  fscanf(input,"%d %d %d",&x,&y,&z);\r\n	  b[6*i].x   = x; b[6*i].y   = y; b[6*i].z   = z;\r\n	  b[6*i+1].x = x; b[6*i+1].y = z; b[6*i+1].z = y;\r\n	  b[6*i+2].x = y; b[6*i+2].y = x; b[6*i+2].z = z;\r\n	  b[6*i+3].x = y; b[6*i+3].y = z; b[6*i+3].z = x;\r\n	  b[6*i+4].x = z; b[6*i+4].y = x; b[6*i+4].z = y;\r\n	  b[6*i+5].x = z; b[6*i+5].y = y; b[6*i+5].z = x;\r\n	}\r\n\r\n      /* 2. Sort blocks by descending width */\r\n\r\n      qsort(b,6*n,sizeof(block),blockcmp);\r\n      \r\n      /* 3. Successively compute h[0], h[1], h[2],..., h[6*n-1] */\r\n\r\n      h[0] = b[0].z;\r\n      for (i=1; i<6*n; i++)\r\n	{\r\n	  height = 0;\r\n	  for (j=0; j<i; j++)\r\n	    if (b[j].x>b[i].x && b[j].y>b[i].y && h[j]>height)\r\n	      height = h[j];\r\n	  h[i] = height+b[i].z;\r\n	}\r\n\r\n      /* 4. Now the desired result is the maximum value in array h */\r\n\r\n      height = h[0];\r\n      for (i=1; i<6*n; i++) \r\n	height = max(height,h[i]);\r\n      printf("Case %d: maximum height = %d\\n",++set,height);\r\n    }\r\n  fclose(input);\r\n  return 0;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n', '', 0, 278528, 1, 1, '2010-08-10 08:36:41', '2010-08-10 08:37:09'),
(153, 1, 139, 0, '/*\r\n   ACM North Central Region, 1993-94\r\n   Problem G, Inventory Maintenance\r\n\r\n   Ed Karrels, March 1996\r\n*/\r\n\r\n#include <stdio.h>\r\n#include <string.h>\r\n#include <stdlib.h>\r\n\r\ntypedef struct {\r\n   char name[11];\r\n   int on_hand;\r\n   float buy, sell;\r\n} Ware;\r\n\r\nint Read(char **name, int *i1, float *f1, float *f2) {\r\n   static char str[20];\r\n\r\n   *name = str;\r\n   scanf("%s", str);\r\n   if (!strcmp(str, "report")) return 5;\r\n   if (!strcmp(str, "new")) {\r\n      scanf("%s %f %f", str, f1, f2);\r\n      return 1;\r\n   } else if (!strcmp(str, "delete")) {\r\n      scanf("%s", str);\r\n      return 2;\r\n   } else if (!strcmp(str, "buy")) {\r\n      scanf("%s %d", str, i1);\r\n      return 3;\r\n   } else if (!strcmp(str, "sell")) {\r\n      scanf("%s %d", str, i1);\r\n      return 4;\r\n   } else {\r\n      return 0;\r\n   }\r\n}   \r\n\r\nint Cmp(const void *av, const void *bv) {\r\n   Ware *a = (Ware*)av;\r\n   Ware *b = (Ware*)bv;\r\n   return strcmp(a->name, b->name);\r\n}\r\n\r\nint Lookup(Ware w[], int nw, char *name) {\r\n   int i;\r\n   for (i=0; i<nw; i++)\r\n      if (!strcmp(w[i].name, name))\r\n	 return i;\r\n\r\n   return 0;\r\n}\r\n\r\nint main() {\r\n   Ware w[100];\r\n   int nw=0, cmd, i, in;\r\n   float f, g, profit = 0;\r\n   char *name;\r\n\r\n   while (cmd = Read(&name, &i, &f, &g)) {\r\n      if (cmd == 5) {\r\n	 qsort(w, nw, sizeof(Ware), Cmp);\r\n	 printf("%35s", "INVENTORY REPORT\\n");\r\n	 printf("Item Name     Buy At      Sell At      On Hand        Value\\n");\r\n	 printf("---------     ------      -------      -------        -----\\n");\r\n	 f = 0;\r\n	 for (i=0; i<nw; i++) {\r\n	    printf("%-14s%6.2f%13.2f%13d%13.2f\\n", w[i].name, w[i].buy,\r\n		   w[i].sell, w[i].on_hand, w[i].on_hand * w[i].buy);\r\n	    f += w[i].on_hand * w[i].buy;\r\n	 }\r\n	 printf("------------------------\\n");\r\n	 printf("Total value of inventory %34.2f\\n", f);\r\n	 printf("Profit since last report %34.2f\\n\\n", profit);\r\n	 profit = 0;\r\n      } else {\r\n	 if (cmd != 1) in = Lookup(w, nw, name);\r\n	 switch (cmd) {\r\n	  case 1:\r\n	    strcpy(w[nw].name, name);\r\n	    w[nw].buy = f;\r\n	    w[nw].sell = g;\r\n	    w[nw].on_hand = 0;\r\n	    nw++;\r\n	    break;\r\n	  case 2:\r\n	    profit -= w[in].on_hand * w[in].buy;\r\n	    w[in] = w[--nw];\r\n	    break;\r\n	  case 3:\r\n	    w[in].on_hand += i;\r\n	    break;\r\n	  case 4:\r\n	    profit += i * (w[in].sell - w[in].buy);\r\n	    w[in].on_hand -= i;\r\n	    break;\r\n	 }\r\n      }\r\n   }\r\n   return 0;\r\n}\r\n', '', 0, 258048, 1, 1, '2010-08-09 10:45:34', '2010-08-09 10:58:36'),
(155, 1, 141, 0, '/* University of Ulm Programming Contest 1996\r\n   Problem H: Humble Numbers\r\n   Implementation: Mark Dettinger */\r\n\r\n#include <stdio.h>\r\n\r\n#define min(a,b) ((a)<(b)?(a):(b))\r\n#define min4(a,b,c,d) min(min(a,b),min(c,d))\r\n\r\nint a[6000];  /* table to store the humble numbers */\r\n\r\nmain()\r\n{\r\n  FILE* input = stdin;//fopen("number.in","r");\r\n  int n,p2,p3,p5,p7;\r\n  \r\n  /* 1. Precompute table of all humble numbers up to 2000000000 */\r\n\r\n  a[1] = n = p2 = p3 = p5 = p7 = 1;\r\n  while (a[n]<2000000000)\r\n    {\r\n      a[++n] = min4(2*a[p2],3*a[p3],5*a[p5],7*a[p7]);\r\n      if (a[n]==2*a[p2]) p2++;\r\n      if (a[n]==3*a[p3]) p3++;\r\n      if (a[n]==5*a[p5]) p5++;\r\n      if (a[n]==7*a[p7]) p7++;\r\n    }\r\n\r\n  /* 2. Read input and generate desired output */\r\n\r\n  while (1)\r\n    {\r\n      fscanf(input,"%d",&n);\r\n      if (n==0) break;\r\n      printf("The %d",n);\r\n      if      (n%10==1 && n/10%10!=1) printf("st");\r\n      else if (n%10==2 && n/10%10!=1) printf("nd");\r\n      else if (n%10==3 && n/10%10!=1) printf("rd");\r\n      else                            printf("th");\r\n      printf(" humble number is %d.\\n",a[n]);\r\n    }\r\n  fclose(input);\r\n  return 0;\r\n}\r\n', '', 15, 282624, 1, 1, '2010-08-10 08:39:37', '2010-08-10 08:39:37'),
(156, 1, 142, 0, '/* University of Ulm Programming Contest 1996\r\n   Problem F: Lotto\r\n   Implementation: Mark Dettinger */\r\n\r\n#include <stdio.h>\r\n\r\nmain()\r\n{\r\n  FILE* input = stdin;//fopen("lotto.in","r");\r\n  int number[15],k,i1,i2,i3,i4,i5,i6,kase=0;\r\n\r\n  while (1)\r\n    {\r\n      fscanf(input,"%d",&k);\r\n      if (k==0) break;\r\n      for (i1=0; i1<k; i1++)\r\n	fscanf(input,"%d",&number[i1]);\r\n      if (kase++>0) printf("\\n");\r\n      for (i1=0; i1<k-5; i1++)\r\n	for (i2=i1+1; i2<k-4; i2++)\r\n	  for (i3=i2+1; i3<k-3; i3++)\r\n	    for (i4=i3+1; i4<k-2; i4++)\r\n	      for (i5=i4+1; i5<k-1; i5++)\r\n		for (i6=i5+1; i6<k; i6++)\r\n		  printf("%d %d %d %d %d %d\\n",number[i1],number[i2],\r\n			 number[i3],number[i4],number[i5],number[i6]);\r\n    }\r\n  fclose(input);\r\n  return 0;\r\n}\r\n\r\n', '', 0, 262144, 1, 1, '2010-08-10 09:04:28', '2010-08-10 09:04:28'),
(157, 1, 32, 0, '/* University of Ulm Programming Contest 1996\r\n   Problem D:      Knight Moves\r\n   Implementation: Mark Dettinger */\r\n\r\n#include <stdio.h>\r\n\r\n#define oo 1000000000\r\n\r\nint d[8][8][8][8];      /* distance matrix */\r\nint startrow,startcol;  /* starting square */\r\nint destrow,destcol;    /* destination square */\r\n\r\nvoid visit (int row, int col, int moves)\r\n{\r\n  if (row<0 || row>7 || col<0 || col>7 || \r\n      moves>=d[startrow][startcol][row][col]) return;\r\n  d[startrow][startcol][row][col] = moves;\r\n  visit(row-2,col-1,moves+1);\r\n  visit(row-2,col+1,moves+1);\r\n  visit(row+2,col-1,moves+1);\r\n  visit(row+2,col+1,moves+1);\r\n  visit(row-1,col-2,moves+1);\r\n  visit(row-1,col+2,moves+1);\r\n  visit(row+1,col-2,moves+1);\r\n  visit(row+1,col+2,moves+1);\r\n}\r\n\r\nint main()\r\n{\r\n  FILE* input =stdin;// fopen("knight.in","r");\r\n  char a[3],b[3];\r\n  int i,j,k,l;\r\n\r\n  for (i=0; i<8; i++)\r\n    for (j=0; j<8; j++)\r\n      for (k=0; k<8; k++)\r\n	for (l=0; l<8; l++)\r\n	  d[i][j][k][l] = oo;\r\n  while (fscanf(input,"%s %s",a,b)==2)\r\n    {\r\n      startcol = a[0]-''a'';\r\n      startrow = a[1]-''1'';\r\n      destcol = b[0]-''a'';\r\n      destrow = b[1]-''1'';\r\n      visit(startrow,startcol,0);\r\n      printf("To get from %s to %s takes %d knight moves.\\n",\r\n	     a,b,d[startrow][startcol][destrow][destcol]);\r\n    }\r\n  fclose(input);\r\n  return 0;\r\n}\r\n\r\n', '', 30, 274432, 1, 1, '2010-08-10 09:05:29', '2010-08-10 09:15:30'),
(158, 1, 30, 0, '/* University of Ulm Programming Contest 1996\r\n   Problem C: Circle\r\n   Implementation: Mark Dettinger */\r\n\r\n#include <stdio.h>\r\n#include <math.h>\r\n\r\n#define PI 3.141592653589793\r\n#define pythagoras(a,b) (sqrt((a)*(a)+(b)*(b)))\r\n#define det(a,b,c,d) ((a)*(d)-(b)*(c))\r\n#define cramer1(a,b,c,d,e,f) (det(e,b,f,d)/det(a,b,c,d))\r\n#define cramer2(a,b,c,d,e,f) (det(a,e,c,f)/det(a,b,c,d))\r\n\r\nint main()\r\n{\r\n  FILE* input = stdin;//fopen("circle.in","r");\r\n  int i;\r\n  double x[3],y[3],s,mx,my,r;\r\n\r\n  while (1)\r\n    {int istatus=0;\r\n      for (i=0; i<3; i++)\r\n	if(fscanf(input,"%lf %lf",&x[i],&y[i])!=2)istatus=1;\r\n      if (istatus) break;\r\n      s = cramer2(y[1]-y[0],y[1]-y[2],x[0]-x[1],x[2]-x[1],\r\n		  0.5*(x[2]-x[0]),0.5*(y[2]-y[0]));\r\n      mx = 0.5*(x[1]+x[2])+s*(y[2]-y[1]);\r\n      my = 0.5*(y[1]+y[2])+s*(x[1]-x[2]);\r\n      r = pythagoras(mx-x[0],my-y[0]);\r\n      printf("%.2f\\n",2*PI*r);\r\n    }\r\n  fclose(input);\r\n  return 0;\r\n}\r\n\r\n', '', 0, 262144, 1, 1, '2010-08-10 09:18:19', '2010-08-10 09:19:04'),
(159, 1, 143, 0, '/* University of Ulm Programming Contest 1996\r\n   Problem G: Matrix Chain Multiplication\r\n   Implementation: Mark Dettinger */\r\n\r\n#include <stdio.h>\r\n\r\ntypedef struct {int mults; int rows; int cols;} triple;  \r\n\r\nint rows[256],cols[256];  /* sizes of the matrices               */\r\nchar e[100];              /* the expression that is to be parsed */\r\nint p;                    /* current position during parsing     */\r\nchar error;               /* error flag                          */\r\n\r\ntriple expression()\r\n{\r\n  /* Precondition: The expression to be parsed begins at &e[p]. */\r\n\r\n  triple t;\r\n  if (e[p]==''('')  /* Case 1: Expr -> ( Expr Expr ) */\r\n    {\r\n      triple t1,t2;\r\n      p++;\r\n      t1 = expression();\r\n      t2 = expression();\r\n      p++;\r\n      if (t1.cols!=t2.rows) error = 1;  /* matrices are incompatible */\r\n      t.rows  = t1.rows;\r\n      t.cols  = t2.cols;\r\n      t.mults = t1.mults+t2.mults+t1.rows*t1.cols*t2.cols;\r\n    }\r\n  else            /* Case 2: Expr -> Matrix */ \r\n    {\r\n      t.rows = rows[e[p]];\r\n      t.cols = cols[e[p]];\r\n      t.mults = 0;\r\n      p++;\r\n    }\r\n  return t;  \r\n\r\n  /* Return Value: a triple consisting of three integers representing\r\n                   - the number of needed multiplications \r\n		   - the number of rows of the resulting matrix\r\n		   - the number of columns of the resulting matrix */\r\n\r\n  /* Postcondition: &e[p] points to the character after the expression\r\n     that has been parsed */\r\n}\r\n\r\nmain()\r\n{\r\n  FILE* input = stdin;//fopen("matrix.in","r");\r\n  char c;\r\n  int i,n,ro,co;\r\n  triple t;\r\n  \r\n  fscanf(input,"%d%c",&n,&c);  /* read number of matrices */\r\n  for (i=0; i<n; i++)          /* read sizes of matrices */\r\n    {\r\n      fgets(e,99,input);\r\n      sscanf(e,"%c %d %d",&c,&ro,&co);\r\n      rows[c] = ro;\r\n      cols[c] = co;\r\n    }\r\n  while (1)               /* for each expression do */\r\n    {\r\n      if (!fgets(e,99,input)) break;\r\n      p = error = 0;           /* parse expression */\r\n      t = expression();      \r\n      if (error)               /* print result */\r\n	puts("error");\r\n      else\r\n	printf("%d\\n",t.mults);\r\n    }\r\n  fclose(input);\r\n  return 0;\r\n}\r\n', '', 0, 262144, 1, 1, '2010-08-10 09:24:04', '2010-08-10 09:24:04'),
(160, 1, 144, 0, '/* University of Ulm Programming Contest 1996\r\n   Problem E: Eeny Meeny Moo\r\n   Fast algorithm by Falk Bartels */\r\n\r\n#include <stdio.h>\r\n\r\nint n,m;\r\n\r\nint suitable (int m)\r\n{\r\n  int cities,p;\r\n  \r\n  cities = n-1;\r\n  p = (m-1)%cities;\r\n  while (cities>1)\r\n    {\r\n      if (p==0) return 0;\r\n      cities--;\r\n      p = (p+m-1)%cities;\r\n    }\r\n  return 1;\r\n}\r\n\r\nmain()\r\n{\r\n  FILE* input = stdin;//fopen("eenymeeny.in","r");\r\n\r\n  while (1)\r\n    {\r\n      fscanf(input,"%d",&n);\r\n      if (n==0) break;\r\n      for (m=2; !suitable(m); m++);\r\n      printf("%d\\n",m);\r\n    }\r\n  fclose(input);\r\n  return 0;\r\n}\r\n', '', 0, 262144, 1, 1, '2010-08-10 09:26:20', '2010-08-10 09:26:37'),
(161, 1, 122, 0, '#include <stdlib.h>\r\nmain()\r\n{\r\n      int a,b;\r\n      while(scanf("%d%d" ,&a, &b)==2) printf("%d\\n",a+b);\r\n}', '', 15, 229376, 1, 1, '2010-08-17 04:47:07', '2010-08-17 04:47:07'),
(162, 1, 145, 0, '#include<stdio.h>\r\nint main()\r\n{\r\n	double y;\r\n	long n;\r\n	while(scanf("%ld",&n)!=EOF&&n!=0)\r\n	{\r\n	    if(n<=4){y=10;printf("%.lf\\n",y);}\r\n	    if(n>4&&n<=8){y=10+2*(n-4);printf("%.lf\\n",y);}\r\n		if(n>8)\r\n		{\r\n		    if(n%8==0){y=18*(n/8);printf("%.lf\\n",y);}\r\n		    if(n%8!=0&&n%8<=4){y=18*(n-n%8)/8+2.4*(n%8);printf("%.1lf\\n",y);}\r\n		    if(n%8!=0&&n%8>=5){y=18*(n-n%8)/8+10+2*(n%8-4);printf("%.lf\\n",y);}\r\n		}\r\n	}\r\n	return 0;\r\n}\r\n', '', 31, 229376, 1, 1, '2010-08-17 04:55:32', '2010-08-17 04:55:32'),
(163, 1, 146, 0, '#include<stdio.h>\r\nint main()\r\n{\r\n	int n,i;\r\n	double x,y,z,x1,y1,z1,x2,y2,z2,d,a[1000],b[1000],c[1000],a1[1000],b1[1000],c1[1000],min;\r\n	scanf("%d",&n);\r\n	for(i=0;i<n;i++)\r\n    {\r\n	    scanf("%lf%lf%lf",&x,&y,&z);\r\n	    a[i]=x;b[i]=y;c[i]=z;\r\n    }\r\n	scanf("%lf%lf%lf",&x1,&y1,&z1);\r\n	scanf("%lf%lf%lf",&x2,&y2,&z2);\r\n	min=(a[0]-(x1+x2)/2)*(a[0]-(x1+x2)/2)+(b[0]-(y1+y2)/2)*(b[0]-(y1+y2)/2)+(c[0]-(z1+z2)/2)*(c[0]-(z1+z2)/2);\r\n	a1[0]=a[0];b1[0]=b[0];c1[0]=c[0];\r\n	for(i=1;i<n;i++)\r\n	{\r\n	    d=(a[i]-(x1+x2)/2)*(a[i]-(x1+x2)/2)+(b[i]-(y1+y2)/2)*(b[i]-(y1+y2)/2)+(c[i]-(z1+z2)/2)*(c[i]-(z1+z2)/2);\r\n	    if(min>d){min=d;a1[i]=a[i];b1[i]=b[i];c1[i]=c[i];while(i==n-1){printf("%.3lf %.3lf %.3lf",a1[i],b1[i],c1[i]);break;}}\r\n	    else {a1[i]=a1[i-1];b1[i]=b1[i-1];c1[i]=c1[i-1];while(i==n-1){printf("%.3lf %.3lf %.3lf",a1[i],b1[i],c1[i]);break;}}\r\n	}\r\n	return 0;\r\n}\r\n', '', 15, 274432, 1, 1, '2010-08-17 05:02:33', '2010-08-17 05:02:33'),
(164, 1, 147, 0, '#include<stdio.h>\r\nint main()\r\n{\r\n	int n,i,a[31];\r\n	a[1]=1;\r\n	a[2]=2;\r\n	a[3]=4;\r\n	for(i=4;i<=30;i++)\r\n	a[i]=a[i-1]+a[i-2]+a[i-3];\r\n	while(scanf("%d",&n)!=EOF&&n!=0)\r\n	{\r\n	    printf("%d\\n",a[n]);\r\n	}\r\n	return 0;\r\n}\r\n', '', 15, 229376, 1, 1, '2010-08-17 05:05:23', '2010-08-17 05:05:23');
INSERT INTO `tbl_submitions` (`id`, `user_id`, `problem_id`, `exercise_id`, `source`, `result`, `used_time`, `used_memory`, `status`, `compiler_id`, `created`, `modified`) VALUES
(165, 1, 148, 0, ' #include <stdio.h>\r\n#include <stdlib.h>\r\n\r\ndouble x[52],y[52],len[52];\r\nint n;\r\n\r\nint cmp(const void *t1, const void *t2) \r\n{ \r\n    if (*((double *)t1) > *((double *)t2)) return 1; \r\n    if (*((double *)t1) < *((double *)t2)) return -1; \r\n    return 0; \r\n}\r\n\r\ndouble calc()\r\n{\r\n	double sum = 0;\r\n	int i;\r\n	for(i=0;i<n;i++)\r\n		sum +=len[i]*y[i];\r\n	return sum/2;\r\n}\r\n\r\nint main()\r\n{\r\n	int i,iCase,nCase;\r\n	//freopen("in.txt","r",stdin);\r\n	//freopen("out3.txt","w",stdout);\r\n	\r\n	scanf("%d",&nCase);\r\n	for(iCase=0;iCase<nCase;iCase++)\r\n	{\r\n		scanf("%d",&n);\r\n		for(i=0;i<n;i++)\r\n			scanf("%lf",&x[i]);\r\n		for(i=0;i<n;i++)\r\n			scanf("%lf",&y[i]);\r\n\r\n		qsort(x, n, sizeof(double), cmp); \r\n		/*for(i=0;i<n;i++)			printf("%lf ",x[i]);		printf("\\n");*/\r\n\r\n		len[0]=x[1]-x[0];\r\n		len[n-1]=x[n-1]-x[n-2];\r\n		for(i=1;i<=n-2;i++)\r\n			len[i]=x[i+1]-x[i-1];\r\n		qsort(len, n, sizeof(double), cmp); \r\n		/*for(i=0;i<n;i++)			printf("%lf ",len[i]);		printf("\\n");*/\r\n\r\n		qsort(y, n, sizeof(double), cmp); \r\n		/*for(i=0;i<n;i++)			printf("%lf ",y[i]);		printf("\\n");*/\r\n\r\n		printf("%.2lf\\n",calc());\r\n	}\r\n	return 0;\r\n}\r\n', '', 375, 229376, 1, 1, '2010-08-17 05:09:29', '2010-08-17 05:09:29'),
(166, 1, 149, 0, '#include <algorithm>\r\n#include <cassert>\r\n#include <complex>\r\n#include <cstdio>\r\n#include <cstdlib>\r\n#include <cstring>\r\n#include <deque>\r\n#include <queue>\r\n#include <vector>\r\nusing namespace std;\r\n\r\n#define FR(i,a,b) for(int i=(a);i<(b);++i)\r\n#define FOR(i,n) FR(i,0,n)\r\n#define CLR(x,a) memset(x,a,sizeof(x))\r\n#define setmax(a,b) a = max(a,b)\r\n#define PB push_back\r\n#define BEND(v) (v).begin(),(v).end()\r\n#define MP make_pair\r\n#define A first\r\n#define B second\r\n#define FORALL(i,v) for(typeof((v).end())i=(v).begin();i!=(v).end();++i)\r\n#define X real()\r\n#define Y imag()\r\ntypedef long long ll;\r\ntypedef complex<ll> cpx;\r\n\r\nint n,m;\r\nint as[1000],bs[1000],cs[1000],xs[1000],ys[1000],zs[1000];\r\nbool known[1000];\r\ncpx pts[1000];\r\nvoid put(int i, int x, int y) {\r\n  assert(!known[i]);\r\n  known[i] = 1;\r\n  pts[i] = cpx(x,y);\r\n}\r\nvoid doit() {\r\n  scanf("%d%d",&n,&m);\r\n  if (n==0) exit(0);\r\n\r\n  FOR(i,n) {\r\n    scanf("%d%d%d%d%d%d",&as[i],&bs[i],&cs[i],&xs[i],&ys[i],&zs[i]);\r\n    --as[i];--bs[i];--cs[i];\r\n  }\r\n\r\n  CLR(known,0);\r\n  put(0, 0, 0);\r\n  put(1, 0, 1);\r\n  put(2, 1, 0);\r\n\r\n  while (1) {\r\n    bool done = 1;\r\n    FOR(i,n) {\r\n      int nk = known[as[i]] + known[bs[i]] + known[cs[i]];\r\n      if (nk == 2) {\r\n	done = 0;\r\n\r\n	while (known[bs[i]]) {\r\n	  swap(as[i], cs[i]);\r\n	  swap(as[i], bs[i]);\r\n	  swap(xs[i], zs[i]);\r\n	  swap(xs[i], ys[i]);\r\n	}\r\n\r\n	int a = as[i], b = bs[i], c = cs[i];\r\n	\r\n	cpx p = pts[a], q = pts[c];\r\n\r\n	for (ll dx = 0; dx*dx <= xs[i]; ++dx) {\r\n	  ll dy = ll(sqrt(xs[i]-dx*dx)+0.5);\r\n	  if (dx*dx+dy*dy != xs[i]) continue;\r\n	  FOR(zz,2) {\r\n	    dx *= -1;\r\n	    FOR(zzz,2) {\r\n	      dy *= -1;\r\n\r\n	      cpx r = p + cpx(dx,dy);\r\n	      assert(xs[i] == norm(p-r));\r\n	      if (ys[i] == norm(q-r) && (conj(q-r)*(r-p)).Y < 0) {\r\n		put(b, r.X, r.Y);\r\n	      }\r\n	    }\r\n	  }\r\n	}\r\n	assert(known[b]);\r\n      }\r\n    }\r\n    if (done) break;\r\n  }\r\n\r\n  FOR(i,m) {\r\n    printf("%lld %lld\\n", pts[i].X, pts[i].Y);\r\n  }\r\n}\r\n\r\nconst int MULTICASE = 1;\r\nint main() {\r\n  do {\r\n    doit();\r\n  } while (MULTICASE);\r\n}\r\n', '', 249, 299008, 1, 2, '2010-08-18 20:18:05', '2010-08-18 20:18:05'),
(167, 1, 150, 0, '#include <algorithm>\r\n#include <cassert>\r\n#include <cstdio>\r\n#include <cstdlib>\r\n#include <cstring>\r\n#include <deque>\r\n#include <queue>\r\n#include <vector>\r\nusing namespace std;\r\n\r\n#define FR(i,a,b) for(int i=(a);i<(b);++i)\r\n#define FOR(i,n) FR(i,0,n)\r\n#define CLR(x,a) memset(x,a,sizeof(x))\r\n#define setmax(a,b) a = max(a,b)\r\n#define PB push_back\r\n#define BEND(v) (v).begin(),(v).end()\r\n#define MP make_pair\r\n#define A first\r\n#define B second\r\n\r\nint R,C;\r\nint i1,j1,i2,j2;\r\nbool mark[20][20][4][1601];\r\nint dist[20][20][4][1601];\r\nbool pass[20][20][4];\r\nint dr[] = { -1, 0, 1, 0 },\r\n    dc[] = { 0, 1, 0, -1 };\r\ndeque<pair<pair<int,int>, pair<int,int> > > q;\r\nvoid enq(int d, int r, int c, int rot, int rem) {\r\n  assert(rem <= 1600);\r\n  if (rem < 0) return;\r\n  if (mark[r][c][rot][rem]) return;\r\n  q.PB(MP(MP(r,c),MP(rot,rem)));\r\n  mark[r][c][rot][rem] = 1;\r\n  dist[r][c][rot][rem] = d;\r\n}\r\nvoid doit() {\r\n  scanf("%d%d",&R,&C);\r\n  if (R==0) exit(0);\r\n\r\n  scanf("%d%d%d%d",&i1,&j1,&i2,&j2);\r\n  --i1;--j1;--i2;--j2;\r\n\r\n  CLR(pass,0);\r\n  FOR(r,R) {\r\n    FOR(c,C) {\r\n      char buf[256];\r\n      scanf("%s",buf);\r\n\r\n      if (buf[0] == ''x'') continue;\r\n\r\n      for (char *p = buf; *p; ++p) {\r\n	pass[r][c][\r\n	  *p==''N'' ? 0 :\r\n	  *p==''E'' ? 1 :\r\n	  *p==''S'' ? 2 :\r\n		    3] = 1;\r\n      }\r\n    }\r\n  }\r\n\r\n  CLR(mark,0);\r\n  q.clear();\r\n  q.PB(MP(MP(i1,j1), MP(0,0)));\r\n  mark[i1][j1][0][0] = 1;\r\n  dist[i1][j1][0][0] = 0;\r\n\r\n  int ans = -1;\r\n  while (q.size()) {\r\n    int r = q.front().A.A,\r\n	c = q.front().A.B,\r\n	rot = q.front().B.A,\r\n	rem = q.front().B.B,\r\n	d = dist[r][c][rot][rem];\r\n    q.pop_front();\r\n\r\n    if (r == i2 && c == j2) {\r\n      ans = d;\r\n      break;\r\n    }\r\n\r\n    for (int drot = -1; drot <= 1; ++drot) {\r\n      int rotp = (rot+drot+4)%4;\r\n      int remp = rem + (drot==0);\r\n\r\n      enq(d+1, r, c, rotp, remp);\r\n\r\n      FOR(k,4) {\r\n	int r2 = r + dr[k], c2 = c + dc[k];\r\n	if (r2<0 || r2>=R || c2<0 || c2>=C) continue;\r\n	int kp = (k+rotp)%4;\r\n	if (!pass[r][c][kp]) continue;\r\n	\r\n	for (int drot2 = -1; drot2 <= 2; ++drot2) {\r\n	  if (abs(drot2) > remp) continue;\r\n	  int rot2 = (drot2+4)%4,\r\n	      rem2 = remp - abs(drot2);\r\n	  if (!pass[r2][c2][(k+rot2+2)%4]) continue;\r\n\r\n	  enq(d+1, r2, c2, rot2, rem2);\r\n	}\r\n      }\r\n    }\r\n  }\r\n\r\n  printf("%d\\n",ans);\r\n}\r\n\r\nconst int MULTICASE = 1;\r\nint main() {\r\n  do {\r\n    doit();\r\n  } while (MULTICASE);\r\n}\r\n', '', 187, 13271040, 1, 2, '2010-08-18 20:19:28', '2010-08-18 20:19:28'),
(168, 1, 151, 0, '#include <algorithm>\r\n#include <cassert>\r\n#include <cstdio>\r\n#include <cstdlib>\r\n#include <cstring>\r\n#include <deque>\r\n#include <queue>\r\n#include <vector>\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\n\r\nusing namespace std;\r\n\r\n#define FR(i,a,b) for(int i=(a);i<(b);++i)\r\n#define FOR(i,n) FR(i,0,n)\r\n#define CLR(x,a) memset(x,a,sizeof(x))\r\n#define setmax(a,b) a = max(a,b)\r\n#define PB push_back\r\n#define BEND(v) (v).begin(),(v).end()\r\n#define MP make_pair\r\n#define A first\r\n#define B second\r\n#define FORALL(i,v) for(typeof((v).end())i=(v).begin();i!=(v).end();++i)\r\n\r\nint n,m;\r\nvector<int> edg[1000000];\r\nint indeg[1000000];\r\nvoid doit() {\r\n  srand(2009);\r\n  scanf("%d%d",&n,&m);\r\n  if (n==0) exit(0);\r\n\r\n  FOR(i,n) indeg[i] = 0;\r\n  FOR(i,m) {\r\n    int a,b;\r\n    scanf("%d%d",&a,&b);\r\n    --a;--b;\r\n    ++indeg[b];\r\n    edg[a].PB(b);\r\n  }\r\n\r\n  deque<int> q;\r\n  FOR(i,n) if (indeg[i] == 0) q.PB(i);\r\n  vector<int> ret;\r\n\r\n  bool happy = 1;\r\n  FOR(i,n) {\r\n    if (!q.size()) {\r\n      happy = 0;\r\n      break;\r\n    }\r\n\r\n    int r = rand()%(int)q.size();\r\n    swap(q[0], q[r]);\r\n\r\n    int v = q.front(); q.pop_front();\r\n    ret.PB(v+1);\r\n\r\n	for(vector<int>::iterator w=edg[v].begin();w!=edg[v].end();w++) {\r\n      if (0==--indeg[*w]) q.PB(*w);\r\n    }\r\n  }\r\n\r\n  FOR(i,n) edg[i].clear();\r\n\r\n  if (happy) {\r\n    FOR(i,n) printf("%d\\n",ret[i]);\r\n  } else {\r\n    printf("IMPOSSIBLE\\n");\r\n  }\r\n}\r\n\r\nconst int MULTICASE = 1;\r\nint main() {\r\n  do {\r\n    doit();\r\n  } while (MULTICASE);\r\n}\r\n', '', 46, 16322560, 1, 2, '2010-08-18 20:19:58', '2010-08-18 12:42:16'),
(169, 1, 152, 0, '#include <algorithm>\r\n#include <cassert>\r\n#include <complex>\r\n#include <cstdio>\r\n#include <cstdlib>\r\n#include <cstring>\r\n#include <deque>\r\n#include <queue>\r\n#include <vector>\r\nusing namespace std;\r\n\r\n#define FR(i,a,b) for(int i=(a);i<(b);++i)\r\n#define FOR(i,n) FR(i,0,n)\r\n#define CLR(x,a) memset(x,a,sizeof(x))\r\n#define setmax(a,b) a = max(a,b)\r\n#define PB push_back\r\n#define BEND(v) (v).begin(),(v).end()\r\n#define MP make_pair\r\n#define A first\r\n#define B second\r\n#define FORALL(i,v) for(typeof((v).end())i=(v).begin();i!=(v).end();++i)\r\ntypedef long long ll;\r\n\r\nchar buf[1024*1024];\r\nvoid doit() {\r\n  scanf(" %s",buf);\r\n  if (0 == strcmp("END",buf)) exit(0);\r\n\r\n  int t = 0;\r\n  string xt = buf,xt1;\r\n  while (xt != xt1) {\r\n    ++t;\r\n    xt1 = xt;\r\n    sprintf(buf, "%d", (int)xt1.size());\r\n    xt = buf;\r\n  }\r\n\r\n  printf("%d\\n", t);\r\n}\r\n\r\nconst int MULTICASE = 1;\r\nint main() {\r\n  do {\r\n    doit();\r\n  } while (MULTICASE);\r\n}\r\n', '', 0, 2318336, 1, 2, '2010-08-18 20:20:05', '2010-08-18 20:20:05'),
(170, 1, 153, 0, '#include <algorithm>\r\n#include <cstdio>\r\n#include <cstdlib>\r\n#include <cstring>\r\nusing namespace std;\r\n\r\n#define FR(i,a,b) for(int i=(a);i<(b);++i)\r\n#define FOR(i,n) FR(i,0,n)\r\n#define CLR(x,a) memset(x,a,sizeof(x))\r\n#define setmax(a,b) a = max(a,b)\r\n\r\nint ls[100000],rs[100000];\r\nbool notroot[100000];\r\nint height[100000];\r\nint ans[100000];\r\nint N;\r\n\r\nvoid doheight(int i) {\r\n  int h = 1;\r\n\r\n  if (ls[i]) {\r\n    doheight(ls[i]-1);\r\n    setmax(h, 1+height[ls[i]-1]);\r\n  }\r\n  if (rs[i]) {\r\n    doheight(rs[i]-1);\r\n    setmax(h, 1+height[rs[i]-1]);\r\n  }\r\n\r\n  height[i] = h;\r\n}\r\n\r\nint getheight(int c) {\r\n  if (c) return height[c-1];\r\n  else return 0;\r\n}\r\n\r\nvoid doans(int i, int lheight=0, int rheight=0, int ltopheight=0, int rtopheight=0) {\r\n  ans[i] = 0;\r\n  setmax(ans[i], 1+lheight);\r\n  setmax(ans[i], 1+rheight);\r\n  setmax(ans[i], 1+ltopheight+getheight(ls[i]));\r\n  setmax(ans[i], 1+rtopheight+getheight(rs[i]));\r\n\r\n  if (ls[i]) {\r\n    doans(ls[i]-1, lheight, max(rheight, 1+rtopheight+getheight(rs[i])),\r\n		   ltopheight, 1+rtopheight);\r\n  }\r\n  if (rs[i]) {\r\n    doans(rs[i]-1, max(lheight, 1+ltopheight+getheight(ls[i])), rheight,\r\n		   1+ltopheight, rtopheight);\r\n  }\r\n}\r\n\r\nvoid doit() {\r\n  scanf("%d",&N);\r\n  if (N==0) exit(0);\r\n\r\n  CLR(notroot,0);\r\n  FOR(i,N) {\r\n    int l,r;\r\n    scanf("%d%d",&l,&r);\r\n    if (l) notroot[l-1] = 1;\r\n    if (r) notroot[r-1] = 1;\r\n    ls[i] = l;\r\n    rs[i] = r;\r\n  }\r\n\r\n  int root = -1;\r\n  FOR(i,N) if (!notroot[i]) root = i;\r\n  \r\n  doheight(root);\r\n  doans(root);\r\n\r\n  FOR(i,N) printf("%d\\n", ans[i]);\r\n}\r\n\r\nconst int MULTICASE = 1;\r\nint main() {\r\n  do {\r\n    doit();\r\n  } while (MULTICASE);\r\n}\r\n', '', 15, 1961984, 1, 2, '2010-08-18 20:20:07', '2010-08-18 20:20:07'),
(171, 1, 154, 0, '#include <cstring>\r\n#include <algorithm>\r\n#include <cassert>\r\n#include <cstdio>\r\n#include <cstdlib>\r\n#include <deque>\r\n#include <iostream>\r\n#include <map>\r\n#include <queue>\r\n#include <set>\r\n#include <utility>\r\n#include <vector>\r\nusing namespace std;\r\n\r\n#define FR(i,a,b) for(int i=(a);i<(b);++i)\r\n#define FOR(i,n) FR(i,0,n)\r\n#define FORI(i,v) FOR(i,(int)(v).size())\r\n#define FORALL(i,v) for(typeof((v).end())i=(v).begin();i!=(v).end();++i)\r\n#define CLR(x,a) memset(x,a,sizeof(x))\r\n#define BEND(v) (v).begin(),(v).end()\r\n#define SZ(v) (int)(v).size()\r\n#define MP make_pair\r\n#define PB push_back\r\n#define A first\r\n#define B second\r\n#define dump(x) cerr << #x << " = " << (x) << endl\r\ntypedef long long ll; typedef long double ld;\r\n\r\nint n,m;\r\nchar grid[2000][2000];\r\nint nmark[2],prev;\r\nbool full;\r\nint nlines[2];\r\nint nkey[2][3000][3000];\r\nint dr[] = { 1, 1, 0, -1 },\r\n    dc[] = { 0, 1, 1, 1 };\r\nchar get(int r, int c) {\r\n  if (r<0 || r>=n || c<0 || c>=n) return ''.'';\r\n  return grid[r][c];\r\n}\r\nvoid detect(int p, char ch) {\r\n  FOR(k,4) {\r\n    FOR(r,n) FOR(c,n) {\r\n      if (get(r-dr[k],c-dc[k]) != ch) {\r\n	int len=0;\r\n	while (get(r+len*dr[k],c+len*dc[k]) == ch) ++len;\r\n\r\n	if (len >= m) {\r\n	  ++nlines[p];\r\n\r\n	  FOR(i,len) if (i<m && m+i >= len) {\r\n	    ++nkey[p][r+i*dr[k]][c+i*dc[k]];\r\n	  }\r\n	}\r\n      }\r\n    }\r\n  }\r\n}\r\nint main() {\r\n  scanf("%d%d",&n,&m);\r\n\r\n  FOR(i,n) FOR(j,n) scanf(" %c",&grid[i][j]);\r\n\r\n  CLR(nmark,0);\r\n  full = 1;\r\n\r\n  FOR(i,n) FOR(j,n) {\r\n    if (grid[i][j] == ''X'') ++nmark[0];\r\n    else if (grid[i][j] == ''O'') ++nmark[1];\r\n    else full = 0;\r\n  }\r\n\r\n  if (nmark[0] == nmark[1]) prev = 1;\r\n  else if (nmark[0] == nmark[1]+1) prev = 0;\r\n  else {\r\n    printf("ERROR\\n");\r\n    return 0;\r\n  }\r\n\r\n  CLR(nlines,0);\r\n  CLR(nkey,0);\r\n  FOR(p,2) {\r\n    detect(p,"XO"[p]);\r\n  }\r\n\r\n  if (nlines[1-prev] != 0) {\r\n    printf("ERROR\\n");\r\n    return 0;\r\n  }\r\n\r\n  if (nlines[prev] == 0) {\r\n    if (full) printf("DRAW\\n");\r\n    else printf("IN PROGRESS\\n");\r\n    return 0;\r\n  }\r\n\r\n  bool happy = 0;\r\n  FOR(i,n) FOR(j,n) if (nkey[prev][i][j] == nlines[prev]) happy = 1;\r\n\r\n  if (!happy) {\r\n    printf("ERROR\\n");\r\n    return 0;\r\n  }\r\n\r\n  printf("%c WINS\\n", "XO"[prev]);\r\n}\r\n', '', 62, 76517376, 1, 2, '2010-08-18 20:47:29', '0001-01-01 00:00:00'),
(172, 1, 155, 0, '#include <cstring>\r\n#include <algorithm>\r\n#include <cassert>\r\n#include <cstdio>\r\n#include <cstdlib>\r\n#include <deque>\r\n#include <iostream>\r\n#include <map>\r\n#include <queue>\r\n#include <set>\r\n#include <utility>\r\n#include <vector>\r\nusing namespace std;\r\n\r\n#define FR(i,a,b) for(int i=(a);i<(b);++i)\r\n#define FOR(i,n) FR(i,0,n)\r\n#define FORALL(i,v) for(typeof((v).end())i=(v).begin();i!=(v).end();++i)\r\n#define CLR(x,a) memset(x,a,sizeof(x))\r\n#define BEND(v) (v).begin(),(v).end()\r\n#define MP make_pair\r\n#define PB push_back\r\n#define A first\r\n#define B second\r\n#define dump(x) cerr << #x << " = " << (x) << endl\r\ntypedef long long ll; typedef long double ld;\r\n\r\nconst int inf = 0x20202020;\r\n\r\nint dr[] = { 0, 1, 0, -1 },\r\n    dc[] = { 1, 0, -1, 0 };\r\n\r\nint R,C;\r\nchar grid[1000][1000];\r\nint fd[1000][1000];\r\nint jd[1000][1000];\r\nvoid bfs(deque<pair<int,int> > &q, int (*d)[1000]) {\r\n  while (q.size()) {\r\n    int r = q.front().A, c = q.front().B;\r\n    q.pop_front();\r\n\r\n    FOR(k,4) {\r\n      int r2 = r+dr[k], c2 = c+dc[k];\r\n      if (r2<0 || r2>=R || c2<0 || c2>=C) continue;\r\n      if (grid[r2][c2] == ''#'') continue;\r\n\r\n      if (1+d[r][c] < d[r2][c2]) {\r\n	d[r2][c2] = 1+d[r][c];\r\n	q.PB(MP(r2,c2));\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nint main() {\r\n  scanf("%d%d",&R,&C);\r\n  assert(1 <= R && R <= 1000);\r\n  assert(1 <= C && C <= 1000);\r\n\r\n  deque<pair<int,int> > fq,jq;\r\n  CLR(fd,0x20);\r\n  CLR(jd,0x20);\r\n  FOR(r,R) {\r\n    FOR(c,C) {\r\n      char ch;\r\n      scanf(" %c",&ch);\r\n\r\n      grid[r][c] = ch;\r\n      if (ch==''J'') {\r\n	jq.PB(MP(r,c));\r\n	jd[r][c] = 0;\r\n      } else if (ch==''F'') {\r\n	fq.PB(MP(r,c));\r\n	fd[r][c] = 0;\r\n      }\r\n    }\r\n  }\r\n  assert(jq.size() == 1);\r\n\r\n  bfs(fq,fd);\r\n  bfs(jq,jd);\r\n\r\n  int best = inf;\r\n  #define TRYIT(r,c) if (grid[r][c] != ''#'' && jd[r][c] < fd[r][c]) if(best>jd[r][c]+1) best = jd[r][c]+1\r\n  FOR(r,R) {\r\n    TRYIT(r,0);\r\n    TRYIT(r,C-1);\r\n  }\r\n  FOR(c,C) {\r\n    TRYIT(0,c);\r\n    TRYIT(R-1,c);\r\n  }\r\n\r\n  if (best < inf) {\r\n    printf("%d\\n",best);\r\n  } else {\r\n    printf("IMPOSSIBLE\\n");\r\n  }\r\n}\r\n', '', 546, 9543680, 1, 2, '2010-08-18 20:47:30', '0001-01-01 00:00:00'),
(173, 1, 156, 0, '#include <cstring>\r\n#include <algorithm>\r\n#include <cassert>\r\n#include <cstdio>\r\n#include <cstdlib>\r\n#include <deque>\r\n#include <iostream>\r\n#include <map>\r\n#include <queue>\r\n#include <set>\r\n#include <utility>\r\n#include <vector>\r\nusing namespace std;\r\n\r\n#define FR(i,a,b) for(int i=(a);i<(b);++i)\r\n#define FOR(i,n) FR(i,0,n)\r\n#define FORALL(i,v) for(typeof((v).end())i=(v).begin();i!=(v).end();++i)\r\n#define CLR(x,a) memset(x,a,sizeof(x))\r\n#define BEND(v) (v).begin(),(v).end()\r\n#define MP make_pair\r\n#define PB push_back\r\n#define A first\r\n#define B second\r\n#define dump(x) cerr << #x << " = " << (x) << endl\r\ntypedef long long ll; typedef long double ld;\r\n\r\nconst ll MOD = 1000000007;\r\n\r\nll L;\r\nint K;\r\nll dp[2][101];\r\nint dodp(int l) {\r\n  FOR(i,l) {\r\n    int i1 = i%2, i2 = (i+1)%2;\r\n    CLR(dp[i2],0);\r\n\r\n    FOR(k2,K+1) {\r\n      int k1 = ((i-2*k2)%K+K)%K;\r\n      int k0 = K-k1-k2;\r\n      if (k0+k1+k2 > K) continue;\r\n      if (k0 < 1) continue;\r\n      \r\n      int k0p = k0-1, k1p = k1+1, k2p = k2;\r\n      if (k0p == 0) k1p = k2p, k2p = 0;\r\n      dp[i2][k2p] = (dp[i2][k2p] + k0*dp[i1][k2])%MOD;\r\n\r\n      if (k1 > 0) {\r\n	k1p = k1-1, k2p = k2+1;\r\n	dp[i2][k2p] = (dp[i2][k2p] + k1*dp[i1][k2])%MOD;\r\n      }\r\n    }\r\n  }\r\n\r\n  return l%2;\r\n}\r\n\r\nstruct Matrix {\r\n  ll dat[101][101];\r\n  Matrix() {\r\n    CLR(dat,0);\r\n    FOR(k,K+1) dat[k][k] = 1;\r\n  }\r\n};\r\n\r\nconst Matrix operator*(const Matrix &A, const Matrix &B) {\r\n  Matrix C;\r\n\r\n  FOR(i,K+1) FOR(j,K+1) {\r\n    C.dat[i][j] = 0;\r\n    FOR(k,K+1) C.dat[i][j] = (C.dat[i][j] + A.dat[i][k]*B.dat[k][j]) % MOD;\r\n  }\r\n\r\n  return C;\r\n}\r\n\r\nconst Matrix expmod(Matrix X, ll n) {\r\n  Matrix ret;\r\n\r\n  while (n) {\r\n    if (n%2) ret = ret*X;\r\n    X = X*X;\r\n    n /= 2;\r\n  }\r\n\r\n  return ret;\r\n}\r\n\r\nint main() {\r\n  scanf("%lld%d",&L,&K);\r\n  assert(1 <= L && L <= 1000000000000000000LL);\r\n  assert(1 <= K && K <= 100);\r\n\r\n  ll matpart = L/K;\r\n\r\n  Matrix X;\r\n\r\n  FOR(k,K+1) {\r\n    CLR(dp,0);\r\n    dp[0][k] = 1;\r\n\r\n    int idx = dodp(K);\r\n\r\n    FOR(kp,K+1) {\r\n      X.dat[kp][k] = dp[idx][kp];\r\n    }\r\n  }\r\n\r\n  Matrix Y = expmod(X, matpart);\r\n\r\n  CLR(dp,0);\r\n  FOR(k,K+1) dp[0][k] = Y.dat[k][0];\r\n\r\n  ll extpart = L-K*matpart;\r\n  assert(extpart >= 0);\r\n\r\n  int finidx = dodp(extpart);\r\n\r\n  ll ans = 0;\r\n  FOR(k2,K+1) ans = (ans + dp[finidx][k2]) % MOD;\r\n\r\n  printf("%lld\\n",ans);\r\n}\r\n', '', 31, 901120, 1, 2, '2010-08-18 20:47:31', '0001-01-01 00:00:00'),
(174, 1, 157, 0, '#include <algorithm>\r\n#include <cassert>\r\n#include <complex>\r\n#include <cstdio>\r\n#include <cstdlib>\r\n#include <deque>\r\n#include <iostream>\r\n#include <map>\r\n#include <queue>\r\n#include <set>\r\n#include <utility>\r\n#include <vector>\r\nusing namespace std;\r\n\r\n#define FR(i,a,b) for(int i=(a);i<(b);++i)\r\n#define FOR(i,n) FR(i,0,n)\r\n#define FORI(i,v) FOR(i,(int)(v).size())\r\n#define RF(i,a,b) for(int i=(a)-1;i>=(b);--i)\r\n#define ROF(i,n) RF(i,n,0)\r\n#define ROFI(i,v) ROF(i,(int)(v).size())\r\n#define FORALL(i,v) for(typeof((v).end())i=(v).begin();i!=(v).end();++i)\r\n#define CLR(x,a) memset(x,a,sizeof(x))\r\n#define BEND(v) (v).begin(),(v).end()\r\n#define SZ(v) (int)(v).size()\r\n#define MP make_pair\r\n#define PB push_back\r\n#define A first\r\n#define B second\r\n#define dump(x) cerr << #x << " = " << (x) << endl\r\ntypedef long long ll; typedef long double ld;\r\n\r\ntypedef complex<ll> cpx;\r\n#define X real()\r\n#define Y imag()\r\n\r\nbool cpxlt(const cpx &p, const cpx &q) {\r\n  if (p.X != q.X) return p.X < q.X;\r\n  return p.Y < q.Y;\r\n}\r\nint n;\r\nll cross(const cpx &p, const cpx &q) {\r\n  return (conj(p)*q).Y;\r\n}\r\nint main() {\r\n  scanf("%d",&n);\r\n\r\n  vector<cpx> pts;\r\n  FOR(i,n) {\r\n    cpx p;\r\n    char ch;\r\n    scanf("%lld%lld %c",&p.X,&p.Y,&ch);\r\n    if (ch == ''Y'') pts.PB(p);\r\n  }\r\n\r\n  sort(BEND(pts),cpxlt);\r\n\r\n  vector<cpx> top,bot;\r\n  for(vector<cpx>::iterator i=pts.begin();i!=pts.end();i++) {\r\n    while (top.size()>=2 && cross(top[SZ(top)-1]-top[SZ(top)-2], *i-top.back())>0) top.pop_back();\r\n    top.PB(*i);\r\n\r\n    while (bot.size()>=2 && cross(bot[SZ(bot)-1]-bot[SZ(bot)-2], *i-bot.back())<0) bot.pop_back();\r\n    bot.PB(*i);\r\n  }\r\n  assert(top[0] == bot[0]);\r\n  assert(top.back() == bot.back());\r\n  assert(SZ(top)+SZ(bot) == 2 + SZ(pts));\r\n\r\n  printf("%d\\n",SZ(pts));\r\n  FORI(i,bot) if (i+1 < SZ(bot)) printf("%lld %lld\\n", bot[i].X, bot[i].Y);\r\n  ROFI(i,top) if (i) printf("%lld %lld\\n", top[i].X, top[i].Y);\r\n}\r\n', '', 264, 5124096, 1, 2, '2010-08-18 20:47:31', '0001-01-01 00:00:00'),
(175, 1, 158, 0, '#include <algorithm>\r\n#include <cassert>\r\n#include <cstdio>\r\n#include <cstdlib>\r\n#include <deque>\r\n#include <iostream>\r\n#include <map>\r\n#include <queue>\r\n#include <set>\r\n#include <utility>\r\n#include <vector>\r\nusing namespace std;\r\n\r\n#define FR(i,a,b) for(int i=(a);i<(b);++i)\r\n#define FOR(i,n) FR(i,0,n)\r\n#define FORALL(i,v) for(typeof((v).end())i=(v).begin();i!=(v).end();++i)\r\n#define CLR(x,a) memset(x,a,sizeof(x))\r\n#define BEND(v) (v).begin(),(v).end()\r\n#define MP make_pair\r\n#define PB push_back\r\n#define A first\r\n#define B second\r\n#define dump(x) cerr << #x << " = " << (x) << endl\r\ntypedef long long ll; typedef long double ld;\r\n\r\nint W,vh,N;\r\nint xs[100000],ys[100000];\r\nint S;\r\nint ss[1000000];\r\nint main() {\r\n  scanf("%d%d%d",&W,&vh,&N);\r\n  assert(1 <= W && W <= 100000000);\r\n  assert(1 <= vh && vh <= 1000000);\r\n  assert(2 <= N && N <= 100000);\r\n\r\n  FOR(i,N) {\r\n    scanf("%d%d",&xs[i],&ys[i]);\r\n    assert(1 <= xs[i] && xs[i] <= 100000000);\r\n    assert(1 <= ys[i] && ys[i] <= 100000000);\r\n  }\r\n\r\n  FOR(i,N-1) assert(ys[i+1] > ys[i]);\r\n\r\n  scanf("%d",&S);\r\n  assert(1 <= S && S <= 1000000);\r\n  FOR(i,S) {\r\n    scanf("%d",&ss[i]);\r\n    assert(1 <= ss[i] && ss[i] <= 1000000);\r\n  }\r\n  sort(&ss[0], &ss[S]);\r\n\r\n  int lo = -1, hi = S;\r\n  while (lo+1 < hi) {\r\n    int mid = (lo+hi)/2;\r\n\r\n    ll s = ss[mid];\r\n\r\n    // 2*10^8 * 10^6 = 2*10^14\r\n    ll l = 0, r = 200000000 * s;\r\n    ll y = 0;\r\n\r\n    bool ok = 1;\r\n    FOR(i,N) {\r\n      // 10^8 * 10^6 = 10^14\r\n      l -= ll(ys[i]-y) * vh;\r\n      r += ll(ys[i]-y) * vh;\r\n\r\n      // 2*10^8 * 10^6 = 2*10^14\r\n      if(l<xs[i]*s) l = xs[i]*s;\r\n      if(r>(xs[i]+W)*s) r = (xs[i]+W)*s;\r\n\r\n      if (r < l) {\r\n	ok = 0;\r\n	break;\r\n      }\r\n\r\n      y = ys[i];\r\n    }\r\n\r\n    if (ok) lo = mid;\r\n    else hi = mid;\r\n  }\r\n\r\n  if (lo==-1) {\r\n    printf("IMPOSSIBLE\\n");\r\n  } else {\r\n    printf("%d\\n", ss[lo]);\r\n  }\r\n}\r\n', '', 0, 5177344, 1, 2, '2010-08-18 20:47:31', '0001-01-01 00:00:00'),
(176, 1, 159, 0, '#include <stdio.h>\r\n#include <string.h>\r\n\r\nusing namespace std;\r\n\r\n#include <queue>\r\n#include <set>\r\n\r\ntypedef pair<int,int> stump;\r\nset<stump> stumps;\r\n\r\nstruct log{\r\n    int a1;\r\n    int a2;\r\n    int b;\r\n    char orient;\r\n    bool touches(stump s) const {\r\n        if(orient==''-'') {\r\n            if(a1==s.first && b==s.second) return true;\r\n            if(a2==s.first && b==s.second) return true;\r\n        } else {\r\n            if(a1==s.second && b==s.first) return true;\r\n            if(a2==s.second && b==s.first) return true;\r\n        }\r\n        return false;\r\n    }\r\n    stump other(stump s) const {\r\n        if(orient==''-'') {\r\n            if(a1==s.first && b==s.second) return stump(a2,b);\r\n            if(a2==s.first && b==s.second) return stump(a1,b);\r\n        } else {\r\n            if(a1==s.second && b==s.first) return stump(b,a2);\r\n            if(a2==s.second && b==s.first) return stump(b,a1);\r\n        }\r\n        return stump(-1,-1);\r\n    }\r\n    int len() const {\r\n        if(a1<a2) return a2-a1; else return a1-a2;\r\n    }\r\n    stump endp1() {\r\n        if(orient == ''-'') return stump(a1,b);\r\n        return stump(b,a1);\r\n    }\r\n    stump endp2() {\r\n        if(orient == ''-'') return stump(a2,b);\r\n        return stump(b,a2);\r\n    }\r\n    bool hits(stump s) {\r\n        if(orient == ''-'') {\r\n            return(s.second == b && a1 < s.first && s.first < a2);\r\n        } else {\r\n            return(s.first == b && a1 < s.second && s.second < a2);\r\n        }\r\n    }\r\n    bool valid() {\r\n        if(!stumps.count(endp1())) return false;\r\n        if(!stumps.count(endp2())) return false;\r\n        for(set<stump>::iterator it = stumps.begin(); it != stumps.end(); it++) {\r\n            if(hits(*it)) return false;\r\n        }\r\n        return true;\r\n    }\r\n    bool crosses(const log l) {\r\n        if(orient == l.orient) return false;\r\n        return(l.a1 < b && b < l.a2 && a1 < l.b && l.b < a2);\r\n    }\r\n};\r\n\r\n\r\nbool operator<(const log l1, const log l2) {\r\n    if(l1.a1<l2.a1) return true;\r\n    if(l1.a1>l2.a1) return false;\r\n    if(l1.a2<l2.a2) return true;\r\n    if(l1.a2>l2.a2) return false;\r\n    if(l1.b<l2.b) return true;\r\n    if(l1.b>l2.b) return false;\r\n    if(l1.orient<l2.orient) return true;\r\n    if(l1.orient>l2.orient) return false;\r\n    return false;\r\n}\r\n\r\nstruct board {\r\n    stump guy;\r\n    int len;\r\n    set<log> logs;\r\n    bool canadd(log l) {\r\n        if(logs.count(l)) return false;\r\n        if(!l.valid()) return false;\r\n        for(set<log>::iterator it = logs.begin(); it != logs.end(); it++) {\r\n            if(l.crosses(*it)) return false;\r\n        }\r\n        return true;\r\n    }\r\n};\r\n\r\nstruct mboard {\r\n    board bd;\r\n    int moves;\r\n};\r\n\r\nbool operator<(const board& b1, const board& b2) {\r\n    if(b1.guy<b2.guy) return true;\r\n    if(b1.guy>b2.guy) return false;\r\n    if(b1.len<b2.len) return true;\r\n    if(b1.len>b2.len) return false;\r\n    if(b1.logs<b2.logs) return true;\r\n    if(b1.logs>b2.logs) return false;\r\n    return false;\r\n}\r\n\r\nvoid printboard(board bd) {\r\n    printf("%d %d %d\\n", bd.guy.first, bd.guy.second, bd.len);\r\n    for(set<log>::iterator it = bd.logs.begin(); it != bd.logs.end(); it++) {\r\n        printf("%d %d %d %c\\n", it->a1, it->a2, it->b, it->orient);\r\n    }\r\n}\r\n\r\nint rows;\r\nint cols;\r\nint cnts[1000];\r\nchar buf[1000];\r\nstump goal;\r\n\r\nset<board> seen;\r\nqueue<mboard> q;\r\n\r\nvoid move(board bd, int moves) {\r\n    if(seen.count(bd) == 0) {\r\n        seen.insert(bd);\r\n        mboard mbd;\r\n        mbd.bd = bd;\r\n        mbd.moves = moves;\r\n        q.push(mbd);\r\n    }\r\n}\r\n\r\nmain() {\r\n    int CASES;\r\n    scanf("%d", &CASES);\r\n    while(CASES--) {\r\n        int i,j,k;\r\n        scanf("%d %d ", &rows, &cols);\r\n        stumps = set<stump>();\r\n        board bd;\r\n        bd.len = 0;\r\n        memset(cnts,0,sizeof(cnts));\r\n        for(i=0; i<rows; i++) {\r\n            gets(buf);\r\n            for(j=0; j<cols; j++) {\r\n                if(cnts[j]) {\r\n                    if(buf[j] != ''|'') {\r\n                        log l;\r\n                        l.a1 = i-cnts[j]-1;\r\n                        l.a2 = i;\r\n                        l.b = j;\r\n                        l.orient = ''|'';\r\n                        bd.logs.insert(l);\r\n                    }\r\n                }\r\n                stump s(j,i);\r\n                switch(buf[j]) {\r\n                    case ''S'':\r\n                        stumps.insert(s);\r\n                        break;\r\n                    case ''B'':\r\n                        bd.guy = stump(j,i);\r\n                        stumps.insert(s);\r\n                        break;\r\n                    case ''E'':\r\n                        goal = s;\r\n                        stumps.insert(s);\r\n                        break;\r\n                    case ''-'':\r\n                        if(buf[j-1] != ''-'') {\r\n                            log l;\r\n                            l.a1 = j-1;\r\n                            for(k=j; buf[k] == ''-''; k++);\r\n                            l.a2 = k;\r\n                            l.b = i;\r\n                            l.orient = ''-'';\r\n                            bd.logs.insert(l);\r\n                        }\r\n                    case ''|'':\r\n                        cnts[j]++;\r\n                }\r\n                if(buf[j] != ''|'') cnts[j] = 0;\r\n            }\r\n        }\r\n        //printboard(bd);\r\n        seen = set<board>();\r\n        q = queue<mboard>();\r\n        mboard mbd;\r\n        mbd.bd = bd;\r\n        mbd.moves = 0;\r\n        q.push(mbd);\r\n        while(q.size() > 0) {\r\n            mboard mbd = q.front();\r\n            q.pop();\r\n            board bd = mbd.bd;\r\n            int moves = mbd.moves;\r\n            if(bd.guy == goal) {\r\n                printf("%d\\n", moves);\r\n                goto next;\r\n            }\r\n            for(set<log>::iterator it = bd.logs.begin(); it != bd.logs.end(); it++) {\r\n                if(it->touches(bd.guy)) {\r\n                    board bd2 = bd;\r\n                    bd2.guy = it->other(bd.guy);\r\n                    move(bd2, moves+1);\r\n                }\r\n            }\r\n            if(!bd.len) {\r\n                for(set<log>::iterator it = bd.logs.begin(); it != bd.logs.end(); it++) {\r\n                    if(it->touches(bd.guy)) {\r\n                        board bd2 = bd;\r\n                        /*\r\n                        bd2.logs = set<log>();\r\n                        log badl = *it;\r\n                        for(set<log>::iterator it2 = bd.logs.begin(); it2 != bd.logs.end(); it2++) {\r\n                            log newl = *it2;\r\n                            if(badl < newl || newl < badl) bd2.logs.insert(newl);\r\n                        }\r\n                        */\r\n                        bd2.logs.erase(*it);\r\n                        bd2.len = it->len();\r\n                        move(bd2, moves+1);\r\n                    }\r\n                }\r\n            }\r\n#define trylog(bd,log) \\\r\n            do { \\\r\n                if(bd.canadd(log)) { \\\r\n                    board bd2 = bd; \\\r\n                    bd2.len = 0; \\\r\n                    bd2.logs.insert(log); \\\r\n                    move(bd2, moves+1); \\\r\n                } \\\r\n            } while(0)\r\n            if(bd.len) {\r\n                log l;\r\n                l.a1 = bd.guy.first;\r\n                l.a2 = bd.guy.first + bd.len;\r\n                l.b = bd.guy.second;\r\n                l.orient = ''-'';\r\n                trylog(bd, l);\r\n                l.a1 = bd.guy.first - bd.len;\r\n                l.a2 = bd.guy.first;\r\n                trylog(bd, l);\r\n                l.a1 = bd.guy.second;\r\n                l.a2 = bd.guy.second + bd.len;\r\n                l.b = bd.guy.first;\r\n                l.orient = ''|'';\r\n                trylog(bd, l);\r\n                l.a1 = bd.guy.second - bd.len;\r\n                l.a2 = bd.guy.second;\r\n                trylog(bd, l);\r\n            }\r\n        }\r\n        puts("0");\r\nnext:;\r\n    }\r\n}\r\n\r\n', '', 15, 466944, 1, 2, '2010-08-18 21:00:22', '0001-01-01 00:00:00'),
(177, 1, 160, 0, '#include <stdio.h>\r\n#include <math.h>\r\n\r\n#define N 11000\r\n#define G 9.8\r\n\r\ndouble A[N+100];\r\n\r\nmain() {\r\n    int CASES;\r\n    scanf("%d", &CASES);\r\n    while(CASES--) {\r\n        int i,j;\r\n        double neginf = -1.0/0;\r\n        for(i=1; i<N; i++) {\r\n            A[i] = neginf;\r\n        }\r\n        A[0] = 0;\r\n        int stages;\r\n        scanf("%d", &stages);\r\n        int maxmass = 0;\r\n        for(i=0;i<stages;i++) {\r\n            int ms, mf, th, fc;\r\n            scanf("%d %d %d %d", &ms, &mf, &th, &fc);\r\n            for(j=N; j>=0; j--) {\r\n                int newm = j + ms;\r\n                int totm = newm+mf;\r\n                if(totm > 10000) continue;\r\n                if(th/totm < G) continue;\r\n                double time = 1.0*mf/fc;\r\n                double acc = th*(log(newm+mf) - log(newm))/fc - time*G;\r\n                acc = acc + A[j];\r\n                if(acc <= A[newm+mf]) continue;\r\n                A[newm+mf] = acc;\r\n            }\r\n            maxmass += ms+mf;\r\n        }\r\n        double mx = 0;\r\n        for(i=0; i<N; i++) {\r\n            if(A[i]>mx) mx = A[i];\r\n        }\r\n        //printf("%lf\\n", mx);\r\n        printf("%.0lf\\n", mx);\r\n    }\r\n}\r\n\r\n', '', 78, 348160, 1, 1, '2010-08-18 21:00:23', '0001-01-01 00:00:00'),
(178, 1, 161, 0, '#define N 1100000\r\n#include <map>\r\n#include <string>\r\n#include <iostream>\r\nusing namespace std;\r\n\r\nint p[N];\r\nmap<string,int> nn;\r\nint numseen;\r\nint cnt[N];\r\n\r\nint lookup(int i) {\r\n    if(i!=p[i]) p[i] = lookup(p[i]);\r\n    return p[i];\r\n}\r\nvoid merge(int i, int j) {\r\n    int ii = lookup(i);\r\n    int jj = lookup(j);\r\n    if(ii==jj) return;\r\n    if(ii<jj) {\r\n        p[jj] = ii;\r\n        cnt[ii] += cnt[jj];\r\n    } else {\r\n        p[ii] = jj;\r\n        cnt[jj] += cnt[ii];\r\n    }\r\n}\r\nint find(string s) {\r\n    int ret = nn[s];\r\n    if(ret == 0) {\r\n        numseen++;\r\n        ret = numseen;\r\n        nn[s] = ret;\r\n    }\r\n    return ret;\r\n}\r\nmain() {\r\n    int CASES;\r\n    cin >> CASES;\r\n    while(CASES--) {\r\n        int i,j;\r\n        for(i=0;i<N;i++) p[i] = i;\r\n        for(i=0;i<N;i++) cnt[i] = 1;\r\n        nn = map<string,int>();\r\n        numseen = 0;\r\n        int num;\r\n        cin >> num;\r\n        for(j=0;j<num;j++) {\r\n            string nm1, nm2;\r\n            cin >> nm1;\r\n            cin >> nm2;\r\n            int n1 = find(nm1);\r\n            int n2 = find(nm2);\r\n            merge(n1, n2);\r\n            cout << cnt[lookup(n1)] << endl;\r\n        }\r\n    }\r\n}\r\n', '', 998, 9953280, 1, 2, '2010-08-18 21:00:23', '0001-01-01 00:00:00'),
(179, 1, 162, 0, '#include <stdio.h>\r\n#include <string.h>\r\n#define N 1100000\r\n\r\nchar toppled[N];\r\nint edges[N][2];\r\nunsigned se[N];\r\nchar incoming[N];\r\n\r\nint topple(int x) {\r\n    if(!toppled[x]) {\r\n        int i;\r\n        toppled[x] = 1;\r\n        for(i = se[x]; i < N && edges[i][0] == x; i++) {\r\n            topple(edges[i][1]);\r\n        }\r\n    }\r\n}\r\nint comp(const int *e1, const int *e2) {\r\n    return *e1 - *e2;\r\n}\r\n\r\nchar seen[N];\r\nint nextfin;\r\nint finish[N];\r\nint dfs(int n) {\r\n    if(!seen[n]) {\r\n        int i;\r\n        seen[n] = 1;\r\n        for(i = se[n]; i < N && edges[i][0] == n; i++) {\r\n            dfs(edges[i][1]);\r\n        }\r\n        finish[n] = ++nextfin;\r\n    }\r\n}\r\nint fincomp(const int *e1, const int *e2) {\r\n    return finish[*e2] - finish[*e1];\r\n}\r\nint nums[N];\r\nmain() {\r\n    int CASES;\r\n    scanf("%d", &CASES);\r\n    while(CASES--) {\r\n        int n, m, i, cnt;\r\n        memset(toppled,0,sizeof(toppled));\r\n        memset(incoming,0,sizeof(incoming));\r\n        memset(seen,0,sizeof(seen));\r\n        memset(finish,0,sizeof(finish));\r\n        scanf("%d %d", &n, &m);\r\n        for(i=0; i<m; i++) {\r\n            int x, y;\r\n            scanf("%d %d", &x, &y);\r\n            x--; y--;\r\n            edges[i][0] = x;\r\n            edges[i][1] = y;\r\n            incoming[y] = 1;\r\n        }\r\n        qsort(edges, m, sizeof(edges[0]), comp);\r\n        memset(se,-1,sizeof(se));\r\n        for(i=m-1; i>=0; i--) {\r\n            se[edges[i][0]] = i;\r\n        }\r\n        cnt = 0;\r\n        for(i=0; i<n; i++) dfs(i);\r\n        for(i=0; i<n; i++) nums[i] = i;\r\n        qsort(nums, n, sizeof(nums[0]), fincomp);\r\n        for(i=0; i<n; i++) {\r\n            if(!toppled[nums[i]]) {\r\n                cnt++;\r\n                topple(nums[i]);\r\n            }\r\n        }\r\n        printf("%d\\n", cnt);\r\n    }\r\n}\r\n', '', 218, 25608192, 1, 1, '2010-08-18 21:00:24', '0001-01-01 00:00:00'),
(180, 1, 163, 0, '#include <math.h>\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#define EPS 0.0000001\r\n\r\nchar buf[100000];\r\nchar fd[200][30];\r\nchar lt[200][30];\r\n\r\ndouble X, Y;\r\n\r\ndouble HD;\r\n\r\nvoid FD(int d) {\r\n    X += d*cos(HD/180*M_PI);\r\n    Y += d*sin(HD/180*M_PI);\r\n    //printf("FD %d to %lf %lf\\n", d, X, Y);\r\n}\r\n\r\nvoid LT(int d) {\r\n    HD+=d;\r\n}\r\n\r\nvoid HOME() {\r\n    HD = 0;\r\n    X = 0;\r\n    Y = 0;\r\n}\r\n\r\nint myatoi(char* st, int other) {\r\n    if(st[0] == ''?'') return other;\r\n    return atoi(st);\r\n}\r\n\r\n\r\n\r\nint main() {\r\n    int CASES;\r\n    scanf("%d ", &CASES);\r\n    while(CASES--) {\r\n        int cnt;\r\n        int i;\r\n        int turn = 0;\r\n        int cmds;\r\n        scanf("%d", &cmds);\r\n        HOME();\r\n        while(cmds--) {\r\n            int dist;\r\n            scanf("%s %d\\n", buf, &dist);\r\n            switch(buf[0]) {\r\n                case ''f'': FD(dist); break;\r\n                case ''b'': FD(-dist); break;\r\n                case ''l'': LT(dist); break;\r\n                case ''r'': LT(-dist); break;\r\n            }\r\n        }\r\n        printf("%.0lf\\n", sqrt(X*X+Y*Y));\r\n    }\r\n}\r\n', '', 31, 372736, 1, 2, '2010-08-18 21:00:24', '0001-01-01 00:00:00'),
(181, 1, 164, 0, '#include <stdio.h>\r\n\r\n#define ROUND 0\r\nint cad[10000];\r\nint usd[10000];\r\n\r\ndouble rate[10000];\r\n\r\nint initcad = 100000;\r\nint initusd = 0;\r\ndouble commission = .03;\r\n\r\ndouble max(double a, double b, double c) {\r\n    if(a>=b && a>=c) return a;\r\n    if(b>=c) return b;\r\n    return c;\r\n}\r\n\r\nmain() {\r\n    int n, i;\r\n    while(1) {\r\n    scanf("%d", &n);\r\n    if(!n) break;\r\n    for(i = 0; i < n; i++) {\r\n        scanf("%lf", rate + i);\r\n    }\r\n\r\n    for(i = 0; i < n; i++) {\r\n        cad[i+1] = max(initcad + initusd*rate[i]*(1-commission) + ROUND,\r\n                cad[i], usd[i]*rate[i]*(1-commission) + ROUND);\r\n        usd[i+1] = max(initusd + initcad/rate[i]*(1-commission) + ROUND,\r\n                usd[i], cad[i]/rate[i]*(1-commission) + ROUND);\r\n        //printf("%d %d\\n", usd[i+1], cad[i+1]);\r\n    }\r\n\r\n    printf("%01d.%02d\\n", cad[n]/100, cad[n]%100);\r\n    }\r\n}', '', 15, 421888, 1, 2, '2010-08-18 22:06:38', '0001-01-01 00:00:00'),
(182, 1, 165, 0, '#include <algorithm>\r\n#include <iostream>\r\n#include <map>\r\n#include <vector>\r\nusing namespace std;\r\n\r\nmain() {\r\n  int n;\r\n  while (cin >> n && n) {\r\n    int mx = 0, ret = 0;\r\n    map<vector<int>, int> num_students;\r\n    for (int i = 0; i < n; i++) {\r\n      vector<int> v(5);\r\n      for (int j = 0; j < 5; j++) cin >> v[j];\r\n      sort(v.begin(), v.end());\r\n      mx =max(mx, ++num_students[v]);\r\n    }\r\n    for (map<vector<int>, int>::iterator it = num_students.begin();\r\n         it != num_students.end();\r\n         ++it) {\r\n      if (it->second == mx) ret += mx;\r\n    }\r\n    cout << ret << endl;\r\n  }\r\n}', '', 499, 1204224, 1, 2, '2010-08-18 22:06:40', '0001-01-01 00:00:00'),
(183, 1, 166, 0, '#include <stdio.h>\r\n\r\n\r\n\r\nint isprime(long long p) {\r\n\r\n    long long i;\r\n\r\n    for(i = 2; i*i <= p; i++) {\r\n\r\n        if(p%i == 0) return 0;\r\n\r\n    }\r\n\r\n    return 1;\r\n\r\n}\r\n\r\nmain() {\r\n\r\n    while(1) {\r\n\r\n        long long p, a, ap, pp, aa;\r\n\r\n\r\n\r\n        scanf("%lld %lld", &p, &a);\r\n\r\n        if(p == 0) break;\r\n\r\n        if(isprime(p)) {\r\n\r\n            puts("no");\r\n\r\n            continue;\r\n\r\n        }\r\n\r\n        ap = 1;\r\n\r\n        pp = p;\r\n\r\n        aa = a;\r\n\r\n        while(pp) {\r\n\r\n            if(pp&1) ap*= aa;\r\n\r\n            ap %= p;\r\n\r\n            aa = (aa*aa)%p;\r\n\r\n            pp >>= 1;\r\n\r\n        }\r\n\r\n        //printf("%lld %lld\\n", ap%p, a);\r\n\r\n        if(ap%p == a) puts("yes"); else puts("no");\r\n\r\n    }\r\n\r\n}', '', 0, 258048, 1, 2, '2010-08-18 22:06:40', '0001-01-01 00:00:00'),
(184, 1, 167, 0, '#include <iostream>\r\n#include <memory.h>\r\n#include <algorithm>\r\nusing namespace std;\r\n\r\nlong long d[17][17];\r\nlong long carcost[32768];\r\nlong long cost[32768], cost2[32768];\r\n\r\nint main() {\r\n  int i, j, k, x, y, z, n, m;\r\n	while (cin >> n >> m) {\r\n	  for (i = 0; i <= n+1; i++)\r\n		for (j = 0; j <= n+1; j++)\r\n		  d[i][j] = (i==j) ? 0 : 1000000000000LL;\r\n    for (i = 0; i < m; i++) {\r\n		  cin >> x >> y >> z;\r\n			d[x][y] =min(d[x][y],(long long)z);\r\n			d[y][x]= min(d[y][x],(long long)z);\r\n		}\r\n	  for (k = 0; k <= n+1; k++)\r\n	  for (i = 0; i <= n+1; i++)\r\n		for (j = 0; j <= n+1; j++)\r\n		  d[i][j] = min( d[i][k] + d[k][j],d[i][j]);\r\n		for (i = 0; i < (1<<n); i++)\r\n		  cost[i] = cost2[i] = carcost[i] = 1000000000000LL;\r\n		for (int a1 = 1; a1 <= n; a1++)\r\n		for (int a2 = 1; a2 <= n; a2++)\r\n		for (int a3 = 1; a3 <= n; a3++)\r\n		for (int a4 = 1; a4 <= n; a4++)\r\n		for (int a5 = 1; a5 <= n; a5++)\r\n		  carcost[((1<<a1)|(1<<a2)|(1<<a3)|(1<<a4)|(1<<a5)) >> 1] =min(  carcost[((1<<a1)|(1<<a2)|(1<<a3)|(1<<a4)|(1<<a5)) >> 1],\r\n			  d[0][a1] + d[a1][a2] + d[a2][a3] + d[a3][a4] + d[a4][a5] + d[a5][n+1] +\r\n				5 * (1 + (a2 != a1) + (a3 != a2) + (a4 != a3) + (a5 != a4)));\r\n    cost[0] = 0;\r\n    for (i = 0; i < (n+4)/5; i++) {\r\n		  for (j = 0; j < (1<<n); j++) if (carcost[j] < 1000000000000LL)\r\n			for (k = (1<<n)-1; (k &= ~j) >= 0; k--)\r\n			  cost2[k|j] =min(cost2[k|j], max(cost[k], carcost[j]));\r\n      memcpy(cost, cost2, sizeof(cost));\r\n		}\r\n		cout << cost[(1<<n)-1] << endl;\r\n	}\r\n	return 0;\r\n}', '', 0, 1155072, 1, 2, '2010-08-18 22:06:40', '0001-01-01 00:00:00'),
(185, 1, 168, 0, '#include <stdio.h>\r\n\r\nint w[11000];\r\nint a[11000];\r\nint b[11000];\r\n\r\nmain() {\r\n    int n;\r\n    int i, j;\r\n    scanf("%d", &n);\r\n    for(i = 0; i<n; i++) {\r\n        scanf("%d", w+i);\r\n    }\r\n    for(i = n-1; i >=0; i--) {\r\n        for(j=i+1; j <= n; j++) {\r\n            if(j==n || w[j] > w[i]) {\r\n                int nw = a[j]+1;\r\n                if(nw > a[i]) a[i] = nw;\r\n            }\r\n            if(j == n || w[j] < w[i]) {\r\n                int nw = b[j]+1;\r\n                if(nw > b[i]) b[i] = nw;\r\n            }\r\n        }\r\n    }\r\n    int max = 0;\r\n    for(i=0; i<n; i++) {\r\n        /*printf("%d %d %d\\n", w[i], a[i], b[i]);*/\r\n        int nw = a[i] + b[i] - 1;\r\n        if(nw > max) max = nw;\r\n    }\r\n    printf("%d\\n", max);\r\n}\r\n', '', 15, 393216, 1, 2, '2010-08-18 22:09:06', '0001-01-01 00:00:00'),
(186, 1, 169, 0, 'using namespace std;\r\n#include <algorithm>\r\n#include <stdlib.h>\r\n#include <bitset>\r\n#include <vector>\r\n#include <stdio.h>\r\n#include <iostream>\r\n\r\n#define MAX 11000\r\n//#define MAX 11\r\n\r\nbitset<MAX> seen;\r\nint es[MAX][2];\r\nint ei[MAX];\r\nvector<int> topo;\r\nint dd[MAX];\r\nint uu[MAX];\r\n\r\nvoid dfs(int i) {\r\n    int j;\r\n    if(seen[i]) return;\r\n    seen[i] = 1;\r\n    for(j = ei[i]; es[j][0] == i; j++) {\r\n        dfs(es[j][1]);\r\n    }\r\n    topo.push_back(i);\r\n}\r\nint comp(const void* aa, const void* bb) {\r\n    int* a = (int*) aa;\r\n    int* b = (int*) bb;\r\n    if(a[0] != b[0]) return a[0]-b[0];\r\n    return a[1] - b[1];\r\n}\r\nbitset<MAX> bounds[MAX];\r\n\r\nint l,r,u,d,a;\r\nint glb(int x, int y) {\r\n    int i;\r\n    bitset<MAX> all = bounds[x] & bounds[y];\r\n    for(i=0; i < topo.size(); i++) {\r\n        if(all[topo[i]]) return topo[i];\r\n    }\r\n    printf("no glb for %u %u\\n", x,y);\r\n    cout << bounds[x] << endl;\r\n    cout << bounds[y] << endl;\r\n    cout << all << endl;\r\n    exit(1);\r\n}\r\n\r\nmain() {\r\n    int i,j;\r\n    scanf("%u%u%u%u%u", &l, &r, &u, &d, &a);\r\n    for(i = 0; i < r; i++) {\r\n        scanf("%u%u", &(es[i][0]), &(es[i][1]));\r\n    }\r\n    qsort(es, r, sizeof(es[0]), comp);\r\n    /*\r\n    for(i = 0; i < r; i++) {\r\n        printf("%u %u\\n", es[i][0], es[i][1]);\r\n    }\r\n    */\r\n    j = 0;\r\n    for(i = 0; i < r; i++) {\r\n        while(j <= es[i][0]) {\r\n            ei[j] = i;\r\n            j++;\r\n        }\r\n    }\r\n    for(i=1; i<= l; i++) dfs(i);\r\n    for(i=1; i<= l; i++) bounds[i][i] = 1;\r\n    reverse(topo.begin(), topo.end());\r\n    for(i=0; i < topo.size(); i++) {\r\n        int k = topo[i];\r\n        for(j = ei[k]; es[j][0] == k; j++) {\r\n            bounds[es[j][1]] |= bounds[es[j][0]];\r\n        }\r\n        //cout << k << " " << bounds[k] << endl;\r\n    }\r\n    reverse(topo.begin(), topo.end());\r\n    for(i=1; i<= u; i++) scanf("%u", uu+i);\r\n    for(i=1; i<= d; i++) scanf("%u", dd+i);\r\n    for(i=1; i<= a; i++) {\r\n        char s[1000];\r\n        int x,y;\r\n        scanf("%u %s %u", &x, s, &y);\r\n        int g = glb(uu[x],dd[y]);\r\n        if(s[0] == ''w'') dd[y] = g;\r\n        else uu[x] = g;\r\n        printf("%u\\n", g);\r\n    }\r\n}\r\n', '', 2636, 16510976, 1, 2, '2010-08-18 22:09:06', '0001-01-01 00:00:00'),
(187, 1, 170, 0, '#define deb 0\r\n#include <stdlib.h>\r\n#include <algorithm>\r\n#include <stdio.h>\r\n#include <queue>\r\n#include <set>\r\n#include <string>\r\nusing namespace std;\r\ntypedef string board;\r\n\r\n#define B(b,i,j) b[((i)*4)+(j)]\r\n\r\ntypedef struct {\r\n    board b;\r\n    int moves;\r\n} mboard;\r\n\r\nint bad(board b) {\r\n    int j;\r\n    for(int i = 0; i < 3; i++) for(j = 0; j < 4; j++) {\r\n        if(B(b,i,j) == ''R'' || B(b,i,j) == ''B'')\r\n            if(B(b,i+1,j) == ''R'' || B(b,i+1,j) == ''B'')\r\n                return 1;\r\n    }\r\n    for(int i = 0; i < 4; i++) for(j = 0; j < 3; j++) {\r\n        if(B(b,i,j) == ''R'' || B(b,i,j) == ''B'')\r\n            if(B(b,i,j+1) == ''R'' || B(b,i,j+1) == ''B'')\r\n                return 1;\r\n    }\r\n    return 0;\r\n}\r\n\r\nqueue<mboard> q;\r\nset<board> seen;\r\n\r\nvoid print(board b) {\r\n    for(int i = 0; i < 4; i++) {\r\n    for(int j = 0; j < 4; j++) {\r\n        printf("%c", B(b,i,j));\r\n    }\r\n        printf("\\n");\r\n    }\r\n        printf("\\n");\r\n}\r\n\r\nvoid attempt(board b, int moves) {\r\n    if(seen.count(b) > 0) return;\r\n    if(deb) puts("not seen");\r\n    seen.insert(b);\r\n    int s = seen.size();\r\n    if(deb) if((s%1000) == 0) printf("seen: %u q: %u\\n", seen.size(), q.size());\r\n    if(deb) print(b);\r\n    if(bad(b)) return;\r\n    if(deb) puts("not bad");\r\n    mboard m;\r\n    m.b = b;\r\n    m.moves = moves;\r\n    q.push(m);\r\n    if(deb) puts("pushed");\r\n}\r\n\r\nint badd(int i, int di) {\r\n    if(i+di >3) return 1;\r\n    if(i+di <0) return 1;\r\n    return 0;\r\n}\r\nvoid move(board b, int i, int j, int di, int dj, int moves) {\r\n    if(badd(i,di*2)) return;\r\n    if(badd(j,dj*2)) return;\r\n    if(B(b,i,j) == ''.'') return;\r\n    if(B(b,i+di,j+dj) == ''.'') return;\r\n    if(B(b,i+di+di,j+dj+dj) != ''.'') return;\r\n    B(b,i+di+di,j+dj+dj) = B(b,i,j);\r\n    B(b,i,j) = ''.'';\r\n    attempt(b, moves+1);\r\n}\r\nvoid move2(board b, int i, int j, int di, int dj, int moves) {\r\n    if(badd(i,di*3)) return;\r\n    if(badd(j,dj*3)) return;\r\n    if(B(b,i,j) == ''.'') return;\r\n    if(B(b,i+di,j+dj) == ''.'') return;\r\n    if(B(b,i+di+di,j+dj+dj) == ''.'') return;\r\n    if(B(b,i+di+di+di,j+dj+dj+dj) != ''.'') return;\r\n    B(b,i+di+di+di,j+dj+dj+dj) = B(b,i,j);\r\n    B(b,i,j) = ''.'';\r\n    attempt(b, moves+1);\r\n}\r\n\r\nint main() {\r\n    int i,j;\r\n    int pos=0;\r\n    int mb=0;\r\n\r\n    char line[100];\r\n\r\n    board b = "................";\r\n    for(i=0; i<4; i++) {\r\n        gets(line);\r\n        for(j=0; j<4; j++) B(b,i,j) = line[j];\r\n    }\r\n    attempt(b, 0);\r\n    while(q.size() > 0) {\r\n        pos++;\r\n        mboard m = q.front();\r\n        q.pop();\r\n        board b = m.b;\r\n        if(deb) if(m.moves > mb) {\r\n            mb = m.moves;\r\n            printf("moves: %u\\n", mb);\r\n        }\r\n        if(B(b,0,0) == ''R'') {\r\n            printf("%u\\n", m.moves);\r\n            break;\r\n        }\r\n        for(i=0; i < 4; i++) for(j=0; j<4; j++) {\r\n            move(b, i,j,0,1, m.moves);\r\n            move(b, i,j,0,-1, m.moves);\r\n            move(b, i,j,1,0, m.moves);\r\n            move(b, i,j,-1,0, m.moves);\r\n            move2(b, i,j,0,1, m.moves);\r\n            move2(b, i,j,0,-1, m.moves);\r\n            move2(b, i,j,1,0, m.moves);\r\n            move2(b, i,j,-1,0, m.moves);\r\n        }\r\n    }\r\n    if(deb) printf("done %u\\n" , pos);\r\n}\r\n', '', 15, 487424, 1, 2, '2010-08-18 22:09:06', '0001-01-01 00:00:00'),
(188, 1, 171, 0, '#include <stdio.h>\r\n\r\nint M[110];\r\nint P[1100000];\r\n\r\nmain() {\r\n    int i,j,a,b,c,p;\r\n    for(i = 0; i < 110; i++) M[i] = i;\r\n    scanf("%u %u %u", &a, &b, &c);\r\n    for(i = 0; i < a; i++) P[i] = 1;\r\n    while(b--) {\r\n        scanf("%u %u", &i, &j);\r\n        M[i] = j;\r\n    }\r\n    p = 0;\r\n    while(c--) {\r\n        scanf("%u", &i);\r\n        P[p] += i;\r\n        if(P[p] > 100) P[p] = 100;\r\n        P[p] = M[P[p]];\r\n        if(P[p] == 100) break;\r\n        p++;\r\n        p %= a;\r\n    }\r\n    for(i = 0; i < a; i++)\r\n        printf("Position of player %u is %u.\\n", i+1, P[i]);\r\n}\r\n', '', 0, 4665344, 1, 1, '2010-08-18 22:09:06', '0001-01-01 00:00:00');
INSERT INTO `tbl_submitions` (`id`, `user_id`, `problem_id`, `exercise_id`, `source`, `result`, `used_time`, `used_memory`, `status`, `compiler_id`, `created`, `modified`) VALUES
(189, 1, 172, 0, '#include <cmath>\r\n#include <cstdio>\r\n#include <iostream>\r\n#include <vector>\r\nusing namespace std;\r\n\r\nvoid add_tri(double x1, double y1, double x2, double y2,\r\n             double* tot_ar, double* wx) {\r\n  double ar = x1*y2 - x2*y1;\r\n  *tot_ar += ar;\r\n  *wx += ar * (x1+x2)/3.0;\r\n}\r\n\r\ntypedef vector<int> VI;\r\n\r\nmain() {\r\n  int n;\r\n  cin >> n;\r\n  VI x(n), y(n);\r\n  for (int i = 0; i < n; i++) cin >> x[i] >> y[i];\r\n  x.push_back(x[0]); y.push_back(y[0]);\r\n  double tar = 0.0, tx = 0.0, bar = 0.0, bx = 0.0;\r\n  for (int i = 0; i < n; i++) {\r\n    if (y[i] >= 0 && y[i+1] >= 0) {\r\n      add_tri(x[i], y[i], x[i+1], y[i+1], &tar, &tx);\r\n    } else if (y[i] <= 0 && y[i+1] <= 0) {\r\n      add_tri(x[i], y[i], x[i+1], y[i+1], &bar, &bx);\r\n    } else {\r\n      double mx = y[i]*(double)(x[i+1]-x[i])/(y[i]-y[i+1]) + x[i];\r\n      add_tri(x[i], y[i], mx, 0.0, y[i] > 0 ? &tar : &bar,\r\n                                   y[i] > 0 ? &tx : &bx);\r\n      add_tri(mx, 0.0, x[i+1], y[i+1], y[i+1] > 0 ? &tar : &bar,\r\n                                       y[i+1] > 0 ? &tx : &bx);\r\n    }\r\n  }\r\n  tx /= tar; bx /= bar;\r\n  if (fabs(tx-bx) < 1e-6) {\r\n    printf("Balanced.\\n");\r\n  } else if (tx < bx) {\r\n    printf("CE is aft of CLR by %.02lf units.\\n", bx-tx);\r\n  } else {\r\n    printf("CE is forward of CLR by %.02lf units.\\n", tx-bx);\r\n  }\r\n}\r\n', '', 0, 372736, 1, 2, '2010-08-18 22:09:06', '0001-01-01 00:00:00'),
(190, 1, 173, 0, '#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include <string>\r\n#include <set>\r\n#include <map>\r\n#include <vector>\r\nusing namespace std;\r\n\r\n#define FORI(i,s) for (int i=0;i<s.size();i++)\r\n#define BEND(x) (x).begin(),(x).end()\r\n#define FORALL(it,st) for(typeof(st.begin())it=st.begin();it!=st.end();it++)\r\n\r\nvoid docase() {\r\n char proj[32768], foo[32768];\r\n vector<string> prj;\r\n vector<set<string> > dudes;\r\n map<string,int> occurs;\r\n while (1) {\r\n  gets(proj);\r\n  hax:\r\n  if (proj[0] == ''0'') exit(0);\r\n  if (proj[0] == ''1'') break;\r\n  set<string> me;\r\n  prj.push_back(string(proj));\r\n  while (1) {\r\n   gets(foo);\r\n   if (!islower(foo[0])) {\r\n    strcpy(proj,foo);\r\n    dudes.push_back(me);\r\n    for(set<string>::iterator it=me.begin();it!=me.end();++it) occurs[*it]++;\r\n    goto hax;\r\n   }\r\n   me.insert(string(foo));\r\n  }\r\n }\r\n set<pair<int,string> > ans;\r\n FORI(i,prj) {\r\n  int j=0;\r\n  for(set<string>::iterator it=dudes[i].begin();it!=dudes[i].end();++it) j += occurs[*it] == 1;\r\n  ans.insert(make_pair(-j,prj[i]));\r\n }\r\n for(set<pair<int,string> >::iterator it=ans.begin();it!=ans.end();++it) printf("%s %i\\n", it->second.c_str(), -it->first);\r\n}\r\n\r\nint main() {\r\n while (1) docase();\r\n}\r\n', '', 31, 897024, 1, 2, '2010-08-18 22:11:07', '0001-01-01 00:00:00'),
(191, 1, 174, 0, '#include <stdio.h>\r\n#include <memory.h>\r\n\r\nint seq[40000];\r\nint dyn[40000];\r\n\r\nmain() {\r\n    int i;\r\n    int sgn;\r\n    int count;\r\n    int n;\r\n    int j;\r\n\r\n    scanf("%d", &count);\r\n    while(count--) {\r\n        scanf("%d", &n);\r\n        for(i = 0; i < n; i++) scanf("%d", seq+i);\r\n        memset(dyn, 0, sizeof(dyn));\r\n        dyn[1] = seq[0];\r\n        sgn = -1;\r\n        for(i=1; i < n; i++) {\r\n            if(dyn[1] < seq[i]) dyn[1] = seq[i];\r\n            for(j = 1; dyn[j]; j++) {\r\n                if(j&1) {\r\n                    if(dyn[j]>seq[i])\r\n                        if(dyn[j+1]==0 || dyn[j+1]>seq[i]) dyn[j+1] = seq[i];\r\n                } else {\r\n                    if(dyn[j]<seq[i])\r\n                        if(dyn[j+1]==0 || dyn[j+1]<seq[i]) dyn[j+1] = seq[i];\r\n                }\r\n            }\r\n        }\r\n        for(j=1; dyn[j]; j++);\r\n        printf("%d\\n", j-1);\r\n    }\r\n}\r\n', '', 16910, 581632, 1, 1, '2010-08-18 22:11:07', '0001-01-01 00:00:00'),
(192, 1, 175, 0, '#include <stdio.h>\r\n#include <math.h>\r\n#include <assert.h>\r\n\r\nchar a,b;\r\ndouble A,B,temp,hum,dew;\r\n\r\ndouble dohum(double tt,double dd){\r\n   double e = 6.11 * exp (5417.7530 * ((1/273.16) - (1/(dd+273.16))));\r\n   double h = (0.5555)*(e - 10.0);\r\n   return tt + h;\r\n}\r\n\r\ndouble dotemp(){\r\n   double e = 6.11 * exp (5417.7530 * ((1/273.16) - (1/(dew+273.16))));\r\n   double h = (0.5555)*(e - 10.0);\r\n   return hum - h;\r\n}\r\n\r\ndouble dodew(){\r\n   double x = 0;\r\n   double delta=100;\r\n   for (delta=100;delta>.00001;delta *=.5) {\r\n      if (dohum(temp,x) > hum) x -= delta;\r\n      else x += delta;\r\n   }\r\n   return x;\r\n}\r\n\r\nmain(){\r\n   while (4 == scanf(" %c %lf %c %lf",&a,&A,&b,&B) && a != ''E''){\r\n      temp = hum = dew = -99999;\r\n      if (a == ''T'') temp = A;\r\n      if (a == ''H'') hum = A;\r\n      if (a == ''D'') dew = A;\r\n      if (b == ''T'') temp = B;\r\n      if (b == ''H'') hum = B;\r\n      if (b == ''D'') dew = B;\r\n      if (hum == -99999) hum = dohum(temp,dew);\r\n      if (dew == -99999) dew = dodew();\r\n      if (temp == -99999) temp = dotemp();\r\n      printf("T %0.1lf D %0.1lf H %0.1lf\\n",temp,dew,hum);\r\n   }\r\n   assert(a == ''E'');\r\n}\r\n', '', 0, 258048, 1, 2, '2010-08-18 22:11:08', '0001-01-01 00:00:00'),
(193, 1, 176, 0, '#include <stdio.h>\r\n#include <assert.h>\r\n#include <stdlib.h>\r\n\r\nint i,j,k,m,f,r,front[100],rear[100];\r\ndouble rat[10000];\r\n\r\nint comp(double *a, double *b){\r\n   if (*a > *b) return 1;\r\n   if (*a < *b) return -1;\r\n   return 0;\r\n}\r\n\r\nint main(){\r\n   while (2 == scanf("%d%d",&f,&r) && f){\r\n      double best=1;\r\n      k = 0;\r\n      for (i=0;i<f;i++) scanf("%d",&front[i]);\r\n      for (i=0;i<r;i++) scanf("%d",&rear[i]);\r\n      for (i=0;i<f;i++) for (j=0;j<r;j++) {\r\n         rat[k++] = (double)rear[j]/front[i];\r\n      }\r\n      qsort(rat,k,sizeof(double),comp);\r\n      //for (i=0;i<k;i++) printf("%0.4lf\\n",rat[i]);\r\n      for (i=0;i+1<k;i++) {\r\n         if (rat[i+1]/rat[i] > best) best = rat[i+1]/rat[i];\r\n      }\r\n      printf("%0.2lf\\n",best);\r\n   }\r\n   //assert (f == 0);\r\n}\r\n', '', 0, 339968, 1, 1, '2010-08-18 22:11:08', '0001-01-01 00:00:00'),
(194, 1, 177, 0, '#include <stdio.h>\r\n#include <math.h>\r\n#include <assert.h>\r\n\r\n#define N 1000\r\n\r\ndouble x[100], y[100], xx, yy, base,scale;\r\nint rep,n,i,j,k,T;\r\n\r\nint main(){\r\n   double minx, maxx, miny, maxy, dx, dy, dd, best; int besti;\r\n   scanf("%d\\n",&T);\r\n   while (T--) {\r\n      assert (1 == scanf("%d",&n));\r\n      for (i=0;i<n;i++) scanf("%lf%lf",&x[i],&y[i]);\r\n      best = 1000;\r\n      base = 0; scale=1;\r\n      for (rep=0;rep<10;rep++) {\r\n         besti = 0;\r\n         for (i=0;i<N;i++) {\r\n            double sininc = sin(base+scale*i*M_PI/2/N);\r\n            double cosinc = cos(base+scale*i*M_PI/2/N);\r\n            maxx = maxy = -1e99; minx = miny = 1e99;\r\n            for (j=0;j<n;j++){\r\n               xx = cosinc*x[j] - sininc*y[j];\r\n               yy = sininc*x[j] + cosinc*y[j];\r\n               //printf("x y xx yy %lg %lg %lg %lg\\n",x[j],y[j],xx,yy);\r\n               if (xx < minx) minx = xx;\r\n               if (xx > maxx) maxx = xx;\r\n               if (yy < miny) miny = yy;\r\n               if (yy > maxy) maxy = yy;\r\n            }\r\n            dx = maxx - minx;\r\n            dy = maxy - miny;\r\n            dd = dx;\r\n            if (dy > dd) dd = dy;\r\n            if (dd < best) {\r\n               best = dd;\r\n               besti = i;\r\n            }\r\n            //printf("i %d dd %0.5lf\\n",i,dd);\r\n         }\r\n         base += scale*(besti-1)*M_PI/2/N;\r\n         scale = scale/N*2;\r\n      }\r\n      printf("%0.2lf\\n",best*best);\r\n   }\r\n   //assert(1 != scanf(" %c",&i));\r\n}\r\n', '', 187, 262144, 1, 2, '2010-08-18 22:11:08', '0001-01-01 00:00:00'),
(195, 1, 178, 0, '#include <iostream>\r\n#include <memory.h>\r\nusing namespace std;\r\n\r\nbool isp[1000002];\r\nint semi[1000002];\r\n\r\nmain() {\r\n  int x, y, n;\r\n  memset(isp, true, sizeof(isp));\r\n  isp[1] = false;\r\n  for( x = 1; x <= 1001; x += 4 ) if( isp[x] )\r\n    for( y = x*x; y <= 1000001; y += 4*x )\r\n      isp[y] = false;\r\n  for( x = 1; x <= 1001; x += 4 ) if( isp[x] )\r\n    for( y = x; x*y <= 1000001; y += 4 ) if( isp[y] )\r\n      semi[x*y] = 1;\r\n  for( x = 5; x <= 1000001; x += 4 ) semi[x] += semi[x-4];\r\n  while( cin >> n && n ) cout << n << '' '' << semi[n] << endl;\r\n}\r\n', '', 31, 5373952, 1, 2, '2010-08-18 22:37:37', '0001-01-01 00:00:00'),
(196, 1, 179, 0, '#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\nstruct point {\r\n    int x;\r\n    int y;\r\n    int v;\r\n    int h;\r\n};\r\nstruct point p[110000];\r\n\r\nstruct point *pv[110000];\r\nstruct point *ph[110000];\r\nint pts;\r\n\r\nint comp1(const struct point** p1, const struct point** p2) {\r\n    if((*p1)->x != (*p2)->x) return (*p1)->x - (*p2)->x;\r\n    return (*p1)->y - (*p2)->y;\r\n}\r\nint comp2(const struct point** p1, const struct point** p2) {\r\n    if((*p1)->y != (*p2)->y) return (*p1)->y - (*p2)->y;\r\n    return (*p1)->x - (*p2)->x;\r\n}\r\nint findv(struct point* pp) {\r\n    struct point** ret = bsearch(&pp, pv, pts, sizeof(pv[0]), comp1);\r\n    //printf("%p\\n", ret);\r\n    return ret - pv;\r\n}\r\nint findh(struct point* pp) {\r\n    struct point** ret = bsearch(&pp, ph, pts, sizeof(ph[0]), comp2);\r\n    //printf("%p\\n", ret);\r\n    return ret - ph;\r\n}\r\n\r\nmain() {\r\n    int cases;\r\n    int i;\r\n    int x;\r\n    int y;\r\n    scanf("%d", &cases);\r\n    while(cases--) {\r\n        scanf("%d", &pts);\r\n        for(i = 0; i < pts; i++) {\r\n            scanf("%d %d", &x, &y);\r\n            p[i].x = x;\r\n            p[i].y = y;\r\n            pv[i] = &p[i];\r\n            ph[i] = &p[i];\r\n        }\r\n        qsort(pv, pts, sizeof(pv[0]), comp1);\r\n        qsort(ph, pts, sizeof(ph[0]), comp2);\r\n        if(pts % 2) goto impossible;\r\n        for(i = 0; i < pts; i+=2) {\r\n            pv[i]->v = 1;\r\n            pv[i+1]->v = -1;\r\n            if(pv[i]->x != pv[i+1]->x) goto impossible;\r\n            ph[i]->h = 1;\r\n            ph[i+1]->h = -1;\r\n            if(ph[i]->y != ph[i+1]->y) goto impossible;\r\n        }\r\n        int j = 0;\r\n        int len = 0;\r\n        for(i = 0; i < pts; i+=2) {\r\n            //printf("%d %d\\n", p[j].x, p[j].y);\r\n            int h = findh(p+j);\r\n            int oldh = h;\r\n            if(p[j].h == 1) h++; else h--;\r\n            len += abs(ph[h]->x- ph[oldh]->x);\r\n            //printf("%d\\n", abs(ph[h]->x- ph[oldh]->x));\r\n            j = ph[h] - p;\r\n            //printf("%d %d\\n", p[j].x, p[j].y);\r\n            int v = findv(p+j);\r\n            int oldv = v;\r\n            if(p[j].v == 1) v++; else v--;\r\n            len += abs(pv[v]->y- pv[oldv]->y);\r\n            //printf("%d\\n", abs(pv[v]->y- pv[oldv]->y));\r\n            j = pv[v] - p;\r\n            if(j == 0 && i != pts-2) goto impossible;\r\n        }\r\n        printf("%d\\n", len);\r\n        continue;\r\nimpossible:\r\n        printf("-1\\n");\r\n    }\r\n}\r\n\r\n', '', 31, 2904064, 1, 1, '2010-08-18 22:37:37', '0001-01-01 00:00:00'),
(197, 1, 180, 0, '#include <stdio.h>\r\n#include <string.h>\r\n#include <stdlib.h>\r\n\r\nchar buf[1024*1024];\r\nchar *p[1024*1024];\r\nchar cnt[1024];\r\nchar *prev;\r\n\r\nint i,j,k,n,c,z,best,done;\r\n\r\ncomp (char **a, char **b){\r\n   return strcmp(*a,*b);\r\n}\r\n\r\ncommon (char *a, char *b){\r\n   int i;\r\n   for (i=0;a[i] && a[i] == b[i];i++);\r\n   return i;\r\n}\r\n\r\nmain(){\r\n   while (1 == scanf("%d",&n) && n) {\r\n      if (done++) printf("\\n");\r\n      for (i=k=0;i<n;i++) {\r\n         scanf("%s",buf+i*1024);\r\n         for (j=0;buf[i*1024+j];j++) {\r\n            p[k++] = buf+i*1024+j;\r\n         }\r\n      }\r\n      qsort(p,k,sizeof(char *),comp);\r\n      memset(cnt,0,sizeof(cnt));\r\n      best = 0;\r\n      for (i=j=c=0;i<k;) {\r\n         while (c <= n/2 && i<k) {\r\n            if (!cnt[(p[i++]-buf)/1024]++) c++;\r\n         }\r\n         while (c > n/2) {\r\n            if (!--cnt[(p[j++]-buf)/1024]) c--;\r\n         }\r\n         if (j && common(p[j-1],p[i-1]) > best) {\r\n            best = common(p[j-1],p[i-1]); \r\n         }\r\n      }\r\n      if (!best) {\r\n         printf("?\\n");\r\n         continue;\r\n      }\r\n      memset(cnt,0,sizeof(cnt));\r\n      prev = "";\r\n      for (i=j=c=0;i<k;) {\r\n         while (c <= n/2 && i<k) {\r\n            if (!cnt[(p[i++]-buf)/1024]++) c++;\r\n         }\r\n         while (c > n/2) {\r\n            if (!--cnt[(p[j++]-buf)/1024]) c--;\r\n         }\r\n         if (j && common(p[j-1],p[i-1]) == best) {\r\n            if (strncmp(prev,p[j-1],best)) {\r\n               prev = p[j-1];\r\n               //printf("%5d %5d ",j-1,i-1);\r\n               for (z=0;z<best;z++) printf("%c",p[j-1][z]);\r\n               printf("\\n");\r\n            }\r\n         }\r\n      }\r\n   }\r\n   if (n) printf("missing input delimiter\\n");\r\n}\r\n', '', 340, 5513216, 1, 1, '2010-08-18 22:37:37', '0001-01-01 00:00:00'),
(198, 1, 181, 0, '#include <string.h>\r\n\r\nchar buf[10*1024*1024];\r\n\r\nchar C[255];\r\n\r\n#define F(x) for(C[x]=0; C[x]<2; C[x]++)\r\n\r\nint eval(int i) {\r\n    if(buf[i] == ''N'') return -eval(i+1);\r\n    if(buf[i] == ''K'') {\r\n        int x = eval(i+1);\r\n        int y = eval(abs(x));\r\n        if(x > 0) return y; else return -abs(y);\r\n    }\r\n    if(buf[i] == ''A'') {\r\n        int x = eval(i+1);\r\n        int y = eval(abs(x));\r\n        if(x < 0) return y; else return abs(y);\r\n    }\r\n    if(buf[i] == ''C'') {\r\n        int x = eval(i+1);\r\n        int y = eval(abs(x));\r\n        if(x<0 && y>0) return -abs(y); else return abs(y);\r\n    }\r\n    if(buf[i] == ''E'') {\r\n        int x = eval(i+1);\r\n        int y = eval(abs(x));\r\n        if(x<0 && y<0) return abs(y);\r\n        if(x>0 && y>0) return abs(y);\r\n        return -abs(y);\r\n    }\r\n    if(C[buf[i]]) return i+1; else return -(i+1);\r\n}\r\nmain() {\r\n    while(1) {\r\n        gets(buf);\r\n        if(buf[0] == ''0'') break;\r\n        F(''p'') F(''q'') F(''r'') F(''s'') F(''t'')\r\n        {\r\n            if(eval(0) <0) goto not;\r\n        }\r\n        puts("tautology");\r\n        continue;\r\nnot:\r\n        puts("not");\r\n    }\r\n}\r\n', '', 15, 10768384, 1, 1, '2010-08-18 22:37:37', '0001-01-01 00:00:00'),
(199, 1, 182, 0, '#include <stdio.h>\r\n#include <string.h>\r\n#include <assert.h>\r\n#include <math.h>\r\n\r\nint g[2048][2048], d[2048][2048], qx[2048*2048], qy[2048*2048];\r\nint qn,i,p,x,y,xx,yy,X,Y;\r\n\r\nint try(a,b){\r\n   if (qx[i]+a > 2000) return;\r\n   if (qx[i]+a < 0) return;\r\n   if (qy[i]+b > 2000) return;\r\n   if (qy[i]+b < 0) return;\r\n   if (d[qx[i]+a][qy[i]+b] > d[qx[i]][qy[i]]+1) {\r\n      d[qx[i]+a][qy[i]+b] = d[qx[i]][qy[i]]+1; \r\n      qx[qn] = qx[i]+a;\r\n      qy[qn++] = qy[i]+b;\r\n   }\r\n}\r\n\r\nmain(){\r\n   while (1 == scanf("%d",&p) && p) {\r\n      memset(g,0,sizeof(g));\r\n      memset(d,100,sizeof(d));\r\n      qn = 0;\r\n      for (i=0;i<p;i++) {\r\n         scanf("%d %d",&x,&y);\r\n         if (g[x][y] ) printf("dupe!! %d %d\\n",x,y);\r\n         if (i && abs(x-xx) + abs(y-yy) != 1) printf("oops! %d %d\\n",x,y);\r\n         if (!i) {X=x;Y=y;}\r\n         xx = x; yy = y;\r\n         g[x][y] = 1;\r\n         d[x][y] = 0;\r\n         qx[qn] = x;\r\n         qy[qn++] = y;\r\n      }\r\n      if (abs(x-X) + abs(y-Y) != 1) printf("oop! doesn''t return\\n");\r\n      assert(1 == scanf("%d",&p) && p);\r\n      for (i=0;i<p;i++) {\r\n         scanf("%d %d",&x,&y);\r\n         if (g[x][y] ) printf("dupe!! %d %d\\n",x,y);\r\n         if (i && abs(x-xx) + abs(y-yy) != 1) printf("oops! %d %d\\n",x,y);\r\n         if (!i) {X=x;Y=y;}\r\n         xx = x; yy = y;\r\n         g[x][y] = 2;\r\n      }\r\n      if (abs(x-X) + abs(y-Y) != 1) printf("oop! doesn''t return\\n");\r\n      for (i=0;i<qn;i++) {\r\n         if (g[qx[i]][qy[i]] == 2) {\r\n            printf("%d\\n",d[qx[i]][qy[i]]);\r\n            break;\r\n         }\r\n         try(1,0);\r\n         try(0,1);\r\n         try(-1,0);\r\n         try(0,-1);\r\n      }\r\n   }\r\n   if (p) printf("no end of input\\n");\r\n}\r\n', '', 545, 67502080, 1, 1, '2010-08-18 22:41:32', '0001-01-01 00:00:00'),
(200, 1, 183, 0, '#include <stdio.h>\r\n#include <math.h>\r\n#include <assert.h>\r\n\r\n#define N 1000\r\n\r\ndouble s,delta,k,hb,db,hn,dn,h,V,hs,v;\r\n\r\ndouble area(double r, double s) {\r\n   double t = db/2-s;\r\n   double theta = t<r?acos(t/r):0;\r\n   double wedge = theta * r * r;\r\n   double triangles = r * cos(theta) * r * sin(theta);\r\n   //printf("t %lg r %lg s %lg\\n",t,r,s);\r\n   return wedge - triangles;\r\n}\r\n\r\ndouble volume(double s) {\r\n   if (s*2 > db) return V - volume(db-s);\r\n   double vb = area(db/2, s) * hb;\r\n   double vn = area(dn/2, s) * hn;\r\n   double vc = area(db/2, s) + area(dn/2, s);\r\n   int i;\r\n   for (i=1;i<N;i+=2) {\r\n      vc += 4 * area((db + (dn-db)*i/N)/2, s);\r\n   }\r\n   for (i=2;i<N;i+=2) {\r\n      vc += 2 * area((db + (dn-db)*i/N)/2, s);\r\n   }\r\n   vc *= (h-hn-hb)/3/N;\r\n   //printf("vb %lg %lg %lg %lg\\n",vb,vn,vc,vb+vn+vc);\r\n   return vb + vn + vc;\r\n}\r\n\r\nint doit(){\r\n   int hnx = hn, hbx = hb, hx = h, dnx = dn;\r\n   V = 2 * volume(db/2);\r\n   if (k <= hb) {\r\n      hn = 0;\r\n      hb = k;\r\n      h = k;\r\n   } else if (k < h-hn) {\r\n      dn = db + (dn-db) * (k-hb) / (h-hn-hb);\r\n      hn = 0;\r\n      h = k;\r\n   } else {\r\n      hn = hn - h + k;\r\n      h = k;\r\n   }\r\n   v = 2 * volume(db/2);\r\n   hn = hnx; hb = hbx; h = hx; dn = dnx;\r\n   //printf("V %lg v %lg %lg\\n",V,v,dn*area(dn/2,db/2) +\r\n                       //db*area(db/2,db/2));\r\n   s = db/2;\r\n   for (delta=s/2;delta > .00001; delta /=2) {\r\n      if (volume(s) > v) s -= delta;\r\n      else s += delta;\r\n   }\r\n   //printf("%lg %lg %lg %lg\\n",s,volume(s),v,V);\r\n   printf("%0.2lf\\n",s);\r\n}\r\n\r\nint main(){\r\n   while (6 == scanf("%lf%lf%lf%lf%lf%lf",&k,&hb,&db,&hn,&dn,&h)) {\r\n      if (!(k||hb||db||hn||dn||h)) return;\r\n      assert (k>=0);\r\n      assert (k<=h);\r\n      assert (hb>=0); \r\n      assert (hn>=0);\r\n      assert (h >= hb+hn);\r\n      assert (h <=100);\r\n      assert (db <=100);\r\n      assert (dn <= db);\r\n      assert (db >=0); \r\n      assert (dn >=0);\r\n      doit();\r\n   }\r\n   printf("wrong input\\n");\r\n}\r\n', '', 249, 258048, 1, 1, '2010-08-18 22:41:33', '0001-01-01 00:00:00'),
(201, 1, 184, 0, '#include <stdio.h>\r\n#include <string.h>\r\n\r\n#define max(a,b) ((a)>(b)?(a):(b))\r\n#define min(a,b) ((a)<(b)?(a):(b))\r\n\r\nchar x[200],y[200];\r\nint b[200][200];\r\nint nx,ny,i,j,k,m,n;\r\n\r\nmain(){\r\n   while (2 == scanf("%s%s",x,y) && x[0] != ''0'') {\r\n      memset(b,0,sizeof(b));\r\n      nx = strlen(x); ny = strlen(y);\r\n      for (i=0;i<nx;i++) {\r\n         for (j=0;j<ny;j++) {\r\n            if (x[i] == y[j]) b[i+1][j+1] = b[i][j]+1;\r\n            else b[i+1][j+1] = max(b[i][j+1], b[i+1][j]);\r\n         }\r\n      }\r\n      k = min(nx,ny);\r\n      m = b[nx][ny];\r\n      n = max(nx,ny) - m;\r\n      //printf("%d %d %d\\n",k,m,n);\r\n      for (i=0;n;i++) {\r\n         n -= min(n,(n+m)/2);\r\n         m += min(n+m,k-m);\r\n         //printf("%d %d %d\\n",k,m,n);\r\n      }\r\n      printf("%d\\n",i>1?i:1);\r\n   }\r\n   if (strcmp(x,"0") || strcmp(y,"0")) printf("bad input\\n");\r\n}\r\n', '', 0, 421888, 1, 1, '2010-08-18 22:41:33', '0001-01-01 00:00:00'),
(202, 1, 185, 0, '#include <iostream>\n#include <string>\nusing namespace std;\n\nint nseq[20];\n\nstring mth_seq(int n, int m) {\n  if (n == 0) return "";\n  for (int j = 0; j < n; j++)\n    if (nseq[n-j-1] * nseq[j] > m)\n      return "E" + mth_seq(n-j-1, m/nseq[j]) + "S" + mth_seq(j, m%nseq[j]);\n    else\n      m -= nseq[n-j-1] * nseq[j];\n}\n\nmain() {\n  nseq[0] = 1;\n  for (int i = 1; i <= 19; i++) {\n    for (int j = 0; j < i; j++) nseq[i] += nseq[i-j-1] * nseq[j];\n  }\n  int N, M;\n  while ((cin >> N && N) && (cin >> M && M)) {\n    if (M-1 >= nseq[N-1])\n      cout << "ERROR" << endl;\n    else\n      cout << mth_seq(N-1, M-1) << endl;\n  }\n}\n', '', 0, 483328, 1, 2, '2010-08-18 22:44:02', '0001-01-01 00:00:00'),
(203, 1, 186, 0, '#include <stdlib.h>\n\n#include <cstdio>\n#include <string>\nusing namespace std;\n\nbool done;\n\ndouble doit() {\n  char ch;\n  do {ch = getchar();} while (isspace(ch));\n  if (ch == '')'') exit(0);\n  if (ch == ''('') {\n    double p;\n    scanf("%lf", &p);\n    return doit() + (p-(1-p)) * doit();\n  } else {\n    string s;\n    while (!isspace(ch)) {s += ch; ch = getchar();}\n    return atoi(s.c_str());\n  }\n}\n\nmain() {\n  for(;;) {printf("%.2lf\\n", doit()); fflush(stdout);}\n}\n', '', 0, 299008, 1, 2, '2010-08-18 22:44:02', '0001-01-01 00:00:00'),
(204, 1, 187, 0, '#include <iostream>\n#include <queue>\n#include <vector>\nusing namespace std;\n\nmain() {\n  int n, m, x;\n  while (cin >> n >> m && n) {\n    priority_queue<int, vector<int>, greater<int> > dh, kh;\n    for (int i = 0; i < n; i++) {cin >> x; dh.push(x);}\n    for (int i = 0; i < m; i++) {cin >> x; kh.push(x);}\n    long long cost = 0;\n    while (dh.size()) {\n      while (kh.size() && kh.top() < dh.top()) kh.pop();\n      if (!kh.size()) goto fail;\n      cost += kh.top();\n      kh.pop(); dh.pop();\n    }\n    cout << cost << endl;\n    continue;\nfail:\n    cout << "Loowater is doomed!" << endl;\n  }\n}\n', '', 140, 552960, 1, 2, '2010-08-18 22:44:02', '0001-01-01 00:00:00'),
(205, 1, 188, 0, '#include <stdio.h>\r\n\r\nint N,i,j,k,m,l,lp,rp,load,x[100000];\r\nchar b[100000][10];\r\n\r\nmain(){\r\n   scanf("%d",&N);\r\n   while (N--) {\r\n      k = 0;\r\n      scanf("%d%d",&l,&m);\r\n      for (i=0;i<m;i++) {\r\n         scanf("%d%s",&x[i],&b[i]);\r\n      }\r\n      lp=rp=k=0;  l *= 100;\r\n      for(;;){\r\n         if (rp >= m && lp >=m) break;\r\n         k++; load = 0;\r\n         for(;lp<m;lp++) {\r\n            if (b[lp][0] != ''l'') continue;\r\n            if (load + x[lp] <= l) load += x[lp];\r\n            else break;\r\n         }\r\n         if (rp >= m && lp >= m) break;\r\n         k++; load = 0;\r\n         for(;rp<m;rp++) {\r\n            if (b[rp][0] != ''r'') continue;\r\n            if (load + x[rp] <= l) load += x[rp];\r\n            else break;\r\n         }\r\n      }\r\n      printf("%d\\n",k);  again:;\r\n   }\r\n}\r\n', '', 15, 1662976, 1, 1, '2010-08-18 23:03:11', '0001-01-01 00:00:00'),
(206, 1, 189, 0, '#include <stdio.h>\r\n#include <string.h>\r\n\r\nint here,nz,i,j,k,m,n,nt,nn,h[100];\r\nchar buf[100], t[100][100];\r\n\r\nint look(char *s){\r\n   int i;\r\n   for (i=0;i<nt && strcmp(t[i],s);i++);\r\n   if (i == nt) nt++;\r\n   strcpy(t[i],s);\r\n   return i;\r\n}\r\n\r\nstruct nnn {\r\n   int p[52];\r\n} z[100000];\r\n\r\nmain(){\r\n   while (1 == scanf("%d",&n) && n) {\r\n      memset(z,0,sizeof(z));\r\n      nz = 0;\r\n      for (i=0;i<n;i++) {\r\n         scanf("%d",&m);\r\n         for (j=0;j<m;j++) {\r\n            scanf("%s",buf);\r\n            h[j] = look(buf);\r\n         }\r\n         here = 0;\r\n         for (j=m-1;j>=0;j--) {\r\n            if (!z[here].p[h[j]]) z[here].p[h[j]] = ++nz;\r\n            here = z[here].p[h[j]];\r\n         }\r\n      }\r\n      printf("%d\\n",nz);\r\n   }\r\n}\r\n', '', 186, 21106688, 1, 2, '2010-08-18 23:03:13', '0001-01-01 00:00:00'),
(207, 1, 190, 0, '#include <stdio.h>\r\n#include <string.h>\r\n#include <assert.h>\r\n\r\nchar op[101][101];\r\nint i,j,k,n,N,no;\r\n\r\nint eval(int x){\r\n   int i,j;\r\n   int stack[101], n=0;\r\n   for (i=0;i<no;i++){\r\n      if (!strcmp(op[i],"x")) {\r\n         stack[n++] = x;\r\n      } else if (!strcmp(op[i],"+")) {\r\n         stack[n-2] = (stack[n-2]+stack[n-1])%N;\r\n         n--;\r\n      } else if (!strcmp(op[i],"*")) {\r\n         stack[n-2] = ((long long)stack[n-2]*stack[n-1])%N;\r\n         n--;\r\n      } else {\r\n         stack[n++] = atoi(op[i]);\r\n      }\r\n   }\r\n   assert (n == 1);\r\n   return stack[0];\r\n}\r\n      \r\nmain(){\r\n   int x,xx;\r\n   while (2 == scanf("%d%d",&N,&n)&&N) {\r\n      for (i=0;1 == scanf("%s",op[i]) && strcmp(op[i],"%");i++);\r\n      no = i-1;\r\n      x = xx = n;\r\n      for (j=1;;j++) {\r\n         x = eval(x);\r\n         xx = eval(xx);\r\n         xx = eval(xx);\r\n         if (x == xx) {\r\n            for (k=1;x != (xx=eval(xx));k++);\r\n            printf("%d\\n",k);\r\n            break;\r\n         }\r\n      }\r\n   }\r\n}\r\n', '', 202, 270336, 1, 1, '2010-08-18 23:03:13', '0001-01-01 00:00:00'),
(208, 1, 191, 0, '/*\r\nProblem : Point of view in Flatland\r\n\r\nIn Flatland, there are three circular planets: their centers and radii\r\nare given. Find a point in Flatland, from which all three planets appear\r\nto have the same size (same angular diameter). Let''s call such a point\r\nan _isoobservation_ point.\r\n\r\nThe input has several lines.\r\nEach line has nine numbers, three for each planet.\r\n    Each triple has X and Y coordinates of a planet center, and the\r\n    radius of that planet. Each radius is positive.\r\nThe input ends with a line with nine zeros; do not process this line.\r\n\r\nFor each input line, print the X and Y coordinates of an isoobservation\r\npoint in the format shown in the sample; but if there is no such point,\r\nprint "No solution".\r\n\r\nTo simplify the problem you may assume that:\r\n    - The planets'' centers are not all collinear.\r\n    - The planets are totally disjoint.\r\n    - The planets are transparent and non-refractive. That is, a planet\r\n      is visible and has the same apparent shape and size, whether or\r\n      not there''s another planet in front of it.\r\n    - The input data are such that the existence or non-existence of\r\n      such a point is computable, even with slight rounding error. But\r\n      use double-precision, eh?\r\n*/\r\n\r\n/* If there are two isoobservation points, this program prints both. */\r\n\r\n#include <math.h>\r\n#include <stdio.h>\r\n#include <stdbool.h>\r\n\r\nstatic double CenterX[3], CenterY[3], Radius[3];\r\n\r\n\r\n\r\n/* The locus of isoobservation points of two planets is either a line\r\n   or a circle.\r\n   If it''s a line, keep a point on the line and a vector along the line;\r\n   if it''s a circle, keep the center and radius. */\r\ntypedef struct {\r\n    double px, py; /* point on line or center of circle */\r\n    double vx, vy; /* vector along line */\r\n    double ra;     /* radius */\r\n    bool isLine;   /* %%% put last, to workaround GDB bug */\r\n} isolocus;\r\n\r\nstatic void computeIsolocus(int idx1, int idx2, isolocus *il) {\r\n    double ux, uy, dist, rd, t1, t2;\r\n\r\n    il->isLine = Radius[idx1] == Radius[idx2];\r\n    if (il->isLine) {\r\n	/* midpoint is on line */\r\n	il->px = (CenterX[idx1] + CenterX[idx2]) / 2.0;\r\n	il->py = (CenterY[idx1] + CenterY[idx2]) / 2.0;\r\n\r\n	/* vx,vy is difference, rotated 90 degrees\r\n	   (or -90 degrees; don''t care which) */\r\n	il->vx = CenterY[idx1] - CenterY[idx2];\r\n	il->vy = CenterX[idx2] - CenterX[idx1];\r\n    } else {\r\n	/* compute distance and unit delta */\r\n	ux = CenterX[idx2] - CenterX[idx1];\r\n	uy = CenterY[idx2] - CenterY[idx1];\r\n	dist = hypot(ux, uy);\r\n	ux /= dist;\r\n	uy /= dist;\r\n\r\n	/* compute circle radius and center */\r\n	rd = Radius[idx1] * dist;\r\n	t1 = rd / (Radius[idx1] - Radius[idx2]);\r\n	t2 = rd / (Radius[idx1] + Radius[idx2]);\r\n	il->ra = fabs(t1 - t2) / 2.0;\r\n	t1 = (t1 + t2) / 2.0;\r\n	il->px = CenterX[idx1] + t1 * ux;\r\n	il->py = CenterY[idx1] + t1 * uy;\r\n    }\r\n}\r\n\r\n\r\n\r\nstatic void intersectLines(const isolocus *il1, const isolocus *il2) {\r\n    double det, dx, dy, tt, xx, yy;\r\n\r\n    det = il1->vx * il2->vy - il1->vy * il2->vx;\r\n	/* If det==0, the planets are collinear. */\r\n    dx = il1->px - il2->px;\r\n    dy = il1->py - il2->py;\r\n#if 1\r\n    /* These two computations should come out the same. */\r\n    tt = (dx * il2->vy - dy * il2->vx) / det;\r\n    xx = il1->px - tt * il1->vx;\r\n    yy = il1->py - tt * il1->vy;\r\n#else\r\n    tt = (dy * il1->vx - dx * il1->vy) / det;\r\n    xx = il2->px + tt * il2->vx;\r\n    yy = il2->py + tt * il2->vy;\r\n#endif\r\n    printf("%.2f %.2f\\n", xx, yy);\r\n}\r\n\r\nstatic void intersectCircs(const isolocus *il1, const isolocus *il2) {\r\n    double dx, dy, dist, aa, bb, xx, yy;\r\n\r\n    dx = il2->px - il1->px;\r\n    dy = il2->py - il1->py;\r\n    dist = hypot(dx, dy);\r\n    aa = (dist * dist + il1->ra * il1->ra - il2->ra * il2->ra) / (2.0 * dist);\r\n    bb = il1->ra * il1->ra - aa * aa;\r\n    if (bb < 0.0) {\r\n	printf("No solution\\n");\r\n	return;\r\n    }\r\n    bb = sqrt(bb) / dist;\r\n    aa /= dist;\r\n\r\n    xx = il1->px + aa * dx;\r\n    yy = il1->py + aa * dy;\r\n    if (xx - bb * dy<0)\r\n    printf("%.2f %.2f\\n",\r\n	xx + bb * dy, yy - bb * dx);\r\n	else\r\n	printf("%.2f %.2f\\n",\r\n	xx - bb * dy, yy + bb * dx);\r\n	    /* Here dx,dy is rotated. */\r\n}\r\n\r\n\r\n\r\nstatic void doit(void) {\r\n    isolocus il1, il2;\r\n\r\n    computeIsolocus(0, 1, &il1);\r\n    computeIsolocus(0, 2, &il2);\r\n\r\n    if (il1.isLine) {\r\n	if (il2.isLine) {\r\n	    intersectLines(&il1, &il2);\r\n	} else {\r\n	    /* avoid writing intersectLineCirc */\r\n	    computeIsolocus(1, 2, &il1);\r\n	    intersectCircs(&il1, &il2);\r\n	}\r\n    } else {\r\n	if (il2.isLine) {\r\n	    /* avoid writing intersectLineCirc */\r\n	    computeIsolocus(1, 2, &il2);\r\n	}\r\n	intersectCircs(&il1, &il2);\r\n    }\r\n}\r\n\r\nint main(void) {\r\n    while (scanf("%lf %lf %lf %lf %lf %lf %lf %lf %lf",\r\n	&CenterX[0], &CenterY[0], &Radius[0],\r\n	&CenterX[1], &CenterY[1], &Radius[1],\r\n	&CenterX[2], &CenterY[2], &Radius[2]) == 9)\r\n    {\r\n	if (Radius[0] == 0.0) break; /* input delimiter */\r\n	doit();\r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\n/**************************************************************\r\n	Problem: 1293\r\n	User: zhblue\r\n	Language: C++\r\n	Result: Wrong Answer\r\n****************************************************************/\r\n\r\n', '', 0, 258048, 1, 2, '2010-08-18 23:03:13', '0001-01-01 00:00:00'),
(209, 1, 192, 0, '#include <stdio.h>\r\n#include <math.h>\r\n#include <string.h>\r\n#include <assert.h>\r\n\r\nunsigned countl(char *s){\r\n   unsigned r;\r\n   if (strlen(s) == 1) return 1;\r\n   if (s[0] == ''0'') {\r\n      sscanf(s+1,"%lu",&r);\r\n      return 1 + r + countl(s+1);\r\n   }\r\n   r = pow(10,strlen(s+1))+0.1;\r\n   r += (s[0]-''0'') * strlen(s+1) * (pow(10,strlen(s+1)-1)+1e-10);\r\n   r += countl(s+1);\r\n   return r;\r\n}\r\n\r\nunsigned count(char *s){\r\n   unsigned r = 1; char tmp[20];\r\n   if (strlen(s) == 1) return 1;\r\n   for (r=0;r<strlen(s)-1;r++) tmp[r] = ''9'';\r\n   tmp[r] = 0;\r\n   r = count(tmp);\r\n   r += (s[0]-''1'') * strlen(s+1) * (pow(10,strlen(s+1)-1)+1e-10);\r\n   r += countl(s+1);\r\n   return r;\r\n}\r\n\r\nchar x[100], y[100];\r\nunsigned u;\r\n\r\nmain(){\r\n   while (2 == scanf("%s%s",x,y) && x[0] != ''-'') {\r\n      if (x[0] == ''0'') printf("%lu\\n",count(y));\r\n      else {\r\n         sscanf(x,"%lu",&u);\r\n         sprintf(x,"%lu",u-1);\r\n         printf("%lu\\n",count(y)-count(x));\r\n      }\r\n   }\r\n}\r\n', '', 218, 258048, 1, 1, '2010-08-18 23:03:13', '0001-01-01 00:00:00'),
(210, 1, 193, 0, '#include <stdio.h>\r\n#include <assert.h>\r\n#include <stdlib.h>\r\n#include <math.h>\r\n\r\n/* how close to call equal */\r\n#define EPSILON 1E-8\r\n\r\ntypedef struct {\r\n  double x, y;\r\n} Point;\r\n\r\n/* returns 1 if intersect at a point, 0 if not, -1 if the lines coincide */\r\nint intersect_line(Point a, Point b, Point c, Point d, Point *p) {\r\n  Point t;\r\n  double r, s, denom, num1, num2;\r\n  assert((a.x != b.x || a.y != b.y) && (c.x != d.x || c.y != d.y));\r\n  num1 = (a.y - c.y)*(d.x - c.x) - (a.x - c.x)*(d.y - c.y);\r\n  num2 = (a.y - c.y)*(b.x - a.x) - (a.x - c.x)*(b.y - a.y);\r\n  denom = (b.x - a.x)*(d.y - c.y) - (b.y - a.y)*(d.x - c.x);\r\n  if (fabs(denom) >= EPSILON) {\r\n    r = num1 / denom;\r\n    s = num2 / denom;\r\n    if (0-EPSILON <= r && r <= 1+EPSILON && \r\n        0-EPSILON <= s && s <= 1+EPSILON) {\r\n      p->x = a.x + r*(b.x - a.x);\r\n      p->y = a.y + r*(b.y - a.y);\r\n      return 1;\r\n    } else return 0;\r\n  } else {\r\n    if (fabs(num1) >= EPSILON) {\r\n      return 0;\r\n    } else {\r\n      if (a.x > b.x || (a.x == b.x && a.y > b.y)) { t = a; a = b; b = t; }\r\n      if (c.x > d.x || (c.x == d.x && c.y > d.y)) { t = c; c = d; d = t; }\r\n      if (a.x == b.x) { /* vertical lines */\r\n        if (b.y == c.y) { *p = b; return 1;\r\n        } else if (a.y == d.y) { *p = a; return 1;\r\n        } else if (b.y < c.y || d.y < a.y) { return 0;\r\n        } else return -1;\r\n      } else {\r\n        if (b.x == c.x) { *p = b; return 1;\r\n        } else if (a.x == d.x) { *p = a; return 1; \r\n	} else if (b.x < c.x || d.x < a.x) return 0;\r\n        else return -1;\r\n      }\r\n      return -1;\r\n    }\r\n  }\r\n}\r\n\r\nint main () {\r\n  int h, m, s;\r\n  double x[6];\r\n  while (1) {\r\n    for (int i = 1; i < 6; i++) {\r\n      if (scanf("%d:%d:%d",&h,&m,&s) != 3) return 0;\r\n      x[i] = h*3600+m*60+s;\r\n    }\r\n    assert(x[1] < x[2]);\r\n    assert(x[2] < x[3]);\r\n    assert(x[3] < x[4]);\r\n    assert(x[4] < x[5]);\r\n    double y0, y1, y2, y3, y4, y5;\r\n    y0 = y5 = 10000;\r\n    y3 = y5+(x[5]-x[3])/x[5]*(y0-y5);\r\n    y4 = y5+(x[5]-x[4])/x[5]*(y0-y5);\r\n    y2 = y3*x[2]/x[3];\r\n    y1 = y3*x[1]/x[3];\r\n    Point a, b, c, d, r;\r\n    a.x=x[1]; a.y=y1; b.x=x[4]; b.y=y4; c.x=x[2]; c.y=y2; d.x=x[5]; d.y=y5;\r\n    int res = intersect_line(a, b, c, d, &r);\r\n    assert (res == 1);\r\n    char buf[100];\r\n    sprintf(buf, "%.0f",r.x); sscanf(buf,"%d",&s);\r\n    h = s/3600; s %= 3600; m = s/60; s %= 60;\r\n    printf("%02d:%02d:%02d\\n",h,m,s);\r\n  }\r\n  return 0;\r\n}\r\n', '', 0, 258048, 1, 2, '2010-08-18 23:16:51', '0001-01-01 00:00:00'),
(211, 1, 194, 0, '#include <stdio.h>\r\n#include <string.h>\r\n#include <assert.h>\r\n\r\nint board[200][200];\r\nint visit[200][200];\r\n#define b(i,j) board[(i)+100][(j)+100]\r\n#define v(i,j) visit[(i)+100][(j)+100]\r\n\r\nint i,j,k,m,n,x,y,z,cookie = 1;\r\nchar P;\r\n\r\ndump(){\r\n   int i,j;\r\n   for (i=-z;i<=z;i++) {\r\n      for (j=-z;j<=z;j++) {\r\n         if (b(i,j)) printf("%c",b(i,j));\r\n         else printf("+");\r\n      }\r\n      printf("\\n");\r\n   }\r\n   printf("\\n");\r\n   return;\r\n   for (i=-z;i<=z;i++) {\r\n      for (j=-z;j<=z;j++) {\r\n         printf("%3d",v(i,j));\r\n      }\r\n      printf("\\n");\r\n   }\r\n   printf("\\n");\r\n}\r\n\r\ndofilled(int x, int y, int c, int B){\r\n   //printf("dofilled %d %d %d %d\\n",x,y,c,B);\r\n   if (v(x,y) == cookie) return 1;\r\n   if (b(x,y) == -1) return 1;\r\n   if (b(x,y) == B) return 1;\r\n   if (b(x,y) != c) return 0;\r\n   v(x,y) = cookie;\r\n   return dofilled(x+1,y,c,B) && dofilled(x-1,y,c,B)\r\n       && dofilled(x,y+1,c,B) && dofilled(x,y-1,c,B); \r\n}\r\n\r\ndofill(int x, int y, int d) {\r\n   if (v(x,y) != cookie) return 0;\r\n   if (b(x,y) == d) return 0;\r\n   b(x,y) = d;\r\n   v(x,y) = 0;\r\n   return 1 + dofill(x+1,y,d) + dofill(x-1,y,d)\r\n      + dofill(x,y+1,d) + dofill(x,y-1,d);\r\n}\r\n\r\nint reach(int x, int y, int c, int B, int d){\r\n   cookie++;\r\n   if (!dofilled(x,y,c,B)) return 0;\r\n   return dofill(x,y,d);\r\n}\r\nint owns[256], caps[256];\r\nupdate(int x, int y, int P, int Q){\r\n   int cap = reach(x,y,Q,P,0);\r\n   caps[P] += cap;\r\n   return cap;\r\n}\r\nfinal(){\r\n   int x,y;\r\n   for (x=-z;x<=z;x++) {\r\n      for (y=-z;y<=z;y++) {\r\n         owns[''W''] += reach(x,y,0,''W'',''w'');\r\n         owns[''B''] += reach(x,y,0,''B'',''b'');\r\n      }\r\n   }\r\n}\r\n\r\nmain(){\r\n   while (2 == scanf("%d%d",&n,&m) && n) {\r\n      z = (n-1)/2;\r\n      memset(board,0,sizeof(board));\r\n      memset(owns,0,sizeof(owns));\r\n      memset(caps,0,sizeof(owns));\r\n      for (i=-z;i<=z;i++) b(i,-z-1) = b(i,z+1) = b(-z-1,i) = b(z+1,i) = -1;\r\n      for (i=0;i<m;i++) {\r\n         if (3 != scanf(" %c ( %d , %d )",&P,&x,&y)) printf("bad input format\\n");\r\n         assert(x >= -z && y >= -z && x <= z && y <= z);\r\n         if (b(x,y)) printf("board occupied %d %d\\n",x,y);\r\n         b(x,y) = P;\r\n         update(x+1,y,P,''B''+''W''-P);\r\n         update(x-1,y,P,''B''+''W''-P);\r\n         update(x,y+1,P,''B''+''W''-P);\r\n         update(x,y-1,P,''B''+''W''-P);\r\n         if (update(x,y,''B''+''W''-P,P)) printf("bad move!");\r\n         \r\n         //dump();\r\n      }\r\n      final();\r\n      //dump();\r\n      printf("%d %d\\n",owns[''B'']+caps[''B''], owns[''W'']+caps[''W'']);\r\n   }\r\n   if (n || m) printf("missing/mangled end delimiter\\n");\r\n}\r\n', '', 0, 581632, 1, 1, '2010-08-18 23:16:51', '0001-01-01 00:00:00'),
(212, 1, 195, 0, '#include <stdio.h>\r\n#include <string.h>\r\n#include <assert.h>\r\n#include <math.h>\r\n\r\nint cCnt, canada, status;\r\nint gold[256], silver[256], bronze[256];\r\ndouble score[256];\r\nchar country[256];\r\n\r\nstatic const int N = 100;\r\n\r\nbool canadaWins(double g, double s, double b) {\r\n	double best = -1;\r\n	for (int i = 0; i < cCnt; i++) {\r\n		score[i] = g * gold[i] + s * silver[i] + b * bronze[i];\r\n		if (score[i] > best)\r\n			best = score[i];\r\n	}\r\n	return (score[canada] >= best);\r\n}\r\n\r\nvoid work() {\r\n	for (int g = 0; g <= 0; g++)\r\n		for (int s = -2; s <= 2; s++)\r\n			for (int b = -3; b <= 3; b++)\r\n				if (canadaWins(pow(N, (double)-g), pow(N, (double)-s), pow(N, (double)-b))) {\r\n					printf("Canada wins!\\n");\r\n					return;\r\n				}\r\n	printf("Canada cannot win.\\n");\r\n}\r\n\r\nint main() {\r\n	while (scanf("%d", &cCnt) == 1) {\r\n		if (cCnt <= 0)\r\n			break;\r\n		canada = -1;\r\n		for (int i = 0; i < cCnt; i++) {\r\n			status = scanf("%s%d%d%d", country, &gold[i], &silver[i], &bronze[i]);\r\n			assert(status == 4);\r\n			if (strcmp(country, "Canada") == 0) {\r\n				assert(canada < 0);\r\n				canada = i;\r\n			}\r\n		}\r\n		//		assert(canada >= 0);\r\n		if (canada < 0) \r\n		  printf("Canada cannot win.\\n");\r\n		else \r\n		  work();\r\n	}\r\n	return 0;\r\n}\r\n\r\n\r\n', '', 0, 262144, 1, 2, '2010-08-18 23:16:51', '0001-01-01 00:00:00'),
(213, 1, 196, 0, '#include <stdio.h>\r\n#include <assert.h>\r\n\r\ndouble x, y, h, v;\r\n\r\nint doit(double llx, double lly, double urx, double ury, int col) {\r\n  assert(llx <= x && x <= urx && lly <= y && y <= ury);\r\n  double nx = llx+(urx-llx)*h, ny = lly+(ury-lly)*v;\r\n  //      printf("\\t\\t %6.3f %6.3f\\n", nx, ny);  \r\n  if (x < nx && y < ny) \r\n    return doit(llx,lly,nx,ny,1-col);\r\n  else if (x > nx && y > ny)\r\n    return doit(nx,ny,urx,ury,1-col);    \r\n  else if (x < nx && y > ny || x > nx && y < ny)\r\n    return col;\r\n  else \r\n    assert (0 && "too close to call");\r\n}\r\n\r\nint main () {\r\n\r\n  double H, V;\r\n  int c = 0, n;\r\n  while (1) {\r\n    scanf("%lf%lf%lf%lf",&H,&V,&h,&v);\r\n    if (!H) {\r\n      assert(!V && !h && !v);\r\n      return 0;\r\n    }\r\n    printf("Case %d:\\n",++c);\r\n    scanf("%d",&n);\r\n    while (n--) {\r\n      scanf("%lf%lf",&x,&y);\r\n      //      printf("\\t %.10f %.10f\\n", x, y);\r\n      printf(doit(0,0,H,V,1) ? "black\\n" : "white\\n");\r\n    }\r\n  }\r\n  \r\n}\r\n', '', 0, 258048, 1, 2, '2010-08-18 23:16:51', '0001-01-01 00:00:00'),
(214, 1, 197, 0, '#include <iostream>\r\n#include <set>\r\n#include <string>\r\n#include <algorithm>\r\n#include <stdio.h>\r\nusing namespace std;\r\n\r\nint main () {\r\n  int n, h, t;\r\n  set<string> W;\r\n  cin >> n;\r\n  for(int i=0;i<n;i++) {\r\n    string s;\r\n    cin >> s;\r\n    sort(s.begin(),s.end());\r\n    W.insert(s);\r\n  }\r\n  cin >> h;\r\n  while(h--) {\r\n    cin >> t;\r\n    char C[20];\r\n    int v[20];\r\n    for(int i=0;i<t;i++) cin >> C[i] >> v[i];\r\n    int maxv = 0;\r\n    for(int b=0;b<(1<<t);b++) {\r\n      string s;\r\n      int cval = 0;\r\n      for(int i=0;i<t;i++)\r\n	if (b & (1<<i)) {\r\n	  cval += v[i];\r\n	  s += C[i];\r\n	}\r\n      sort(s.begin(),s.end());\r\n      if (W.count(s) && cval > maxv) maxv = cval;\r\n    }\r\n    printf("%d\\n",maxv);\r\n  }\r\n}\r\n', '', 733, 4390912, 1, 2, '2010-08-18 23:16:51', '0001-01-01 00:00:00'),
(215, 1, 198, 0, '#include<stdio.h>\r\n#include<math.h>\r\n#define PI 3.14159265\r\nint main()\r\n{\r\n	#ifndef ONLINE_JUDGE\r\n	freopen("in.txt","r",stdin);\r\n	#endif\r\n	int k,m,i,j,t[100],n;\r\n	double a[100],b[100],c[100],a1[100],b1[100],c1[100],d,r;\r\n	while(scanf("%d%d",&k,&m)!=EOF,k||m)\r\n	{\r\n		for(i=0;i<k;i++)\r\n			scanf("%lf%lf%lf",&a[i],&b[i],&c[i]);\r\n		for(i=0;i<m;i++)\r\n			scanf("%lf%lf%lf",&a1[i],&b1[i],&c1[i]);\r\n		for(i=0;i<100;i++)\r\n			t[i]=0;\r\n		n=0;\r\n		r=40000/(2*PI);\r\n		for(i=0;i<k;i++)\r\n		{\r\n			d=sqrt(a[i]*a[i]+b[i]*b[i]+c[i]*c[i]-r*r);\r\n			for(j=0;j<m;j++)\r\n			{\r\n				if(sqrt((a[i]-a1[j])*(a[i]-a1[j])+(b[i]-b1[j])*(b[i]-b1[j])+(c[i]-c1[j])*(c[i]-c1[j]))<=d)\r\n					t[j]++;\r\n				else\r\n					continue;\r\n				if(t[j]==1)\r\n					n++;\r\n			}\r\n		}\r\n		printf("%d\\n",n);\r\n	}\r\n	return 0;\r\n}', '', 15, 262144, 1, 1, '2010-08-18 23:18:12', '0001-01-01 00:00:00'),
(216, 1, 199, 0, '#include<stdio.h>\r\n#include<math.h>\r\nint main()\r\n{\r\n	int y,i;\r\n	double sum;\r\n	while(scanf("%d",&y)!=EOF,y)\r\n	{\r\n		sum=0;\r\n		if(y==1960)\r\n			printf("3\\n");\r\n		else\r\n		{\r\n			for(i=1;;i++)\r\n			{\r\n				sum+=log10(i)/log10(2);\r\n				if(sum>pow(2,(y-1960)/10+2))\r\n					break;\r\n			}\r\n			printf("%d\\n",i-1);\r\n		}\r\n	}\r\n	return 0;\r\n}', '', 592, 262144, 1, 1, '2010-08-18 23:18:12', '0001-01-01 00:00:00'),
(217, 1, 200, 0, '#include <stdio.h>\r\n#include <string.h>\r\n#include <assert.h>\r\n\r\nint adj[1001][1001];\r\nint e[1001][1001];\r\nint d, dist[1001];\r\nint a,b,i,j,k,m,n,ne[1001],qn,q[1000000];\r\ndouble cnt[1001];\r\n\r\ndouble combos(int x){\r\n   int i,k;\r\n   double c = 0;\r\n   if (cnt[x] >= 0) return cnt[x];\r\n   if (x == 1) return 1;\r\n   for (i=0;i<ne[x];i++) {\r\n      k = e[x][i];\r\n      if (dist[k] <= dist[x]) continue;\r\n      c += combos(k);\r\n   }\r\n   return cnt[x] = c;\r\n}\r\n      \r\n\r\nmain(){\r\n   double Q;\r\n   while (2 == scanf("%d%d",&n,&m)) {\r\n      memset(adj,0,sizeof(adj));\r\n      memset(ne,0,sizeof(ne));\r\n      memset(cnt,0,sizeof(cnt));\r\n      for (i=0;i<m;i++) {\r\n         scanf("%d%d%d", &a,&b,&d);\r\n         assert (!adj[a][b] && !adj[b][a]);\r\n         assert (a!=b && a >= 1 && a <= n && b >= 1 && b <= n);\r\n         adj[a][b] = adj[b][a] = d;\r\n         e[a][ne[a]++] = b;\r\n         e[b][ne[b]++] = a;\r\n      }\r\n      for (i=1;i<=n;i++) dist[i] = 2000000000;\r\n      dist[2] = 0;\r\n      q[qn=0] = 2;\r\n      ++qn;\r\n      for (i=0;i<qn;i++) {\r\n         for (j=0;j<ne[q[i]];j++) {\r\n            k = e[q[i]][j];\r\n            if (dist[q[i]] + adj[q[i]][k] < dist[k]) {\r\n               dist[k] = dist[q[i]] + adj[q[i]][k];\r\n               q[qn++] = k;\r\n            }\r\n         }\r\n      }\r\n      //for (i=1;i<=n;i++) printf("%d: %lg\\n",i,dist[i]);\r\n      for (i=1;i<=n;i++) cnt[i] = -1;\r\n      Q = combos(2);\r\n      printf("%0.0lf\\n",Q);\r\n      assert(Q <= 2147483647);\r\n   }\r\n   if (n) printf("bad eof %d %d\\n",n,m);\r\n}\r\n', '', 31, 12316672, 1, 2, '2010-08-18 23:18:12', '0001-01-01 00:00:00'),
(218, 1, 201, 0, '#include<stdio.h>\r\nint main()\r\n{\r\n	int n,i,a[31];\r\n	a[0]=1;\r\n	a[2]=3;\r\n	a[4]=11;\r\n	for(i=6;i<31;i+=2)\r\n		a[i]=a[i-2]*4-a[i-4];\r\n	while(scanf("%d",&n)!=EOF,n!=-1)\r\n	{\r\n		if(n%2==0)\r\n			printf("%d\\n",a[n]);\r\n		else\r\n			printf("0\\n");\r\n	}\r\n	return 0;\r\n}', '', 0, 262144, 1, 1, '2010-08-18 23:18:13', '0001-01-01 00:00:00'),
(219, 1, 202, 0, '#include<stdio.h>\r\n#include<string.h>\r\nint main()\r\n{\r\n	int k,m,c,r,i,j,n,t,x;\r\n	char a[100][5],b[100][5];\r\n	while(scanf("%d",&k)!=EOF,k)\r\n	{\r\n		scanf("%d%*c",&m);\r\n		for(i=0;i<k;i++)\r\n			scanf("%s",a[i]);\r\n		n=0;\r\n		x=m;\r\n		while(m--)\r\n		{\r\n			t=0;\r\n			scanf("%d%d%*c",&c,&r);\r\n			for(i=0;i<c;i++)\r\n				scanf("%s",b[i]);\r\n			for(i=0;i<k;i++)\r\n				for(j=0;j<c;j++)\r\n					if(!strcmp(a[i],b[j]))\r\n						t++;\r\n			if(t>=r)\r\n				n++;\r\n		}\r\n		if(n==x)\r\n			printf("yes\\n");\r\n		else\r\n			printf("no\\n");\r\n	}\r\n	return 0;\r\n}', '', 296, 262144, 1, 1, '2010-08-18 23:18:13', '0001-01-01 00:00:00'),
(220, 1, 203, 0, '#include <math.h>\r\n#include <stdio.h>\r\n\r\nint n,k; \r\ndouble p,win,thresh;\r\n\r\nmain(){\r\n   while (2 == scanf("%d%lf",&n,&p)) {\r\n      if (!n) break;\r\n      win = 1<<n;\r\n      for (k=n-1;k>=0;k--) {\r\n         thresh = (1<<k)/win;\r\n         if (p >= thresh) win = (p+1)/2*win;\r\n         else win = (1<<k) * (thresh-p)/(1-p) \r\n                     + win * (thresh+1)/2 * (1-thresh)/(1-p);\r\n      }\r\n      printf("%0.3lf\\n",win);\r\n   }\r\n   if (n || p) printf("extraneous input %d %d\\n",n,p);\r\n}', '', 0, 262144, 1, 2, '2010-08-18 23:20:10', '0001-01-01 00:00:00'),
(221, 1, 204, 0, '#include <stdio.h>\r\n#include <string.h>\r\n\r\nint n,m,t,i,j,c;\r\nint arr[20000], done[20000], nl, nr, f;\r\nchar bank[20000][20],x;\r\n\r\n#define mina (arr[nl]<arr[nr]?arr[nl]:arr[nr])\r\n\r\nmain(){\r\n   char z;\r\n   scanf("%d",&c);\r\n   for (j=0;j<c;j++) {\r\n      if(j) printf("\\n");\r\n      if (3 != scanf("%d%d%d",&n,&t,&m)) printf("short input!\\n");\r\n      for (i=0;i<m;i++) scanf("%d%s",&arr[i],bank[i]);\r\n      arr[m] = 99999999;\r\n      for (i=0;i<m;i++) done[i] = 0;\r\n      for (nl=0;nl<m && bank[nl][0] != ''l'';nl++);\r\n      for (nr=0;nr<m && bank[nr][0] != ''r'';nr++);\r\n      for (f=0;nl < m || nr < m;){\r\n         if (f < mina) f = mina;\r\n         for (i=0;i<n && arr[nl] <= f;i++) {\r\n            done[nl] = f+t;  \r\n            for (;++nl<m && bank[nl][0] != ''l'';);\r\n         }\r\n         f += t;\r\n \r\n         if (f < mina) f = mina;\r\n         for (i=0;i<n && arr[nr] <= f;i++) {\r\n            done[nr] = f+t;\r\n            for (;++nr<m && bank[nr][0] != ''r'';);\r\n	 }\r\n         f += t;\r\n      }\r\n      for (i=0;i<m;i++) printf("%d\\n",done[i]);\r\n   }\r\n   if (1 == scanf( " %c", &x)) printf("extra input!! %c\\n",x);\r\n}', '', 15, 819200, 1, 2, '2010-08-18 23:20:10', '0001-01-01 00:00:00'),
(222, 1, 205, 0, '#include <stdio.h>\r\n#include <math.h>\r\n#include <string.h>\r\n#include <vector>\r\n\r\n#define y1 Y1\r\n\r\n#define T double  // long double if you need exact for ints > 10^7\r\n\r\nusing namespace std;\r\n\r\nstruct point { \r\n   T x,y;\r\n   point () { x=y=0; }\r\n   point (T xx, T yy) { x=xx; y = yy; }\r\n};\r\n\r\nint strictcross(point p1, point p2, point p3, point p4) {\r\n    T a, b, c, d;\r\n    a=(p3.y-p2.y)*(p1.x-p2.x)-(p1.y-p2.y)*(p3.x-p2.x);\r\n    b=(p4.y-p2.y)*(p1.x-p2.x)-(p1.y-p2.y)*(p4.x-p2.x);\r\n    c=(p1.y-p4.y)*(p3.x-p4.x)-(p3.y-p4.y)*(p1.x-p4.x);\r\n    d=(p2.y-p4.y)*(p3.x-p4.x)-(p3.y-p4.y)*(p2.x-p4.x);\r\n    return a*b<0 && c*d<0;\r\n}\r\n\r\nint i,j,k,m,n;\r\ndouble x1[100000], x2[100000], Y1[100000], y2[100000];\r\nint me[100000];\r\nchar covered[100000];\r\n\r\nint main(){\r\n   while (1 == scanf("%d",&n) && n) {\r\n      memset(covered,0,n);\r\n      for (m=i=0;i<n;i++,m++) {\r\n         scanf("%lf%lf%lf%lf",&x1[m],&Y1[m],&x2[m],&y2[m]);\r\n         me[m] = i+1;\r\n         for (k=m-1;k>=0;k--) {\r\n            if (strictcross(point(x1[m],y1[m]),point(x2[m],y2[m]),\r\n                            point(x1[k],y1[k]),point(x2[k],y2[k]))){\r\n               for (j=k;j<m;j++) {\r\n                  x1[j] = x1[j+1]; y1[j] = y1[j+1];\r\n                  x2[j] = x2[j+1]; y2[j] = y2[j+1];\r\n                  me[j] = me[j+1];\r\n               }\r\n               m--;\r\n            }\r\n            \r\n         }\r\n      }\r\n      printf("Top sticks:");\r\n      for (i=0;i<m-1;i++) printf(" %d,",me[i]);\r\n      printf(" %d.\\n",me[m-1]);\r\n   } \r\n   return 0;\r\n}', '', 421, 3964928, 1, 2, '2010-08-18 23:20:10', '0001-01-01 00:00:00'),
(223, 1, 206, 0, '#include <stdio.h>\r\n#include <string.h>\r\n\r\nint w[200], l[200];\r\nint p1,p2,i,j,k,m,n;\r\nchar m1[10], m2[10];\r\n\r\nmain(){\r\n   for (m=0;1 <= scanf("%d%d",&n,&k) && n;m++) {\r\n      if (m) {\r\n         printf("\\n");\r\n         memset(w,0,sizeof(w));\r\n         memset(l,0,sizeof(l));\r\n      }\r\n      for (i=0; i< k*n*(n-1)/2;i++) {\r\n         scanf("%d%s%d%s",&p1,m1,&p2,m2);\r\n         if (!strcmp(m1,"rock") && !strcmp(m2,"scissors") ||\r\n             !strcmp(m1,"scissors") && !strcmp(m2,"paper") ||\r\n             !strcmp(m1,"paper") && !strcmp(m2,"rock")) {\r\n             w[p1]++; l[p2]++;\r\n         }\r\n         if (!strcmp(m2,"rock") && !strcmp(m1,"scissors") ||\r\n             !strcmp(m2,"scissors") && !strcmp(m1,"paper") ||\r\n             !strcmp(m2,"paper") && !strcmp(m1,"rock")) {\r\n             w[p2]++; l[p1]++;\r\n         }\r\n      }\r\n      for (i=1;i<=n;i++) {\r\n         if (w[i] + l[i]) printf("%0.3lf\\n",(double)w[i]/(w[i]+l[i]));\r\n         else printf("-\\n");\r\n      }\r\n   }\r\n   if (n) printf("extraneous input! %d\\n",n);\r\n}', '', 343, 258048, 1, 2, '2010-08-18 23:20:10', '0001-01-01 00:00:00');
INSERT INTO `tbl_submitions` (`id`, `user_id`, `problem_id`, `exercise_id`, `source`, `result`, `used_time`, `used_memory`, `status`, `compiler_id`, `created`, `modified`) VALUES
(224, 1, 207, 0, '#include <stdio.h>\r\n#include <string.h>\r\n#include <assert.h>\r\n\r\nchar same[256][256], def[256][256], done[256];\r\nchar op[100], lhs, rhs;\r\nint i,j,k,m,n,c;\r\n\r\nissame(int a, int b) {\r\n   int i,r;\r\n   if (same[a][b] == 1) return 1;\r\n   if (same[a][b] == -1) return 0;\r\n   if (isupper(def[a][0])) return issame(def[a][0],b);\r\n   if (isupper(def[b][0])) return issame(a,def[b][0]);\r\n   if (def[a][0] != def[b][0]) return 0;\r\n   if (def[a][0] != ''s'') return 1;\r\n   same[a][b] = same[b][a] = 1;\r\n   for (i=1;(def[a][i] && def[b][i]) && issame(def[a][i],def[b][i]);i++);\r\n   r = !def[a][i] && !def[b][i];\r\n   same[a][b] = same[b][a] = r-1;\r\n   return r;\r\n}\r\n   \r\n   \r\n\r\nmain(){\r\n   for (c=0;strcmp(op,"--");c++) {\r\n      if (c) {\r\n         printf("\\n"); \r\n         memset(same,0,sizeof(same)); \r\n         memset(def,0,sizeof(def));\r\n         memset(done,0,sizeof(done));\r\n      }\r\n      def[''i''][0] = ''i''; def[''c''][0] = ''c''; def[''r''][0] = ''r'';\r\n      for (n=0;(1 == scanf("%s",op)) && *op != ''-'';n++) {\r\n         assert(!strcmp(op,"type"));\r\n         scanf(" %c = %c%*[a-z(]",&lhs,&rhs);\r\n         def[lhs][0] = rhs;\r\n         if (rhs == ''s'') {\r\n            for (j=1;scanf(" %c",&def[lhs][j]) && def[lhs][j] != '')'';j++);\r\n            def[lhs][j] = 0;\r\n         }\r\n      }\r\n\r\n      for (i=''A'';i<=''Z'';i++) {\r\n         if (!def[i][0] || done[i]) continue;\r\n         printf("%c",i);\r\n         for (j=i+1;j<=''Z'';j++) {\r\n            if (done[j]) continue;\r\n            if (issame(i,j)) {\r\n               assert(issame(j,i));\r\n               printf(" %c",j);\r\n               done[j] = 1;\r\n            } else assert(!issame(j,i));\r\n         }\r\n         printf("\\n");\r\n      }\r\n   }\r\n}', '', 15, 389120, 1, 1, '2010-08-18 23:20:11', '0001-01-01 00:00:00'),
(225, 1, 208, 0, '//  PR, meant to be immediate\r\n\r\n#include <stdio.h>\r\n#include <assert.h>\r\n#include <stdlib.h>\r\n\r\nusing namespace std;\r\n\r\n#define MAXN 200000\r\n\r\nint main () {\r\n  int n;\r\n  int x[MAXN], y[MAXN];\r\n  while (1) {\r\n    scanf("%d",&n);\r\n    if (!n) break;\r\n    assert(0 < n && n%2 && n <= MAXN);\r\n    int nn = (n-1)/2;\r\n    int xb, yb;\r\n    for(int i=0;i<n;i++) {\r\n      scanf("%d%d",&x[i],&y[i]);\r\n      if (i == nn) {\r\n	xb = x[i]; yb = y[i];\r\n      }\r\n    }\r\n    int ss = 0, os = 0;\r\n    for (int i = 0; i<n; i++) {\r\n      if (x[i] < xb && y[i] < yb || x[i] > xb && y[i] > yb) ss++;\r\n      if (x[i] < xb && y[i] > yb || x[i] > xb && y[i] < yb) os++;\r\n    }\r\n    printf("%d %d\\n",ss,os);\r\n  }\r\n  return 0;\r\n}\r\n', '', 0, 1826816, 1, 2, '2010-08-18 23:20:48', '0001-01-01 00:00:00'),
(226, 1, 209, 0, '// PR, May 14, 2005\r\n\r\n// 1 2\r\n// 2 4  6\r\n//   6  9 12\r\n//     12 16 20\r\n//        20 25 30\r\n//           30 36 42\r\n//              42 49 56\r\n\r\n// Set 1 to 0, whatever is 2 then 4 has to be 0 because of the first\r\n// two raws. 4 and 9 have to be the same bacause of raws 2 and 3\r\n// and so on for all squares.\r\n\r\n// find smallest binary magic string of lenght p-1 where p is prime \r\n// Set the diagonal of the magic square to 0''s the rest to 1''s.\r\n// Indices that are quadratic residues mod p appear on the diagonal\r\n// and p has the same number od residues and non-residues unless\r\n// p is 2.\r\n// there are 4 magic strings of any length except 2.\r\n\r\n// The string must be a palindrom or its reverse is its complement.\r\n\r\n#include <stdio.h>\r\n#include <assert.h>\r\n#include <math.h>\r\n\r\n#define MAXP 100000\r\n\r\nint isPrime(int a) {\r\n  if (a < 2) return 0;\r\n  for (int i = 2; i <= sqrt((double)a); i++) if (!(a%i)) return 0;\r\n  return 1;\r\n}\r\n\r\nchar A[MAXP+10];\r\n\r\nint main () {\r\n  while (1) {\r\n    int p;\r\n    scanf("%d",&p);\r\n    if (!p) break;\r\n    assert(isPrime(p) && p <= MAXP);\r\n    if (p == 2) { printf("Impossible\\n"); continue; }\r\n    for (int i=1;i<p;i++) A[i] = ''1'';\r\n    for (unsigned long long i=1;i<p;i++) \r\n      A[(i*i)%p]=''0'';\r\n    for (int i=1;i<p;i++)\r\n      printf("%c",A[i]);\r\n    printf("\\n");\r\n  }\r\n}\r\n', '', 62, 356352, 1, 2, '2010-08-18 23:20:48', '0001-01-01 00:00:00'),
(227, 1, 210, 0, '#include <stdio.h>\r\n#include <assert.h>\r\n#include <math.h>\r\n#include <stdlib.h>\r\n\r\n#define MAX 1000\r\n\r\ntypedef struct { double x, y; } Point;\r\nPoint poly[MAX+10], ipoint[MAX+10];\r\nPoint a,b;\r\n#define EPS 1e-8\r\n#define SQR(x) ((x)*(x))\r\n\r\ndouble dist2d(Point a, Point b) {\r\n  return sqrt(SQR(a.x-b.x) + SQR(a.y-b.y));\r\n}\r\n\r\nint pt_in_poly(Point *p, int n, Point a) {\r\n  int i, j, c = 0;\r\n  for (i = 0, j = n-1; i < n; j = i++) {\r\n    if (dist2d(p[i],a)+dist2d(p[j],a)-dist2d(p[i],p[j]) < EPS)\r\n      return 1;\r\n    if ((((p[i].y<=a.y) && (a.y<p[j].y)) ||\r\n         ((p[j].y<=a.y) && (a.y<p[i].y))) &&\r\n        (a.x < (p[j].x-p[i].x) * (a.y - p[i].y) \r\n               / (p[j].y-p[i].y) + p[i].x)) c = !c;\r\n  }\r\n  return c;\r\n}\r\n\r\ndouble dist_iline(Point a, Point b, Point p){\r\n  return fabs(((a.y-p.y)*(b.x-a.x)-\r\n               (a.x-p.x)*(b.y-a.y))\r\n              /dist2d(a,b));\r\n}\r\n\r\nint isect_iline(Point a, Point b, Point c, Point d, Point *p){\r\n  double r, denom, num1;\r\n  if (dist_iline(c,d,a) < EPS && dist_iline(c,d,b) < EPS) return -1;\r\n  num1  = (a.y - c.y) * (d.x - c.x) - (a.x - c.x) * (d.y - c.y);\r\n  denom = (b.x - a.x) * (d.y - c.y) - (b.y - a.y) * (d.x - c.x);\r\n  if (fabs(denom) >= EPS) {\r\n    r = num1 / denom;\r\n    p->x = a.x + r*(b.x - a.x);\r\n    p->y = a.y + r*(b.y - a.y);\r\n    return ((p->x-a.x)*(p->x-b.x) < 0 ||\r\n	    (p->y-a.y)*(p->y-b.y) < 0 ||\r\n	    fabs((p->x-a.x)*(p->x-b.x)) < EPS) ? 1 : 0; // in segment a,b\r\n  } \r\n  if (fabs(num1) >= EPS) return 0;\r\n  return -1;\r\n}\r\n\r\nint cmp( const void *a, const void *b) {\r\n  const Point *ap = (Point *)a, *bp = (Point *)b;\r\n  if (fabs(ap->x-bp->x) < EPS) {\r\n    if (fabs(ap->y-bp->y) < EPS) return 0;\r\n    if (ap->y < bp->y)   return -1;\r\n    return 1;\r\n  }\r\n  if (ap->x < bp->x)     return -1;\r\n  return 1;\r\n}\r\n\r\nvoid addifnew(Point c, int& cnt) {\r\n  for (int i=0;i<cnt;i++) \r\n    if (dist2d(ipoint[i],c) < EPS) return;\r\n  ipoint[cnt++]=c;\r\n}\r\n\r\nint main () {\r\n  while (1) {\r\n    int n, m;\r\n    scanf("%d%d",&n, &m);\r\n    if (!n) break;\r\n    assert(2 < n && n <= MAX);\r\n    for (int i=0;i<n;i++) scanf("%lf %lf", &poly[i].x, &poly[i].y);\r\n    poly[n] = poly[0];\r\n    for (;m;m--) {\r\n      scanf("%lf%lf%lf%lf",&a.x,&a.y,&b.x,&b.y);\r\n      int ip = 0;\r\n      Point p;\r\n      for (int i=0;i<n;i++) {\r\n	switch (isect_iline(poly[i], poly[i+1],a,b, &p)) {\r\n	case 0: break;\r\n	case 1: addifnew(p,ip); break;\r\n	case -1: addifnew(poly[i],ip); addifnew(poly[i+1],ip); break;\r\n	default: assert(0);\r\n	}\r\n      }\r\n      qsort(ipoint,ip,sizeof(Point),cmp);\r\n      double dist = 0.0;\r\n      for(int i=0;i+1<ip;i++) {\r\n	Point m;\r\n	m.x = (ipoint[i].x+ipoint[i+1].x)/2;\r\n	m.y = (ipoint[i].y+ipoint[i+1].y)/2;\r\n	if (pt_in_poly(poly, n, m)) dist += dist2d(ipoint[i],ipoint[i+1]);\r\n      }\r\n      printf("%.3f\\n",dist);\r\n    }\r\n  }\r\n}\r\n', '', 218, 290816, 1, 2, '2010-08-18 23:20:48', '0001-01-01 00:00:00'),
(228, 1, 211, 0, '#include <stdio.h>\r\n#include <assert.h>\r\n#include <math.h>\r\n\r\n#define dt 0.00005\r\n#define g 9.81\r\n\r\nint main () {\r\n  while (1) {\r\n    double k, l, s, w;\r\n    scanf("%lf%lf%lf%lf",&k,&l,&s,&w);\r\n    if (k == 0) break;\r\n    assert(0 <= k && 0 <= l && 0 <= s && s < 200 && 0 <= w);\r\n    double d = s<l?s:l, a, f, F = g*w, t = sqrt(2*d/g), v = g*t;\r\n    int click = 0;\r\n    while (1) {\r\n      if (d >= s) {\r\n	if (v > 10) \r\n	  printf("Killed by the impact.\\n");\r\n	if (v < 10) \r\n	  printf("James Bond survives.\\n");\r\n	break;\r\n      }\r\n      if ( v < 0) {\r\n	printf("Stuck in the air.\\n");\r\n	break;\r\n      }\r\n      f = F-k*(d<l?0:d-l);\r\n      a = f/w;\r\n      d += v*dt+dt*dt*a/2;\r\n      v += dt*a;\r\n      click++;\r\n    }\r\n  }\r\n}\r\n', '', 31, 262144, 1, 2, '2010-08-18 23:20:48', '0001-01-01 00:00:00'),
(229, 1, 212, 0, '#include <stdio.h>\r\n#include <assert.h>\r\n#include <stdlib.h>\r\n#include <map>\r\n#include <set>\r\n\r\nusing namespace std;\r\n\r\n#define MAXN 200000\r\n\r\ntypedef struct {\r\n  int x; int y;\r\n} point;\r\n\r\n// s sorted by y, t sorted by x, \r\n\r\nint cmpt( const void *a, const void *b) {\r\n  const point *ap = (point *)a, *bp = (point *)b;\r\n  if (ap->x == bp->x && ap->y == bp->y)\r\n    return 0;\r\n  if (ap->x < bp->x || ap->x == bp->x && ap->y < bp->y)\r\n    return -1;\r\n  return 1;\r\n}\r\n\r\nint cmps( const void *a, const void *b) {\r\n  const point *ap = (point *)a, *bp = (point *)b;\r\n  if (ap->x == bp->x && ap->y == bp->y)\r\n    return 0;\r\n  if (ap->y < bp->y || ap->y == bp->y && ap->x < bp->x)\r\n    return -1;\r\n  return 1;\r\n}\r\n\r\n  point t[MAXN], s[MAXN];\r\n  int c[MAXN], res[MAXN];\r\n\r\nint main () {\r\n  int n;\r\n\r\n  while (1) {\r\n    scanf("%d",&n);\r\n    if (!n) break;\r\n    assert(0 < n && n <= MAXN);\r\n    for (int i = 0; i < n; i++) {\r\n      scanf("%d%d", &(s[i].x), &(s[i].y));\r\n      t[i].x = s[i].x; t[i].y = s[i].y;\r\n      c[i] = 0;\r\n    }\r\n    qsort(t, n, sizeof(point), cmpt);\r\n    qsort(s, n, sizeof(point), cmps);\r\n    int l,m,r, cnt;\r\n    for (int i = 0; i < n; i++) {\r\n      l = 0; r = n-1;\r\n      cnt = 0;\r\n      while (l < r) {\r\n	m = (l+r)/2;\r\n	if (cmpt(&t[m], &s[i]) == -1) {\r\n	  cnt += c[m]; l = m+1;\r\n	} else {\r\n	  c[m]++; r = m;\r\n	}\r\n      }\r\n      res[r] = cnt+1;\r\n    }\r\n    map<int,int> xm, ym, xc, yc; // count to the left or below and on the lines\r\n    for (int i=0;i<n;i++) {\r\n      xm[t[i].x] = i+1; ym[s[i].y] = i+1;\r\n      xc[t[i].x]++; yc[s[i].y]++;\r\n    }\r\n    map<pair<int,int>,int> pxb, pyb; // left and below on x and y of a point\r\n    int i = 0;\r\n    while (i<n) {\r\n      int xi = t[i].x, j = i;\r\n      while (i<n && xi == t[i].x) {\r\n	pyb[make_pair(t[i].x,t[i].y)] = i-j;\r\n	i++;\r\n      }\r\n    }\r\n    i = 0;\r\n    while (i<n) {\r\n      int yi = s[i].y, j = i;\r\n      while (i<n && yi == s[i].y) {\r\n	pxb[make_pair(s[i].x,s[i].y)] = i-j;\r\n	i++;\r\n      }\r\n    }\r\n    int ss = -1;\r\n    set<int> oset;\r\n    i = 0;\r\n    while (i<n) {\r\n      int xi = t[i].x;\r\n      int lss = n, los = 0;\r\n      while (i<n && xi == t[i].x) {\r\n	int nos = xm[xi]-xc[xi]+ym[t[i].y]-yc[t[i].y]-2*res[i]+2\r\n	  +pyb[make_pair(t[i].x,t[i].y)]+pxb[make_pair(t[i].x,t[i].y)];\r\n	int nss = n-nos-xc[xi]-yc[t[i].y]+1;\r\n	if (nss < lss) { lss = nss; los = nos; }\r\n	i++;\r\n      }\r\n      if (lss > ss) { \r\n	ss = lss; oset.clear(); oset.insert(los); \r\n      } else if (lss == ss)  oset.insert(los); \r\n    }\r\n    printf("Stan: %d; Ollie:",ss);\r\n    for (set<int>::iterator p=oset.begin(); p!=oset.end();p++)\r\n      printf(" %d",*p);\r\n    printf(";\\n");\r\n  }\r\n  return 0;\r\n}\r\n', '', 997, 21495808, 1, 2, '2010-08-18 23:20:48', '0001-01-01 00:00:00'),
(230, 1, 213, 0, '#include <stdio.h>\r\n#include <math.h>\r\n#define y1 Y1\r\n#define M_PI 3.14159265\r\ndouble lat1, long1, lat2, long2, x1,y1,z1,x2,y2,z2;\r\ndouble alpha, delta, x, y, z, norm, bestx, besty, bestz;\r\n\r\nvoid try(double a){\r\n   if (a < 0 || a > 1) return;\r\n   x = x1 * a + x2 * (1-a);\r\n   y = y1 * a + y2 * (1-a);\r\n   z = z1 * a + z2 * (1-a);\r\n   norm = sqrt(x*x + y*y + z*z);\r\n   x /= norm;\r\n   y /= norm;\r\n   z /= norm;\r\n   if (x > bestx) {\r\n      bestx = x;\r\n      besty = y; \r\n      bestz = z;\r\n      alpha = a;\r\n   }\r\n}\r\n\r\nmain(){\r\n   int i,j,k,m,n,N;\r\n   int deg,sec;\r\n   char dir;\r\n   scanf("%d",&N);\r\n   while (N--) {\r\n      scanf("%d,%d%c",&deg,&sec,&dir);\r\n      lat1 = deg + sec / 60.0;\r\n      if (dir == ''S'') lat1 = -lat1;\r\n      scanf("%d,%d%c",&deg,&sec,&dir);\r\n      long1 = deg + sec / 60.0;\r\n      if (dir == ''W'') long1 = -long1;\r\n      scanf("%d,%d%c",&deg,&sec,&dir);\r\n      lat2 = deg + sec / 60.0;\r\n      if (dir == ''S'') lat2 = -lat2;\r\n      scanf("%d,%d%c",&deg,&sec,&dir);\r\n      long2 = deg + sec / 60.0;\r\n      if (dir == ''W'') long2 = -long2;\r\n\r\n      if (lat1 == -lat2 && fabs(long1-long2) == 180) {\r\n         printf("undefined\\n");\r\n         continue;\r\n      }\r\n\r\n      x1 = sin(lat1*M_PI/180);\r\n      y1 = sin(long1*M_PI/180) * cos(lat1*M_PI/180);\r\n      z1 = cos(long1*M_PI/180) * cos(lat1*M_PI/180);\r\n\r\n      x2 = sin(lat2*M_PI/180);\r\n      y2 = sin(long2*M_PI/180) * cos(lat2*M_PI/180);\r\n      z2 = cos(long2*M_PI/180) * cos(lat2*M_PI/180);\r\n\r\n      bestx = -2;\r\n      try(0);\r\n      try(.5);\r\n      try(1);\r\n      for (delta=.5;delta > .000000000001;delta *= .5) {\r\n         try(alpha+delta);\r\n         try(alpha-delta);\r\n      }\r\n      if (bestx >= 0) {\r\n         i = floor(asin(bestx)*180/M_PI*60+.5);\r\n         printf("%d,%dN\\n",i/60,i%60);\r\n      } else {\r\n         i = floor(asin(-bestx)*180/M_PI*60+.5);\r\n         printf("%d,%dS\\n",i/60,i%60);\r\n      }\r\n   }\r\n}\r\n\r\n', '', 0, 258048, 1, 1, '2010-08-18 23:27:09', '0001-01-01 00:00:00'),
(231, 1, 214, 0, '#include <stdlib.h>\r\n#include <stdio.h>\r\n\r\nint N;\r\n#define RANGE 100000;\r\n\r\nint p[1000000],new[1000000];\r\nlong long count;\r\n\r\nmain(){\r\n  register i,j;\r\n  while (1 == scanf("%d",&N) && N) {\r\n   for (i=0;i<N;i++) scanf("%d",&p[i]);\r\n   count=0;\r\n   sort(0,N);\r\n   printf("%lld\\n",count);\r\n }\r\n}\r\n\r\nsort(int a, int b){\r\n   register mx, mn, md, below, mdi, ni, i, j;\r\n\r\n   if (a >= b) return;\r\n\r\n   /* naive pivot selection - handles obvious pathologies */\r\n\r\n   md = p[a+(b-a)/2];\r\n   \r\n   /* move everything above the pivot over everything below */\r\n\r\n   for (mdi=i=a;i<b;i++) if (p[i] < md) mdi++;\r\n   below = mdi-a;\r\n   for (ni=i=a;i<b;i++){\r\n      if (p[i] < md) {\r\n         new[ni++] = p[i];\r\n         below--;\r\n      }else{\r\n         new[mdi++] = p[i];\r\n         count += below;\r\n      }\r\n   }\r\n\r\n   /* shuffle the pivot to the middle */\r\n\r\n   for (mdi=a;new[mdi] != md;mdi++);\r\n   for (mdi;mdi && new[mdi-1] > md;mdi--){\r\n      int tmp = new[mdi-1];\r\n      new[mdi-1] = new[mdi];\r\n      new[mdi] = tmp;\r\n      count++;\r\n   }\r\n   for (i=a;i<b;i++) p[i] = new[i];\r\n         \r\n   sort(a,mdi);\r\n   while(mdi < b && p[mdi] == md) mdi++;  /* skip pivot & duplicates */\r\n   sort(mdi,b);\r\n}\r\n', '', 295, 8273920, 1, 1, '2010-08-18 23:27:09', '0001-01-01 00:00:00'),
(232, 1, 215, 0, '#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\nstruct thing {\r\n   int run, win; double p;\r\n} p1[1000000], p2[1000000];\r\n\r\ncomp(struct thing *a, struct thing *b){\r\n   if (a->run != b->run) return a->run - b->run;\r\n   if (a->win != b->win) return a->win - b->win;\r\n   return 0;\r\n}\r\n\r\nint pwr[] = {1,2,4,8,16,32,64,128,256,512,1024};\r\n\r\nint i,j,k,m,n,l,n1,n2,n3,bet;\r\n\r\ndouble prob, sumprob;\r\n\r\ndump(struct thing *x, int nx, char *msg){\r\n   int i;\r\n   return 0;\r\n   printf("--- %s %d\\n",msg,nx);\r\n   for (i=0;i<nx;i++){\r\n      printf("%5d %5d %0.8lf\\n",x[i].run, x[i].win,x[i].p);\r\n   }\r\n}\r\n\r\nmain(){\r\n   scanf("%d",&n);\r\n   while (n--) {\r\n      scanf("%d%d%d",&k,&m,&l);\r\n      n1 = 1;\r\n      p1[0].win = 0;\r\n      p1[0].run = 0;\r\n      p1[0].p = 1;\r\n      prob = 1;\r\n      for (i=1;i<=m;i++) {\r\n         n2 = 0;\r\n         for (j=0;j<n1;j++) {\r\n            bet = pwr[p1[j].run];\r\n            // lose 10/14 of the time\r\n            p2[n2].run = bet*2 <= l ? p1[j].run + 1 : 0;\r\n            p2[n2].win = p1[j].win - bet;\r\n            p2[n2++].p = p1[j].p * 10/14;\r\n            // win 1 (2 cases)\r\n            p2[n2].run = 0;\r\n            p2[n2].win = p1[j].win + bet;\r\n            p2[n2++].p = p1[j].p * 2/14;\r\n            // win 2\r\n            p2[n2].run = 0;\r\n            p2[n2].win = p1[j].win + bet * 2;\r\n            p2[n2++].p = p1[j].p * 1/14;\r\n            // win 3\r\n            p2[n2].run = 0;\r\n            p2[n2].win = p1[j].win + bet * 3;\r\n            p2[n2++].p = p1[j].p * 1/14;\r\n         }\r\n         dump(p2,n2,"new");\r\n         qsort(p2,n2,sizeof(struct thing),comp);\r\n         dump(p2,n2,"newsort");\r\n         n1 = 0;\r\n         sumprob = 0;\r\n         for (j=0;j<n2;) {\r\n            p1[n1].win = p2[j].win;\r\n            p1[n1].run = p2[j].run;\r\n            p1[n1].p = p2[j].p;\r\n            for (j++;p2[j].win == p1[n1].win && p1[n1].run == p2[j].run;j++){\r\n               p1[n1].p += p2[j].p;\r\n            }\r\n            if (p1[n1].win <= 0 || i < k) {\r\n               sumprob += p1[n1].p;\r\n               n1++; \r\n            }\r\n         }\r\n         for (j=0;j<n1;j++) p1[j].p /= sumprob;\r\n         if (i >= k) prob *= sumprob;\r\n         dump(p1,n1,"newer");\r\n      }\r\n      printf("%0.4lf\\n",1-prob);\r\n   }\r\n}\r\n', '', 93, 32317440, 1, 1, '2010-08-18 23:27:10', '0001-01-01 00:00:00'),
(233, 1, 216, 0, '#include <stdio.h>\r\n\r\nint s,d,a,b,n;\r\n\r\nmain(){\r\n   scanf("%d",&n);\r\n   while (n--){\r\n      if (2 != scanf("%d%d",&s,&d)) {\r\n         printf("short input\\n");\r\n         exit(1);\r\n      }\r\n      // a + b = s;\r\n      // a - b = d;\r\n      // 2a = s+d;\r\n      a = (s+d)/2;\r\n      b = a - d;\r\n      if (a+b == s && a-b == d && b >= 0) printf("%d %d\\n",a,b);\r\n      else printf("impossible\\n");\r\n   }\r\n}\r\n', '', 0, 258048, 1, 1, '2010-08-18 23:27:10', '0001-01-01 00:00:00'),
(234, 1, 217, 0, '#include <stdio.h>\r\n\r\nint i,j,k,m,n,done,board[5][5];\r\n\r\nmain(){\r\n  scanf("%d",&n);\r\n  while (n--) {\r\n     done = 0;\r\n     for (i=0;i<5;i++) for (j=0;j<5;j++)\r\n        if (i != 2 || j != 2) scanf("%d",&board[i][j]);\r\n     for (k=0;k<75;k++) {\r\n        scanf("%d",&m);\r\n        for (i=0;i<5;i++) for (j=0;j<5;j++) \r\n           if (board[i][j] == m) board[i][j] = 0;\r\n        if (!done) {\r\n           for (i=0;i<5;i++) {\r\n              for (j=0;j<5 && !board[i][j];j++);\r\n              if (j == 5) break;\r\n              for (j=0;j<5 && !board[j][i];j++);\r\n              if (j == 5) break;\r\n              for (j=0;j<5 && !board[j][j];j++);\r\n              if (j == 5) break;\r\n              for (j=0;j<5 && !board[j][4-j];j++);\r\n              if (j == 5) break;\r\n           }\r\n           if (i < 5) {\r\n              printf("BINGO after %d numbers announced\\n",k+1);\r\n              done = 1;\r\n           }\r\n         }\r\n      }\r\n   }\r\n   if (1 == scanf(" %c",&n)) printf("Extra input!\\n");\r\n}\r\n', '', 0, 258048, 1, 1, '2010-08-18 23:27:10', '0001-01-01 00:00:00'),
(235, 1, 218, 0, '#include <stdio.h>\n#include <math.h>\n\nint n[100], w[100], i,j,k,m,t;\n\ndouble a,b,delta,p,q;\n\ndouble like(double a, double b){\n   int i,j,k;\n   double r = 1;\n   for (i=0;i<t;i++) {\n      double odds = exp(a + b * n[i]);\n      double p = odds / (1 + odds);\n      if (w[i]) r *= p; else r *= (1-p);\n   }\n   //printf("like %lg %lg: %lg\\n",a,b,r);\n   return r;\n}\n\ndouble alike(double a){\n   double p,q,delta;\n   b = p = 0;\n   for (delta=1;delta > 1e-9;) {\n      if ((q=like(a,b+delta)) > p) {\n         b += delta;\n         p = q;\n      } else if ((q = like(a,b-delta)) > p) {\n         b -= delta;\n         p = q;\n      } else delta *= .5;\n   }\n   return p;\n}\n\nmain(){\n   while (1 == scanf("%d",&t) && t) {\n      for (i=0;i<t;i++) scanf("%d%d",&n[i],&w[i]);\n      a = p = 0;\n      for (delta = 1;delta > 1e-9;) {\n         if ((q=alike(a+delta)) > p) {\n            a += delta;\n            p = q;\n         } else if ((q = alike(a-delta)) > p) {\n            a -= delta;\n            p = q;\n         } else delta *= .5;\n      }\n      printf("%0.4lf %0.4lf\\n",a,b);\n   }\n   if (t) printf("missing end delimiter\\n");\n}\n', '', 249, 262144, 1, 2, '2010-08-18 23:28:26', '0001-01-01 00:00:00'),
(236, 1, 219, 0, '#include <stdio.h>\n#include <string.h>\n\nchar a[1000], b[1000];\nint t,i,j;\n\nstruct nn {\n   int n; char lbl;\n   struct nn *fwd[100];\n   int fwdi[100];\n} n[200], *p, *root1, *root2;\n\nchar * parse(int depth,char *x, int ni, struct nn **r) {\n   char lbl = *x++;\n   struct nn *pp = p++;\n   int i;\n   pp->n=ni;\n   pp->lbl = lbl;\n   if (*x == ''('') {\n      while (*x == '','' || *x == ''('') {\n         x = parse(depth+1,++x,1,&pp->fwd[pp->n]);\n         pp->fwdi[pp->n] = 0;\n         pp->fwd[pp->n]->fwd[0] = pp;\n         pp->fwd[pp->n]->fwdi[0] = pp->n;\n         pp->n++;\n      }\n      x++;\n   }\n   *r = pp;\n   return x;\n}\n\ncomp(struct nn *t, struct nn *u, int w, int x){\n   int i,j;\n   if (t->n != u->n | t->lbl != u->lbl) return 0;\n   if (w == -1) return comp(t->fwd[0],u->fwd[0],t->fwdi[0],u->fwdi[0]);\n   j = (x+1)%u->n;\n   for (i=(w+1)%t->n;i!=w;i=(i+1)%t->n) {\n      if (!comp(t->fwd[i],u->fwd[j],t->fwdi[i],u->fwdi[j])) return 0;\n      j = (j+1)%u->n;\n   }\n   return 1;\n}\n\nequiv(struct nn *t, int where,int depth){\n   int i;\n   if (t->n == 1 && comp(t,root1,-1,-1)) return 1;\n   if (where == -1) {\n      for (i=0;i<t->n;i++) {\n         if(equiv(t->fwd[i],t->fwdi[i],depth+1)) return 1;\n     }\n   }else{\n      for (i=(where+1)%t->n;i!=where;i=(i+1)%t->n) if(equiv(t->fwd[i],t->fwdi[i],depth+1)) return 1;\n   }\n   return 0;\n}\n\nmain(){\n   scanf("%d ",&t);\n   while (t--) {\n      p = n;\n      if (!gets(a)) {printf("short input\\n"); exit(1); }\n      parse(0,a,0,&root1);\n      while(root1->n > 1)root1=root1->fwd[1];\n      if (!gets(b)) {printf("short input\\n"); exit(1); }\n      parse(0,b,0,&root2);\n      if(!strcmp(a,b) || equiv(root2,-1,0)) printf("same\\n");else printf("different\\n");\n   }\n   if (gets(a)) printf("extraneous input!\\n");\n}\n', '', 0, 425984, 1, 1, '2010-08-18 23:28:26', '0001-01-01 00:00:00'),
(237, 1, 220, 0, '#include <stdio.h>\nint main()\n{\n	int n,i,k=0,j,nn[10001],f[10001];\n	while(scanf("%d:",&n))\n	{\n		if(n==0)break;\n		for(i=0;i<n;i++)\n		{\n			scanf("%d",&f[i]);\n		}\n		for(i=0;i<n;i++)\n		{\n			nn[f[i]]=i;\n		}\n		for(i=0;k!=1&&i<n-1;i++)\n		{\n			for(j=i+1;k!=1&&j<n;j++)\n			{if(2*j-i>=n)\n			{break;}\n				if((nn[i]<nn[j])&&(nn[j]<nn[2*j-i]))\n				{\n					printf("no\\n");\n					k=1;\n				}\n				if((nn[i]>nn[j])&&(nn[j]>nn[2*j-i]))\n				{printf("no\\n");\n					k=1;\n				}\n			}\n		}\n		if(k==0)\n		{\n			printf("yes\\n");\n		}\n		k=0;\n	}\n	return 0;\n}', '', 0, 303104, 1, 1, '2010-08-18 23:28:27', '0001-01-01 00:00:00'),
(238, 1, 221, 0, '#include <stdio.h>\n#include <string.h>\n\nchar c[256][256], d[256], x[256];\nint i,j,k,n,t;\n\nmain(){\n   while (1 == scanf("%d",&n) && n) {\n      if (t++) printf("\\n");\n      memset(c,0,sizeof(c));\n      memset(d,0,sizeof(d));\n      for (i=0;i<n;i++) {\n         for (j=0;j<6;j++) scanf(" %c",&x[j]);\n         for (j=0;j<6;j++) c[x[5]][x[j]] = 1;\n         for (j=0;j<6;j++) d[x[j]] = 1;\n      }\n      for (i=''A'';i<=''Z'';i++) for (j=''A'';j<=''Z'';j++) for (k=''A'';k<=''Z'';k++)\n         c[j][k] |= (c[j][i] && c[i][k]);\n      for (i=''A'';i<=''Z'';i++) {\n         if (!d[i]) continue;\n         d[i] = 0;\n         printf("%c",i);\n         for (j=i+1;j<=''Z'';j++) {\n            if (c[i][j] && c[j][i]) {\n               printf(" %c",j);\n               d[j] = 0;\n            }\n         }\n         printf("\\n");\n      }\n   }\n   if (n) printf("missing end delimiter\\n");\n}\n', '', 46, 327680, 1, 2, '2010-08-18 23:28:27', '0001-01-01 00:00:00'),
(239, 1, 222, 0, '#include <stdio.h>\r\n\r\nint c,big,little,L,i,j,k,n;\r\n\r\nmain(){\r\n   scanf("%d",&c);\r\n   while (c-- && (2 == scanf("%d%d",&L,&n))) {\r\n      big = little = 0;\r\n      for (i=0;i<n;i++) {\r\n         scanf("%d",&k);\r\n         if (k > big) big = k;\r\n         if (L-k > big) big = L-k;\r\n         if (k > L-k) k = L-k;\r\n         if (k > little) little = k;\r\n      }\r\n      printf("%d %d\\n",little,big);\r\n   }\r\n   if (c != -1) printf("missing input\\n");\r\n}\r\n', '', 93, 262144, 1, 2, '2010-08-18 23:29:46', '0001-01-01 00:00:00'),
(240, 1, 223, 0, '#include <stdio.h>\r\n#include <string.h>\r\n\r\nchar buf[2000];\r\n\r\nint c,i,j,n,swaps,extra;\r\n\r\nmain(){\r\n   scanf("%d",&c);\r\n   while (c--) {\r\n      scanf("%s",buf);\r\n      n = strlen(buf);\r\n      swaps = 0;\r\n      extra = 0;\r\n      for (i=0;i<n/2;i++) {\r\n         for (j=n-i-!extra;j>i && buf[i] != buf[j];j--) {}\r\n         if (j == i) {\r\n            if (extra || n%2 == 0) {\r\n               printf("Impossible\\n");\r\n               goto dun;\r\n            }\r\n            extra = n/2 - i;\r\n            continue;\r\n         }\r\n         for (; j < n-i-!extra ; j++) {\r\n            int t = buf[j];\r\n            buf[j] = buf[j+1];\r\n            buf[j+1] = t;\r\n            swaps++;\r\n         }\r\n      }\r\n      printf("%d\\n",swaps+extra);\r\n   dun:;}\r\n   if (1 == scanf("%s",buf)) printf("extra input!!!\\n");\r\n}\r\n', '', 0, 262144, 1, 2, '2010-08-18 23:29:46', '0001-01-01 00:00:00'),
(241, 1, 224, 0, '#include <stdio.h>\r\n\r\nunsigned gcd(unsigned a, unsigned b){\r\n   if (b == 0) return a;\r\n   return gcd(b,a%b);\r\n}\r\n\r\nunsigned lo,hi,bestlo, besthi, c[100], i,j,k,m,n,t,L,g;\r\n\r\nmain(){\r\n   while (2 == scanf("%d%d",&n,&t)) {\r\n      for (i=0;i<n;i++) scanf("%d",&c[i]);\r\n      while (t--) {\r\n         scanf("%d",&L);\r\n         bestlo = 0;\r\n         besthi = 0xffffffff;\r\n         for (i=0;i<n;i++) for (j=i+1;j<n;j++) for (k=j+1;k<n;k++) for (m=k+1;m<n;m++) {\r\n            g = c[i]/gcd(c[i],c[j])*c[j];\r\n            g = g/gcd(g,c[k])*c[k];\r\n            g = g/gcd(g,c[m])*c[m];\r\n            lo = L/g*g;\r\n            if (lo > bestlo) bestlo = lo;\r\n            if (lo != L) lo += g;\r\n            if (lo < besthi) besthi = lo;\r\n         }\r\n         printf("%u %u\\n",bestlo,besthi);\r\n      }\r\n   }\r\n}\r\n', '', 483, 258048, 1, 2, '2010-08-18 23:29:46', '0001-01-01 00:00:00'),
(242, 1, 225, 0, '#include <cstdio>\r\n#include <cstdlib>\r\n#include <cstring>\r\n#include <cmath>\r\n\r\nint main()\r\n{\r\n	int i,j;\r\n	double L,d,C,L2,R,delta,theta,x;\r\n\r\n	while (scanf("%lf %lf %lf ", &L, &d, &C)==3) {\r\n	  if (L < 0) break;\r\n 		if (L < 1e-6 || d < 1e-6 || C < 1e-6) {\r\n 			printf("0.000\\n");\r\n 			continue;\r\n 		}\r\n		L2 = d*C*L + L;\r\n		L2/=2.0; L/=2.0;\r\n		for (x = 1e20, delta=1e20; delta>=1e-12; delta/=2.0) {\r\n			R = sqrt(x*x + L*L);\r\n			if (fabs(x) < 1e-10) x = 1e-10;\r\n			theta = atan(L/x);\r\n			if (theta*R < L2) x-=delta;else x+=delta;\r\n		}\r\n		R = sqrt(x*x + L*L);\r\n		printf("%.3lf\\n", R-x);\r\n	}\r\n	return 0;\r\n}\r\n', '', 0, 262144, 1, 2, '2010-08-19 00:02:16', '0001-01-01 00:00:00'),
(243, 1, 226, 0, '// three powers problem\r\n// took me about 20 min, but I was struggling with java.\r\n// I could see somebody doing it <10 min.\r\nimport java.math.*;\r\nimport java.io.*;\r\nimport java.util.*;\r\n\r\nclass Main {\r\n    public static void main(String[] args) {\r\n        BufferedReader in = new BufferedReader(\r\n				new InputStreamReader(System.in));\r\n        String line;\r\n	StringTokenizer st;\r\n	BigInteger a,b,n,r;\r\n	BigInteger two,three;\r\n	int p,first;\r\n\r\n	two = new BigInteger("2");\r\n	three = new BigInteger("3");\r\n	try {\r\n	    while(true) {\r\n                line = in.readLine();\r\n                if(line == null) break;\r\n		st = new StringTokenizer(line);\r\n		n = new BigInteger(st.nextToken());\r\n		if (n.intValue() == 0) break;\r\n		n = n.subtract(BigInteger.valueOf(1));\r\n		System.out.print("{");\r\n		\r\n		for (p=0, first=1; n.signum()>0; p++) {\r\n			r = n.mod(two);\r\n			if (r.intValue() == 1) {\r\n				if (first==0) System.out.print(", ");\r\n				else System.out.print(" ");\r\n				first = 0;\r\n				System.out.print(three.pow(p));\r\n			}\r\n			n = n.divide(BigInteger.valueOf(2));		\r\n		}\r\n		System.out.println(" }");\r\n	    }\r\n	} catch(Exception e) {\r\n            System.err.println(e.toString());\r\n	}\r\n    }\r\n}\r\n', '', 139, 42278912, 1, 4, '2010-08-19 00:02:17', '0001-01-01 00:00:00'),
(244, 1, 227, 0, '#include <cstdio>\r\n#include <cstdlib>\r\n#include <string>\r\n#include <utility>\r\n#include <vector>\r\n#include <set>\r\nusing namespace std;\r\nint main()\r\n{\r\n	int cnum,nc,i,n,N,M,L,cost;\r\n	char name[105][32];\r\n	int A[105],B[105];\r\n\r\n	scanf("%d ", &nc);\r\n	for (cnum=1; cnum<=nc; cnum++) {\r\n		set<pair<int,string> >::iterator ii;\r\n		set<pair<int,string> > ss;\r\n		printf("Case %d\\n", cnum);\r\n		scanf("%d %d %d ", &N, &M, &L);\r\n		for (i=0; i<L; i++) {\r\n			scanf("%[^:]: %d, %d ", name[i], &A[i], &B[i]);\r\n			n = N;\r\n			cost = 0;\r\n			while(n/2>=M && B[i]<=(n-n/2)*A[i]) {\r\n				n /= 2;\r\n				cost += B[i];\r\n			}\r\n			cost += (n-M)*A[i];\r\n			string sss = name[i];\r\n			ss.insert(make_pair(cost,sss));\r\n		}\r\n		for (ii=ss.begin(); ii!=ss.end(); ii++) \r\n			printf("%s %d\\n", (ii->second).c_str(), ii->first);\r\n	}\r\n	return 0;\r\n}\r\n', '', 15, 405504, 1, 2, '2010-08-19 00:02:17', '0001-01-01 00:00:00'),
(245, 1, 228, 0, '#include <stdio.h>\r\n#include <assert.h>\r\n#include <math.h>\r\n#include <map>\r\n#include <limits.h>\r\n#include <float.h>\r\n\r\nusing namespace std;\r\n\r\n#define MAXN 10+1\r\n\r\nint main () {\r\n  int t;\r\n  scanf("%d",&t);\r\n  for(int sc = 1; sc <=t; sc++) {\r\n    printf("Scenario %d:\\n",sc);\r\n    int n, v[MAXN], h[MAXN];\r\n    scanf("%d",&n);\r\n    assert(1<=n && n<=MAXN);\r\n    int gs;\r\n    scanf("%d\\n",&gs);\r\n    for(int i=1;i<=n;i++) { scanf("%d",&h[i]); assert(1<=h[i]&&h[i]<=50); }\r\n    for(int i=1;i<=n;i++) { scanf("%d",&v[i]); assert(1<=v[i]&&v[i]<=50); }\r\n    int xs,ys,xt,yt,te,tl;\r\n    scanf("%d%d%d%d%d%d",&xs,&ys,&xt,&yt,&te,&tl);\r\n    assert(tl <= 1000);\r\n    int dx = 0, dy = 0;\r\n    map<int,double> m[MAXN][MAXN];\r\n    pair<int,double> p;\r\n    if (tl < te) goto B;\r\n    if (xs<xt) dx = 1; if (xs>xt) dx = -1;\r\n    if (ys<yt) dy = 1; if (ys>yt) dy = -1;\r\n    m[xs][ys][0] = 0.0;\r\n    for(int i=xs;;i+=dx) {\r\n      if (dx > 0 && i>xt) break;\r\n      if (dx < 0 && i<xt) break;\r\n      for(int j=ys;;j+=dy) {\r\n	//	printf("%d %d, qsize = %d \\n",i,j, m[i][j].size());\r\n	if (dy > 0 && j>yt) break;\r\n	if (dy < 0 && j<yt) break;\r\n	if (i==xt && j==yt) goto A;\r\n	if (i!=xt) {\r\n	  map<int,double> :: iterator pos;\r\n	  for(pos=m[i][j].begin();pos!=m[i][j].end();pos++) {\r\n	    for(int s=5;s<=h[j];s+=5) {\r\n	      int t = (*pos).first+3600*gs/s;\r\n	      if ( t > 60*tl) continue;\r\n	      if (m[i+dx][j].find(t) == m[i+dx][j].end() ||\r\n		  m[i+dx][j][t] > (*pos).second+gs/(80-0.03*s*s))\r\n		m[i+dx][j][t] = (*pos).second+gs/(80-0.03*s*s);\r\n	    }\r\n	  }\r\n	}\r\n	if (j!=yt) {\r\n	  map<int,double> :: iterator pos;\r\n	  for(pos=m[i][j].begin();pos!=m[i][j].end();pos++) {\r\n	    for(int s=5;s<=v[i];s+=5) {\r\n	      int t = (*pos).first+3600*gs/s;\r\n	      if (t > 60*tl) continue;\r\n	      if (m[i][j+dy].find(t) == m[i][j+dy].end() ||\r\n		  m[i][j+dy][t] > (*pos).second+gs/(80-0.03*s*s))\r\n		m[i][j+dy][t] = (*pos).second+gs/(80-0.03*s*s);\r\n	    }\r\n	  }\r\n	}\r\n	if (!dy) break;\r\n      }\r\n      if (!dx) break;\r\n    }\r\n  A: if (m[xt][yt].empty()) goto B;\r\n  else {\r\n    p = *(m[xt][yt].begin());\r\n    assert(p.first <= tl*60);\r\n    double bt=INT_MAX,btf, bf=DBL_MAX, bft;\r\n    map<int,double>:: iterator pos;\r\n    for(pos=m[xt][yt].begin();pos!=m[xt][yt].end();pos++) {\r\n      p = *pos;\r\n      assert(p.first <= tl*60);\r\n      if (p.first < 60*te || p.first > 60*tl) continue;\r\n      if (p.second < bf) { bf = p.second; bft = p.first; }\r\n      else if (p.second == bf && p.first < bft) bft = p.first;\r\n      if (p.first < bt) { bt = p.first; btf = p.second; }\r\n      else if (p.first == bt && p.second < btf) btf = p.second;\r\n    }\r\n    if (bt == -1) goto B;\r\n    printf("The earliest  arrival: %.0f minutes, fuel %.2f gallons\\n",\r\n	   ceil(bt/60), btf);\r\n    printf("The economical travel: %.0f minutes, fuel %.2f gallons\\n",\r\n	   ceil(bft/60), bf);\r\n    continue;\r\n  }\r\n  B: printf("IMPOSSIBLE\\n"); \r\n  }\r\n}\r\n', '', 1069, 24862720, 1, 2, '2010-08-19 00:02:17', '0001-01-01 00:00:00'),
(246, 1, 229, 0, '// Leaf prunning.\r\n\r\n// Each leaf keeps information about the subtree that was reduced\r\n// to the leaf during the course of the algorithm, it is the number\r\n// of surplus marbles in the subtree, when negative it is the number of missing\r\n// marbles in the subtree.\r\n\r\n// Initially, each vertex has the value m equal the number of original marbles\r\n// at it.\r\n\r\n// Let set L be the set of leaves of the tree.\r\n// tcost = 0\r\n// while card(L) > 1\r\n//   pick a member of L, name it v\r\n//   switch m[v] of\r\n//   case m[v] < 0\r\n//     tcost += -m[v]           // all have to walk this step from the parent\r\n//     m[parent[v]] += m[v]\r\n//   case m[v] = 0\r\n//     tcost++                  // 1 has to walk from the parent\r\n//     m[parent[v]--   \r\n//   else\r\n//     tcost += m[v]-1          // 1 has to stay the rest has to walk \r\n//                              // to the parent\r\n//     m[parent[v]] += m[v]-1\r\n//   \r\n\r\n// P. Rudnicki, Edmonton, April 8th \r\n\r\n#include <stdio.h>\r\n#include <set>\r\n\r\nusing namespace std;\r\n#define MAXN 10000\r\n\r\nint m[MAXN], parent[MAXN];\r\nset<int> children[MAXN];\r\nset<int> leaves, nleaves;\r\nint main () {\r\n  int n, tcost;\r\n  while (scanf("%d",&n) == 1) {\r\n    if (!n) break;\r\n    leaves.clear();\r\n    tcost = 0;\r\n    for(int i = 1; i <= n; i++) {\r\n      int v, d;\r\n      scanf("%d",&v);\r\n      scanf("%d%d",&m[v],&d);\r\n      for(int j = 1; j <= d; j++) {\r\n	int c;\r\n	scanf("%d",&c);\r\n	children[v].insert(c);\r\n	parent[c] = v;\r\n      }\r\n      if (!d) leaves.insert(v);\r\n    }\r\n    set<int>:: iterator pos;\r\n    while (leaves.size() != 1) {\r\n      nleaves.clear();\r\n      for(pos = leaves.begin(); pos != leaves.end(); pos++) {\r\n	if (m[*pos] <= 0) {\r\n	  tcost += -m[*pos]+1;\r\n	  m[parent[*pos]] += m[*pos]-1;\r\n	} else {\r\n	  tcost += m[*pos]-1;\r\n	  m[parent[*pos]] += m[*pos]-1;\r\n	}\r\n	children[parent[*pos]].erase(*pos);\r\n	if (children[parent[*pos]].empty()) \r\n	  nleaves.insert(parent[*pos]);\r\n      }\r\n      leaves = nleaves;\r\n    }\r\n    printf("%d\\n",tcost);\r\n  }\r\n}\r\n', '', 31, 1376256, 1, 2, '2010-08-19 00:02:17', '0001-01-01 00:00:00'),
(247, 1, 230, 0, '#include <stdio.h>\r\n#include <math.h>\r\n\r\nint n, m, i, j, k, c, cases, x[1000000], y[1000000], l[1000000], r[1000000], \r\n                    d[1000000];\r\nint hi, lo, mid, cookie;\r\n\r\nint test(int dd) {\r\n   int i, rr=0;\r\n   ++cookie;\r\n   for (i=j=0;i<n;i++) {\r\n      if (d[l[i]] == cookie) continue;\r\n      rr++;\r\n      int xx = x[l[i]]+y[l[i]]+dd;\r\n//printf("i %d l[i] %d xx %d\\n",i,l[i],xx);\r\n      for (;j<n && x[r[j]]-y[r[j]] <= xx;j++) {\r\n         d[r[j]] = cookie;\r\n      }\r\n      if (j >= n) break;\r\n   }\r\n//printf("test %d return %d\\n",dd,rr);\r\n   return rr;\r\n}\r\n\r\nint compl(int *a, int *b){\r\n   return (x[*a]+y[*a]) - (x[*b]+y[*b]);\r\n}\r\n\r\nint compr(int *a, int *b){\r\n   return (x[*a]-y[*a]) - (x[*b]-y[*b]);\r\n}\r\n\r\nmain(){\r\n   scanf("%d",&cases);\r\n   for (c=1; c <= cases; c++) {\r\n      int miny = 2000000;\r\n      scanf("%d%d",&n,&m);  \r\n      for (i=0;i<n;i++) {\r\n         scanf("%d%d",&y[i],&x[i]);\r\n         l[i] = r[i] = i;\r\n         if (y[i] < miny) miny = y[i];\r\n      }\r\n//printf("sorting\\n");\r\n      qsort(l,n,sizeof(int),compl);\r\n//printf("done sort 1\\n");\r\n      qsort(r,n,sizeof(int),compr);\r\n//printf("done sort 2\\n");\r\n\r\nfor (i=0;i<n;i++) {\r\n   //printf("lefti %d %d: %d,%d: %d\\n", i, l[i], x[l[i]], y[l[i]], x[l[i]]+y[l[i]]);\r\n}\r\nfor (i=0;i<n;i++) {\r\n   //printf("riti %d %d: %d,%d: %d\\n", i, r[i], x[r[i]], y[r[i]], x[r[i]]-y[r[i]]);\r\n}\r\n      lo = -miny*2+1;\r\n      hi = 4000000;\r\n      while (hi >= lo) {\r\n         mid = (hi+lo)/2;\r\n         if (test(mid) > m) lo = mid+1;\r\n         else hi = mid-1;\r\n      }\r\n      if (test(hi) <= m) lo = hi;\r\n      printf("Case %d: %0.0lf\\n",c,floor(lo/-2.0+.00000001));\r\n   }\r\n}\r\n', '', 468, 20295680, 1, 1, '2010-08-19 00:04:28', '0001-01-01 00:00:00'),
(248, 1, 231, 0, '#include <stdio.h>\r\n\r\nint i, S, x, y, dx, dy;\r\n\r\nmain(){\r\n   while (5 == scanf("%d%d%d%d%d",&S,&x,&y,&dx,&dy)) {\r\n      if (!S) return 0;\r\n      for (i=0; i< 2000000 && (x%S == 0 || y%S == 0 || x%(2*S)/S == y%(2*S)/S); i++) {\r\n         x += dx;\r\n         y += dy;\r\n      }\r\n      if (i < 2000000) \r\n         printf("After %d jumps the flea lands at (%d, %d).\\n", i,x,y);\r\n      else\r\n         printf("The flea cannot escape from black squares.\\n");\r\n   }\r\n   printf("missing delimiter\\n");\r\n}\r\n', '', 124, 262144, 1, 1, '2010-08-19 00:04:29', '0001-01-01 00:00:00'),
(249, 1, 232, 0, '#include <stdio.h>\r\n#include <math.h>\r\n\r\ndouble x,xx,b,r;\r\nint p;\r\n\r\nmain(){\r\n   while (1 == scanf("%lf",&x)) {\r\n      if (!x) return 0;\r\n      xx = fabs(x);\r\n      for (b=2;(r=b*b)<=xx;b++) {\r\n         for (p=2;r<xx;p++) r*=b;\r\n         if (r == xx) {\r\n            if (x > 0 || p%2) {\r\n               printf("%d\\n",p);\r\n               goto done;\r\n            }\r\n         }\r\n      }\r\n      printf("1\\n");\r\n   done:;} \r\n   printf("missing delimter\\n");\r\n}\r\n', '', 15, 258048, 1, 1, '2010-08-19 00:04:29', '0001-01-01 00:00:00'),
(250, 1, 233, 0, '#include <stdio.h>\r\n\r\nint cperg[] = {9,4,4,4,7};\r\n\r\nint i,j,k,m,n,q[5];\r\ndouble cals, percent, totfat, totcal;\r\nchar u[5];\r\n\r\nmain(){\r\n   for (;;) {\r\n      totfat = totcal = 0;\r\n      for (n=0;;n++){\r\n         cals = percent = 0;\r\n         for (i=0;i<5;i++) {\r\n            if (2 != scanf("%d%c",&q[i],&u[i])) break;\r\n            if (u[i] == ''C'') cals += q[i];\r\n            if (u[i] == ''g'') cals += q[i]*cperg[i];\r\n            if (u[i] == ''%'') percent += q[i];\r\n         }\r\n         if (i == 0) break;\r\n         cals = cals * 100 / (100-percent);\r\n         totcal += cals;\r\n         if (u[0] == ''C'') totfat += q[0];\r\n         if (u[0] == ''g'') totfat += q[0]*9;\r\n         if (u[0] == ''%'') totfat += q[0]*cals/100;\r\n      }\r\n      if (n == 0) break;\r\n      printf("%0.0lf%%\\n",100*totfat/totcal);\r\n   }\r\n}\r\n', '', 15, 262144, 1, 1, '2010-08-19 00:05:23', '0001-01-01 00:00:00'),
(251, 1, 234, 0, '#include <stdio.h>\r\n#include <math.h>\r\n\r\nint g,i,j,k,m,n,term,rep,q,num,den;\r\nint bestn, bestd;\r\nchar d[10], a[10], b[10], c[10];\r\n\r\ngcd(int a, int b) {\r\n   if (b == 0) return a;\r\n   return gcd(b,a%b);\r\n}\r\n\r\nmain(){\r\n   while (1 == scanf(" 0.%[0-9]...",d)) {\r\n      bestn=bestd=1000000000;\r\n      for (i=0;d[i];i++) {\r\n         strncpy(a,d,i);\r\n         a[i] = 0;\r\n         strcpy(b,d+i);\r\n         num = atoi(a) * (int)(pow(10,strlen(b))-1+1e-10) + atoi(b);\r\n         den = (int)(1e-8+pow(10,i)) * (int)(1e-8+pow(10,strlen(b))-1);\r\n         g = gcd(num,den);\r\n         num /= g; den /=g;\r\n         if (den < bestd) {\r\n            bestn = num; bestd = den;\r\n         }\r\n      }\r\n      printf("%d/%d\\n",bestn,bestd);\r\n   }\r\n}\r\n', '', 0, 258048, 1, 1, '2010-08-19 00:05:23', '0001-01-01 00:00:00'),
(252, 1, 235, 0, '#include <stdio.h>\r\n#include <math.h>\r\n\r\n#define sq(x) ((x)*(x))\r\n\r\nint x[10],y[10],X[10],Y[10];\r\nint i,j,k,f,a,A,d,D,s,S;\r\n\r\nmain(){\r\n   while (1 == scanf("%d",&f) && f) {\r\n      for (i=0;i<f;i++) scanf("%d%d",&x[i],&y[i]);\r\n      for (i=0;i<f;i++) scanf("%d%d",&X[i],&Y[i]);\r\n      a = sq(x[0]-x[1]) + sq(y[0]-y[1]);\r\n      A = sq(X[0]-X[1]) + sq(Y[0]-Y[1]);\r\n      for (i=0;i<f;i++) for (j=0;j<f;j++) {\r\n         d = sq(x[i]-x[j]) + sq(y[i]-y[j]);\r\n         D = sq(X[i]-X[j]) + sq(Y[i]-Y[j]);\r\n         if ((long long)a*D != (long long)A*d) goto foo;\r\n      }\r\n      for (i=2;i<f;i++) {\r\n         s = (x[1]-x[0])*(y[i]-y[0]) - (y[1]-y[0])*(x[i]-x[0]);\r\n         S = (X[1]-X[0])*(Y[i]-Y[0]) - (Y[1]-Y[0])*(X[i]-X[0]);\r\n         if (s < 0 && S > 0 || s > 0 && S < 0) goto foo;\r\n      }\r\n      printf("similar\\n");\r\n      continue;\r\n      foo: printf("dissimilar\\n");\r\n   }\r\n   if (f) printf("missing end delimiter\\n");\r\n}\r\n', '', 0, 258048, 1, 1, '2010-08-19 00:05:23', '0001-01-01 00:00:00'),
(253, 1, 236, 0, '/*\r\n\r\n   XYZZY ADVEN Game Solution\r\n\r\n   Method:\r\n\r\n      1.  V steps of Ford Fulkerson\r\n      2.  If no progress after V steps we have\r\n            the least-cost path (no cycles)\r\n      3.  At the Vth cycle, one vertex of every\r\n            strongly connected component with\r\n            a negative cycle will be updated.\r\n            All vertices that are updated are\r\n            either members of or reachable from\r\n            a negative cycle.  We can set all \r\n            other vertices to ''infeasible''\r\n      4.  At the Vth cycle we can also set all\r\n            edge costs to 0, because we don''t\r\n            care about the cost any more; only\r\n            connectivity\r\n      5.  Another V steps tells us if we can\r\n            reach our goal\r\n\r\n*/\r\n\r\n#include <stdio.h>\r\n#include <string.h>\r\n\r\nint cost[101];\r\nint best[101];\r\nint last[101];\r\nchar adj[101][101];\r\n\r\nint z,i,j,k,m,n,e,progress;\r\nmain(){\r\n   while ((1 == scanf("%d",&n)) && n != -1){\r\n      memset(adj,0,sizeof(adj));\r\n      memset(last,0,sizeof(last));\r\n      for (i=1;i<=n;i++) best[i] = 0x3fffffff;\r\n      for (i=1;i<=n;i++) {\r\n         scanf("%d%d",&e,&m);\r\n         cost[i] = -e;\r\n         for (j=0;j<m;j++) {\r\n            scanf("%d",&k);\r\n            adj[i][k] = 1;\r\n         }\r\n      }\r\n      best[1] = -100;\r\n      for (z=0;;z++) {\r\n         progress = 0;\r\n         for (i=1;i<=n;i++) for (j=1;j<=n;j++) {\r\n            if (adj[i][j] &&\r\n                best[i] < 0 && best[i] + cost[j] < 0 &&\r\n                best[i] + cost[j] < best[j]){\r\n                   best[j] = best[i] + cost[j];\r\n                   progress = 1;\r\n                   last[j] = z;\r\n            }\r\n         }\r\n         if (!progress || best[n] < 0) break;\r\n         if (z == n) {\r\n            for (i=1;i<=n;i++) if (last[i] != z) best[i] = 0x3fffffff;\r\n            for (i=1;i<=n;i++) cost[i] = 0;\r\n         }\r\n      }\r\n      if (best[n] < 0 /*|| z == n*/) printf("winnable\\n");\r\n      else printf("hopeless\\n");\r\n   }\r\n   if (n != -1) printf("missing end delimiter\\n");\r\n}\r\n', '', 31, 270336, 1, 1, '2010-08-19 00:05:23', '0001-01-01 00:00:00'),
(254, 1, 237, 0, '#include <stdio.h>\r\n\r\nint a,b,c,d,r;\r\n\r\nmain(){\r\n   while ((4 == scanf("%d%d%d%d",&a,&b,&c,&d)) && (a||b||c||d)){\r\n      a*=9; b*=9; c*=9; d*=9;\r\n      r = 720;\r\n      r += (a-b+360)%360;\r\n      r += 360;\r\n      r += (c-b+360)%360;\r\n      r += (c-d+360)%360;\r\n      printf("%d\\n",r);\r\n   }\r\n   if (a||b||c||c) printf("missing end delimiter\\n");\r\n}\r\n', '', 0, 262144, 1, 1, '2010-08-19 00:08:06', '0001-01-01 00:00:00'),
(255, 1, 238, 0, '#include <stdio.h>\r\n\r\nint b,i,j,k,n;\r\nlong long r,m;\r\n\r\nchar P[2000], M[10];\r\n\r\ndump(int r){\r\n   if (!r) return;\r\n   dump(r/b);\r\n   printf("%d",r%b);\r\n}\r\n\r\nmain(){\r\n   while ((3 == scanf("%d%s%s",&b,P,M)) && b){\r\n      m = 0;\r\n      for (i=0;M[i];i++) m = m*b + M[i] - ''0'';\r\n      r = 0;\r\n      for (i=0;P[i];i++) {\r\n         r = r * b + P[i] - ''0'';\r\n         r %= m;\r\n      }\r\n      if (!r) printf("0");\r\n      dump(r);\r\n      printf("\\n");\r\n   }\r\n   if(b) printf("missing end delimiter\\n");\r\n}\r\n', '', 15, 262144, 1, 1, '2010-08-19 00:08:06', '0001-01-01 00:00:00'),
(256, 1, 239, 0, '#include <stdio.h>\r\n\r\ntypedef char str[101];\r\n\r\nstruct pp {\r\n   str name, p1, p2, b, d;\r\n} p[1000];\r\nint np, first;\r\n\r\nstr buf, cmd, name, p1, p2, b, d;\r\n\r\nfix(char *s){\r\n   while (s[strlen(s)-1] == '' '') s[strlen(s)-1] = 0;\r\n}\r\n\r\nmain(){\r\n   int i;\r\n   while (gets(buf)) {\r\n      *cmd = *name = *d = *p1 = *p2 = 0;\r\n      sscanf(buf,"%s %[^:] : %[^:] : %[^:] : %[^:]",cmd,name,d,p1,p2);\r\n      fix(name);\r\n      fix(p1);\r\n      fix(p2);\r\n      fix(d);\r\n      if (!strcmp(cmd,"BIRTH")) {\r\n         strcpy(p[np].name, name);\r\n         strcpy(p[np].b, d);\r\n         if (strcmp(p1,p2) < 0) {\r\n            strcpy(p[np].p1, p1);\r\n            strcpy(p[np].p2, p2);\r\n         } else {\r\n            strcpy(p[np].p1, p2);\r\n            strcpy(p[np].p2, p1);\r\n         }\r\n         np++;\r\n         qsort(p,np,sizeof(struct pp),strcmp);\r\n      } else if (!strcmp(cmd,"DEATH")) {\r\n         for (i=0;i<np && strcmp(name,p[i].name);i++);\r\n         strcpy(p[i].d, d);\r\n      } else if (!strcmp(cmd,"ANCESTORS")) {\r\n         if (first++) printf("\\n");\r\n         printf("ANCESTORS of %s\\n",name);\r\n         ancestors(name,0);\r\n      } else if (!strcmp(cmd,"DESCENDANTS")) {\r\n         if (first++) printf("\\n");\r\n         printf("DESCENDANTS of %s\\n",name);\r\n         descendants(name,2);\r\n      } else if (!strcmp(cmd,"QUIT")) {\r\n         exit(0);\r\n      } else {\r\n         printf("invalid command %s\\n",cmd);\r\n      }\r\n   }\r\n   printf("missing QUIT command \\n");\r\n}\r\n\r\nancestors(str n, int ind){\r\n   int i,j;\r\n   for (i=0;i<np && strcmp(n,p[i].name);i++) {}\r\n   if (ind) {\r\n      for (j=0;j<ind;j++) printf(" ");\r\n      printf("%s",n);\r\n      if (i < np) {\r\n         printf(" %s -",p[i].b);\r\n         if (*p[i].d) printf(" %s",p[i].d);\r\n      }\r\n      printf("\\n");\r\n   }\r\n   if (i < np) {\r\n      ancestors(p[i].p1,ind+2);\r\n      ancestors(p[i].p2,ind+2);\r\n   }\r\n}\r\n\r\ndescendants(str n, int ind){\r\n   int i,j;\r\n   for (i=0;i<np;i++) {\r\n      if (!strcmp(n,p[i].p1) || !strcmp(n,p[i].p2)) {\r\n         for (j=0;j<ind;j++) printf(" ");\r\n         printf("%s %s -",p[i].name,p[i].b);\r\n         if (*p[i].d) printf(" %s",p[i].d);\r\n         printf("\\n");\r\n         descendants(p[i].name, ind+2);\r\n      }\r\n   }\r\n}\r\n', '', 0, 765952, 1, 1, '2010-08-19 00:08:06', '0001-01-01 00:00:00'),
(257, 1, 240, 0, '#include <stdio.h>\r\n#include <math.h>\r\n#include <string.h>\r\n#include <assert.h>\r\n\r\nchar dirname[32][10] = {\r\n  "N", "NbE", "NNE", "NEbN", "NE", "NEbE",\r\n  "ENE", "EbN", "E", "EbS", "ESE", "SEbE", "SE",\r\n  "SEbS", "SSE", "SbE", "S", "SbW", "SSW", "SWbS",\r\n  "SW", "SWbW", "WSW", "WbS", "W", "WbN", "WNW",\r\n  "NWbW", "NW", "NWbN", "NNW", "NbW"\r\n};\r\n\r\nint dirs[1000];\r\nint pace[1000];\r\n\r\nint n;\r\n\r\nint find_dirs(char *name)\r\n{\r\n  int i;\r\n  for (i = 0; i < 32; i++) {\r\n    if (!strcmp(dirname[i], name)) {\r\n      return i;\r\n    }\r\n  }\r\n  assert(0);\r\n}\r\n\r\ndouble dist_line(double ax, double ay, double bx, double by, \r\n		 double cx, double cy)\r\n{\r\n  double L2, s;\r\n\r\n  L2 = (bx-ax)*(bx-ax)+(by-ay)*(by-ay);\r\n  assert(L2 > 0);\r\n  s = ((ay-cy)*(bx-ax)-(ax-cx)*(by-ay)) / L2;\r\n\r\n  return fabs(s*sqrt(L2));\r\n}\r\n\r\ndouble project(double ax, double ay, double bx, double by,\r\n	       double cx, double cy)\r\n{\r\n  double vx, vy, wx, wy;\r\n\r\n  vx = bx-ax; vy = by-ay;\r\n  wx = cx-ax; wy = cy-ay;\r\n  return (vx*wx+vy*wy)/(vx*vx+vy*vy);\r\n}\r\n\r\nint main(void)\r\n{\r\n  char buffer[10];\r\n  double angle;\r\n  double tx, ty, x, y, x2, y2, theta;\r\n  int i;\r\n  double pi, d, d2, t;\r\n\r\n  pi = atan(1)*4;\r\n\r\n  while (scanf("%d", &n) == 1 && n > 0) {\r\n    for (i = 0; i < n; i++) {\r\n      scanf("%s", buffer);\r\n      dirs[i] = find_dirs(buffer);\r\n      scanf("%d", pace+i);\r\n    }\r\n    scanf("%lf", &angle);\r\n    angle = angle*2*pi/360.0;\r\n    \r\n    /* figure out the treasure */\r\n    tx = ty = 0.0;\r\n    for (i = 0; i < n; i++) {\r\n      theta = (2*pi/32.0)*dirs[i]+angle;\r\n      theta = pi/2 - theta;\r\n      tx += pace[i]*cos(theta);\r\n      ty += pace[i]*sin(theta);\r\n    }\r\n\r\n    /* now do it again and find the distance */\r\n    d = sqrt(tx*tx+ty*ty);\r\n    x = y = 0.0;\r\n    for (i = 0; i < n; i++) {\r\n      theta = (2*pi/32.0)*dirs[i];\r\n      theta = pi/2 - theta;\r\n      x2 = x + pace[i]*cos(theta);\r\n      y2 = y + pace[i]*sin(theta);\r\n      d2 = sqrt((tx-x2)*(tx-x2) + (ty-y2)*(ty-y2));\r\n      if (d2 < d) {\r\n	d = d2;\r\n      }\r\n\r\n      /* what if it''s in between? */\r\n      d2 = dist_line(x,y,x2,y2,tx,ty);\r\n      t = project(x,y,x2,y2,tx,ty);\r\n      if (-1e-8 <= t && t <= 1.0+1e-8 && d2 < d) {\r\n	d = d2;\r\n      }\r\n\r\n      x = x2;\r\n      y = y2;\r\n    }\r\n    printf("%.2f\\n", d);\r\n  }\r\n\r\n  return 0;\r\n}\r\n', '', 62, 266240, 1, 1, '2010-08-19 00:08:06', '0001-01-01 00:00:00');
INSERT INTO `tbl_submitions` (`id`, `user_id`, `problem_id`, `exercise_id`, `source`, `result`, `used_time`, `used_memory`, `status`, `compiler_id`, `created`, `modified`) VALUES
(258, 1, 241, 0, '#include <stdio.h>\r\n#include <string.h>\r\n\r\nchar buf[101000], cb1[101000], cb2[101000], *c[101000];\r\n\r\nint comp(char **a, char **b) {\r\n   return strcmp(*a,*b);\r\n}\r\n\r\nstruct ss {\r\n   char *p;\r\n   int len;\r\n} s[101000];\r\n\r\nint comps(struct ss *a, struct ss *b) {\r\n   if (a->len != b->len) return b->len - a->len;\r\n   return a->p - b->p;\r\n}\r\n\r\nint n1, n2, ns, i, j, k, m, prev, hi, lo, mid, other, C;\r\n\r\nmain(){\r\n   while (1 == scanf("%d ",&k) && k) {\r\n      if (C++) printf("\\n");\r\n      printf("CASE %d\\n",C);\r\n      gets(buf);\r\n      n1 = n2 = ns = 0;\r\n      while (gets(buf) && strcmp(buf,"END TDP CODEBASE")) {\r\n         strcpy(cb1+n1,buf);\r\n         n1 += strlen(buf);\r\n         strcpy(cb1+n1++,"\\n");\r\n      }\r\n      gets(buf);\r\n      while (gets(buf) && strcmp(buf,"END JCN CODEBASE")) {\r\n         strcpy(cb2+n2,buf);\r\n         n2 += strlen(buf);\r\n         strcpy(cb2+n2++,"\\n");\r\n      }\r\n      for (i=0;i<n1;i++) c[i] = cb1+i;\r\n      qsort(c,n1,sizeof(char *),comp);\r\n      prev = 0;\r\n      for (i=0;i<n2;i++) {\r\n         lo = 1;\r\n         hi = n1-2;\r\n         while (hi >= lo) {\r\n            mid = (hi + lo)/2;\r\n            int t = strcmp(cb2+i, c[mid]);\r\n            if (t < 0) hi = mid-1;\r\n            else lo = mid+1;\r\n         }\r\n         if (lo > mid) other = lo;\r\n         else other = hi;\r\n         for (j=0;c[mid][j] && c[mid][j] == cb2[i+j];j++);\r\n         for (m=0;c[other][m] && c[other][m] == cb2[i+m];m++);\r\n         if (m > j) j = m;\r\n         if (j && j >= prev) {\r\n            s[ns].p = cb2+i;\r\n            s[ns++].len = j;\r\n         }\r\n         prev = j;\r\n      }\r\n      qsort(s,ns,sizeof(struct ss),comps);\r\n      for (j=i=0;i<k && i<ns;i++) {\r\n         printf("INFRINGING SEGMENT %d LENGTH %d POSITION %d\\n",\r\n               ++j,s[i].len,s[i].p-cb2);\r\n         for (m=0;m<s[i].len;m++) printf("%c",s[i].p[m]);\r\n         printf("\\n");\r\n      }\r\n   }\r\n   if (k) printf("missing end delimiter\\n");\r\n}', '', 733, 1769472, 1, 1, '2010-08-19 00:09:28', '0001-01-01 00:00:00'),
(259, 1, 242, 0, '#include <stdlib.h>\r\n#include <stdio.h>\r\n\r\nchar n[5000], m[5000];\r\n\r\nint i,j,k,nn,mn;\r\n\r\nint rem(int d){\r\n   int i,carry=0;\r\n   for (i=0;i<nn;i++) {\r\n      carry = 10 * carry + n[i];\r\n      carry %= d;\r\n   }\r\n   return carry;\r\n}\r\n\r\nvoid Div(int d){\r\n   int i,carry=0;\r\n   for (i=0;i<nn;i++) {\r\n     carry = 10 * carry + n[i];\r\n     n[i] = carry/d;\r\n     carry %= d;\r\n   }\r\n}\r\n\r\nint one(){\r\n   int i;\r\n   for (i=0;i+1<nn;i++) if (n[i]) return 0;\r\n   return n[i] == 1;\r\n}\r\n     \r\nmain(){\r\n   while (strcmp(gets(n),"-1")) {\r\n      nn = strlen(n);\r\n      if (nn == 1) {\r\n         printf("1%c\\n",n[0]);\r\n         continue;\r\n      }\r\n      mn = 0;\r\n      for (i=0;i<nn;i++) n[i] -= ''0'';\r\n      for (i=9;i>1;i--) {\r\n         while (rem(i) == 0) {\r\n            m[mn++] = ''0''+i;\r\n            Div(i);\r\n         }\r\n      }\r\n      if (!one()) {\r\n         printf("There is no such number.\\n");\r\n         continue;\r\n      }\r\n      for (i=mn-1;i>=0;i--) printf("%c",m[i]);\r\n      printf("\\n");\r\n   }\r\n}', '', 93, 266240, 1, 1, '2010-08-19 00:09:28', '0001-01-01 00:00:00'),
(260, 1, 243, 0, '#include <stdio.h>\r\n#include <string.h>\r\n\r\nint i,j,k,m, mm[12];\r\nchar buf[2000];\r\n\r\nchar *p;\r\n\r\nchar *t[] = {"C","C#","D","D#","E","F","F#","G","G#","A","A#","B"};\r\n\r\nmain(){\r\n   for (i=0;i<12;i++) {\r\n      mm[i] |= (1<<((i+0)%12));\r\n      mm[i] |= (1<<((i+2)%12));\r\n      mm[i] |= (1<<((i+4)%12));\r\n      mm[i] |= (1<<((i+5)%12));\r\n      mm[i] |= (1<<((i+7)%12));\r\n      mm[i] |= (1<<((i+9)%12));\r\n      mm[i] |= (1<<((i+11)%12));\r\n   }\r\n      \r\n   while (gets(buf)) {\r\n      if (!strcmp(buf,"END")) break;\r\n      m = 0;\r\n      for (p=strtok(buf," ");p;p=strtok(NULL," ")) {\r\n         for (i=0;i<12 && strcmp(p,t[i]);i++);\r\n         m |= (1<<i);\r\n      }\r\n      for (k=i=0;i<12;i++) {\r\n         if (!(m & (~mm[i]))) {\r\n            if (k++) printf(" ");\r\n            printf("%s",t[i]);\r\n         }\r\n      }\r\n      printf("\\n");\r\n   }\r\n}', '', 0, 262144, 1, 1, '2010-08-19 00:09:28', '0001-01-01 00:00:00'),
(261, 1, 244, 0, '#include <math.h>\r\n#include <stdio.h>\r\n\r\ndouble Pl, Pr, C[1100], c;  // C[m] is cost to build m in a row\r\n\r\nint i,l,k,m,n,r;\r\n\r\nmain(){\r\n   while (3 == scanf("%d%lf%lf",&n,&Pl,&Pr)) {\r\n      if (Pl+Pr == 0) {\r\n         printf("%d.00\\n",n);\r\n         continue;\r\n      }\r\n      C[0] = 0;\r\n      for (i=1;i<=n;i++) C[i] = 1e19;\r\n      for (m=1;m<=n;m++) { \r\n         for (l=0;l<m;l++) {   // l dominoes on the left\r\n            r = m-l-1;\r\n            c = 1 + C[l] + C[r] + \r\n                (1/(1-Pr-Pl)-1) * (1+ Pl/(Pr+Pl)*C[l] + Pr/(Pr+Pl)*C[r]);\r\n            if (c < C[m]) C[m] = c;\r\n         }\r\n      }\r\n      printf("%0.2lf\\n",C[n]);\r\n   }\r\n}', '', 592, 266240, 1, 1, '2010-08-19 00:09:28', '0001-01-01 00:00:00'),
(262, 1, 245, 0, '#include <stdio.h>\r\n#include <string.h>\r\n\r\nchar buf[1000];\r\nchar couldbe[20];\r\n\r\n\r\nmain(){\r\n   memset(couldbe,1,sizeof(couldbe));\r\n   while (gets(buf) && strcmp(buf,"0")) {\r\n      int i, n = atoi(buf);\r\n      gets(buf);\r\n      if (!strcmp(buf,"too high")) {\r\n         for (i=n;i<=10;i++) couldbe[i] = 0;\r\n      } else if (!strcmp(buf,"too low")) {\r\n         for (i=1;i<=n;i++) couldbe[i] = 0;\r\n      } else {\r\n         if (couldbe[n]) printf("Stan may be honest\\n");\r\n         else printf("Stan is dishonest\\n");\r\n         memset(couldbe,1,sizeof(couldbe));\r\n      }\r\n   }\r\n   if (strcmp(buf,"0")) printf("missing input terminator\\n");\r\n}', '', 15, 262144, 1, 1, '2010-08-19 00:09:28', '0001-01-01 00:00:00'),
(263, 1, 246, 0, '#include <math.h>\r\n#define M_PI (2*acos((double)0))\r\n\r\nint i,j,k,m,n,t,besti;\r\ndouble x[3], y[3], xx, yy, delta, a1, a2, a3, a;\r\n\r\ndouble gcd(double a, double b) {\r\n   if (fabs(b) < 6e-3) return a;\r\n   return gcd(b,fmod(a,b));\r\n}\r\n\r\nvoid bi(double x1, double y1, double x2, double y2,\r\n        double *a, double *b, double *c) {\r\n   *a = 2*(x2-x1);\r\n   *b = 2*(y2-y1);\r\n   *c = x2*x2 + y2*y2 - x1*x1 - y1*y1;\r\n}\r\n\r\nint isct(double a, double b, double c, double aa, double bb, double cc,\r\n         double *x, double *y) {\r\n   double det = a*bb - b*aa;\r\n   if (fabs(det) < 1e-10) return 0;\r\n   *x = (-b*cc + c*bb)/det;\r\n   *y = (a*cc - c*aa)/det;\r\n   return 1;\r\n}\r\n\r\n\r\nint circle(double x1, double y1, double x2, double y2,\r\n           double x3, double y3, double *x, double *y) {\r\n   double a1,b1,c1,a2,b2,c2;\r\n   bi(x1,y1,x2,y2,&a1,&b1,&c1);\r\n   bi(x2,y2,x3,y3,&a2,&b2,&c2);\r\n   return isct(a1,b1,c1,a2,b2,c2,x,y);\r\n}\r\n\r\n\r\nmain(){\r\n   scanf("%d",&t);\r\n   while (t--) {\r\n      for (i=0;i<3;i++) scanf("%lf%lf",&x[i],&y[i]);\r\n\r\n      circle(x[0],y[0],x[1],y[1],x[2],y[2],&xx,&yy);\r\n\r\n      a1 = atan2(x[0]-xx,y[0]-yy);\r\n      a2 = atan2(x[1]-xx,y[1]-yy);\r\n      a3 = atan2(x[2]-xx,y[2]-yy);\r\n      a = gcd(fabs(a1-a2),M_PI*2);\r\n      a = gcd(a,fabs(a2-a3));\r\n      printf("%0.0lf\\n",M_PI*2/a);\r\n   }\r\n}', '', 0, 258048, 1, 1, '2010-08-19 00:09:47', '0001-01-01 00:00:00'),
(264, 1, 247, 0, '#include <stdio.h>\r\n\r\nint f,i,k,m,n,t,c,nf,leave[2000];\r\n\r\nmain(){\r\n   scanf("%d",&c);\r\n   while (c--) {\r\n      scanf("%d%d%d",&n,&t,&m);\r\n      t *= 2;\r\n      nf = (m+n-1)/n;\r\n      k = m - (nf-1) * n;\r\n      for (i=0;i<k;i++) scanf("%d",&leave[0]);\r\n      for (f=1;f<nf;f++) {\r\n         for (i=0;i<n;i++) scanf("%d",&leave[f]);\r\n      }\r\n      for (f=0;f+1<nf;f++) {\r\n         if (leave[f]+t > leave[f+1]) leave[f+1] = leave[f]+t;\r\n      }\r\n      printf("%d %d\\n",leave[nf-1]+t/2,nf);\r\n   }\r\n}', '', 0, 266240, 1, 1, '2010-08-19 00:09:47', '0001-01-01 00:00:00'),
(265, 1, 248, 0, '#include <stdio.h>\r\n#include <string.h>\r\n#include <assert.h>\r\n\r\nchar d[1000][32], used[1001];\r\nint i,j,k,m,n,c,tot,source,sink;\r\nint ar[256], adj[256][256],out[1000];\r\nint nused[256];\r\n\r\nint ad[256][256];\r\n\r\nmark(char x){\r\n   int i;\r\n   for (i=''a'';i<=''z'';i++) {\r\n      if (ad[x][i] > 0) {\r\n         ad[x][i] = -1;\r\n         mark(i);\r\n      }\r\n   }\r\n}\r\n   \r\n\r\n\r\nreachable(char x) {\r\n   int i,j;\r\n   memcpy(ad,adj,sizeof(adj));\r\n   mark(x);\r\n   for (i=''a'';i<=''z'';i++) for (j=''a'';j<=''z'';j++)\r\n      if (ad[i][j] > 0) return 0;\r\n   return 1;\r\n}\r\n\r\nmain(){\r\n   scanf("%d",&c);\r\n   while (c--) {\r\n      if(1 != scanf("%d",&n)) {printf("missing input\\n");exit(1);};\r\n      memset(ar,0,sizeof(ar));\r\n      memset(adj,0,sizeof(adj));\r\n      tot = n-1;\r\n      for (i=0;i<n;i++) {\r\n         if (1 != scanf(" %s",d[i])) {printf("missing input\\n");exit(1);};\r\n         ar[d[i][0]]--;\r\n         ar[d[i][strlen(d[i])-1]]++;\r\n         adj[d[i][0]][d[i][strlen(d[i])-1]]++;\r\n      }\r\n\r\n      qsort(d,n,32,strcmp);\r\n\r\n      for (source = ''a''; source <= ''z'' && ar[source]>=0; source++);\r\n      if (source > ''z'') source = d[0][0];\r\n\r\n      memset(used,0,sizeof(used));\r\n      memset(nused,0,sizeof(nused));\r\n\r\n      for (j=0;j<n;j++) {\r\n         nused[source]++;\r\n         for (i=0;i<n ;i++) {\r\n            if (used[i]) continue;\r\n            if (d[i][0] != source) continue;\r\n            adj[d[i][0]][d[i][strlen(d[i])-1]]--;\r\n            if (reachable(d[i][strlen(d[i])-1])) break;\r\n            adj[d[i][0]][d[i][strlen(d[i])-1]]++;\r\n         }\r\n         if (i == n) break;\r\n         out[j] = i;\r\n         source = d[i][strlen(d[i])-1];\r\n         used[i] = 1;\r\n      }\r\n      if (j < n) {\r\n         printf("***\\n");\r\n      } else {\r\n         for (i=0;i+1<n;i++) printf("%s.",d[out[i]]);\r\n         printf("%s\\n",d[out[n-1]]);\r\n      }\r\n   }\r\n   if (scanf("%s",d[0]) == 1) printf("extra input\\n");\r\n}', '', 78, 823296, 1, 1, '2010-08-19 00:09:47', '0001-01-01 00:00:00'),
(266, 1, 249, 0, '#include <stdio.h>\r\n\r\nint i,j,k,m,n;\r\nchar buf[1000];\r\n\r\nint state;\r\ndouble base, val;\r\n\r\nint v[256];\r\n\r\n#define check(x) if (!(x)) {printf("no\\n");goto bad;}\r\n\r\n#define DSTART 1\r\n#define DEC 2\r\n#define BSTART 3\r\n#define BASE 4\r\n#define BDONE 5\r\n\r\nmain(){\r\n   for (i=0;i<255;i++) v[i] = -1;\r\n   for (i=0;i<=9;i++) v[i+''0''] = i;\r\n   for (i=0;i<=5;i++) v[i+''a''] = i+10;\r\n   scanf("%d",&n);\r\n   gets(buf);\r\n   while (n--) {\r\n      if (!gets(buf)) {\r\n         printf("Error - short input!\\n"); \r\n         exit(1);\r\n      }\r\n      state = DSTART;\r\n      val = base = 0;\r\n      for (i=0;buf[i];i++) {\r\n         char c = buf[i];\r\n         switch(state) {\r\n            case DSTART: {\r\n               check(v[c] >=0 && v[c] <= 9);\r\n               val = v[c];\r\n               state = DEC;\r\n               break;\r\n            }\r\n            case DEC: {\r\n               if (c == ''#'') {\r\n                  check(val >= 2 && val <= 16);\r\n                  base = val;\r\n                  val = 0;\r\n                  state = BSTART;\r\n                  break;\r\n               }\r\n               check (v[c] >= 0 && v[c] <= 9);\r\n               val = val * 10 + v[c];\r\n               break;\r\n            }\r\n            case BSTART: {\r\n               check (v[c] >= 0 && v[c] < base);\r\n               val = v[c];\r\n               state = BASE;\r\n               break;\r\n            }\r\n            case BASE: {\r\n               if (c == ''#'') {\r\n                  state = BDONE;\r\n                  break;\r\n               }\r\n               check (v[c] >= 0 && v[c] < base);\r\n               val = val * base + v[c];\r\n               break;\r\n           }\r\n           case BDONE: {\r\n              check (c == ''#'');\r\n              check (val >=2 && val <= 16);\r\n              base = val;\r\n              val = 0;\r\n              state = BSTART;\r\n              break;\r\n           }\r\n        }\r\n      }\r\n      check(state == DEC || state == BDONE);\r\n      printf("yes\\n");\r\n      bad:;\r\n   }\r\n   if (gets(buf)) printf("Error - excessinput!\\n");\r\n}', '', 0, 258048, 1, 1, '2010-08-19 00:09:47', '0001-01-01 00:00:00'),
(267, 1, 250, 0, '#include <stdio.h>\r\n#include <string.h>\r\n\r\nint i,j,k,t,tt,r,c,n;\r\n\r\nchar g[101][105], gg[101][105];\r\n\r\ndoit(int i, int j, int ii, int jj) {\r\n   if (i<0 || i>=r || j<0 || j >= c) return 0;\r\n   if (g[i][j] == ''R'' && g[ii][jj] == ''S'') gg[ii][jj] = ''R'';\r\n   if (g[i][j] == ''S'' && g[ii][jj] == ''P'') gg[ii][jj] = ''S'';\r\n   if (g[i][j] == ''P'' && g[ii][jj] == ''R'') gg[ii][jj] = ''P'';\r\n   return 0;\r\n}\r\n\r\nmain(){\r\n   scanf("%d",&t);\r\n   for (tt=0;tt<t;tt++) { \r\n      scanf("%d%d%d",&r,&c,&n);\r\n      for (i=0;i<r;i++) if (1 != scanf("%s",g[i])) {printf("missing input\\n");exit(1);}\r\n      for (i=0;i<n;i++) {\r\n         memcpy(gg,g,sizeof(gg));\r\n         for (j=0;j<r;j++) for (k=0;k<c;k++) {\r\n            doit(j,k,j+1,k);\r\n            doit(j,k,j-1,k);\r\n            doit(j,k,j,k+1);\r\n            doit(j,k,j,k-1);\r\n         }\r\n         memcpy(g,gg,sizeof(gg));\r\n      }\r\n      if (tt) printf("\\n");\r\n      for (i=0;i<r;i++) printf("%s\\n",g[i]);\r\n   }\r\n   if (1 == scanf("%s",g[0])) printf("Extra junk in input!\\n");\r\n}', '', 748, 278528, 1, 1, '2010-08-19 00:09:47', '0001-01-01 00:00:00'),
(268, 1, 251, 0, '#include <stdio.h>\r\n#include <ctype.h>\r\n\r\nint i,j,k,m,n,N;\r\nchar buf[10000];\r\nchar *b;\r\nint val,sign,cx[2],cy[2],c[2],eq,state,coef,op;\r\nint xnum,ynum,den;\r\n\r\nint gcd(int a, int b){\r\n   if (b == 0) return a;\r\n   if (b < 0) return -gcd(a,-b);\r\n   if (a < 0) return gcd(-a,b);\r\n   return gcd(b,a%b);\r\n}\r\n\r\nvoid pr(int n, int d){\r\n   if (n%d == 0) printf("%d\\n",n/d);\r\n   else printf("%d/%d\\n",n/gcd(n,d),d/gcd(n,d));\r\n}\r\n\r\nmain(){\r\n   scanf("%d",&N); \r\n   gets(buf);\r\n   while (N--) {\r\n      if (m++) printf("\\n");\r\n      for (i=0;i<2;i++){\r\n         gets(buf);\r\n         b = buf;\r\n         op = 1;\r\n         eq = 1;\r\n         cx[i] = cy[i] = c[i] = 0;\r\n         while (*b) {\r\n            while (*b == '' '') b++;\r\n            sign = 1;\r\n            if (*b == ''+'') {\r\n               sign = 1;\r\n               b++;\r\n            } else if (*b == ''-'') {\r\n               sign = -1;\r\n               b++;\r\n            }\r\n            if (!isdigit(*b)) val = 1;\r\n            else val = 0;\r\n            while (isdigit(*b)) {\r\n               val = val * 10 + (*b-''0'');\r\n               b++;\r\n            }\r\n            if (*b == ''x'') {\r\n               cx[i] += sign * op * val;\r\n               b++;\r\n            } else if (*b == ''y'') {\r\n               cy[i] += sign * op * val;\r\n               b++;\r\n            } else c[i] += sign * op * val;\r\n            while (*b == '' '') b++;\r\n            if (*b == ''='') {\r\n               eq = -1;\r\n               op = -1;\r\n               b++;\r\n            } else if (*b == ''+'') {\r\n               op = eq;\r\n               b++;\r\n            } else if (*b == ''-'') {\r\n               op = -eq;\r\n               b++;\r\n            } else if (!*b) break;\r\n            else printf("oops! at %s\\n",b);\r\n         }\r\n         //printf("%dx + %dy + %d = 0\\n",cx[i],cy[i],c[i]);\r\n      }\r\n      den = (cx[0]*cy[1]) - (cx[1] * cy[0]);\r\n      if (den) {\r\n         xnum = (-c[0]*cy[1]) - (-c[1] * cy[0]);\r\n         ynum = (cx[0]*-c[1]) - (cx[1] * -c[0]);\r\n         pr(xnum,den);\r\n         pr(ynum,den);\r\n      } else if (c[0] && !cx[0] && !cy[0] || cy[1] && !cx[1] && !cy[1]) {\r\n         printf("don''t know\\ndon''t know\\n");\r\n      } else {\r\n         if (cx[0] && !cy[0] && !cx[1]) pr(-c[0],cx[0]);\r\n         else if (cx[1] && !cy[1] && !cx[0]) pr(-c[1],cx[1]);\r\n         else if (cx[1] && !cy[1] && cx[0] && !cy[0] && cx[1]*c[0] == cx[0]*c[1]) pr(-c[0],cx[0]);\r\n         else printf("don''t know\\n");\r\n         if (cy[0] && !cx[0] && !cy[1]) pr(-c[0],cy[0]);\r\n         else if (cy[1] && !cx[1] && !cy[0]) pr(-c[1],cy[1]);\r\n         else if (cy[1] && !cx[1] && cy[0] && !cx[0] && cy[1]*c[0] == cy[0]*c[1]) pr(-c[0],cy[0]);\r\n         else printf("don''t know\\n");\r\n      }\r\n      gets(buf);\r\n   }\r\n}\r\n', '', 0, 270336, 1, 1, '2010-08-19 00:27:17', '0001-01-01 00:00:00'),
(269, 1, 252, 0, '#include <stdio.h>\r\n\r\nint i,j,k,a,b;\r\n\r\nint gcd(int a, int b) {\r\n   if (b > a) return gcd(b,a);\r\n   if (b == 0) return 0;  // this player loses\r\n   if (a/b == 1) return !gcd(b,a%b); // no choice\r\n   return 1; // this player can force a win\r\n}\r\n\r\nmain(){\r\n   while (2 == scanf("%d%d",&a,&b) && a) {\r\n      if (gcd(a,b)%2) printf("Stan wins\\n");\r\n      else printf("Ollie wins\\n");\r\n   }\r\n}\r\n', '', 0, 262144, 1, 2, '2010-08-19 00:27:17', '0001-01-01 00:00:00'),
(270, 1, 253, 0, '/* \r\n   The proper way to do this is with Union Find, but \r\n   binary search works OK, too.  O(n^2 log d) where\r\n   d is the max distance.  \r\n\r\n   The recursive connected components implementaiton\r\n   is a dog on Sun SPARC.\r\n*/\r\n\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <math.h>\r\n#include <string.h>\r\n\r\nint i,j,k,N,C,P;\r\nint x[1000],y[1000];\r\ndouble dsq,delta;\r\nint mark[1000];\r\n\r\nvoid set(int w, int c, double d) {\r\n   int i,j,k;\r\n   if (mark[w]) return;\r\n   mark[w] = c;\r\n   for (i=0;i<P;i++) {\r\n      if ((x[i]-x[w])*(x[i]-x[w]) + (y[i]-y[w])*(y[i]-y[w]) < d) {\r\n         set(i,c,d);\r\n      }\r\n   }\r\n}\r\n\r\nint try(double d) {\r\n   int i,j,k=0;\r\n   memset(mark,0,sizeof(mark));\r\n   for (i=0;i<P;i++) {\r\n      if (mark[i]) continue;\r\n      set(i,++k,d);\r\n   }\r\n   return k;\r\n}\r\n\r\nmain(){\r\n   scanf("%d",&N);\r\n   while (N--) {\r\n      scanf("%d%d",&C,&P);\r\n      for (i=0;i<P;i++) scanf("%d%d",&x[i],&y[i]);\r\n      dsq = 100;\r\n      for (delta = 100000000;delta > .00001; delta *=.5) {\r\n         if (try(dsq) > C) dsq += delta;\r\n         else dsq -= delta;\r\n      }\r\n      printf("%0.2lf\\n",sqrt(dsq));\r\n   }\r\n}\r\n', '', 312, 270336, 1, 1, '2010-08-19 00:27:17', '0001-01-01 00:00:00'),
(271, 1, 254, 0, '#include <stdio.h>\r\n\r\nint i,j,k,C,N,m[1000];\r\ndouble sum,avg,cnt;\r\n\r\nmain(){\r\n   scanf("%d",&C);\r\n   while (C--) {\r\n      scanf("%d",&N);\r\n      sum = 0;\r\n      for (i=0;i<N;i++) {\r\n         scanf("%d",&m[i]);\r\n         sum += m[i];\r\n      }\r\n      avg = sum/N;\r\n      cnt = 0;\r\n      for (i=0;i<N;i++) if (m[i]>avg) cnt++;\r\n      printf("%0.3lf%%\\n",100*cnt/N);\r\n   }\r\n}\r\n', '', 0, 266240, 1, 1, '2010-08-19 00:27:17', '0001-01-01 00:00:00'),
(272, 1, 255, 0, '#include <stdio.h>\r\n#include <string.h>\r\n\r\nchar *x[] = {\r\n"WET","0",\r\n"UTC","0",\r\n"GMT","0",\r\n"BST","+1",\r\n"IST","+1",\r\n"WEST","+1",\r\n"CET","+1",\r\n"CEST","+2",\r\n"EET","+2",\r\n"EEST","+3",\r\n"MSK","+3",\r\n"MSD","+4",\r\n"AST","-4",\r\n"ADT","-3",\r\n"NST","-3.5",\r\n"NDT","-2.5",\r\n"EST","-5",\r\n"EDT","-4",\r\n"CST","-6",\r\n"CDT","-5",\r\n"MST","-7",\r\n"MDT","-6",\r\n"PST","-8",\r\n"PDT","-7",\r\n"HST","-10",\r\n"AKST","-9",\r\n"AKDT","-8",\r\n"AEST","+10",\r\n"AEDT","+11",\r\n"ACST","+9.5",\r\n"ACDT","+10.5",\r\n"AWST","+8",\r\n"",""};\r\n\r\nint i,j,k,h,m,n,N,time;\r\nchar buf[100];\r\ndouble off;\r\n\r\nmain(){\r\n   scanf("%d",&N);\r\n   while (N--) {\r\n      scanf(" %s",buf);\r\n      if (!strcmp(buf,"noon")) time = 12*60;\r\n      else if (!strcmp(buf,"midnight")) time = 0;\r\n      else {\r\n         sscanf(buf,"%d:%d",&h,&m);\r\n         if (h == 12) h = 0;\r\n         time = h*60 + m;\r\n         scanf(" %s",buf);\r\n         if (!strcmp(buf,"p.m.")) time += 12*60;\r\n      }\r\n      scanf(" %s",buf);\r\n      for (i=0;*x[i] && strcmp(x[i],buf);i++);\r\n      if (strcmp(x[i],buf)) printf("oops:  <<<%s>>>\\n",buf);\r\n      sscanf(x[i+1],"%lf",&off);\r\n      time -= 60 * off; \r\n      scanf(" %s",buf);\r\n      for (i=0;*x[i] && strcmp(x[i],buf);i++);\r\n      if (strcmp(x[i],buf)) printf("oops:  %s\\n",buf);\r\n      sscanf(x[i+1],"%lf",&off);\r\n      time += 60 * off; \r\n      time = (time + 24*60) % (24*60);\r\n      if (time == 0) printf("midnight\\n");\r\n      else if (time == 12 * 60) printf("noon\\n");\r\n      else {\r\n         h = time/60%12;\r\n         if (h == 0) h = 12;\r\n         m = time%60;\r\n         printf("%d:%02d %s\\n",h,m,time>12*60?"p.m.":"a.m.");\r\n      }\r\n   }\r\n}\r\n', '', 0, 262144, 1, 1, '2010-08-19 00:27:17', '0001-01-01 00:00:00'),
(273, 1, 256, 0, '#include <stdio.h>\r\n#include <ctype.h>\r\n\r\nint i,j,k,m,n,N;\r\nchar buf[10000];\r\nchar *b;\r\nint val,sign,cx[2],cy[2],c[2],eq,state,coef,op;\r\nint xnum,ynum,den;\r\n\r\nint gcd(int a, int b){\r\n   if (b == 0) return a;\r\n   if (b < 0) return -gcd(a,-b);\r\n   if (a < 0) return gcd(-a,b);\r\n   return gcd(b,a%b);\r\n}\r\n\r\nvoid pr(int n, int d){\r\n   if (n%d == 0) printf("%d\\n",n/d);\r\n   else printf("%d/%d\\n",n/gcd(n,d),d/gcd(n,d));\r\n}\r\n\r\nmain(){\r\n   scanf("%d",&N); \r\n   gets(buf);\r\n   while (N--) {\r\n      if (m++) printf("\\n");\r\n      for (i=0;i<2;i++){\r\n         gets(buf);\r\n         b = buf;\r\n         op = 1;\r\n         eq = 1;\r\n         cx[i] = cy[i] = c[i] = 0;\r\n         while (*b) {\r\n            while (*b == '' '') b++;\r\n            sign = 1;\r\n            if (*b == ''+'') {\r\n               sign = 1;\r\n               b++;\r\n            } else if (*b == ''-'') {\r\n               sign = -1;\r\n               b++;\r\n            }\r\n            if (!isdigit(*b)) val = 1;\r\n            else val = 0;\r\n            while (isdigit(*b)) {\r\n               val = val * 10 + (*b-''0'');\r\n               b++;\r\n            }\r\n            if (*b == ''x'') {\r\n               cx[i] += sign * op * val;\r\n               b++;\r\n            } else if (*b == ''y'') {\r\n               cy[i] += sign * op * val;\r\n               b++;\r\n            } else c[i] += sign * op * val;\r\n            while (*b == '' '') b++;\r\n            if (*b == ''='') {\r\n               eq = -1;\r\n               op = -1;\r\n               b++;\r\n            } else if (*b == ''+'') {\r\n               op = eq;\r\n               b++;\r\n            } else if (*b == ''-'') {\r\n               op = -eq;\r\n               b++;\r\n            } else if (!*b) break;\r\n            else printf("oops! at %s\\n",b);\r\n         }\r\n         //printf("%dx + %dy + %d = 0\\n",cx[i],cy[i],c[i]);\r\n      }\r\n      den = (cx[0]*cy[1]) - (cx[1] * cy[0]);\r\n      if (den) {\r\n         xnum = (-c[0]*cy[1]) - (-c[1] * cy[0]);\r\n         ynum = (cx[0]*-c[1]) - (cx[1] * -c[0]);\r\n         pr(xnum,den);\r\n         pr(ynum,den);\r\n      } else if (c[0] && !cx[0] && !cy[0] || cy[1] && !cx[1] && !cy[1]) {\r\n         printf("don''t know\\ndon''t know\\n");\r\n      } else {\r\n         if (cx[0] && !cy[0] && !cx[1]) pr(-c[0],cx[0]);\r\n         else if (cx[1] && !cy[1] && !cx[0]) pr(-c[1],cx[1]);\r\n         else if (cx[1] && !cy[1] && cx[0] && !cy[0] && cx[1]*c[0] == cx[0]*c[1]) pr(-c[0],cx[0]);\r\n         else printf("don''t know\\n");\r\n         if (cy[0] && !cx[0] && !cy[1]) pr(-c[0],cy[0]);\r\n         else if (cy[1] && !cx[1] && !cy[0]) pr(-c[1],cy[1]);\r\n         else if (cy[1] && !cx[1] && cy[0] && !cx[0] && cy[1]*c[0] == cy[0]*c[1]) pr(-c[0],cy[0]);\r\n         else printf("don''t know\\n");\r\n      }\r\n      gets(buf);\r\n   }\r\n}\r\n', '', 0, 266240, 1, 1, '2010-08-19 00:27:38', '0001-01-01 00:00:00'),
(274, 1, 257, 0, '#include <stdio.h>\r\n\r\nint i,j,k,a,b;\r\n\r\nint gcd(int a, int b) {\r\n   if (b > a) return gcd(b,a);\r\n   if (b == 0) return 0;  // this player loses\r\n   if (a/b == 1) return !gcd(b,a%b); // no choice\r\n   return 1; // this player can force a win\r\n}\r\n\r\nmain(){\r\n   while (2 == scanf("%d%d",&a,&b) && a) {\r\n      if (gcd(a,b)%2) printf("Stan wins\\n");\r\n      else printf("Ollie wins\\n");\r\n   }\r\n}\r\n', '', 0, 262144, 1, 2, '2010-08-19 00:27:38', '0001-01-01 00:00:00'),
(275, 1, 258, 0, '/* \r\n   The proper way to do this is with Union Find, but \r\n   binary search works OK, too.  O(n^2 log d) where\r\n   d is the max distance.  \r\n\r\n   The recursive connected components implementaiton\r\n   is a dog on Sun SPARC.\r\n*/\r\n\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <math.h>\r\n#include <string.h>\r\n\r\nint i,j,k,N,C,P;\r\nint x[1000],y[1000];\r\ndouble dsq,delta;\r\nint mark[1000];\r\n\r\nvoid set(int w, int c, double d) {\r\n   int i,j,k;\r\n   if (mark[w]) return;\r\n   mark[w] = c;\r\n   for (i=0;i<P;i++) {\r\n      if ((x[i]-x[w])*(x[i]-x[w]) + (y[i]-y[w])*(y[i]-y[w]) < d) {\r\n         set(i,c,d);\r\n      }\r\n   }\r\n}\r\n\r\nint try(double d) {\r\n   int i,j,k=0;\r\n   memset(mark,0,sizeof(mark));\r\n   for (i=0;i<P;i++) {\r\n      if (mark[i]) continue;\r\n      set(i,++k,d);\r\n   }\r\n   return k;\r\n}\r\n\r\nmain(){\r\n   scanf("%d",&N);\r\n   while (N--) {\r\n      scanf("%d%d",&C,&P);\r\n      for (i=0;i<P;i++) scanf("%d%d",&x[i],&y[i]);\r\n      dsq = 100;\r\n      for (delta = 100000000;delta > .00001; delta *=.5) {\r\n         if (try(dsq) > C) dsq += delta;\r\n         else dsq -= delta;\r\n      }\r\n      printf("%0.2lf\\n",sqrt(dsq));\r\n   }\r\n}\r\n', '', 312, 274432, 1, 1, '2010-08-19 00:27:38', '0001-01-01 00:00:00'),
(276, 1, 259, 0, '#include <stdio.h>\r\n\r\nint i,j,k,C,N,m[1000];\r\ndouble sum,avg,cnt;\r\n\r\nmain(){\r\n   scanf("%d",&C);\r\n   while (C--) {\r\n      scanf("%d",&N);\r\n      sum = 0;\r\n      for (i=0;i<N;i++) {\r\n         scanf("%d",&m[i]);\r\n         sum += m[i];\r\n      }\r\n      avg = sum/N;\r\n      cnt = 0;\r\n      for (i=0;i<N;i++) if (m[i]>avg) cnt++;\r\n      printf("%0.3lf%%\\n",100*cnt/N);\r\n   }\r\n}\r\n', '', 0, 266240, 1, 1, '2010-08-19 00:27:38', '0001-01-01 00:00:00'),
(277, 1, 260, 0, '#include <stdio.h>\r\n#include <string.h>\r\n\r\nchar *x[] = {\r\n"WET","0",\r\n"UTC","0",\r\n"GMT","0",\r\n"BST","+1",\r\n"IST","+1",\r\n"WEST","+1",\r\n"CET","+1",\r\n"CEST","+2",\r\n"EET","+2",\r\n"EEST","+3",\r\n"MSK","+3",\r\n"MSD","+4",\r\n"AST","-4",\r\n"ADT","-3",\r\n"NST","-3.5",\r\n"NDT","-2.5",\r\n"EST","-5",\r\n"EDT","-4",\r\n"CST","-6",\r\n"CDT","-5",\r\n"MST","-7",\r\n"MDT","-6",\r\n"PST","-8",\r\n"PDT","-7",\r\n"HST","-10",\r\n"AKST","-9",\r\n"AKDT","-8",\r\n"AEST","+10",\r\n"AEDT","+11",\r\n"ACST","+9.5",\r\n"ACDT","+10.5",\r\n"AWST","+8",\r\n"",""};\r\n\r\nint i,j,k,h,m,n,N,time;\r\nchar buf[100];\r\ndouble off;\r\n\r\nmain(){\r\n   scanf("%d",&N);\r\n   while (N--) {\r\n      scanf(" %s",buf);\r\n      if (!strcmp(buf,"noon")) time = 12*60;\r\n      else if (!strcmp(buf,"midnight")) time = 0;\r\n      else {\r\n         sscanf(buf,"%d:%d",&h,&m);\r\n         if (h == 12) h = 0;\r\n         time = h*60 + m;\r\n         scanf(" %s",buf);\r\n         if (!strcmp(buf,"p.m.")) time += 12*60;\r\n      }\r\n      scanf(" %s",buf);\r\n      for (i=0;*x[i] && strcmp(x[i],buf);i++);\r\n      if (strcmp(x[i],buf)) printf("oops:  <<<%s>>>\\n",buf);\r\n      sscanf(x[i+1],"%lf",&off);\r\n      time -= 60 * off; \r\n      scanf(" %s",buf);\r\n      for (i=0;*x[i] && strcmp(x[i],buf);i++);\r\n      if (strcmp(x[i],buf)) printf("oops:  %s\\n",buf);\r\n      sscanf(x[i+1],"%lf",&off);\r\n      time += 60 * off; \r\n      time = (time + 24*60) % (24*60);\r\n      if (time == 0) printf("midnight\\n");\r\n      else if (time == 12 * 60) printf("noon\\n");\r\n      else {\r\n         h = time/60%12;\r\n         if (h == 0) h = 12;\r\n         m = time%60;\r\n         printf("%d:%02d %s\\n",h,m,time>12*60?"p.m.":"a.m.");\r\n      }\r\n   }\r\n}\r\n', '', 15, 262144, 1, 1, '2010-08-19 00:27:38', '0001-01-01 00:00:00'),
(278, 1, 261, 0, '#include <stdio.h>\r\n#include <assert.h>\r\n\r\nchar w[1000][20];\r\nint d[1000];\r\nint n,m,i,j,k,sum;\r\nchar buf[1000];\r\n\r\nmain(){\r\n   scanf("%d%d",&m,&n);\r\n   for (i=0;i<m;i++) {\r\n      scanf(" %s %d",w[i],&d[i]);\r\n      assert(strlen(w[i]) <= 16);\r\n   }\r\n   for (i=0;i<n;i++) {\r\n      sum = 0;\r\n      while (scanf(" %s",buf) && strcmp(buf,".")) {\r\n         assert(strlen(buf) <= 16);\r\n         for (j=0;j<m && strcmp(buf,w[j]);j++);\r\n         if (j < m) sum += d[j];\r\n      }\r\n      printf("%d\\n",sum);\r\n   }\r\n}\r\n', '', 0, 282624, 1, 1, '2010-08-19 00:28:15', '0001-01-01 00:00:00'),
(279, 1, 262, 0, '#include <stdio.h>\r\n#include <string.h>\r\n\r\nint m,n,i,j,k,p,tot;\r\n\r\nint d[21][21], e;\r\n\r\nint cost[1<<20+1];\r\n\r\nmatch(int e){\r\n   int i,j,k,best=0x7fffffff;\r\n   if (!e) return 0;\r\n   if (cost[e] != 0) return cost[e];\r\n   for (i=1;!(e & (1<<i));i++);\r\n   for (j=i+1;j<=n;j++){\r\n      if (!(e & (1<<j))) continue;\r\n      k = match(e - (1<<i) - (1<<j));\r\n      if (d[i][j] + k < best) best = d[i][j] + k;\r\n   }\r\n   return cost[e] = best;\r\n}\r\n\r\nmain(){\r\n   while (2 == scanf("%d%d",&n,&m)){\r\n      for (i=1;i<=n;i++) for (j=1;j<=n;j++) d[i][j] = (i!=j) * 0x3fffffff;\r\n      memset(cost,0,sizeof(cost));\r\n      e = 0;\r\n      tot = 0;\r\n      for (i=0;i<m;i++) {\r\n         scanf("%d%d%d",&j,&k,&p);\r\n         if (p < d[j][k]) d[j][k] = d[k][j] = p;\r\n         tot += p;\r\n         e ^= (1<<j);\r\n         e ^= (1<<k);\r\n      }\r\n      for (i=1;i<=n;i++) for (j=1;j<=n;j++) for (k=1;k<=n;k++) {\r\n         if (d[j][i]+d[i][k] < d[j][k]) d[j][k] = d[j][i]+d[i][k];\r\n      }\r\n      printf("%d\\n",tot+match(e));\r\n   }\r\n   if (n) printf("input data missing end delim\\n");\r\n}\r\n', '', 15, 8667136, 1, 1, '2010-08-19 00:28:15', '0001-01-01 00:00:00'),
(280, 1, 263, 0, '#include <math.h>\r\n#include <stdio.h>\r\n#define pi (2*acos(0))\r\n\r\ndouble D,V,d,delta;\r\n\r\nint i,j,k;\r\n\r\ndouble v(double d){\r\n   double R = D/2;\r\n   double r = d/2;\r\n   double vCyl = D * pi * R * R;\r\n   double vcyl = d * pi * r * r;\r\n   double vCone = pi * (D/2)*(D/2)*(D/2) / 3;\r\n   double vcone = pi * (d/2)*(d/2)*(d/2) / 3;\r\n   double res = vCyl - 2*vCone - vcyl + 2*vcone;\r\n   return res;\r\n}\r\n\r\nmain(){\r\n   while (2 == scanf("%lf%lf",&D,&V) && D) {\r\n      delta = d = D/2;\r\n      for (d=D/2; delta > .000000001; delta /=2) {\r\n         if (v(d) < V) d -= delta;\r\n         else d += delta;\r\n      }\r\n      printf("%0.3lf\\n",d);\r\n   }\r\n}\r\n', '', 0, 262144, 1, 1, '2010-08-19 00:28:15', '0001-01-01 00:00:00'),
(281, 1, 264, 0, '#include <stdio.h>\r\n\r\nchar s[2000002];\r\n\r\nmain(){\r\n   int i,j,k,m,n;\r\n   while (gets(s) && strcmp(s,".")) {\r\n      m = n = strlen(s);\r\n      for (i=2;i<=n;i++) {\r\n         while (n%i == 0) {\r\n            n /= i;\r\n            for (j=0;j<m-m/i && s[j] == s[j+m/i];j++);\r\n            if (j == m-m/i) m /= i;\r\n         }\r\n      }\r\n      printf("%d\\n",strlen(s)/m);\r\n   }\r\n}\r\n', '', 171, 2260992, 1, 1, '2010-08-19 00:28:15', '0001-01-01 00:00:00'),
(282, 1, 265, 0, '#include <stdio.h>\r\n\r\nmain(){\r\n   int n,i,sum;\r\n   while (1 == scanf("%d",&n) && n) {\r\n      sum = n;\r\n      for (i=2;i*i <= n;i++) {\r\n         if (n%i == 0) {\r\n            sum -= sum/i;\r\n         }\r\n         while (n%i == 0) n /= i;\r\n      }\r\n      if (n > 1) sum -= sum/n;\r\n      printf("%d\\n",sum);\r\n   }\r\n}\r\n', '', 15, 262144, 1, 1, '2010-08-19 00:28:16', '0001-01-01 00:00:00'),
(283, 1, 266, 0, '/*\r\n ============================================================================\r\n Name        : tests.c\r\n Author      :\r\n Version     :\r\n Copyright   : Your copyright notice\r\n Description : Hello World in C, Ansi-style\r\n ============================================================================\r\n */\r\n\r\n#include <math.h>\r\n#include <stdlib.h>\r\n#include <stdio.h>\r\n\r\ndouble x[100], y[100], r[100];\r\n\r\ndouble xp[1000], yp[1000]; int tree[1000];\r\nint i,j,k, np, T;\r\ndouble D, E, F, dx, dy, rdx, rdy, theta, phi;\r\ndouble adj[1000][1000];  int derv[1000][1000];\r\n\r\nvoid linepoints(double x1, double y1, double x2, double y2,\r\n                double *a, double *b, double *c) {\r\n   *a = y2 - y1;\r\n   *b = x1 - x2;\r\n   *c = *a * x1 + *b * y1;\r\n}\r\n\r\ndouble distpointline(double x, double y, double a, double b, double c) {\r\n   return fabs(a*x + b*y - c)/sqrt(a*a + b*b);\r\n}\r\n\r\ndouble sqdist(double a, double b, double c, double d){\r\n   return (a-c)*(a-c) + (b-d)*(b-d);\r\n}\r\n\r\nvoid check(int i, int j, double xj, double yj, double xi, double yi){\r\n   int k;\r\n   double a,b,c,d;\r\n   double dot1 = (xj-x[j])*(xj-xi) + (yj-y[j])*(yj-yi);\r\n   double dot2 = (xi-x[i])*(xi-xj) + (yi-y[i])*(yi-yj);\r\n   //printf("check %d %d %lf %lf : %lf %lf %lf %lf\\n",i,j,dot2,dot1,xi,yi,xj,yj);\r\n\r\n   linepoints(xi,yi,xj,yj,&a,&b,&c);\r\n\r\n   for (k = 0; k<T; k++){\r\n      if (k == i || k == j) continue;\r\n      if (distpointline(x[k],y[k],a,b,c) > r[k]) continue;\r\n      if ((x[k]-xi)*(xj-xi)+(y[k]-yi)*(yj-yi) < 0) continue;\r\n      if ((x[k]-xj)*(xi-xj)+(y[k]-yj)*(yi-yj) < 0) continue;\r\n      //printf(" ... rejected by circle %d\\n",k);\r\n      return;\r\n   }\r\n   adj[np][np+1] = adj[np+1][np] = hypot(xi-xj,yi-yj);\r\n   tree[np] = j;\r\n   xp[np] = xj;\r\n   yp[np++] = yj;\r\n   tree[np] = i;\r\n   xp[np] = xi;\r\n   yp[np++] = yi;\r\n}\r\n\r\n\r\nint main(){\r\n   double x1a, x1b, x1c, x1d, x2a, x2b, x2c, x2d, y1a, y1b,y1c, y1d, y2a, y2b, y2c, y2d;\r\n   scanf("%d%lf%lf%lf%lf",&T,&x[0],&y[0],&x[1],&y[1]);\r\n   r[0] = r[1] = 0;\r\n   T += 2;\r\n   for (i=2;i<T;i++) {\r\n      scanf("%lf%lf%lf",&x[i],&y[i],&r[i]);\r\n      r[i] /= 2;\r\n   }\r\n   xp[np] = x[0];\r\n   yp[np++] = y[0];\r\n   tree[np]=1;\r\n   xp[np] = x[1];\r\n   yp[np++] = y[1];\r\n   for (i=0;i<T;i++) for (j=0;j<T;j++) {\r\n      if (r[i] > r[j] || r[i]==r[j] && i>=j) continue;\r\n\r\n      D = hypot(x[i]-x[j], y[i]-y[j]);\r\n      theta = asin((r[j]-r[i])/D);\r\n\r\n      E = D * cos(theta);\r\n      phi = atan(r[i]/E);\r\n\r\n      F = E / cos(phi);\r\n\r\n      dx = (x[j] - x[i]) * F/D;\r\n      dy = (y[j] - y[i]) * F/D;\r\n\r\n      rdx = cos(theta+phi) * dx - sin(theta+phi) * dy;\r\n      rdy = sin(theta+phi) * dx + cos(theta+phi) * dy;\r\n\r\n      x1a = x[i] + rdx;\r\n      y1a = y[i] + rdy;\r\n\r\n      rdx = cos(-theta-phi) * dx - sin(-theta-phi) * dy;\r\n      rdy = sin(-theta-phi) * dx + cos(-theta-phi) * dy;\r\n\r\n      x1b = x[i] + rdx;\r\n      y1b = y[i] + rdy;\r\n\r\n      dx = (x[j] - x[i]) * r[i]/D;\r\n      dy = (y[j] - y[i]) * r[i]/D;\r\n\r\n      rdx = cos(theta+M_PI/2) * dx - sin(theta+M_PI/2) * dy;\r\n      rdy = sin(theta+M_PI/2) * dx + cos(theta+M_PI/2) * dy;\r\n\r\n      x2a = x[i] + rdx;\r\n      y2a = y[i] + rdy;\r\n\r\n      rdx = cos(-theta-M_PI/2) * dx - sin(-theta-M_PI/2) * dy;\r\n      rdy = sin(-theta-M_PI/2) * dx + cos(-theta-M_PI/2) * dy;\r\n\r\n      x2b = x[i] + rdx;\r\n      y2b = y[i] + rdy;\r\n\r\n      // Case 2:  tangent passes between centres\r\n\r\n      D = hypot(x[i]-x[j], y[i]-y[j]);\r\n      theta = asin((r[i]+r[j])/D);\r\n      E = D * cos(theta);\r\n      phi = atan(r[i]/E);\r\n      F = E / cos(phi);\r\n\r\n      dx = (x[j] - x[i]) * F/D;\r\n      dy = (y[j] - y[i]) * F/D;\r\n\r\n      rdx = cos(theta-phi) * dx - sin(theta-phi) * dy;\r\n      rdy = sin(theta-phi) * dx + cos(theta-phi) * dy;\r\n\r\n      x1c = x[i] + rdx;\r\n      y1c = y[i] + rdy;\r\n\r\n      rdx = cos(-theta+phi) * dx - sin(-theta+phi) * dy;\r\n      rdy = sin(-theta+phi) * dx + cos(-theta+phi) * dy;\r\n\r\n      x1d = x[i] + rdx;\r\n      y1d = y[i] + rdy;\r\n\r\n      dx = (x[j] - x[i]) * r[i]/D;\r\n      dy = (y[j] - y[i]) * r[i]/D;\r\n\r\n      rdx = cos(theta-M_PI/2) * dx - sin(theta-M_PI/2) * dy;\r\n      rdy = sin(theta-M_PI/2) * dx + cos(theta-M_PI/2) * dy;\r\n\r\n      x2c = x[i] + rdx;\r\n      y2c = y[i] + rdy;\r\n\r\n      rdx = cos(-theta+M_PI/2) * dx - sin(-theta+M_PI/2) * dy;\r\n      rdy = sin(-theta+M_PI/2) * dx + cos(-theta+M_PI/2) * dy;\r\n\r\n      x2d = x[i] + rdx;\r\n      y2d = y[i] + rdy;\r\n\r\n      check(i,j,x1a,y1a,x2a,y2a);\r\n      check(i,j,x1b,y1b,x2b,y2b);\r\n      check(i,j,x1c,y1c,x2c,y2c);\r\n      check(i,j,x1d,y1d,x2d,y2d);\r\n\r\n   }\r\n\r\n   for (i=0;i<np;i++) for (j=0;j<np; j++) {\r\n      if (i == j || adj[i][j]) continue;\r\n      if (tree[i] != tree[j]) {\r\n         adj[i][j] = 1e99;\r\n      } else {\r\n         double xx = x[tree[i]];\r\n         double yy = y[tree[i]];\r\n         double rr = r[tree[i]];\r\n         double costheta = ((xp[i]-xx)*(xp[j]-xx)+(yp[i]-yy)*(yp[j]-yy)) / (rr*rr);\r\n         double theta = acos(costheta);\r\n         double d = theta * rr;\r\n         if (rr == 0) continue;\r\n         adj[i][j] = d;\r\n      }\r\n   }\r\n   for (i=0;i<np;i++) for (j=0;j<np; j++) {\r\n      if (adj[i][j] > 1e98) continue;\r\n      //printf("edge %d %d %lf %lf %lf %lf (%lf)\\n",tree[i],tree[j],xp[i],yp[i],xp[j],yp[j],adj[i][j]);\r\n   }\r\n   for (i=0;i<np;i++)for(j=0;j<np;j++)for(k=0;k<np;k++){\r\n      if (adj[j][i]+adj[i][k] < adj[j][k]) {\r\n         adj[j][k] = adj[j][i]+adj[i][k];\r\n         derv[j][k] = i;\r\n      }\r\n   }\r\n   printf("%0.2lf\\n",adj[0][1]*3600/200, adj[0][1]);\r\n   //printderv(0,1);\r\n   return 0;\r\n}\r\n\r\nvoid printderv(int i, int j){\r\n   double r1, r2;\r\n   if (i == j) return;\r\n   if (!derv[i][j]) {\r\n      printf("derv %lf %lf (tree %d)-> %lf %lf (tree %d) (%lf) \\n",xp[i],yp[i],tree[i],xp[j],yp[j],tree[j],adj[i][j]);\r\n   }else{\r\n      printderv(i,derv[i][j]);\r\n      printderv(derv[i][j],j);\r\n   }\r\n}\r\n\r\n', '', 30, 12308480, 1, 2, '2010-08-19 00:29:22', '0001-01-01 00:00:00'),
(284, 1, 267, 0, '/*\r\n * sadf.cc\r\n *\r\n *  Created on: 2010-4-29\r\n *      Author: teacher\r\n */\r\n\r\n#include <stdio.h>\r\n#include <map>\r\n#include <math.h>\r\nusing namespace std;\r\nmap <unsigned,unsigned> M;\r\n\r\nunsigned long\r\ntimes (unsigned long a, unsigned long b, unsigned long m){\r\n   return (unsigned long long) a * b % m;\r\n}\r\n\r\nunsigned long\r\npower (unsigned long val, unsigned long power, unsigned long m){\r\n   unsigned long acc = 1;\r\n   unsigned long p;\r\n\r\n   for (p = power; p ; p=p>>1) {\r\n      if (p & 1) acc = times(acc, val, m);\r\n      val = times(val, val, m);\r\n   }\r\n   return acc;\r\n}\r\n\r\nint main(){\r\n   unsigned P,B,L,N;\r\n   unsigned i,j,k,m,n;\r\n   unsigned jump;\r\n   while (scanf("%d %d %d",&P,&B,&N) == 3) {\r\n      M.clear();\r\n      jump = sqrt(P);\r\n      for (i=0;i<jump && i < P-1;i++){\r\n         M[power(B,i,P)] = i+1;\r\n      }\r\n      for (i=0;i<P-1;i+=jump){\r\n         if (j = M[times(N,power(B,P-1-i,P),P)]) {\r\n            j--;\r\n            L = (i+j)%(P-1);\r\n            if (power(B,L,P) != N) printf("***oops*** %d %d ",i,j);\r\n            printf("%d\\n",L);\r\n            goto done;\r\n         }\r\n      }\r\n      printf("no solution\\n");\r\n      done:;\r\n   }\r\n   return 0;\r\n}\r\n\r\n/**************************************************************\r\n	Problem: 1269\r\n	User: zhblue\r\n	Language: C++\r\n	Result: Compile Error\r\n****************************************************************/\r\n\r\n', '', 421, 2781184, 1, 2, '2010-08-19 00:29:22', '0001-01-01 00:00:00'),
(285, 1, 268, 0, '#include <stdio.h>\r\n#include <string.h>\r\n#include <map>\r\n#include <malloc.h>\r\nusing namespace std;\r\nstruct species {\r\n   char s[81];\r\n} buf;\r\n\r\nbool operator==(const species &a, const species &b) {\r\n   return !strcmp(a.s, b.s);\r\n}\r\n\r\nbool operator<(const species &a, const species &b) {\r\n   return strcmp(a.s, b.s) < 0;\r\n}\r\n\r\nmap<species,int> cnt;\r\n\r\nmain(){\r\n   int tot = 0;\r\n   while(gets(buf.s)){\r\n      cnt[buf]++;\r\n      tot++;\r\n   }\r\n   for (map<species,int>::iterator i = cnt.begin(); i!=cnt.end(); *i++) {\r\n      printf("%s %0.4lf\\n",i->first.s, 100.0*i->second/tot);\r\n   }\r\n}\r\n\r\n/**************************************************************\r\n	Problem: 1270\r\n	User: zhblue\r\n	Language: C++\r\n	Result: Compile Error\r\n****************************************************************/\r\n\r\n', '', 1293, 667648, 1, 2, '2010-08-19 00:29:22', '0001-01-01 00:00:00'),
(286, 1, 269, 0, 'int obs[200][200];\r\nint done[200];\r\n\r\nmain(){\r\n   int P,T,i,j=0,k,cnt=0;\r\n   scanf("%d%d",&P,&T);\r\n   while (2 == scanf("%d%d",&i,&j)) {\r\n      obs[i][j] = 1;\r\n   }\r\n   for (i=1;i<=P;i++) {\r\n      if (done[i]) continue;\r\n      cnt++;\r\n      for (j=i;j<=P;j++) {\r\n         for (k=1;k<=T && obs[i][k]==obs[j][k];k++);\r\n         if (k > T) done[j] = 1;\r\n      }\r\n   }\r\n   printf("%d\\n",cnt);\r\n}\r\n', '', 0, 417792, 1, 1, '2010-08-19 00:29:25', '0001-01-01 00:00:00'),
(287, 1, 270, 0, '#include <stdio.h>\r\n#include <math.h>\r\n#define hypot(x,y) sqrt((x)*(x)+(y)*(y))\r\n\r\ndouble x[100], y[100];\r\nint N;\r\n\r\ndouble test(double xx, double yy) {\r\n   double tot = 0;\r\n   int i;\r\n   for (i=0;i<N;i++) {\r\n      tot += hypot(x[i]-xx,y[i]-yy);\r\n   }\r\n   return tot;\r\n}\r\n\r\nmain(){\r\n   int i,j,k;\r\n   double xx,yy,delta;\r\n\r\n   scanf("%d",&N);\r\n   for (i=0;i<N;i++) scanf("%lf%lf",&x[i],&y[i]);\r\n   \r\n   xx = 5000;\r\n   yy = 5000;\r\n\r\n   for (delta=5000;delta > .0001;delta *=.9) {\r\n      if (test(xx,yy+delta) < test(xx,yy)) yy+=delta;\r\n      if (test(xx,yy-delta) < test(xx,yy)) yy-=delta;\r\n      if (test(xx+delta,yy) < test(xx,yy)) xx+=delta;\r\n      if (test(xx-delta,yy) < test(xx,yy)) xx-=delta;\r\n   }\r\n   printf("%0.0lf\\n",test(xx,yy));\r\n}\r\n', '', 0, 262144, 1, 1, '2010-08-19 00:29:25', '0001-01-01 00:00:00'),
(288, 1, 271, 0, '#include <algorithm>\r\n#include <cmath>\r\n#include <cstdio>\r\n#include <cstdlib>\r\n#include <cstring>\r\nusing namespace std;\r\n\r\n#define FR(i,a,b) for(int i=(a);i<(b);++i)\r\n#define FOR(i,n) FR(i,0,n)\r\n#define CLR(x,a) memset(x,a,sizeof(x))\r\n#define setmax(a,b) a = max(a,b)\r\n#define setmin(a,b) a = min(a,b)\r\ntypedef long long ll;\r\n\r\nconst int R=15,C=15;\r\nint i;\r\nchar grid[16][16];\r\nint colset[16];\r\nvoid doit() {\r\n  FOR(r,R) {\r\n    scanf("%s",grid[r]);\r\n    if (0==strcmp("END",grid[r])) exit(0);\r\n  }\r\n\r\n  int ans = 15;\r\n  FOR(S,(1<<R)) {\r\n    CLR(colset,0);\r\n\r\n    FOR(r,R) if (0==((1<<r)&S)) {\r\n      FOR(c,C) if (grid[r][c]==''#'') colset[c]=1;\r\n    }\r\n\r\n    int now = 0;\r\n    FOR(c,C) now += colset[c];\r\n    setmax(now, __builtin_popcount(S));\r\n    setmin(ans, now);\r\n  }\r\n\r\n  printf("%d\\n",ans);\r\n}\r\nint main() {\r\n  while (1) doit();\r\n}', '', 1027, 262144, 1, 2, '2010-08-19 00:31:58', '0001-01-01 00:00:00'),
(289, 1, 272, 0, '#include <algorithm>\r\n#include <cmath>\r\n#include <cstdio>\r\n#include <cstdlib>\r\n#include <cstring>\r\n#include <deque>\r\n#include <string>\r\n#include <vector>\r\nusing namespace std;\r\n\r\n#define SZ(v) int((v).size())\r\n#define FR(i,a,b) for(int i=(a);i<(b);++i)\r\n#define FOR(i,n) FR(i,0,n)\r\n#define FORI(i,v) FOR(i,SZ(v))\r\n#define CLR(x,a) memset(x,a,sizeof(x))\r\n#define setmax(a,b) a = max(a,b)\r\n#define setmin(a,b) a = min(a,b)\r\ntypedef long long ll;\r\n\r\nint R,C;\r\nchar buf[16];\r\nint deg[16][16];\r\nint nod[16][16][4];\r\nconst int MAXV = 514;\r\nbool mark[MAXV];\r\nint cap[MAXV][MAXV];\r\nvector<int> edg[MAXV];\r\nconst int s=MAXV-2,t=MAXV-1;\r\nvoid connect(int v, int w, int u) {\r\n  cap[v][w] = u;\r\n  cap[w][v] = 0;\r\n  edg[v].push_back(w);\r\n  edg[w].push_back(v);\r\n}\r\nint dr[] = { -1, 0, 1, 0 },\r\n    dc[] = { 0, 1, 0, -1 };\r\nconst int inf = 123456789;\r\nint dfs(int v, int flocap=inf) {\r\n  if (v==t) return flocap;\r\n\r\n  if (mark[v]) return 0;\r\n  mark[v] = 1;\r\n\r\n  FORI(i,edg[v]) {\r\n    int w = edg[v][i];\r\n    if (cap[v][w]) {\r\n      int f = dfs(w, min(flocap, cap[v][w]));\r\n\r\n      if (f) {\r\n	cap[v][w] -= f;\r\n	cap[w][v] += f;\r\n	return f;\r\n      }\r\n    }\r\n  }\r\n  return 0;\r\n}\r\nvoid doit() {\r\n  scanf("%d%d",&R,&C);\r\n  if (R==0) exit(0);\r\n\r\n  FOR(v,MAXV) edg[v].clear();\r\n  CLR(cap,0);\r\n\r\n  FOR(r,R) {\r\n    FOR(c,C) {\r\n      scanf(" %s",buf);\r\n      if (0==strcmp("x",buf)) deg[r][c]=0;\r\n      else deg[r][c] = strlen(buf);\r\n    }\r\n  }\r\n\r\n  int next = 0;\r\n  FOR(r,R) FOR(c,C) {\r\n    if (deg[r][c] != 2) {\r\n      FOR(k,4) nod[r][c][k] = next;\r\n      if ((r+c)%2) connect(s, next, deg[r][c]);\r\n      else connect(next, t, deg[r][c]);\r\n      ++next;\r\n    } else {\r\n      FOR(k,4) nod[r][c][k] = next + (k%2);\r\n      if ((r+c)%2) FOR(k,2) connect(s, next+k, 1);\r\n      else FOR(k,2) connect(next+k, t, 1);\r\n      next += 2;\r\n    }\r\n  }\r\n\r\n  FOR(r,R) FOR(c,C) if ((r+c)%2) {\r\n    FOR(k,4) {\r\n      int r2 = r+dr[k], c2 = c+dc[k];\r\n      if (r2<0||r2>=R||c2<0||c2>=C) continue;\r\n      int k2 = (k+2)%4;\r\n\r\n      connect(nod[r][c][k], nod[r2][c2][k2], 1);\r\n    }\r\n  }\r\n\r\n  while (1) {\r\n    CLR(mark,0);\r\n    int f = dfs(s);\r\n    if (f == 0) break;\r\n  }\r\n\r\n  int ed=0,od=0;\r\n  FOR(r,R) FOR(c,C) {\r\n    if ((r+c)%2) od += deg[r][c];\r\n    else ed += deg[r][c];\r\n  }\r\n\r\n  bool happy = 1;\r\n  FOR(v,MAXV) if (cap[s][v] || cap[v][t]) happy = 0;\r\n\r\n  printf("%s\\n", happy ? "SOLVABLE" : "UNSOLVABLE");\r\n}\r\nint main() {\r\n  while (1) doit();\r\n}', '', 30, 1478656, 1, 2, '2010-08-19 00:31:58', '0001-01-01 00:00:00'),
(290, 1, 273, 0, '#include<stdio.h>\r\n#include<string.h>\r\n#include<stdlib.h>\r\nint main()\r\n{\r\n	int i,t;\r\n	double x;\r\n	char a[9];\r\n	while(gets(a),strcmp(a,"END"))\r\n	{\r\n		x=atof(a);\r\n		t=0;\r\n		if(x==0||x==1)\r\n			printf("MEMBER\\n");\r\n		else\r\n		{\r\n			i=13;\r\n			while(i--)\r\n			{\r\n				x=(x-(int)x)*3;\r\n				if((int)x==1)\r\n				{\r\n					printf("NON-MEMBER\\n");\r\n					t++;\r\n					break;\r\n				}\r\n			}\r\n			if(t==0)\r\n				printf("MEMBER\\n");\r\n		}\r\n	}\r\n	return 0;\r\n}', '', 0, 262144, 1, 1, '2010-08-19 00:31:58', '0001-01-01 00:00:00'),
(291, 1, 274, 0, '#include <algorithm>\r\n#include <cmath>\r\n#include <cstdio>\r\n#include <cstdlib>\r\n#include <cstring>\r\n#include <deque>\r\n#include <string>\r\n#include <vector>\r\nusing namespace std;\r\n\r\n#define SZ(v) int((v).size())\r\n#define FR(i,a,b) for(int i=(a);i<(b);++i)\r\n#define FOR(i,n) FR(i,0,n)\r\n#define FORI(i,v) FOR(i,SZ(v))\r\n#define CLR(x,a) memset(x,a,sizeof(x))\r\n#define setmax(a,b) a = max(a,b)\r\n#define setmin(a,b) a = min(a,b)\r\ntypedef long long ll;\r\n\r\nint N,x,y,v,c;\r\nint xs[30],ys[30];\r\ndouble sqr(double x) { return x*x; }\r\ndouble f(int i, int j, double a) {\r\n  double x0 = xs[i]*(1-a) + xs[j]*a;\r\n  double y0 = ys[i]*(1-a) + ys[j]*a;\r\n\r\n  return sqrt(sqr(x-x0)+sqr(y-y0))/c + y0/v;\r\n}\r\nvoid doit() {\r\n  scanf("%d%d%d%d%d",&N,&x,&y,&v,&c);\r\n  if (N==0) exit(0);\r\n\r\n  FOR(i,N) {\r\n    scanf("%d%d",&xs[i],&ys[i]);\r\n  }\r\n\r\n  double t = 1e100;\r\n  FOR(i,N) {\r\n    int j = (i+1)%N;\r\n    double lo = 0, hi = 1;\r\n\r\n    FOR(k,200) {\r\n      double m1 = (2*lo+hi)/3, m2 = (lo+2*hi)/3;\r\n      \r\n      if (f(i,j,m1) < f(i,j,m2)) hi = m2;\r\n      else lo = m1;\r\n    }\r\n\r\n    setmin(t, f(i,j,lo));\r\n  }\r\n\r\n  printf("%.4lf\\n",t);\r\n}\r\nint main() {\r\n  while (1) doit();\r\n}', '', 30, 262144, 1, 2, '2010-08-19 00:31:58', '0001-01-01 00:00:00'),
(292, 1, 275, 0, '#include<stdio.h>\r\n#include<math.h>\r\n	int n,a[1000001];\r\nint main()\r\n{\r\n	double i,x,y,z;\r\n	a[0]=1;\r\n	for(i=1;i<=1000000;i++)\r\n	{\r\n		x=i-sqrt(i);\r\n		y=log(i);\r\n		z=i*sin(i)*sin(i);\r\n		a[(int)i]=(a[(int)x]+a[(int)y]+a[(int)z])%1000000;\r\n	}\r\n	while(scanf("%d",&n)!=EOF,n!=-1)\r\n		printf("%d\\n",a[n]);\r\n	return 0;\r\n}', '', 670, 4263936, 1, 1, '2010-08-19 00:31:58', '0001-01-01 00:00:00'),
(293, 1, 276, 0, '#include <stdio.h>\n#include <math.h>\n\n#define hypot(a,b) sqrt((a)*(a)+(b)*(b))\n\ndouble x[100], y[100], bestd, totd;\nchar in[100];\nint n,nin,best;\n\nmain(){\n   int i,j,k;\n   scanf("%d",&n);\n   for (i=0;i<n;i++) scanf("%lf%lf",&x[i],&y[i]);\n   in[0] = 1;\n   for (nin=1;nin<n;nin++){\n      bestd = 1e100;\n      for (i=0;i<n;i++) {\n         if (!in[i]) continue;\n         for (j=0;j<n;j++) {\n            if (i==j || in[j]) continue;\n            if (bestd == 1e100 || hypot(x[i]-x[j],y[i]-y[j]) < bestd){\n               best = j;\n               bestd = hypot(x[i]-x[j],y[i]-y[j]);\n            }\n         }\n      }\n      in[best]=1;\n      totd += bestd;\n   }\n   printf("%0.2lf\\n",totd);\n}\n', '', 15, 262144, 1, 1, '2010-08-19 00:35:22', '0001-01-01 00:00:00');
INSERT INTO `tbl_submitions` (`id`, `user_id`, `problem_id`, `exercise_id`, `source`, `result`, `used_time`, `used_memory`, `status`, `compiler_id`, `created`, `modified`) VALUES
(294, 1, 277, 0, '\r\n\r\n#include <string.h>\r\n#include <stdlib.h>\r\n#include <iostream>\r\n#include <string>\r\n#include <vector>\r\n\r\n#define LINESIZE 32\r\nusing namespace std;\r\n\r\nstruct Rule {\r\n    string str1;\r\n    string str2;\r\n};\r\n\r\nint calcCount(string& initialStr, vector<Rule>& rules);\r\n\r\nint main()\r\n{\r\n    int caseNum = 0;\r\n    char buffer[LINESIZE];\r\n    vector<Rule> ruleList;\r\n    string initialStr;\r\n    char* p1;\r\n    char* p2;\r\n\r\n    // get case num\r\n    //cin.getline(buffer, LINESIZE);\r\n    caseNum =1;// atoi(buffer);\r\n\r\n    // skip blank line\r\n    //cin.getline(buffer, 32);\r\n\r\n    for (; caseNum != 0; caseNum--) {\r\n        // get initial string\r\n        cin.getline(buffer, LINESIZE);\r\n        buffer[strlen(buffer)-1] = ''\\0'';\r\n        initialStr = buffer+1;\r\n\r\n        // get replace list\r\n        cin.getline(buffer, LINESIZE);\r\n        while (buffer[0] != ''\\0'') {\r\n            p1 = strchr(buffer, ''\\"'');\r\n            p1++;\r\n            p2 = strchr(p1, ''\\"'');\r\n            *p2++ = ''\\0'';\r\n            Rule rule;\r\n            rule.str1 = p1;\r\n\r\n            p1 = strchr(p2, ''\\"'');\r\n            p1++;\r\n            p2 = strchr(p1, ''\\"'');\r\n            *p2 = ''\\0'';\r\n            rule.str2 = p1;\r\n\r\n            ruleList.push_back(rule);\r\n            cin.getline(buffer, LINESIZE);\r\n        }\r\n\r\n        int count = calcCount(initialStr, ruleList);\r\n        if (0 == count) {\r\n            cout << "Too many." << endl;\r\n        } else {\r\n            cout << count << endl;\r\n        }\r\n        if (caseNum != 1) {\r\n            cout << endl;\r\n        }\r\n        ruleList.clear();\r\n    }\r\n}\r\n\r\nint calcCount(string& initialStr, vector<Rule>& rules)\r\n{\r\n    vector<string> strList;\r\n    strList.push_back(initialStr);\r\n    int i = 0;\r\n    int count = 0;\r\n    int maxSize = initialStr.size();\r\n    for (i = 0; i < strList.size(); i++) {\r\n        for (int k = 0; k < rules.size(); k++) {\r\n            if (rules[k].str1 == "" && rules[k].str2 != "") {\r\n                // must over 1000\r\n                return 0;\r\n            }\r\n            if (rules[k].str1 != rules[k].str2 && rules[k].str2.find(rules[k].str1, 0) != string::npos) {\r\n                // must over 1000\r\n                return 0;\r\n            }\r\n            int firstPos = -1;\r\n            while ((firstPos = strList[i].find(rules[k].str1, firstPos+1)) != string::npos) {\r\n                string tmpStr = strList[i];\r\n                tmpStr.replace(firstPos, rules[k].str1.size(), rules[k].str2);\r\n                int m = 0;\r\n                if (tmpStr.size() > maxSize) {\r\n                    if (count == 1000) {\r\n                        return 0;\r\n                    }\r\n                    maxSize = tmpStr.size();\r\n                    strList.push_back(tmpStr);\r\n                    count++;\r\n                    continue;\r\n                }\r\n                for (m = 0; m < strList.size(); m++) {\r\n                    if (strList[m] == tmpStr) {\r\n                        break;\r\n                    }\r\n                }\r\n                if (m == strList.size()) {\r\n                    if (count == 1000) {\r\n                        return 0;\r\n                    }\r\n                    strList.push_back(tmpStr);\r\n                    count++;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return i;\r\n}', '', 30, 516096, 1, 2, '2010-08-19 00:35:22', '0001-01-01 00:00:00'),
(295, 1, 278, 0, '#include <stdio.h>\n\nint a,b;\n\nint i,j,k,carry,carries;\n\nmain(){\n   while (2 == scanf("%d%d",&a,&b)){\n      if (a == 0 && b == 0) return;\n      carries = carry = 0;\n      for (i=9;i>=0;i--) {\n        carry = a%10+b%10+carry > 9;\n        carries += carry;\n        a /= 10; \n        b /= 10;\n      }\n      if (carries == 0) printf("No carry operation.\\n");\n      else if (carries == 1) printf("1 carry operation.\\n");\n      else printf("%d carry operations.\\n",carries);\n   }\n}\n', '', 0, 262144, 1, 1, '2010-08-19 00:35:22', '0001-01-01 00:00:00'),
(296, 1, 279, 0, '#include <stdio.h>\n\nint merits,demerits,points,lastoff,nextoff;\n\nmain(){\n   scanf("%d",&lastoff);\n   dump();\n   for(;;){\n      nextoff = 99999999;\n      scanf("%d%d",&nextoff,&points);\n      while ((demerits && lastoff+10000 <= nextoff) ||\n             (!demerits && merits < 5  && lastoff+20000 <= nextoff)){\n         if (demerits) {\n            if (demerits > 2) demerits /=2; else demerits = 0;\n            lastoff += 10000;\n         } else {\n            merits++;\n            lastoff += 20000;\n         }\n         dump();\n      }\n      if (nextoff == 99999999) break;\n      lastoff = nextoff;\n      if (merits*2 <= points) {\n         demerits += (points - merits*2);\n         merits = 0;\n      } else {\n         merits -= ((points+1)/2);\n      }\n      dump();\n   }\n}\n\ndump(){\n   printf("%04d-%02d-%02d ",lastoff/10000,lastoff/100%100,lastoff%100);\n   if (merits) printf("%d merit point(s).\\n",merits);\n   else if (demerits) printf("%d demerit point(s).\\n",demerits);\n   else printf("No merit or demerit points.\\n");\n}\n', '', 0, 262144, 1, 1, '2010-08-19 00:35:22', '0001-01-01 00:00:00'),
(297, 1, 280, 0, '#include <stdio.h>\n#include <stdlib.h>\n\n#define dup xdup\n\nstruct s {\n   int i;\n   char *s;\n};\n\nstruct s wd[50000], subs[400000], ins[400000];\nint nw, ns, ni;\n\nint d[50000], prev[50000];\n\nchar buf[20];\n\ncmp(struct s *a, struct s *b){\n   if (strcmp(a->s,b->s) > 0) return 1;\n   if (strcmp(a->s,b->s) < 0) return -1;\n   return a->i - b->i;\n}\n\nstruct s dup(int i, char *s){\n   struct s t;\n   t.s = (char *) malloc(strlen(s)+1);\n   strcpy(t.s,s);\n   t.i = i;\n   return t;\n}\n\nstruct s sub(int i, char *s, int j){\n   struct s t;\n   t.s = (char *) malloc(strlen(s)+1);\n   strcpy(t.s,s);\n   t.s[j] = ''*'';\n   t.i = i;\n   return t;\n}\n\nstruct s in(int i, char *s, int j){\n   struct s t;\n   t.s = (char *) malloc(strlen(s)+2);\n   strncpy(t.s,s,j);\n   t.s[j] = ''*'';\n   strcpy(t.s+j+1,s+j);\n   t.i = i;\n   return t;\n}\n\nlook(int from, char *s, struct s *t){\n   int i,j,k,hi,lo,mid;\n   hi = (t==subs?ns:ni)-1;\n   lo = 0;\n   while (hi >= lo) {\n      mid = (hi+lo)/2;\n      i = strcmp(s,t[mid].s);\n      if (i > 0) lo = mid+1;\n      else if (i < 0) hi = mid-1;\n      else if (from >= t[mid].i) lo = mid+1;\n      else hi = mid-1;\n   } \n   for (i=lo;!strcmp(s,t[i].s);i++) {\n      0&&printf ("found %s (%s) from %s\\n", t[i].s, wd[t[i].i].s, wd[from].s);\n      if (d[from]+1 > d[t[i].i]){\n         d[t[i].i] = d[from]+1;\n         prev[t[i].i] = from;\n      }\n   }\n}\n\nmain(){\n   int i,j,k;\n   for (nw=0;gets(buf);nw++){\n      wd[nw] = dup(nw,buf);\n      for (i=0;i<strlen(buf);i++) subs[ns++] = sub(nw,buf,i);\n      for (i=0;i<=strlen(buf);i++) ins[ni++] = in(nw,buf,i);\n      subs[ns].s = ins[ni].s = "";\n   }\n   qsort(subs,ns,sizeof(struct s),cmp);\n   qsort(ins,ni,sizeof(struct s),cmp);\n\n   for (i=0;i<nw;i++){\n      for (j=0;j<strlen(wd[i].s);j++) look(i,sub(i,wd[i].s,j).s,subs);\n      for (j=0;j<strlen(wd[i].s);j++) look(i,sub(i,wd[i].s,j).s,ins);\n      for (j=0;j<=strlen(wd[i].s);j++) look(i,in(i,wd[i].s,j).s,subs);\n   }\n\n   for (i=j=0;i<nw;i++) {\n      if (d[i] > d[j]) j=i;\n   }\n\n   printf("%d\\n",d[j]+1);\n   0&&dump(j);\n}\n\ndump(int i){\n   if (d[i] > 0) dump(prev[i]);\n   printf("%s\\n",wd[i].s);\n}\n\n', '', 623, 31281152, 1, 1, '2010-08-19 00:35:22', '0001-01-01 00:00:00'),
(298, 1, 281, 0, '#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\nchar in[5000];\r\nint i,j,k,n,next,prev,jolly;\r\n\r\nmain(){\r\n   while (1 == scanf("%d",&n)){\r\n      jolly = 1;\r\n      for (i=1;i<n;i++) in[i] = 0;\r\n      scanf("%d",&prev);\r\n      for (i=1;i<n;i++) {\r\n         scanf("%d",&next);\r\n         j = abs(next-prev);\r\n         if (j < 1 || j >= n || in[j]++) jolly = 0;\r\n         prev = next;\r\n      }\r\n      if (jolly) printf("Jolly\\n");else printf("Not jolly\\n");\r\n   }\r\n}\r\n', '', 0, 266240, 1, 1, '2010-08-19 00:36:38', '0001-01-01 00:00:00'),
(299, 1, 282, 0, '#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\nint people[1000];\r\nint i,j,k,n,tot,best;\r\nchar cando[101][50000];\r\n\r\nmain(){\r\n   scanf("%d",&n);\r\n   for (i=0;i<n;i++) {\r\n      scanf("%d",&people[i]);\r\n      tot += people[i];\r\n   }\r\n\r\n   cando[0][0] = 1;\r\n   for (i=0;i<n;i++) {  /* try every person */\r\n      for (j=n/2;j>=0;j--) {\r\n         for (k=45000;k>=0;k--) {\r\n            if (cando[j][k]) cando[j+1][k+people[i]]=1;\r\n         }\r\n      }\r\n   }\r\n   for (i=0;i<=45000;i++) {\r\n      if (!cando[n/2][i]) continue;\r\n      if (abs(tot-2*i) < abs(tot-2*best)) best = i;\r\n   }\r\n   if (best > tot-best) best = tot-best;\r\n   printf("%d %d\\n",best,tot-best);\r\n}\r\n', '', 2322, 5320704, 1, 1, '2010-08-19 00:36:38', '0001-01-01 00:00:00'),
(300, 1, 283, 0, '#include <stdio.h>\r\n\r\nint ram[1000];\r\nint r[10];\r\nint i,ip,a,b,c;\r\n\r\nmain(){\r\n   while (1 == scanf("%d",&ram[i++])){} \r\n   for (i=1;;i++){\r\n      a = ram[ip]/100;\r\n      b = ram[ip]/10%10;\r\n      c = ram[ip]%10;\r\n      ip++;\r\n      if (a == 1) break;\r\n      if (a == 2) r[b] = c;\r\n      else if (a == 3) r[b] = (r[b]+c)%1000;\r\n      else if (a == 4) r[b] = (r[b]*c)%1000;\r\n      else if (a == 5) r[b] = r[c];\r\n      else if (a == 6) r[b] = (r[b]+r[c])%1000;\r\n      else if (a == 7) r[b] = (r[b]*r[c])%1000;\r\n      else if (a == 8) r[b] = ram[r[c]];\r\n      else if (a == 9) ram[r[c]] = r[b];\r\n      else if (a == 0 && r[c] !=0) ip = r[b];\r\n   }\r\n   printf("%d\\n",i);\r\n}\r\n', '', 0, 266240, 1, 1, '2010-08-19 00:36:38', '0001-01-01 00:00:00'),
(301, 1, 284, 0, '/*  Solution for "bridge" problem, a generalization of a problem\r\n    generally believed to be a Microsoft intelligence test.\r\n*/\r\n\r\n/*  Algorithm\r\n\r\n    Observation 1:  somebody has to get the flashlight back after every\r\n                    forward trip.  This should obviously be the fastest\r\n                    person on the far shore.\r\n\r\n    Observation 2:  in the general case, we have 4 or more people, the\r\n                    flashlight is on the starting side. \r\n                   \r\n                    Consider the two slowest people.\r\n                    there are 2 sensible strategies; we pick the fastest:\r\n\r\n                    1. we can send each with the fastest person, who returns\r\n                    with the flashlight.  this takes 2a+x+y time where a is\r\n                    the fastest and x and y are the two slowest\r\n\r\n                    2. we can send the fastest & 2nd fastest person, have\r\n                    the fastest return with the flashlight, send the \r\n                    slowpokes together, have the 2nd fastest return with\r\n                    the flashlight.  This takes a+2b+y where a is fastest,\r\n                    b second fastest, and y slowest\r\n\r\n                    BUT WAIT, you say.  What if strategy 1 is better than\r\n                    2 for x and y but perhaps x or y could have been paired\r\n                    with somebody else.  We already know that\r\n\r\n                        2a+x+y <= a+2b+y\r\n                             x <= 2b - a\r\n\r\n                    Now if we had a different x'' and y'', it would be\r\n                    the case that x'' <= x and y'' <= y so\r\n\r\n                             x'' <= 2b - a\r\n\r\n                    so for any other pair 1 will be the best strategy.\r\n\r\n                    BUT WAIT, you say again.  What if strategy 2 is better\r\n                    than strategy 1, but prevents strategy 2 from being used\r\n                    later, which would have been even better.\r\n\r\n                    Let a,b be the 2 fastest and w,x,y be the slowest.\r\n                    If we do x,y together we (may) force w to be done alone.\r\n\r\n                      x,y together:  a+2b+y\r\n                      w alone:       a+w\r\n                      total:         2a+2b+w+y\r\n\r\n                    If we do y alone, then w,x together.\r\n\r\n                      y alone:       a+y\r\n                      w,x together:  a+2b+x\r\n                      total:         2a+2b+x+y\r\n\r\n                    Since x >= w, this is worse so there''s no point in\r\n                    deferring the pairing.  \r\n\r\n\r\n    Observation 3:  The end game.  If there are 3 people left, the fastest\r\n                    shuttles them across.  If there are 2 people left,\r\n                    they go together.\r\n\r\n    Observation 4:  One person alone is a special case.  Happens only if\r\n                    this person started alone.\r\n\r\n*/\r\n\r\n\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\nint i,j,k,n;\r\n\r\nint t[1000];\r\n\r\nchar cross[2000][20];\r\nint nc=0,tot;\r\n\r\nint compare (const void * a, const void * b)\r\n{\r\n  return ( *(int*)a - *(int*)b );\r\n}\r\n\r\n\r\nmain(){\r\n   scanf("%d",&n);\r\n   for (i=0;i<n;i++) scanf("%d",&t[i]);\r\n\r\n   qsort(t,n,sizeof(int),compare);\r\n\r\n   for (i=n-1;i>=3 && 2*t[1] < t[0]+t[i-1];i-=2){\r\n      sprintf(cross[nc++],"%d %d\\n",t[0],t[1]);\r\n      sprintf(cross[nc++],"%d\\n",t[0]);\r\n      sprintf(cross[nc++],"%d %d\\n",t[i-1],t[i]);\r\n      sprintf(cross[nc++],"%d\\n",t[1]);\r\n      tot = tot + t[0]+2*t[1]+t[i];\r\n   }\r\n   for (;i>=2;i--){\r\n      sprintf(cross[nc++],"%d %d\\n",t[0],t[i]);\r\n      sprintf(cross[nc++],"%d\\n",t[0]);\r\n      tot = tot + t[0] + t[i];\r\n   }\r\n   if (i==1) {\r\n      sprintf(cross[nc++],"%d %d\\n",t[0],t[1]);\r\n      tot = tot + t[1];\r\n   }else{\r\n      sprintf(cross[nc++],"%d\\n",t[0]);\r\n      tot = tot + t[0];\r\n   }\r\n   printf("%d\\n",tot);\r\n   for (i=0;i<nc;i++) printf("%s",cross[i]);\r\n}\r\n', '', 0, 303104, 1, 1, '2010-08-19 00:42:08', '0001-01-01 00:00:00'),
(302, 1, 285, 0, '#include <stdio.h>\r\n\r\nstruct e {\r\n   long x,y,x1,y1;\r\n};\r\n\r\nlong x[101], y[101];\r\n\r\nstruct e up[101], dn[101];\r\nint n, nup, ndn;\r\nlong top,top1,top2,bot,bot1,bot2;\r\nlong long area;\r\n\r\ncmp (struct e *a, struct e *b){\r\n   if (b->y > a->y) return 1;\r\n   if (b->y < a->y) return -1;\r\n   return b->y1 - a->y1;\r\n}\r\n\r\nmain(){\r\n   int i,j,k;\r\n   for (n=0;2 == scanf("%d%d",&x[n],&y[n]);n++);\r\n   x[n] = x[0]; y[n] = y[0];\r\n   for (i=0;i<n;i++) {\r\n      if (x[i] < x[i+1]) {\r\n         if (y[i] < y[i+1]) {\r\n            up[nup].x = x[i];\r\n            up[nup].y = y[i];\r\n            up[nup].x1 = x[i+1];\r\n            up[nup++].y1 = y[i+1];\r\n         }else {\r\n            dn[ndn].x = x[i];\r\n            dn[ndn].y = y[i];\r\n            dn[ndn].x1 = x[i+1];\r\n            dn[ndn++].y1 = y[i+1];\r\n         }\r\n      }else if (x[i+1] < x[i]) {\r\n         if (y[i+1] < y[i]) {\r\n            up[nup].x = x[i+1];\r\n            up[nup].y = y[i+1];\r\n            up[nup].x1 = x[i];\r\n            up[nup++].y1 = y[i];\r\n         }else {\r\n            dn[ndn].x = x[i+1];\r\n            dn[ndn].y = y[i+1];\r\n            dn[ndn].x1 = x[i];\r\n            dn[ndn++].y1 = y[i];\r\n         }\r\n      }\r\n   }\r\n   qsort(up,nup,sizeof(struct e),cmp);\r\n   qsort(dn,ndn,sizeof(struct e),cmp);\r\n\r\n   up[nup].x = 0;\r\n   up[nup].y = -1;\r\n   up[nup].x1 = 1000000;\r\n   up[nup++].y1 = -1;\r\n\r\n   dn[ndn].x = 0;\r\n   dn[ndn].y = -1;\r\n   dn[ndn].x1 = 1000000;\r\n   dn[ndn++].y1 = -1;\r\n\r\n   for (i=0;i<1000000;i++) {\r\n      for (j=0;up[j].x > i || up[j].x1 <= i;j++);\r\n      for (k=0;dn[k].x > i || dn[k].x1 <= i;k++);\r\n      while(1){\r\n         bot1 = up[j].y+((long long)i-up[j].x)*(up[j].y1-up[j].y)/(up[j].x1-up[j].x);\r\n         bot2 = dn[k].y+((long long)(i+1-dn[k].x)*(dn[k].y1-dn[k].y)-(dn[k].x1-dn[k].x)+1)/(dn[k].x1-dn[k].x);\r\n         if (bot1 > bot2) {\r\n            bot = bot1;\r\n            for (j++;up[j].x > i || up[j].x1 <= i;j++);\r\n         }else if (bot2 > bot1){\r\n            bot = bot2;\r\n            for (k++;dn[k].x > i || dn[k].x1 <= i;k++);\r\n         }else break;\r\n            \r\n         top1 = up[j].y+((long long)(i+1-up[j].x)*(up[j].y1-up[j].y)+(up[j].x1-up[j].x)-1)/(up[j].x1-up[j].x);\r\n         top2 = dn[k].y+((long long)i-dn[k].x)*(dn[k].y1-dn[k].y)/(dn[k].x1-dn[k].x);\r\n         if (top1 > top2) {\r\n            top = top1;\r\n            for (j++;up[j].x > i || up[j].x1 <= i;j++);\r\n         }else if (k < ndn && top2 > top1){\r\n            top = top2;\r\n            for (k++;dn[k].x > i || dn[k].x1 <= i;k++);\r\n         }else {\r\n             fprintf(stderr,"oops!\\n;"); *(char *)0 = 1;\r\n         }\r\n         if (bot > top) area = area + bot - top;\r\n      }\r\n   }\r\n   printf("%lld\\n",area);\r\n}\r\n', '', 3066, 266240, 1, 1, '2010-08-19 00:42:09', '0001-01-01 00:00:00'),
(303, 1, 286, 0, '/* There''s a 5-case analytic solution but why bother? */\r\n\r\n#include <stdio.h>\r\n\r\nmain(){\r\n   int i,j,k,m,n,s,d;\r\n\r\n   while (2 == scanf("%d%d",&s,&d)){\r\n      int best = -9999999, tot;\r\n      for (i=0;i<4096;i++){\r\n         for (j=0;j<8;j++){\r\n            for (tot=k=0;k<5;k++) tot += ((i>>(j+k))&1)?s:-d;\r\n            if (tot >= 0) break;\r\n         }\r\n         if (j<8) continue;\r\n         for (tot=j=0;j<12;j++) tot += ((i>>j)&1)?s:-d;\r\n         if (tot > best) best = tot;\r\n      }\r\n      if (best > 0) printf("%d\\n",best);\r\n      else printf("Deficit\\n");\r\n   }\r\n}\r\n', '', 1215, 262144, 1, 1, '2010-08-19 01:28:06', '0001-01-01 00:00:00'),
(304, 1, 287, 0, '#include <stdio.h>\r\n#include <math.h>\r\n\r\ndouble lat[1000], lng[1000], x[1000], y[1000], z[1000];\r\ndouble d, bestcos = -1, mincos;\r\nint n, besti;\r\n\r\nmain(){\r\n   int i,j,k;\r\n   scanf("%d",&n);\r\n   for (i=0;i<n;i++) {\r\n      scanf("%lf%lf",&lat[i],&lng[i]);\r\n      z[i] = sin(lat[i]*M_PI/180);\r\n      x[i] = cos(lng[i]*M_PI/180) * cos(lat[i]*M_PI/180);\r\n      y[i] = sin(lng[i]*M_PI/180) * cos(lat[i]*M_PI/180);\r\n   }\r\n   for (i=0;i<n;i++){\r\n      mincos = 1;\r\n      for (j=0;j<n;j++){\r\n         d = x[i]*x[j] + y[i]*y[j] + z[i]*z[j];\r\n         if (d < mincos) mincos = d;\r\n      }\r\n      if (mincos > bestcos) {\r\n         bestcos = mincos;\r\n         besti = i;\r\n      }\r\n   }\r\n   printf("%0.2lf %0.2lf\\n",lat[besti],lng[besti]);\r\n} \r\n      \r\n', '', 15, 299008, 1, 2, '2010-08-19 01:28:07', '0001-01-01 00:00:00'),
(305, 1, 288, 0, '#include <stdio.h>\r\n#include <math.h>\r\n\r\nint n;\r\ndouble x[1000], y[1000], r[1000];\r\nint top[1000];\r\n\r\nint possible = 1;\r\ndouble ne = 1000, nw = 1000;\r\n\r\nmain(){\r\n   int i,j,k;\r\n   scanf("%d",&n);\r\n   for (i=0;i<n;i++) scanf("%lf%lf%lf",&x[i],&y[i],&r[i]);\r\n   for (i=0;i<n;i++) if (y[i]+r[i] > 1000) visit(i);\r\n   if (possible) printf(\r\n     "Bill enters at (0.00, %0.2lf) and leaves at (1000.00, %0.2lf).\\n",nw,ne);\r\n   else printf("Bill will be bitten.\\n");\r\n}\r\n\r\nvisit(int i){\r\n   int j,k;\r\n   double yy;\r\n   if (top[i]++) return;\r\n\r\n   for (j=0;j<n;j++) {\r\n      if (hypot(x[j]-x[i],y[j]-y[i]) < r[i]+r[j]) visit(j);\r\n   }\r\n   if (y[i]-r[i] < 0) possible = 0;\r\n   if (x[i]-r[i] < 0) {\r\n      yy = y[i] - sqrt(r[i]*r[i] - x[i]*x[i]);\r\n      if (yy < nw) nw = yy;\r\n   }\r\n   if (x[i]+r[i] > 1000) {\r\n      yy = y[i] - sqrt(r[i]*r[i] - (1000-x[i])*(1000-x[i]));\r\n      if (yy < ne) ne = yy;\r\n   }\r\n}\r\n', '', 138, 286720, 1, 1, '2010-08-19 01:28:08', '0001-01-01 00:00:00'),
(306, 1, 289, 0, '/* use of random() portable among:\r\n\r\n   Solaris, SunOS, DECUnix, Linux\r\n\r\n*/\r\n\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\nchar jane[200], john[200];\r\nint janei, johni;\r\n\r\nmain(){\r\n   int i,j;\r\n   gets(jane);\r\n   gets(john);\r\n   for (j=janei=johni=0;j<1000 && strlen(jane)&&strlen(john);j++){\r\n      if (jane[janei] == john[johni]) {\r\n         if (rand()/141%2 == 0) { /* jane wins */\r\n            printf("Snap! for Jane: ");\r\n            for (i=strlen(jane);i>janei;i--) jane[i+johni+1] = jane[i];\r\n            strncpy(jane+janei+1,john,johni+1);\r\n            strcpy(john,john+johni+1);\r\n            janei = janei + johni + 2;\r\n            johni = 0;\r\n            for (i=janei-1;i>=0;i--) printf("%c",jane[i]);\r\n            printf("\\n");\r\n         }else{  /* john wins */ \r\n            printf("Snap! for John: ");\r\n            for (i=strlen(john);i>johni;i--) john[i+janei+1] = john[i];\r\n            strncpy(john+johni+1,jane,janei+1);\r\n            strcpy(jane,jane+janei+1);\r\n            johni = johni + janei + 2;\r\n            janei = 0;\r\n            for (i=johni-1;i>=0;i--) printf("%c",john[i]);\r\n            printf("\\n");\r\n         }\r\n      }else{\r\n         janei++; johni++;\r\n      }\r\n      if (!jane[janei]) janei = 0;\r\n      if (!john[johni]) johni = 0;\r\n   }\r\n   if (!strlen(jane)) printf("John wins.\\n");\r\n   else if (!strlen(john)) printf("Jane wins.\\n");\r\n   else printf("No winner after %d turns\\n",j);\r\n}\r\n', '', 15, 262144, 1, 1, '2010-08-19 01:28:08', '0001-01-01 00:00:00'),
(307, 1, 290, 0, '/* Don''t need the array; doesn''t need to be so big; who cares? */\r\n\r\n#include <stdio.h>\r\n\r\nlong long most[1000000];\r\n\r\nmain(){\r\n   long long i;\r\n   int j,n,x,y;\r\n   for (i=0;i<500000;i++){\r\n      most[2*i] = i*(i+1);\r\n      most[2*i+1] = (i+1)*(i+1);\r\n   }\r\n   scanf("%d",&n);\r\n   while (n--) {\r\n      scanf("%d%d",&x,&y);\r\n      for (j=0;most[j] < y-x;j++);\r\n      printf("%d\\n",j);\r\n   }\r\n}\r\n\r\n   \r\n', '', 76, 8278016, 1, 1, '2010-08-19 01:28:08', '0001-01-01 00:00:00'),
(308, 1, 291, 0, '#define ONE_ANSWER 1\r\n\r\nint n, d[500][500];\r\nint nf, f[100];\r\nint fd[500];\r\n\r\nmain() {\r\n	int i, j, k, x, y, z, min, nmin;\r\n\r\n	scanf( " %d %d", &nf, &n );\r\n	for( i = 0; i < nf; i++ ) {\r\n		scanf( " %d", &f[i] );\r\n		f[i]--;\r\n	}\r\n	for( i = 0; i < n; i++ ) for( j = 0; j < n; j++ ) d[i][j] = 1000000000;\r\n	for( i = 0; i < n; i++ ) d[i][i] = 0;\r\n	while( scanf( " %d %d %d", &x, &y, &z ) == 3 ) {\r\n		x--; y--;\r\n		d[x][y] = d[y][x] = z;\r\n	}\r\n	for( i = 0; i < n; i++ ) for( j = 0; j < n; j++ ) for( k = 0; k < n; k++ ) {\r\n		x = d[j][i] + d[i][k];\r\n		if( d[j][k] > x ) d[j][k] = x;\r\n	}\r\n	for( i = 0; i < n; i++ ) {\r\n		fd[i] = 1000000000;\r\n		for( j = 0; j < nf; j++ )\r\n			if( d[i][f[j]] < fd[i] ) fd[i] = d[i][f[j]];\r\n	}\r\n	nmin = -1; min = 1000000000;\r\n	for( i = 0; i < n; i++ ) {\r\n		x = -1;\r\n		for( j = 0; j < n; j++ ) {\r\n			y = (d[j][i]<fd[j]) ? d[j][i] : fd[j];\r\n			if( y > x ) x = y;\r\n		}\r\n		if( x < min ) {\r\n			nmin = i; \r\n			min = x;\r\n		}\r\n	}\r\n#if !ONE_ANSWER\r\n	printf( "Possible answers:" );\r\n	for( i = 0; i < n; i++ ) {\r\n		x = -1;\r\n		for( j = 0; j < n; j++ ) {\r\n			y = (d[j][i]<fd[j]) ? d[j][i] : fd[j];\r\n			if( y > x ) x = y;\r\n		}\r\n		if( x == min ) printf( " %d", i+1 );\r\n	}\r\n	putchar( ''\\n'' );\r\n#else\r\n	printf( "%d\\n", nmin+1 );\r\n#endif\r\n}\r\n', '', 4007, 1261568, 1, 1, '2010-08-19 01:35:03', '0001-01-01 00:00:00'),
(309, 1, 292, 0, '#include <stdio.h>\r\n\r\nchar alph[27] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";\r\nchar code[27] = "01230120022455012623010202";\r\n\r\nmain() {\r\n	int ch;\r\n	char last = ''0'';\r\n\r\n	while( (ch=getchar()) != EOF ) {\r\n		if( ch == ''\\n'' ) {\r\n			putchar( ''\\n'' );\r\n			last = ''0'';\r\n		} else if( code[ch-''A''] != last ) {\r\n			last = code[ch-''A''];\r\n			if( last != ''0'' ) putchar( last );\r\n		}\r\n	}\r\n}\r\n', '', 0, 262144, 1, 1, '2010-08-19 01:35:03', '0001-01-01 00:00:00'),
(310, 1, 293, 0, '#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\nint ar[201][10001];\r\nint len;\r\n\r\nvoid pr( int i, int j ) {\r\n	if( i == 0 ) return;\r\n	pr( i-1, ar[i][j] );\r\n	printf( (j == ar[i][j]) ? "port\\n" : "starboard\\n" );\r\n}\r\n\r\nmain() {\r\n	int i, j, k, x, y, z, n;\r\n\r\n	scanf( " %d", &len );\r\n	len *= 100;\r\n	for( i = 0; i <= 200; i++ ) for( j = 0; j <= 10000; j++ ) ar[i][j] = -1;\r\n	ar[0][0] = 0;\r\n	y = 0;\r\n	for( i = 0; i < 200; i++ ) {\r\n		scanf( " %d", &x );\r\n		if( !x ) break;\r\n		y += x;\r\n		z = 0;\r\n		for( j = 0; j <= 10000; j++ ) if( ar[i][j] >= 0 ) {\r\n			if( j+x <= len && y-x-j <= len ) {ar[i+1][j+x] = j; z = 1;}\r\n			if( j <= len && y-j <= len ) {ar[i+1][j] = j; z = 1;}\r\n		}\r\n		if( !z ) break;\r\n	}\r\n	printf( "%d\\n", i );\r\n	for( j = 0; j <= 10000; j++ ) if( ar[i][j] >= 0 ) break;\r\n	pr( i, j );\r\n}\r\n', '', 165, 8318976, 1, 1, '2010-08-19 01:35:03', '0001-01-01 00:00:00'),
(311, 1, 294, 0, '#include <math.h>\r\n\r\nmain() {\r\n	double dx, dy, gx, gy;\r\n	double x, y;\r\n	double dd, gd;\r\n\r\n	scanf( " %lf %lf %lf %lf", &gx, &gy, &dx, &dy );\r\n	while( scanf( " %lf %lf", &x, &y ) == 2 ) {\r\n		dd = hypot( dx-x, dy-y );\r\n		gd = hypot( gx-x, gy-y );\r\n		if( gd * 2.0 < dd ) {\r\n			printf( "The gopher can escape through the hole at "\r\n					"(%.3f,%.3f).\\n", x, y );\r\n			return;\r\n		}\r\n	}\r\n	printf( "The gopher cannot escape.\\n" );\r\n}\r\n', '', 15, 262144, 1, 1, '2010-08-19 01:35:03', '0001-01-01 00:00:00'),
(312, 1, 295, 0, 'char dig[50];\r\n\r\nint ccmp( void *a, void *b ) {\r\n	return *((char*)a)-(int)*((char*)b);\r\n}\r\n\r\nmain() {\r\n	int i, j, k, x, y, z, n;\r\n\r\n	for(;;) {\r\n		scanf( " %s", dig );\r\n		if( !dig[1] ) break;\r\n		n = strlen(dig);\r\n		dig[n-2] = dig[n-1];\r\n		dig[n-1] = 0;\r\n		n--;\r\n		for( i = n-1; i >= 0; i-- ) {\r\n			for( j = dig[i]+1; j <= ''9''; j++ ) {\r\n				for( k = i; dig[k]; k++ ) {\r\n					if( dig[k] == j ||\r\n						dig[k] == ''2'' && j == ''5'' ||\r\n						dig[k] == ''5'' && j == ''2'' ||\r\n						dig[k] == ''6'' && j == ''9'' ||\r\n						dig[k] == ''9'' && j == ''6'' ) {\r\n						dig[k] = dig[i];\r\n						dig[i] = j;\r\n						goto found;\r\n					}\r\n				}\r\n			}\r\n		}\r\nfound:\r\n		if( i < 0 ) {\r\n			printf( "The price cannot be raised.\\n" );\r\n			continue;\r\n		}\r\n		for( k = i+1; dig[k]; k++ ) {\r\n			if( dig[k] == ''5'' ) dig[k] = ''2'';\r\n			if( dig[k] == ''9'' ) dig[k] = ''6'';\r\n		}\r\n		qsort( &dig[i+1], n-i-1, sizeof(char), ccmp );\r\n		dig[n] = dig[n-1];\r\n		dig[n-1] = ''.'';\r\n		printf( "%s\\n", dig );\r\n	}\r\n}\r\n', '', 15, 262144, 1, 1, '2010-08-19 01:35:03', '0001-01-01 00:00:00'),
(313, 1, 296, 0, '#include <stdio.h>\r\n#include <math.h>\r\n\r\nmain() {\r\n	int i, j, k, a, b, s, m, n;\r\n	double x, y, z;\r\n\r\n	for(;;) {\r\n		scanf( " %d %d %d %d %d", &a, &b, &s, &m, &n );\r\n		if( a+b+s+m+n == 0 ) break;\r\n		x = a*(double)m;\r\n		y = b*(double)n;\r\n		z = hypot( x, y );\r\n		printf( "%.2lf %.2lf\\n", atan2(y,x)*180.0/M_PI, z/s );\r\n	}\r\n}', '', 0, 262144, 1, 2, '2010-08-19 01:35:39', '0001-01-01 00:00:00'),
(314, 1, 297, 0, 'int mp[21][20001];\r\nint cn, cm[100], ccmin[100], ccmax[100];\r\nint bn, bc[200], bp[200];\r\n\r\nmain() {\r\n	int i, j, k, m, x, y, z, n;\r\n\r\n	scanf( " %d", &bn );\r\n	for( i = 0; i < bn; i++ )\r\n		scanf( " %d %d", &bc[i], &bp[i] );\r\n	scanf( " %d", &cn );\r\n	for( i = 0; i < cn; i++ ) {\r\n		scanf( " %d %d %d", &cm[i], &ccmin[i], &ccmax[i] );\r\n		ccmin[i] *= cm[i];\r\n		ccmax[i] *= cm[i];\r\n	}\r\n\r\n	for( j = 0; j <= 20; j++ ) {\r\n		n = 1000*j;\r\n		for( k = 0; k <= n; k++ ) mp[j][k] = 1000000000;\r\n	}\r\n	mp[0][0] = 0;\r\n\r\n	for( j = 0; j < bn; j++ ) {\r\n		for( k = 20; k > 0; k-- ) {\r\n			n = 1000*(k-1);\r\n			for( m = 0, z = bc[j]; m <= n; m++, z++ )\r\n				if( (y=mp[k-1][m]+bp[j]) < mp[k][z] )\r\n					mp[k][z] = y;\r\n		}\r\n	}\r\n\r\n	for( i = 0; i < cn; i++ ) {\r\n		x = 1000000000;\r\n		for( j = ccmin[i]; j <= ccmax[i]; j++ )\r\n			if( mp[cm[i]][j] < x ) x = mp[cm[i]][j];\r\n		if( x == 1000000000 )\r\n			printf( "impossible\\n" );\r\n		else\r\n			printf( "%d\\n", x );\r\n	}\r\n}', '', 699, 1945600, 1, 1, '2010-08-19 01:35:39', '0001-01-01 00:00:00'),
(315, 1, 298, 0, 'char name[30][100];\r\nchar party[30][100];\r\nchar v[30];\r\nchar buff[100];\r\n\r\nmain() {\r\n	int i, j, k, x, y, z, n;\r\n\r\n	scanf( "%d ", &n );\r\n	for( i = 0; i < n; i++ ) {\r\n		gets( name[i] );\r\n		gets( party[i] );\r\n	}\r\n	scanf( "%d ", &x );\r\n	for( i = 0; i < x; i++ ) {\r\n		gets( buff );\r\n		for( j = 0; j < n; j++ ) if( !strcmp( name[j], buff ) ) v[j]++;\r\n	}\r\n	x = -1; y = -1;\r\n	for( i = 0; i < n; i++ ) {\r\n		if( v[i] > x ) {\r\n			x = v[i];\r\n			y = i;\r\n		} else if( v[i] == x ) {\r\n			y = -1;\r\n		}\r\n	}\r\n	if( y == -1 )\r\n		printf( "tie\\n" );\r\n	else\r\n		printf( "%s\\n", party[y] );\r\n}', '', 0, 266240, 1, 1, '2010-08-19 01:35:39', '0001-01-01 00:00:00'),
(316, 1, 299, 0, '#define QSIZE 250000\r\n#define HSIZE 250001\r\n#define MSIZE 10\r\n\r\ntypedef struct mnode {\r\n	unsigned long long pos;\r\n	struct mnode *pred;\r\n	struct mnode *hnext;\r\n	char pmove;\r\n} MNode;\r\n\r\nMNode *hash[HSIZE];\r\nMNode *q[QSIZE];\r\nint qs, qe;\r\nint nnode = 0;\r\nchar g[MSIZE][MSIZE];\r\nint gs;\r\n\r\nvoid printbmp( unsigned long long nbmp, char *name ) {\r\n	int i, j;\r\n	unsigned long long mask;\r\n\r\n	printf( "%s:\\n", name );\r\n	mask = 0x8000000000000000LL;\r\n	for( i = 0; i < gs-2; i++ ) {\r\n		for( j = 0; j < gs-2; j++ ) {\r\n			putchar( (nbmp&mask)?''1'':''0'' );\r\n			mask = mask >> 1;\r\n		}\r\n		putchar( ''\\n'' );\r\n	}\r\n	putchar( ''\\n'' );\r\n}\r\n\r\nvoid PrintPath( MNode *tmp ) {\r\n	if( tmp == 0 ) return;\r\n	PrintPath( tmp->pred );\r\n	switch( tmp->pmove ) {\r\n	case ''n'': printf( "north\\n" ); break;\r\n	case ''e'': printf( "east\\n" ); break;\r\n	case ''s'': printf( "south\\n" ); break;\r\n	case ''w'': printf( "west\\n" ); break;\r\n	}\r\n}\r\n\r\nint AddNode( MNode *tmp ) {\r\n	int i, j, x;\r\n	MNode *hsh;\r\n\r\n	if( !tmp->pos ) {\r\n		PrintPath( tmp );\r\n		//printf( "used %d nodes\\n", nnode );\r\n		exit(0);\r\n	}\r\n\r\n	x = tmp->pos % HSIZE;\r\n	hsh = hash[x];\r\n	while( hsh ) {\r\n		if( tmp->pos == hsh->pos ) return 0;\r\n		hsh = hsh->hnext;\r\n	}\r\n\r\n	tmp->hnext = hash[x];\r\n	hash[x] = tmp;\r\n	nnode++;\r\n	q[qe++] = tmp;\r\n	if( qe == QSIZE ) qe = 0;\r\n	if( qe == qs ) {printf( "Queue overflow!!\\n" ); exit(0);}\r\n	return 1;\r\n}\r\n\r\nmain() {\r\n	int i, j, k, x, y, z, n;\r\n	MNode *tmp, *tmp2;\r\n	unsigned long long nbmp, ebmp, sbmp, wbmp, nwbmp, ewbmp, swbmp, wwbmp;\r\n	unsigned long long mask;\r\n\r\n	memset( hash, 0, sizeof(hash) );\r\n	tmp = (MNode*)malloc(sizeof(MNode));\r\n	tmp->pred = 0;\r\n	scanf( " %d", &gs );\r\n	for( i = 0; i < gs; i++ ) for( j = 0; j < gs; j++ )\r\n		scanf( " %c", &g[j][i] );\r\n	tmp->pos = nbmp = ebmp = sbmp = wbmp = nwbmp = ewbmp = swbmp = wwbmp = 0;\r\n	mask = 0x8000000000000000LL;\r\n	for( j = 1; j < gs-1; j++ ) for( i = 1; i < gs-1; i++ ) {\r\n		if( g[i][j] != ''O'' ) tmp->pos |= mask;\r\n		if( g[i][j] != ''O'' && j < gs-2 ) nbmp |= mask;\r\n		if( g[i][j] != ''O'' && i > 1 ) ebmp |= mask;\r\n		if( g[i][j] != ''O'' && j > 1 ) sbmp |= mask;\r\n		if( g[i][j] != ''O'' && i < gs-2 ) wbmp |= mask;\r\n		if( g[i][j-1] == ''O'' ) nwbmp |= mask;\r\n		if( g[i+1][j] == ''O'' ) ewbmp |= mask;\r\n		if( g[i][j+1] == ''O'' ) swbmp |= mask;\r\n		if( g[i-1][j] == ''O'' ) wwbmp |= mask;\r\n		mask = mask >> 1;\r\n	}\r\n	qs = qe = 0;\r\n	AddNode( tmp );\r\n\r\n	tmp2 = (MNode*)malloc(sizeof(MNode));\r\n	while( qs != qe ) {\r\n		tmp = q[qs++];\r\n		if( qs == QSIZE ) qs = 0;\r\n\r\n		tmp2->pred = tmp;\r\n		tmp2->pmove = ''n'';\r\n		tmp2->pos = ((tmp->pos << (gs-2)) & nbmp) | (tmp->pos & nwbmp);\r\n		if( AddNode( tmp2 ) ) tmp2 = (MNode*)malloc(sizeof(MNode));\r\n		if( !tmp2 ) {printf( "Out of memory at %d nodes\\n", nnode ); exit(0);}\r\n\r\n		tmp2->pred = tmp;\r\n		tmp2->pmove = ''e'';\r\n		tmp2->pos = ((tmp->pos >> 1) & ebmp) | (tmp->pos & ewbmp);\r\n		if( AddNode( tmp2 ) ) tmp2 = (MNode*)malloc(sizeof(MNode));\r\n		if( !tmp2 ) {printf( "Out of memory at %d nodes\\n", nnode ); exit(0);}\r\n\r\n		tmp2->pred = tmp;\r\n		tmp2->pmove = ''s'';\r\n		tmp2->pos = ((tmp->pos >> (gs-2)) & sbmp) | (tmp->pos & swbmp);\r\n		if( AddNode( tmp2 ) ) tmp2 = (MNode*)malloc(sizeof(MNode));\r\n		if( !tmp2 ) {printf( "Out of memory at %d nodes\\n", nnode ); exit(0);}\r\n\r\n		tmp2->pred = tmp;\r\n		tmp2->pmove = ''w'';\r\n		tmp2->pos = ((tmp->pos << 1) & wbmp) | (tmp->pos & wwbmp);\r\n		if( AddNode( tmp2 ) ) tmp2 = (MNode*)malloc(sizeof(MNode));\r\n		if( !tmp2 ) {printf( "Out of memory at %d nodes\\n", nnode ); exit(0);}\r\n	}\r\n	printf( "Impossible\\n" );\r\n}\r\n', '', 1244, 25321472, 1, 1, '2010-08-19 01:35:39', '0001-01-01 00:00:00'),
(317, 1, 300, 0, 'main() {\r\n	unsigned long long i, j, k, x, y, z, n;\r\n	unsigned long long p, q;\r\n	unsigned int pi, qi;\r\n\r\n	for(;;) {\r\n		scanf( " %u %u", &pi, &qi );\r\n		p = pi; q = qi;\r\n		if( pi+qi == 0 ) break;\r\n\r\n		x = 0;\r\n		for( i = 2; i <= 50000; i++ ) {\r\n			n = i*(i-1)*p;\r\n			while( x*(x-1)*q < n ) x++;\r\n			if( x*(x-1)*q == n ) break;\r\n		}\r\n		if( i > 50000 )\r\n			printf( "impossible\\n" );\r\n		else\r\n			printf( "%d %d\\n", (int)x, (int)(i-x) );\r\n	}\r\n}', '', 60, 262144, 1, 1, '2010-08-19 01:35:39', '0001-01-01 00:00:00'),
(318, 1, 301, 0, '#include <math.h>\r\n#include <stdlib.h>\r\n#include <stdio.h>\r\n#include <assert.h>\r\n\r\nint r,e,i,k,j,n,dun;\r\nint x[300], y[300], z[300];\r\ndouble a,b,c,d,w;\r\n\r\nint main(){\r\n   while (1 == scanf("%d",&r) && r >= 0) {\r\n      for (i=0;i<r;i++) scanf("%d%d%d",&x[i],&y[i],&z[i]);\r\n      scanf("%d",&e);\r\n      n = r + e;\r\n      for (i=r;i<n;i++) scanf("%d%d%d",&x[i],&y[i],&z[i]);\r\n      dun = 0;\r\n      for (k=0;k<100000 && !dun;k++) {\r\n         dun=1;\r\n         for (i=0;i<r;i++) {\r\n            if (a*x[i]+b*y[i]+c*z[i]+d > 0) {\r\n               a -= x[i];\r\n               b -= y[i];\r\n               c -= z[i];\r\n               d -= 1;\r\n               dun = 0;\r\n            }\r\n         }\r\n         for (i=r;i<n;i++) {\r\n            if (a*x[i]+b*y[i]+c*z[i]+d <= 0) {\r\n               a += x[i];\r\n               b += y[i];\r\n               c += z[i];\r\n               d += 1;\r\n               dun = 0;\r\n            }\r\n         }\r\n      }\r\n      if (dun) printf("%lg %lg %lg %lg\\n",a,b,c,d);\r\n      else printf("no solution\\n");\r\n   }\r\n   assert (r == -1);\r\n   assert (1 == scanf("%d",&r) && r == -1);\r\n   assert (1 != scanf(" %c",&c));\r\n}', '', 31, 258048, 1, 2, '2010-08-20 00:30:15', '0001-01-01 00:00:00'),
(319, 1, 302, 0, '#include <stdio.h>\r\n\r\nmain() {\r\n    double vb, vw, vr, vc;\r\n    int k, i;\r\n    while(1) {\r\n        scanf("%d %lf %lf %lf %lf", &k, &vb, &vw, &vr, &vc);\r\n        if(k == 0) break;\r\n        double f = -(-k*vr+vr-vb+k*vw-vw)/k;\r\n        if(f<0) f = 0;\r\n        double leftover = vb-(k-1)*(vc-vr);\r\n        if(f<leftover) f = leftover;\r\n        if(f+vw>vc) f = vc-vw;\r\n        if(f>vb) f= vb;\r\n        double s = 0;\r\n        if(k>1) {\r\n            s = (vb-f)/(k-1);\r\n            if(vr+s > vc) s=vc-vr;\r\n        }\r\n        printf("%d %lf", k, f);\r\n        for(i = 0; i < k-1; i++) {\r\n            printf(" %lf", s);\r\n        }\r\n        printf("\\n");\r\n    }\r\n}\r\n', '', 0, 258048, 1, 1, '2010-08-20 00:31:52', '0001-01-01 00:00:00'),
(320, 1, 303, 0, '#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include <memory.h>\r\n\r\n#define N 1200000\r\n\r\nint A[N];\r\nint in[N];\r\nint x;\r\n\r\nint comp(const int* a, const int* b) {\r\n    return (*a)-(*b);\r\n}\r\nmain() {\r\n   int n, max, i, j;\r\n   while (1 == scanf("%d", &n) && n) {\r\n      if (x++) printf("\\n");\r\n      memset(A,0,sizeof(A));\r\n      memset(in,0,sizeof(in));\r\n      max = 0;\r\n      for(i = 0; i < n; i++) {\r\n          int d;\r\n          scanf("%d", &d);\r\n          A[d]++;\r\n          in[i] = d;\r\n          if(A[d]>max) max = A[d];\r\n      }\r\n      printf("%d\\n", max);\r\n      qsort(in, n, sizeof(in[0]), comp);\r\n      for(i = 0; i < max; i++) {\r\n          for(j = i; j < n; j+=max) {\r\n              if(j>i) printf(" ");\r\n              printf("%d", in[j]);\r\n          }\r\n          printf("\\n");\r\n      }\r\n   }\r\n   if (n) printf("missing end delimiter\\n");\r\n}\r\n', '', 0, 9871360, 1, 1, '2010-08-20 00:32:37', '0001-01-01 00:00:00'),
(321, 1, 304, 0, '#include <stdio.h>\r\n#include <string.h>\r\n\r\nchar s[200];\r\nint i,j,vars, bins, uns;\r\n\r\nmain(){\r\n   while (1 == scanf("%s",s) && strcmp(s,"0")) {\r\n      vars = bins = uns = 0;\r\n      for (i=0;s[i];i++) {\r\n         if (s[i] >=''p'' && s[i] <= ''t'') vars++;\r\n         else if (s[i] == ''N'') uns++;\r\n         else bins++;\r\n      }\r\n      if (!vars) {\r\n         printf("no WFF possible\\n");\r\n         continue;\r\n      }\r\n      if (vars > bins+1) vars = bins+1;\r\n      for (i=0;i<uns;i++) printf("N");\r\n      for (i=j=0;s[i] && j+1 < vars;i++) {\r\n         if (s[i] < ''Z'' && s[i] != ''N'') {\r\n            printf("%c",s[i]);\r\n            j++;\r\n         }\r\n      }\r\n      for (i=j=0;s[i] && j < vars;i++) {\r\n         if (s[i] > ''a'') {\r\n            printf("%c",s[i]);\r\n            j++;\r\n         }\r\n      }\r\n      printf("\\n");\r\n   }\r\n   if (strcmp(s,"0")) printf("wrong input\\n");\r\n}\r\n', '', 0, 262144, 1, 2, '2010-08-20 00:32:37', '0001-01-01 00:00:00'),
(322, 1, 305, 0, '#include <algorithm>\n#include <iostream>\n#include <queue>\n#include <set>\n#include <string>\n#include <vector>\nusing namespace std;\n\nmain() {\n  int n, first = 1;\n  while (cin >> n && n) {\n    vector<pair<double, string> > k(n);\n    for (int i = 0; i < n; i++) cin >> k[i].second >> k[i].first;\n    sort(k.begin(), k.end());\n    vector<double> cum_pair(n+1);\n    for (int i = 2; i <= n; i++)\n      cum_pair[i] = cum_pair[i-2] +\n          (k[i-2].first-k[i-1].first) * (k[i-2].first-k[i-1].first);\n    priority_queue<pair<double, pair<int, int> > > q;\n    for (int i = 0; i+1 < n; i++)\n      q.push(make_pair(-(cum_pair[i+2]-cum_pair[i]), make_pair(i, i+1)));\n    set<int> byes;\n    for (int i = -1; i <= n; i++) byes.insert(i);\n    int spots;\n    for (spots = n; spots & (spots-1); spots++)\n      ;\n    while (n + byes.size()-2 != spots) {\n      int x = q.top().second.first, y = q.top().second.second;\n      q.pop();\n      if (!byes.count(x) || !byes.count(y)) continue;\n      byes.erase(x); byes.erase(y);\n      y = *byes.lower_bound(y);\n      x = *(--byes.lower_bound(x));\n      if (x < 0 || y >= n) continue;\n      q.push(make_pair(\n          (cum_pair[y]-cum_pair[x+1]) - (cum_pair[y+1]-cum_pair[x]),\n          make_pair(x, y)));\n    }\n    if (!first) cout << endl;\n    first = 0;\n    for (set<int>::iterator it = byes.begin(); it != byes.end(); ++it)\n      if (*it >= 0 && *it < n) cout << k[*it].second << endl;\n  }\n}\n', '', 0, 368640, 1, 2, '2010-08-20 00:33:01', '0001-01-01 00:00:00'),
(323, 1, 306, 0, '#include <memory.h>\n#include <iostream>\n#include <map>\n#include <set>\n#include <string>\n#include <vector>\nusing namespace std;\n\nvector<pair<int, bool> > implications[30][2];  // T = w, F = h\nint val[30], val2[30];\n\nbool doit(int n, int v) {\n  if (val[n] != -1) return val[n] == v;\n  val[n] = v;\n  vector<pair<int, bool> >& imp = implications[n][v];\n  for (int i = 0; i < imp.size(); i++)\n    if (!doit(imp[i].first, imp[i].second)) return false;\n  return true;\n}\n\nmain() {\n  int N, M;\n  while (cin >> N >> M && N) {\n    for (int i = 0; i < N; i++)\n    for (int j = 0; j < 2; j++)\n      implications[i][j].clear();\n    for (int i = 0; i < M; i++) {\n      char a, b;\n      int an, bn;\n      cin >> an >> a >> bn >> b;\n      implications[an][a==''h''].push_back(make_pair(bn, b==''w''));\n      implications[bn][b==''h''].push_back(make_pair(an, a==''w''));\n    }\n    memset(val, -1, sizeof(val));\n    if (!doit(0, 1)) goto fail;\n    for (int i = 0; i < N; i++) if (val[i] == -1) {\n      memcpy(val2, val, sizeof(val));\n      if (!doit(i, 0)) {\n        memcpy(val, val2, sizeof(val));\n        if (!doit(i, 1)) goto fail;\n      }\n    }\n    for (int i = 1; i < N; i++) {\n      if (i > 1) cout << '' '';\n      cout << i << (val[i] ? ''w'' : ''h'');\n    }\n    cout << endl;\n    continue;\nfail:\n    cout << "bad luck" << endl;\n  }\n}\n', '', 0, 483328, 1, 2, '2010-08-20 00:33:01', '0001-01-01 00:00:00'),
(324, 1, 307, 0, '#include <string.h>\n#include <stdio.h>\n#include <ctype.h>\n\nchar a[1000], b[1000];\n\nint na,nb,i,j,k,m,n,c;\nchar *pa, *pb, aa[100][100], bb[100][100];\n\nint main(){\n\n   scanf("%d ",&c);\n   while (c--) {\n      gets(a);\n      gets(b);\n      na = nb = 0;\n      for (pa = strtok(a," ");pa;pa = strtok(NULL," ")){\n         if (*pa == ''<'') *pa = ''0'';\n         strcpy(aa[na++],pa);\n      }\n      for (pb = strtok(b," ");pb;pb = strtok(NULL," ")){\n         if (*pb == ''<'') *pb = ''1'';\n         strcpy(bb[nb++],pb);\n      }\n      if (na != nb) {\n         printf("-\\n");\n         continue;\n      }\n      for (i=0;i<na;i++) {\n         if (isdigit(aa[i][0])) {\n           for (j=0;j<na;j++) if (!strcmp(bb[j],aa[i])) strcpy(bb[j],bb[i]);\n           for (j=i+1;j<na;j++) if (!strcmp(aa[j],aa[i])) strcpy(aa[j],bb[i]);\n           for (j=0;j<=i;j++) if (!strcmp(aa[j],aa[i])) strcpy(aa[j],bb[i]);\n         } else if (isdigit(bb[i][0])) {\n           for (j=0;j<na;j++) if (!strcmp(aa[j],bb[i])) strcpy(aa[j],aa[i]);\n           for (j=i+1;j<na;j++) if (!strcmp(bb[j],bb[i])) strcpy(bb[j],aa[i]);\n           for (j=0;j<=i;j++) if (!strcmp(bb[j],bb[i])) strcpy(bb[j],aa[i]);\n         } else if (strcmp(aa[i],bb[i])){\n            printf("-\\n");\n            goto dun;\n         }\n      }\n      for (i=0;i<na;i++) {\n         if (i) printf(" ");\n         if (isdigit(aa[i][0])) printf("x"); else printf("%s",aa[i]);\n      }\n      printf("\\n");\n   dun:;}\n   if (gets(a)) printf("Extra input!\\n");\n   return 0;\n}\n', '', 0, 278528, 1, 2, '2010-08-20 00:36:56', '0001-01-01 00:00:00'),
(325, 1, 308, 0, '#include <stdio.h>\r\n#include <string.h>\r\n#include <math.h>\r\n\r\n#define EPS 1e-10\r\n\r\ndouble r,x,y,xx,yy,X,Y,dx,dy,dd,c;\r\n\r\nvoid move(double x, double y, double X, double Y){\r\n   char tmp[100];\r\n   tmp[0] = 0;\r\n   if (Y - y > EPS) strcpy(tmp,"north");\r\n   if (Y - y < -EPS) strcpy(tmp,"south");\r\n   if (X - x > EPS) strcat(tmp,"east");\r\n   if (X - x < -EPS) strcat(tmp,"west");\r\n   printf("%s %0.10lf\\n",tmp,hypot(X-x,Y-y));\r\n}\r\n\r\nmain(){\r\n   while (5 == scanf("%lf%lf%lf%lf%lf",&r,&x,&y,&X,&Y)) {\r\n      if (c++) printf("\\n");\r\n      dx = fabs(X-x);\r\n      dy = fabs(Y-y);\r\n      if (dx == 0 || dy == 0 || dx == dy) {\r\n         move(x,y,X,Y);\r\n         continue;\r\n      }\r\n      dd = dx < dy ? dx : dy;\r\n      xx = x + (X>x?dd:-dd);\r\n      yy = y + (Y>y?dd:-dd);\r\n      if (hypot(xx,yy) < r) {\r\n         move(x,y,xx,yy);\r\n         move(xx,yy,X,Y);\r\n         continue;\r\n      }\r\n      xx = X - (X>x?dd:-dd);\r\n      yy = Y - (Y>y?dd:-dd);\r\n\r\n      move(x,y,xx,yy);\r\n      move(xx,yy,X,Y);\r\n   }\r\n   if (r != -1) printf("Invalid terminator %0.10lf\\n");\r\n}\r\n', '', 0, 262144, 1, 2, '2010-08-20 00:37:31', '0001-01-01 00:00:00'),
(326, 1, 309, 0, '#include <stdio.h>\r\n#include <memory.h>\r\n\r\ndouble sum,r[100];\r\nint i,j,k,m,n, R[100], prev[20001], who[20001];\r\nchar tmp[1000];\r\n\r\nmain(){\r\n   while (1 == scanf("%d",&n) && n) {\r\n      for (i=0;i<n;i++) scanf("%lf",&r[i]);\r\n      for (i=sum=0;i<n;i++) sum += r[i];\r\n      for (i=0;i<n;i++) R[i] = r[i] * 20000/sum;\r\n      memset(who,0,sizeof(who));\r\n      memset(prev,0,sizeof(prev));\r\n      who[0] = -1;\r\n      for (i=0;i<n;i++) {\r\n         for (j=10000;j>=0;j--) {\r\n            if (!who[j]) continue;\r\n            if (who[j+R[i]]) continue;\r\n            who[j+R[i]] = i+1;\r\n            prev[j+R[i]] = j;\r\n         }\r\n      }\r\n      for (i=10000;!who[i];i--);\r\n      while (i) {\r\n         printf("%d ", who[i]);\r\n         i = prev[i];\r\n      }\r\n      printf("\\n");\r\n   }\r\n   if (n != 0) printf("missing end delimeter\\n");\r\n}\r\n\r\n/**************************************************************\r\n	Problem: 1217\r\n	User: zhblue\r\n	Language: C++\r\n	Result: Compile Error\r\n****************************************************************/\r\n\r\n', '', 514, 417792, 1, 2, '2010-08-20 00:37:31', '0001-01-01 00:00:00'),
(327, 1, 310, 0, '#include <stdio.h>\r\n\r\nchar *B[] = {"LR","LU","LD","UR","UD","UL","RD","RU","DL","DU","DR"};\r\n\r\nint t[200][22], prev[200][22];\r\n\r\nstepcost(char x, char y){\r\n   if (x == y) return 3;\r\n   if (x == ''R'' && y == ''L'' || x == ''U'' && y == ''D'') return 7;\r\n   if (x == ''L'' && y == ''R'' || x == ''D'' && y == ''U'') return 7;\r\n   return 5;\r\n}\r\n\r\ncost(int s1, int s2, char m) {\r\n   int p1 = s1%2, b1 = s1/2, p2 = s2%2, b2 = s2/2;\r\n   if (m == ''.'') {\r\n      int a,b;\r\n      if (s1/2 == s2/2) return 0;\r\n      a = cost(s1,s2,''L'');\r\n      b = cost(s1,s2,''R'');\r\n      if (b<a) a = b;\r\n      b = cost(s1,s2,''U'');\r\n      if (b<a) a = b;\r\n      b = cost(s1,s2,''D'');\r\n      if (b<a) a = b;\r\n      return a;\r\n   }\r\n   if (p2 == 0) {                          // moving left foot\r\n      if (B[b2][0] != m) return 999999;    // have to end with foot in place\r\n      if (B[b2][1] == m) return 999999;    // other foot on the square\r\n      if (B[b1][1] == ''L'' && B[b1][0] != m) return 999999;  // crossed over\r\n      if (B[b1][1] != B[b2][1]) return 999999; // can''t move other foot\r\n      if (p1 == 1) return 1;               // alternating feet\r\n      return stepcost(B[b1][0],m);\r\n   } else {\r\n      if (B[b2][1] != m) return 999999;    // have to end with foot in place\r\n      if (B[b2][0] == m) return 999999;    // other foot on the square\r\n      if (B[b1][0] == ''R'' && B[b1][1] != m) return 999999;  // crossed over\r\n      if (B[b1][0] != B[b2][0]) return 999999; // can''t move other foot\r\n      if (p1 == 0) return 1;               // alternating feet\r\n      return stepcost(B[b1][1],m);\r\n   }\r\n}\r\n\r\nchar buf[10000];\r\n\r\nint i,j,k,n;\r\n\r\ndump(int j, int k) {\r\n   int i;\r\n   if (j == 0) return 0;\r\n   for (i=0;i<22;i++) {\r\n      if (t[j-1][i] + cost(i,k,buf[j-1]) == t[j][k]) {\r\n         dump(j-1,i);\r\n         if (cost(i,k,buf[j-1]) == 0) printf(".");\r\n         else printf("%c","LR"[k%2]);\r\n         return 0;\r\n      }\r\n   }\r\n}\r\n\r\n\r\nmain(){\r\n   while (gets(buf) && *buf != ''#'') {\r\n      n = strlen(buf);\r\n      for (i=0;i<=n;i++) for (j=0;j<22;j++) t[i][j] = 999999;\r\n      t[0][0] = t[0][1] = 0;\r\n      for (i=0;i<n;i++) {\r\n         for (j=0;j<22;j++) for (k=0;k<22;k++) {\r\n            if (t[i][j] == 999999) continue;\r\n            int c = cost(j,k,buf[i]);\r\n            if (t[i][j] + c < t[i+1][k]) {\r\n               t[i+1][k] = t[i][j] + c;\r\n               prev[i+1][k] = j;\r\n               0&&printf("step %d from %d %s to %d %s cost %d total %d\\n",\r\n                          i,j%2,B[j/2],k%2,B[k/2],c,t[i+1][k]);\r\n\r\n            }\r\n         }\r\n      }\r\n      k = 0;\r\n      for (i=0;i<22;i++) if (t[n][i] < t[n][k]) k = i;\r\n      dump(n,k);\r\n      //printf(" %d\\n",t[n][k]);\r\n      printf("\\n",t[n][k]);\r\n   }\r\n   if (*buf != ''#'') printf("missing end delimiter\\n");\r\n}\r\n', '', 46, 307200, 1, 1, '2010-08-20 00:38:44', '0001-01-01 00:00:00');
INSERT INTO `tbl_submitions` (`id`, `user_id`, `problem_id`, `exercise_id`, `source`, `result`, `used_time`, `used_memory`, `status`, `compiler_id`, `created`, `modified`) VALUES
(328, 1, 311, 0, '#include <stdio.h>\r\n#include <string.h>\r\n#include <math.h>\r\n\r\n#define N 0\r\n#define S 1\r\n#define E 2\r\n#define W 3\r\n\r\nchar g[100][101], jack[10000], jill[10000];\r\n\r\nint i,j,k,m,n,Hi,Hj,Si,Sj,hi,hj,si,sj,qn;\r\nint cnt,a,b,i,j,qi,I,J,hi,lo,mid,min2;\r\ndouble bestd;\r\n\r\nstruct qq{\r\n   char I,J,i,j;\r\n   int d;\r\n   int prev;\r\n   int link;\r\n} q[1000000];\r\n\r\nint fst[20000], lst[20000], qh, here;\r\n\r\nchar done[30][30][30][30];\r\n\r\n#define isdone(a,b,c,d) done[a][b][c][d]\r\n#define setdone(a,b,c,d) (done[a][b][c][d] = 1)\r\n\r\ndump(int z){\r\n   if (z == 0) return;\r\n   dump(q[z].prev);\r\n   if (q[q[z].prev].I < q[z].I) strcat(jack,"S");\r\n   if (q[q[z].prev].I > q[z].I) strcat(jack,"N");\r\n   if (q[q[z].prev].J < q[z].J) strcat(jack,"E");\r\n   if (q[q[z].prev].J > q[z].J) strcat(jack,"W");\r\n   if (q[q[z].prev].i < q[z].i) strcat(jill,"S");\r\n   if (q[q[z].prev].i > q[z].i) strcat(jill,"N");\r\n   if (q[q[z].prev].j < q[z].j) strcat(jill,"E");\r\n   if (q[q[z].prev].j > q[z].j) strcat(jill,"W");\r\n}\r\n\r\nmain(){\r\n   while (1 == scanf("%d",&n) && n) {\r\n      for (i=0;i<n;i++) scanf("%s",g[i]);\r\n      jack[0] = jill[0] = 0;\r\n      bestd = 0;\r\n      for (i=0;i<n;i++) for (j=0;j<n;j++) {\r\n         if (g[i][j] == ''H'') {q[0].I = i; q[0].J = j;}\r\n         if (g[i][j] == ''h'') {q[0].i = i; q[0].j = j;}\r\n      }\r\n      memset(done,0,sizeof(done));\r\n      memset(fst,-1,sizeof(fst));\r\n      memset(lst,0,sizeof(lst));\r\n      q[0].d = (q[0].I-q[0].i)*(q[0].I-q[0].i)+ (q[0].J-q[0].j)*(q[0].J-q[0].j);\r\n      q[0].link = -1;\r\n      fst[q[0].d] = lst[q[0].d] = 0;\r\n         here = 20000;\r\n         qi = -1;\r\n         qn = 1;\r\n         for (qh=0;qh<qn;qh++,qi=q[qi].link) {\r\n         if (qi == -1) {\r\n            while(fst[--here] == -1);\r\n            qi = fst[here];\r\n         }\r\n         for (a=0;a<4;a++) for (b=0;b<4;b++) {\r\n            I = q[qi].I; J = q[qi].J; i = q[qi].i; j = q[qi].j;\r\n            if (g[I][J] == ''S'') { }\r\n            else if (a == N) I--;\r\n            else if (a == S) I++;\r\n            else if (a == W) J--;\r\n            else if (a == E) J++;\r\n            if (g[i][j] == ''s'') { }\r\n            else if (b == N) i--;\r\n            else if (b == S) i++;\r\n            else if (b == W) j--;\r\n            else if (b == E) j++;\r\n            if (I<0 || J<0 || i<0 || j<0 || I == n || J == n || i == n || j == n) continue;\r\n            if (g[I][J] == ''*'' || g[I][J] == ''h'' || g[I][J] == ''s'') continue;\r\n            if (g[i][j] == ''*'' || g[i][j] == ''H'' || g[i][j] == ''S'') continue;\r\n            if (isdone(I,J,i,j)) continue;\r\n            q[qn].d = (I-i)*(I-i) + (J-j)*(J-j);\r\n            if (q[qi].d < q[qn].d) q[qn].d = q[qi].d;\r\n            setdone(I,J,i,j);\r\n            q[qn].I = I; q[qn].J = J; q[qn].i = i; q[qn].j = j; q[qn].prev = qi;\r\n            if (fst[q[qn].d] == -1) fst[q[qn].d] = lst[q[qn].d] = qn;\r\n            else {\r\n               q[lst[q[qn].d]].link = qn;\r\n               lst[q[qn].d] = qn;\r\n            }\r\n            q[qn].link = -1;\r\n            if (g[I][J] == ''S'' && g[i][j] == ''s'') goto dun;\r\n            qn++;\r\n         }\r\n      }\r\n      printf("oops!\\n");\r\n      dun: jack[0] = jill[0] = 0; dump(qn); bestd = sqrt(q[qn].d);\r\n      if (cnt++) printf("\\n");\r\n      i = strlen(jack);\r\n      j = strlen(jill);\r\n      if (j > i) i = j;\r\n      i = 9 * 60 - i;\r\n      printf("%0.2lf\\n%s\\n%s\\n",bestd,jack,jill);\r\n   }\r\n   if (n) printf("missing 0 in input\\n");\r\n}\r\n', '', 358, 17289216, 1, 1, '2010-08-20 00:38:44', '0001-01-01 00:00:00'),
(329, 1, 312, 0, '#include <stdio.h>\r\n#include <string.h>\r\n\r\n#define SIZE 100\r\n\r\nchar g[SIZE][SIZE];\r\n\r\nint i,j,k,m,n,p,x,a,size;\r\n\r\nint v[SIZE], cnt[SIZE][SIZE], is, best[SIZE][SIZE], prev[SIZE][SIZE];\r\n\r\ndump(int p, int x){\r\n   if (p) dump(p-1,prev[p][x]);\r\n   printf(" %d",x+1);\r\n}\r\n\r\nmain(){\r\n   while (1 == scanf("%d",&n) && n != -1) {\r\n      memset(g,0,sizeof(g));\r\n      memset(cnt,0,sizeof(cnt));\r\n      for (i=0;i<n;i++) {\r\n         scanf("%d%d",&j,&k);\r\n         g[k-1][j-1] = 1;\r\n      }\r\n\r\n      scanf("%d",&m); m--;\r\n      for (i=0;i<=m;i++) {\r\n         scanf("%d",&v[i]);\r\n         v[i]--;\r\n      }\r\n      scanf("%d",&p); p--;\r\n   \r\n      for (a=0;a<m;a++) {\r\n         for (i=0;i<SIZE;i++) {\r\n            is = 0;\r\n            for (size=1;i+size<SIZE;size++) {\r\n               for(j=v[a];j<v[a+1];j++) {\r\n                  is |= g[i+size-1][j];\r\n                  if (is) {\r\n                     cnt[i][i+size]++;\r\n                     break;\r\n                  }\r\n               }\r\n            }\r\n         }\r\n      }\r\n\r\n      for (i=0;i<SIZE;i++) for (j=0;j<SIZE;j++) best[i][j] = -1;\r\n      best[0][0] = 0;\r\n      for (n=0;n<p;n++) {\r\n         for (j=SIZE-1;j>0;j--) {\r\n            for (i=0;i<j;i++) {\r\n               if (cnt[i][j] + best[n][i] > best[n+1][j]) {\r\n                  best[n+1][j] = cnt[i][j] + best[n][i];\r\n                  prev[n+1][j] = i;\r\n               }\r\n            }\r\n         }\r\n      }\r\n      printf("%d",p+1);\r\n      dump(p,SIZE-1);\r\n      printf("\\n");\r\n   }\r\n   if (n != -1) printf("missing end delimiter\\n");\r\n}\r\n', '', 296, 385024, 1, 1, '2010-08-20 00:39:00', '0001-01-01 00:00:00'),
(330, 1, 313, 0, '#include <stdio.h>\r\n#include <string.h>\r\n\r\nstruct cc {\r\n   int h,d,w;\r\n} c[201];\r\n\r\nint i,k,j,m,n,cnt,qn,next,which;\r\n\r\nint comp(struct cc *a, struct cc *b){\r\n   if (a->h != b->h) return a->h - b->h;\r\n   if (a->d != b->d) return a->d - b->d;\r\n   return b->w - a->w;\r\n}\r\n\r\nint holds(int a, int b) {\r\n   int r = c[a].h-2*c[a].w >= c[b].h && c[a].d-2*c[a].w >= c[b].d;\r\n   return r;\r\n}\r\n\r\nchar memo[201][201][201];\r\n\r\nfoo(int a, int b, int na){\r\n   int next;\r\n   if (memo[a][b][na]) return 0;\r\n   next = a>b?a:b;\r\n   if (na > n/2 || next-na > n/2) return 0;\r\n   if (next++ == n) return 1;\r\n   if (holds(next,a) && foo(next,b,na+1)) {\r\n      if (which) printf("%d %d %d\\n",c[next].h,c[next].d,c[next].w);\r\n      return 1;\r\n   }\r\n   if (holds(next,b) && foo(a,next,na)) {\r\n      if (!which) printf("%d %d %d\\n",c[next].h,c[next].d,c[next].w);\r\n      return 1;\r\n   }\r\n   memo[a][b][na] = 1;\r\n   return 0;\r\n}\r\n\r\nmain(){\r\n   while (1 == scanf("%d",&n) && n) {\r\n      n *= 2;\r\n      if (cnt++) printf("\\n");\r\n      for (i=1;i<=n;i++) scanf("%d%d%d",&c[i].h,&c[i].d,&c[i].w);\r\n      qsort(c,n+1,sizeof(struct cc),comp);\r\n      memset(memo,0,sizeof(memo));\r\n      which = 0;\r\n      foo(0,0,0);\r\n      printf("-\\n");\r\n      which = 1;\r\n      foo(0,0,0);\r\n   }\r\n}\r\n', '', 78, 8392704, 1, 1, '2010-08-20 00:39:42', '0001-01-01 00:00:00'),
(331, 1, 314, 0, '#include <stdio.h>\n\nmain()\n{\n	int i,j,x,a,b,n[20],m[20];\n	double c,e,d[20]; \n	while(scanf("%d%d",&a,&b)!=EOF)\n	{\n		if(!a&&!b)break;\n		for(i=0;i<a;i++)\n			scanf("%d%d",&n[i],&m[i]);\n		for(i=0;i<a;i++)\n		{\n			d[i]=(double)m[i]/(double)n[i];\n		}\n		c=0;\n		e=0;\n		for(x=0;x<a;x++)\n		{\n			for(i=j=0;i<a;i++)\n			{\n				if(d[j]<d[i])j=i;\n			}\n			if((e+n[j])>=b){i=(b-e);c+=d[j]*i;break;}\n			else if(d[j]==0)break;\n			else{e+=n[j];c+=m[j];}\n			d[j]=0;\n		}\n		printf("%.2f\\n",c);\n	}\n}\n\n', '', 0, 258048, 1, 1, '2010-08-20 00:59:53', '0001-01-01 00:00:00'),
(332, 1, 315, 0, '#include<stdio.h>\nint main()\n{\n 	int m,n;\n 	while(scanf("%d %d",&m,&n),m||n)\n	{\n		if((n-2*m)%2==0&&(n-2*m)/2>=0&&(n-2*m)/2<=m)\n 			printf("%d %d\\n",m-(n-2*m)/2,(n-2*m)/2);\n 		else printf("Error\\n");\n 	}\n	return 0;\n }\n', '', 0, 258048, 1, 1, '2010-08-20 00:59:59', '0001-01-01 00:00:00'),
(333, 1, 316, 0, '#include <stdio.h>\n#include <stdlib.h>\n\n#define MAXN 1001\nint horses1[MAXN];\nint horses2[MAXN];\n\nint compare (const void * a, const void * b)\n{\n  return ( *(int*)a - *(int*)b );\n}\n\nint main()\n{\n  int n, i, j, t, end;\n  while(scanf("%d", &n), n)\n  {\n     for (i = 0; i < n; ++i)\n        scanf("%d", &horses1[i]);\n     for (i = 0; i < n; ++i)\n        scanf("%d", &horses2[i]);\n\n     qsort(horses1, n, sizeof(int), compare);\n     qsort(horses2, n, sizeof(int), compare);\n   \n     t = 0; \n     end = n - 1;\n     for (i = n - 1; i >= 0; --i)\n        for (j = end; j >= 0; --j)\n          if (horses1[i] > horses2[j])\n          {\n             ++t;\n             end = j - 1;\n             break;\n          }\n     if (t > n / 2) printf("YES\\n");\n       else printf("NO\\n");\n  }\n  return 0;\n}\n', '', 0, 270336, 1, 1, '2010-08-20 01:00:04', '0001-01-01 00:00:00'),
(334, 1, 317, 0, '#include<stdio.h>\n#include<string.h>\nstruct node\n{\n	int x,y;\n}que[401];\nchar visited[21][21];\nint xs,ys,xe,ye,head,tail,pt,n,m;\nint go[4][2]={{0,1},{1,0},{-1,0},{0,-1}};\nint bfs(int x1,int y1,int x2,int y2)\n{\n	int i,x,y,step=0,k;\n	head=pt=0;\n	tail=1;\n	que[0].x=x1;\n	que[0].y=y1;\n	while(head<tail)\n	{\n		pt=tail;\n		step++;\n		for(k=head;k<tail;k++)\n		{\n			for(i=0;i<4;i++)\n				{\n					x=que[k].x+go[i][0];\n					y=que[k].y+go[i][1];\n					if(x>=0&&x<m&&y>=0&&y<n&&visited[x][y]!=''*'')\n					{\n						que[pt].x=x;\n						que[pt++].y=y;\n						visited[x][y]=''*'';\n					}\n					if(x==x2&&y==y2) return step;\n				}\n		}\n		head=tail;\n		tail=pt;\n	}\n	return -1;\n}\nint main()\n{\n	int t,res;\n	int i,j;\n	while(scanf("%d%d%d",&n,&m,&t),n||m||t)\n	{\n		getchar();\n		for(i=0;i<m;i++)\n		   gets(visited[i]);\n		for(i=0;i<m;i++)\n		{		\n			for(j=0;j<n;j++)\n			{\n				if(visited[i][j]==''S'')\n				{\n					xs=i,ys=j;\n					visited[i][j]=''*'';\n				}	\n				if(visited[i][j]==''P'')\n					xe=i,ye=j;\n			}\n			\n		}\n			res=bfs(xs,ys,xe,ye);\n			if(res>-1&&res<=t)printf("YES\\n");\n			else printf("NO\\n");\n	}\n	return 0;\n}', '', 0, 258048, 1, 1, '2010-08-20 01:00:09', '0001-01-01 00:00:00'),
(335, 1, 318, 0, '#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#define size 3200\nint pm[446] = {2,3,5};\nint total = 3;\nint abc;\nint num;\nint Len;\n\nvoid R(int n, int b, int sum)\n{\n	if (n < Len)\n	{\n		int i, tmp;\n		for (i = b; i < total - Len + 1 + n; i++)\n		{\n			tmp = num;\n			R(n + 1, i + 1, sum * pm[i]);\n			if (tmp == num) return;\n		}\n	}\n	else\n	{\n		num += abc / sum;\n	}\n}\n\nint B(int len)\n{\n	int left = 0;\n	int right = 445;\n	int middle;\n\n	while (left < right)\n	{\n		middle = (left + right) / 2;\n		if (pm[middle] > len)\n			right = middle - 1;\n		else if (pm[middle] < len)\n			left = middle + 1;\n		else\n			return middle + 1;\n	}\n	return pm[left] <= len ? left + 1 : left;\n}\n\nint creat_prime(int prime[],int n,int total)\n{\n	int	i, j;\n	int	gab=2;\n	int	count;\n	for(i=7;i<=n;i+=gab)\n	{\n		count=1;\n		gab=6-gab;\n		for(j=0;prime[j]*prime[j]<=i;j++)\n		{\n			if(i%prime[j]==0)\n			{\n				count=0;\n				break;\n			}\n		}\n		if(count)\n		{\n			prime[total]=i;\n			total++;\n		}\n	}\n\n	return total;\n}\n\nint main(void)\n{\n	int len;\n	int count = 2;\n\n	total=creat_prime(pm,3162,total);\n	while (scanf("%d", &abc), abc)\n	{\n		total = B((int)(sqrt(abc) + 0.5));\n		for (len = 0, Len = 1; Len <= total; Len++)\n		{\n			num = 0;\n			R(0, 0, 1);\n			if (!num) break;\n			Len % 2 ? (len -= num) : (len += num);\n		}\n		printf("%d\\n", total - 1 + abc + len);\n	}\n\n	return 0;\n}\n', '', 15, 262144, 1, 1, '2010-08-20 01:00:13', '0001-01-01 00:00:00'),
(336, 1, 319, 0, '#include<stdio.h>\n#include<memory.h>\nint a[45];\nint total(int n)\n{\n	if(n==1||n==2)return n;\n	else \n	{\n		if(a[n]==0)\n			a[n]=total(n-1)+total(n-2);\n		return a[n];\n	}\n}\nmain()\n{\n	int n;\n	int m;\n	memset(a,0,(sizeof(a[0]))*45);\n	scanf("%d",&n);\n	while(n)\n	{\n		m=total(n);\n		printf("%d",m);\n		printf("\\n");\n		scanf("%d",&n);\n	}\n	return 0;\n}', '', 0, 258048, 1, 1, '2010-08-20 01:00:17', '0001-01-01 00:00:00'),
(337, 1, 320, 0, '#include<stdio.h>\n#include<string.h>\nvoid main()\n{\n	char tran1[]=" E C F A J K L B D G H I V W Z Y M N O P Q R S T U X",tran2[]=" e r w q t y g h b n u i o p s j k d l f a z x c v m",s1[1000],s2[1000],s[]="#";\n	int i;\n	gets(s1);\n	\n	while(strcmp(s1,s)!=0)\n	{\n\n		for(i=0;s1[i]!=''\\0'';i++)\n		{\n			if(s1[i]>=''a''&&s1[i]<=''z'')\n			{\n				s2[i]=tran2[(s1[i]-''a''+1)*2-1];\n			}\n			else if(s1[i]>=''A''&&s1[i]<=''Z'')\n			{\n				s2[i]=tran1[(s1[i]-''A''+1)*2-1];\n			}\n			else\n				s2[i]=s1[i];\n\n		}\n		s2[i]=''\\0'';\n		puts(s2);\n		gets(s1);\n		\n	}\n}\n\n\n', '', 0, 262144, 1, 1, '2010-08-20 01:00:21', '0001-01-01 00:00:00'),
(338, 1, 321, 0, '#include <stdio.h>\n#include <string.h>\n\nint main(void)\n{\n	int i, j, len;\n	char code[1024] = " ", tmp;\n\n	while (gets(code + 1))\n	{\n		len = strlen(code) - 1;\n		for (i = len / 2; i; i--)\n		{\n			if (i % 2)\n			{\n				tmp = code[i];\n				for (j = i; j + i <= len; j += i)\n					code[j] = code[j + i];\n				code[j] = tmp;\n				\n			}\n			else\n			{\n				tmp = code[len/i*i];\n				for (j = len/i*i; j; j -= i)\n					code[j] = code[j - i];\n				code[i] = tmp;\n			}\n		}\n		puts(code + 1);\n	}\n\n	return 0;\n}', '', 31, 258048, 1, 1, '2010-08-20 01:00:25', '0001-01-01 00:00:00'),
(339, 1, 322, 0, '#include<stdio.h>\nint main()\n{\n    int n,x,s,a,i,j,t,p[1000];\n    while(scanf("%d",&n)&&n)\n    {\n        while(scanf("%d",&x)&&x)\n        {\n            s=x-1;\n            for(j=0;j<x;j++)\n                p[j]=j;\n            a=x+1;\n            t=1;\n            for(i=1;i<n;i++)\n            {\n            scanf("%d",&x);\n            if(t)\n            if(x>=a||x==p[s])\n            {\n                if(x==p[s])\n                s--;\n                else if(x>=a)\n                {\n                for(j=a;j<x;j++)\n                p[j-a+s+1]=j;\n                s+=x-a;\n                a=x+1;\n                }\n            }\n            else t=0;\n            }\n    if(t) printf("Yes\\n");\n    else printf("No\\n");\n        }\n        printf("\\n");\n    }\n    return 0;\n}  ', '', 31, 262144, 1, 1, '2010-08-20 01:00:29', '0001-01-01 00:00:00'),
(340, 1, 323, 0, 'var\r\n  a,l,r:array[1..50000]of longint;\r\n  ii,nn:longint;\r\n  i,n,now,last:longint;\r\nbegin\r\n  readln(nn);\r\n  for ii:=1 to nn do\r\n    begin\r\n      readln(n);\r\n      for i:=1 to n do read(a[i]);\r\n      readln;\r\n      last:=a[1];now:=0;\r\n      for i:=1 to n do\r\n        begin\r\n          inc(now,a[i]);\r\n          if now>last then last:=now;\r\n          if a[i]>last then last:=a[i];\r\n          l[i]:=last;\r\n          if now<0 then now:=0;\r\n        end;\r\n      last:=a[n];now:=0;\r\n      for i:=n downto 1 do\r\n        begin\r\n          inc(now,a[i]);\r\n          if now>last then last:=now;\r\n          if a[i]>last then last:=a[i];\r\n          r[i]:=last;\r\n          if now<0 then now:=0;\r\n        end;\r\n      last:=a[1]+a[n];\r\n      for i:=1 to n-1 do\r\n        begin\r\n          now:=l[i]+r[i+1];\r\n          if now>last then last:=now;\r\n        end;\r\n      writeln(last);\r\n    end;\r\nend.', '', 124, 1400832, 1, 3, '2010-08-20 08:35:13', '0001-01-01 00:00:00'),
(341, 1, 324, 0, 'var\r\n  x,y,c,l,r,m,a,b:real;\r\nbegin\r\n  repeat\r\n    readln(x,y,c);\r\n    if x<y\r\n      then r:=x\r\n      else r:=y;\r\n    l:=0;\r\n    while r-l>=1e-6 do\r\n      begin\r\n        m:=(l+r)/2;\r\n        a:=sqrt(x*x-m*m);\r\n        b:=sqrt(y*y-m*m);\r\n        if a*b/(a+b)>c\r\n          then l:=m\r\n          else r:=m;\r\n      end;\r\n    writeln(r:1:3);\r\n  until seekeof;\r\nend.', '', 0, 798720, 1, 3, '2010-08-20 08:42:15', '0001-01-01 00:00:00'),
(342, 1, 325, 0, 'var\r\n  i,n:longint;\r\n  x,y,l,r:longint;\r\nbegin\r\n  readln(n);\r\n  for i:=1 to n do\r\n    begin\r\n      writeln(''Scenario #'',i,'':'');\r\n      readln(x,y);\r\n      l:=0;r:=0;\r\n      repeat\r\n        if (x>y)and(x mod y<>0) then\r\n          begin inc(l,x div y);x:=x mod y; end;\r\n        if (x>y)and(x mod y=0) then\r\n          begin inc(l,x div y-1);x:=y; end;\r\n        if (y>x)and(y mod x<>0) then\r\n          begin inc(r,y div x);y:=y mod x; end;\r\n        if (y>x)and(y mod x=0) then\r\n          begin inc(r,y div x-1);y:=x; end;\r\n      until x=y;\r\n      writeln(l,'' '',r);\r\n      writeln;\r\n    end;\r\nend.', '', 0, 798720, 1, 3, '2010-08-20 08:44:57', '0001-01-01 00:00:00'),
(343, 1, 326, 0, 'var\r\n  a:array[0..9,1..100]of double;\r\n  i,j,k,n:longint;\r\n  t:double;\r\nbegin\r\n  while not seekeof do\r\n    begin\r\n      readln(k,n);\r\n      if k=0 then\r\n        begin\r\n          writeln(''100.00000'');\r\n          continue;\r\n        end;\r\n      for i:=0 to k do a[i,1]:=1;\r\n      for j:=2 to n do\r\n        begin\r\n          a[0,j]:=a[0,j-1]+a[1,j-1];\r\n          for i:=1 to k-1 do\r\n            a[i,j]:=a[i-1,j-1]+a[i,j-1]+a[i+1,j-1];\r\n          a[k,j]:=a[k-1,j-1]+a[k,j-1];\r\n        end;\r\n      t:=0;\r\n      for i:=0 to k do t:=t+a[i,n];\r\n      for i:=1 to n do t:=t/(k+1);\r\n      writeln(100*t:1:5);\r\n    end;\r\nend.', '', 0, 802816, 4, 3, '2010-08-20 08:53:26', '0001-01-01 00:00:00'),
(344, 1, 326, 0, '#include<iostream>\r\n#include<cmath>\r\n#include<cstdio>\r\nusing namespace std;\r\nint k, n;\r\ndouble dp[101][10], ans[101][10];\r\nint main()\r\n{\r\n    for(int i = 0; i <= 9; i++)\r\n    {\r\n        for(int j = 0; j <= i; j++)\r\n            dp[1][j] = ans[1][j] = 1;\r\n        for(int j = 2; j <= 100; j++)\r\n        {\r\n            double sum = 0;\r\n            for(int k = 0; k <= i; k++)\r\n            {\r\n                dp[j][k] = dp[j - 1][k];\r\n                if (k - 1 >= 0) dp[j][k] += dp[j - 1][k - 1];\r\n                if (k + 1 <= i) dp[j][k] += dp[j - 1][k + 1];\r\n                sum += dp[j][k];\r\n            }\r\n            ans[j][i] = sum / pow((i + 1) * 1.0, j * 1.0);\r\n        }\r\n    }\r\n    while(scanf("%d%d", &k, &n) != EOF)\r\n        printf("%.5f\\n", ans[n][k] * 100);\r\n    return 0;\r\n}', '', 0, 385024, 1, 2, '2010-08-20 08:54:58', '0001-01-01 00:00:00'),
(345, 1, 327, 0, '#include<iostream>\r\n#include <algorithm>\r\nusing namespace std;\r\nint len=2,l,l1,l2,l3,ll[3];\r\nlong long *a;\r\nint main()\r\n{\r\n    int n,k,i;\r\n         long long min;\r\n    while(cin>>ll[0]>>ll[1]>>ll[2]>>k)\r\n        {\r\n            a=new long long[k+1];\r\n            sort(ll,ll+3);\r\n            a[0]=1;\r\n            len=1;\r\n            l1=l2=l3=0;\r\n            while(len<=k)\r\n                {\r\n                    min=a[l1]*ll[0];\r\n                    l=1;\r\n                    if(a[l2]*ll[1]<min) min=a[l2]*ll[1],l=2;\r\n                    if(a[l3]*ll[2]<min) min=a[l3]*ll[2],l=3;\r\n                    if(a[len-1]!=min)\r\n                        a[len++]=min;\r\n                    if(l==1) l1++;\r\n                    if(l==2) l2++;\r\n                    if(l==3) l3++;\r\n                }\r\n            cout<<a[k]<<endl;\r\n            delete []a;\r\n        }\r\n}', '', 0, 364544, 1, 2, '2010-08-20 08:57:45', '0001-01-01 00:00:00'),
(346, 1, 328, 0, '#include<stdio.h>\r\nint main()\r\n{\r\n    int n, i, sum;\r\n    while(scanf("%d", &n) != -1)\r\n    {\r\n        for(i=1,sum=1; sum%n; i++)\r\n        {\r\n            sum = (sum % n * 10) + 1;\r\n        }\r\n        printf("%d\\n", i);\r\n    }\r\n    return 0;\r\n}', '', 0, 262144, 1, 1, '2010-08-20 09:02:07', '0001-01-01 00:00:00'),
(347, 1, 329, 0, 'type\r\n  gj=array[0..4448]of int64;\r\nfunction mul(a,b:gj):gj;\r\n  var\r\n    i,j,l:longint;\r\n    f:gj;\r\n  begin\r\n    fillchar(f,sizeof(f),0);\r\n    l:=a[0];\r\n    for i:=1 to l do\r\n      for j:=1 to l do\r\n        f[i+j-1]:=f[i+j-1]+a[i]*b[j];\r\n    l:=2*l;\r\n    for i:=1 to l do\r\n      if f[i]>=1000000 then\r\n        begin\r\n          f[i+1]:=f[i+1]+f[i]div 1000000;\r\n          f[i]:=f[i]mod 1000000;\r\n        end;\r\n    while f[l]=0 do dec(l);\r\n    f[0]:=l;\r\n    mul:=f;\r\n  end;\r\nprocedure out(a:gj);\r\n  var\r\n    i,n:longint;\r\n  begin\r\n    n:=a[0];\r\n    write(a[n]);\r\n    for i:=n-1 downto 1 do\r\n      if a[i]>99999 then write(a[i])\r\n      else if a[i]>9999 then write(''0'',a[i])\r\n      else if a[i]>999 then write(''00'',a[i])\r\n      else if a[i]>99 then write(''000'',a[i])\r\n      else if a[i]>9 then write(''0000'',a[i])\r\n      else write(''00000'',a[i]);\r\n    writeln;\r\n  end;\r\nvar\r\n  i,n:longint;\r\n  a,b:gj;\r\nbegin        \r\n  readln(n);\r\n  a[0]:=1;a[1]:=1;\r\n  b[0]:=1;b[1]:=1;\r\n  for i:=1 to n do\r\n    begin\r\n      a:=mul(a,b);\r\n      b:=a;\r\n      b[1]:=b[1]+1;\r\n      out(b);       \r\n    end;      \r\nend.', '', 187, 1003520, 1, 3, '2010-08-20 09:05:33', '0001-01-01 00:00:00'),
(348, 1, 330, 0, '#include <utility>\r\n#include <queue>\r\n#include <cstring>\r\n#include <cstdio>\r\n#include <cstdlib>\r\nusing namespace std;\r\n\r\ntypedef pair<int,unsigned> piu;\r\n\r\nstruct road {\r\n  int s;\r\n  int d;\r\n  int l;\r\n};\r\n\r\nroad roads[202000];\r\nint first[202000];\r\nunsigned best[202000];\r\n\r\nint comp(const void* vr1, const void* vr2) {\r\n  const road* r1 = (const road*) vr1;\r\n  const road* r2 = (const road*) vr2;\r\n  int ret;\r\n  ret = r1->s - r2->s;\r\n  if(ret) return ret;\r\n  ret = r1->d - r2->d;\r\n  if(ret) return ret;\r\n  ret = r1->l - r2->l;\r\n  if(ret) return ret;\r\n  return ret;\r\n}\r\n\r\nint dist(int s, int d) {\r\n  memset(best,-1,sizeof(best));\r\n  queue<piu> q;\r\n  q.push(piu(s,0));\r\n  while(q.size() > 0) {\r\n    piu cl = q.front();\r\n    q.pop();\r\n    int c = cl.first;\r\n    unsigned l = cl.second;\r\n    if(l >= best[c]) continue;\r\n    best[c] = l;\r\n    if(l >= best[d]) continue;\r\n    for(int i = first[c]; roads[i].s == c; i++) {\r\n      q.push(piu(roads[i].d, l+roads[i].l));\r\n    }\r\n  }\r\n  if(best[d] == -1) *((int*)5) = 0;\r\n  return best[d];\r\n}\r\nint store[20];\r\nint dists[20][20];\r\nint perm[20];\r\nint S;\r\nunsigned bestest;\r\nvoid print(const int *v, const int size)\r\n{\r\n  unsigned ret = 0;\r\n  int i;\r\n  if (v != 0) {\r\n    for (i = 0; i < size; i++) {\r\n      int j;\r\n      if(i == 0) j = S; else j = v[i-1]-1;\r\n      0&&printf("(%d,%d) ", j, v[i]-1);\r\n      ret += dists[j][v[i]-1];\r\n      0&&printf("d%d ", dists[j][v[i]-1]);\r\n      0&&printf("%d ", v[i]);\r\n    }\r\n      0&&printf("(%d,%d) ", v[i-1]-1, S);\r\n    ret += dists[v[i-1]-1][S];\r\n      0&&printf("d%d ", dists[v[i-1]-1][S]);\r\n    0&&printf("%d\\n", ret);\r\n    if(ret < bestest) bestest = ret;\r\n  }\r\n} // print\r\n\r\n\r\nvoid visit(int *Value, int N, int k)\r\n{\r\n    int i;\r\n  static int level = -1;\r\n  level = level+1; Value[k] = level;\r\n\r\n  if (level == N)\r\n    print(Value, N);\r\n  else\r\n    for (i = 0; i < N; i++)\r\n      if (Value[i] == 0)\r\n        visit(Value, N, i);\r\n\r\n  level = level-1; Value[k] = 0;\r\n}\r\n\r\nmain() {\r\n  int NN;\r\n  scanf("%d", &NN);\r\n  while(NN--) {\r\n    int N, M;\r\n    memset(roads, 0, sizeof(roads));\r\n    memset(first, 0, sizeof(first));\r\n    scanf("%d %d", &N, &M);\r\n    for(int i = 0; i < M; i++) {\r\n      scanf("%d %d %d", &roads[2*i].s, &roads[2*i].d, &roads[2*i].l);\r\n      roads[2*i+1].s = roads[2*i].d;\r\n      roads[2*i+1].d = roads[2*i].s;\r\n      roads[2*i+1].l = roads[2*i].l;\r\n    }\r\n    qsort(roads, M*2, sizeof(road), comp);\r\n    roads[M*2].s = -1;\r\n    for(int i = 0; i < N; i++) {\r\n      first[i] = M*2;\r\n    }\r\n    for(int i = 0; i < M*2; i++) {\r\n      if(first[roads[i].s] == M*2) {\r\n        first[roads[i].s] = i;\r\n      }\r\n    }\r\n    scanf("%d", &S);\r\n    for(int i = 0; i < S; i++) {\r\n      scanf("%d", store+i);\r\n    }\r\n    store[S] = 0;\r\n    for(int ii = 0; ii < S+1; ii++) {\r\n      for(int jj = 0; jj < S+1; jj++) {\r\n        int i = store[ii];\r\n        int j = store[jj];\r\n        dists[ii][jj] = dist(i,j);\r\n      }\r\n    }\r\n    bestest = -1;\r\n    for(int i = 0; i < S; i++) perm[i] = 0;\r\n    visit(perm, S, 0);\r\n    printf("%d\\n", bestest);\r\n  }\r\n}\r\n', '', 5771, 6316032, 1, 2, '2010-08-28 01:25:19', '0001-01-01 00:00:00'),
(349, 1, 331, 0, '#include <utility>\r\n#include <queue>\r\n#include <set>\r\n#include <bitset>\r\n#include <map>\r\n#include <cstdio>\r\n#include <cstring>\r\n\r\nusing namespace std;\r\n\r\ntypedef pair<int,int> pi;\r\n\r\nstruct road {\r\n    int s;\r\n    int d;\r\n    int p;\r\n};\r\n\r\nbool operator<(const road r1, const road r2) {\r\n  if(r1.s < r2.s) return true;\r\n  if(r1.s > r2.s) return false;\r\n  if(r1.d < r2.d) return true;\r\n  if(r1.d > r2.d) return false;\r\n  if(r1.p < r2.p) return true;\r\n  if(r1.p > r2.p) return false;\r\n  return false;\r\n}\r\n\r\nqueue<pi> q;\r\nbitset<220> inq[220];\r\n\r\nint bridge[220][220];\r\nint qs;\r\nint deqs;\r\nvoid addbridge(int s, int d, unsigned l) {\r\n  if(l%2) *((int*)5)=0;\r\n  unsigned cur = bridge[s][d];\r\n  if(cur <= l) return;\r\n  bridge[s][d] = l;\r\n  q.push(pi(s,d));\r\n  inq[s].set(d);\r\n  qs++;\r\n}\r\n\r\nset<road> from[220];\r\nset<road> to[220];\r\nmap<int,set<road> > top[220];\r\n\r\nmain() {\r\n  int NN;\r\n  scanf("%d", &NN);\r\n  while(NN--) {\r\n    int N, M, Q;\r\n    scanf("%d %d %d", &N, &M, &Q);\r\n    for(int i = 0; i < N; i++) {\r\n      from[i] = set<road>();\r\n      to[i] = set<road>();\r\n      top[i] = map<int,set<road> >();\r\n    }\r\n    memset(bridge, -1, sizeof(bridge));\r\n    for(int i = 0; i < M; i++) {\r\n      int x,y,z;\r\n      scanf("%d %d %d", &x, &y, &z);\r\n      0&&printf("R: %d %d %d\\n", x, y, z);\r\n      road r;\r\n      x--;\r\n      y--;\r\n      r.s = x;\r\n      r.d = y;\r\n      r.p = z;\r\n      from[x].insert(r);\r\n      to[y].insert(r);\r\n      top[y][z].insert(r);\r\n    }\r\n    q = queue<pi>();\r\n    for(int i = 0; i < N; i++) {\r\n      set<road> fromi = from[i];\r\n      for(set<road>::iterator it = fromi.begin(); it != fromi.end(); it++) {\r\n        int p = it->p;\r\n        if(p<0) continue;\r\n        int s = it->d;\r\n        set<road> froms = from[s];\r\n        for(set<road>::iterator it2 = froms.begin(); it2 != froms.end(); it2++) {\r\n          if(it2->p == -p) addbridge(i, it2->d, 2);\r\n        }\r\n      }\r\n    }\r\n    while(q.size() > 0) {\r\n      pi sd = q.front();\r\n      int s = sd.first;\r\n      int d = sd.second;\r\n      q.pop();\r\n      if(!inq[s].test(d)) continue;\r\n      inq[s].reset(d);\r\n      deqs++;\r\n      set<road> fromd = from[d];\r\n      for(set<road>::iterator it = fromd.begin(); it != fromd.end(); it++) {\r\n        int p = it->p;\r\n        if(p>0) continue;\r\n        int dd = it->d;\r\n        set<road> topsp = top[s][-p];\r\n        for(set<road>::iterator it2 = topsp.begin(); it2 != topsp.end(); it2++) {\r\n          int ss = it2->s;\r\n          addbridge(ss, dd, bridge[s][d]+2);\r\n        }\r\n      }\r\n      for(int dd = 0; dd < N; dd++) {\r\n        if(bridge[d][dd] != -1) {\r\n          addbridge(s, dd, bridge[s][d]+bridge[d][dd]);\r\n        }\r\n        if(bridge[dd][s] != -1) {\r\n          addbridge(dd, d, bridge[s][d]+bridge[dd][s]);\r\n        }\r\n      }\r\n    }\r\n    for(int i = 0; i < Q; i++) {\r\n      int x,y;\r\n      scanf("%d %d\\n", &x, &y);\r\n      0&&printf("Q: %d %d\\n", x, y);\r\n      x--;\r\n      y--;\r\n      if(bridge[x][y] == -1) puts("impossible");\r\n      else printf("%d\\n", bridge[x][y]);\r\n    }\r\n    0&&printf("qs: %d deqs: %d\\n", qs, deqs);\r\n  }\r\n}\r\n', '', 62, 806912, 1, 2, '2010-08-28 01:25:19', '0001-01-01 00:00:00'),
(350, 1, 332, 0, '#include <cstring>\r\n#include <cstdio>\r\n#include <bitset>\r\n#include <set>\r\n#include <vector>\r\nusing namespace std;\r\n\r\nbitset<1010> pres[1010];\r\nbitset<1010> use[1010];\r\n\r\nbitset<1010> bef[1010];\r\nbitset<1010> aft[1010];\r\n\r\nset<int> preds[1010];\r\n\r\nchar buf[100000];\r\nbitset<1010> seen;\r\nvector<int> po;\r\nint endofedge[1010];\r\n\r\nint N, M, I;\r\n\r\nvoid printset(char* msg, bitset<1010> s) {\r\n  bool first = true;\r\n  printf(msg);\r\n  for(int i = 0; i < I; i++) {\r\n    if(s.test(i)) {\r\n      if(!first) printf(" ");\r\n      printf("%d", i);\r\n      first = false;\r\n    }\r\n  }\r\n  puts("");\r\n}\r\nbitset<1010> readset() {\r\n  bitset<1010> ret = bitset<1010>();\r\n  gets(buf);\r\n  char* tok = strtok(buf, " ");\r\n  while(tok) {\r\n    int i;\r\n    if(1 == sscanf(tok, "%d", &i)) {\r\n      ret.set(i);\r\n    }\r\n    tok = strtok(0, " ");\r\n  }\r\n  return ret;\r\n}\r\n\r\n\r\nvoid dfs(int i) {\r\n  if(seen[i]) return;\r\n  seen.set(i);\r\n  for(set<int>::iterator it = preds[i].begin(); it != preds[i].end(); it++) {\r\n    dfs(*it);\r\n  }\r\n  po.push_back(i);\r\n}\r\n\r\nmain() {\r\n  int NN;\r\n    gets(buf);\r\n  sscanf(buf, "%d ", &NN);\r\n  while(NN--) {\r\n    gets(buf);\r\n    sscanf(buf, "%d %d %d ", &N, &M, &I);\r\n    for(int i = 0; i < N; i++) {\r\n      use[i] = readset();\r\n      pres[i] = ~readset();\r\n      bef[i] = bitset<1010>();\r\n      aft[i] = bitset<1010>();\r\n      preds[i] = set<int>();\r\n    }\r\n    for(int i = 0; i < M; i++) {\r\n      int x,y;\r\n      scanf("%d %d ", &x, &y);\r\n      preds[y].insert(x);\r\n      endofedge[i] = y;\r\n    }\r\n    seen = bitset<1010>();\r\n    po = vector<int>();\r\n    for(int i = 0; i < N; i++) {\r\n      dfs(i);\r\n    }\r\n    bool change = true;\r\n    while(change) {\r\n      change = false;\r\n      for(vector<int>::reverse_iterator it = po.rbegin(); it != po.rend(); it++) {\r\n        bitset<1010> old = bef[*it];\r\n        bef[*it] = (aft[*it] & pres[*it]) | use[*it];\r\n        if(bef[*it] != old) change = true;\r\n        for(set<int>::iterator it2 = preds[*it].begin(); it2 != preds[*it].end(); it2++) {\r\n          old = aft[*it2];\r\n          aft[*it2] |= bef[*it];\r\n          if(aft[*it2] != old) change = true;\r\n        }\r\n      }\r\n    }\r\n    for(int i = 0; i < M; i++) {\r\n      printset("", bef[endofedge[i]]);\r\n    }\r\n    /*\r\n    for(int i = 0; i < N; i++) {\r\n      printf("%d:\\n", i);\r\n      printset("use " , use[i]);\r\n      printset("pres ", pres[i]);\r\n      printset("bef ", bef[i]);\r\n      printset("aft ", aft[i]);\r\n    }\r\n    */\r\n  }\r\n}\r\n\r\n', '', 733, 1089536, 1, 2, '2010-08-28 01:25:20', '0001-01-01 00:00:00'),
(351, 1, 333, 0, '#include <cstdio>\r\n#include <string>\r\n#include <map>\r\n\r\n#define ll long long\r\n\r\nusing namespace std;\r\n\r\nll tax(ll cents, ll rate) {\r\n  return (cents * rate + 5000) / 10000;\r\n}\r\nmain() {\r\n    int NN;\r\n    scanf("%d", &NN);\r\n    while(NN--) {\r\n      map<string, ll> pst;\r\n      map<string, ll> gst;\r\n      map<string, ll> hst;\r\n      int N, M;\r\n      scanf("%d %d ", &N, &M);\r\n      while(N--) {\r\n        char name[100];\r\n        double pp, gg, hh;\r\n        scanf("%s %lf%% %lf%% %lf%%\\n", &name, &pp, &gg, &hh);\r\n        ll p = pp*100+.5;\r\n        ll g = gg*100+.5;\r\n        ll h = hh*100+.5;\r\n        pst[string(name)] = p;\r\n        gst[string(name)] = g;\r\n        hst[string(name)] = h;\r\n      }\r\n      ll cents = 0;\r\n      while(M--) {\r\n        char name[100];\r\n        double pp;\r\n        scanf("%s $%lf\\n", &name, &pp);\r\n        ll p = pp*100+.5;\r\n        string nm = string(name);\r\n        cents += tax(p, hst[nm]) - tax(p, gst[nm]) - tax(p, pst[nm]);\r\n      }\r\n      printf("%.02lf\\n", cents*.01);\r\n    }\r\n}\r\n', '', 1622, 22192128, 1, 2, '2010-08-28 01:25:21', '0001-01-01 00:00:00'),
(352, 1, 334, 0, '#include <math.h>\r\n#include <stdio.h>\r\n\r\ndouble r = 6371009;\r\ndouble sqr(double x) { return x*x; }\r\ndouble torad(double deg) { return deg/180*M_PI; }\r\nmain() {\r\n    int N;\r\n    scanf("%d ", &N);\r\n    while(N--) {\r\n        double alat, alng, blat, blng;\r\n        scanf("%lf %lf %lf %lf ", &alat, &alng, &blat, &blng);\r\n        //printf("%lf %lf %lf %lf\\n", alat, alng, blat, blng);\r\n        alat = torad(alat);\r\n        alng = torad(alng);\r\n        blat = torad(blat);\r\n        blng = torad(blng);\r\n        double ax = cos(alat) * cos(alng);\r\n        double ay = cos(alat) * sin(alng);\r\n        double az = sin(alat);\r\n        double bx = cos(blat) * cos(blng);\r\n        double by = cos(blat) * sin(blng);\r\n        double bz = sin(blat);\r\n        double dist = r*sqrt(sqr(ax-bx)+ sqr(ay-by)+sqr(az-bz));\r\n        double arc = r * acos(ax*bx + ay*by + az*bz);\r\n        //printf("%lf %lf\\n", dist, arc);\r\n        double TOL=0.00001;\r\n        int a1 = arc-dist+TOL+.5;\r\n        int a2 = arc-dist-TOL+.5;\r\n        if(a1 != a2) *((int*)5) = 0;\r\n        printf("%.0lf\\n", arc-dist);\r\n    }\r\n}\r\n', '', 0, 262144, 1, 2, '2010-08-28 01:25:22', '0001-01-01 00:00:00'),
(353, 3, 1, 0, '#include <iostream>\r\nusing namespace std;\r\nint  main()\r\n{\r\n    int a,b;\r\n    cin >> a >> b;\r\n    cout << a+b << endl;\r\n    return 0;\r\n}', '', 0, 368640, 3, 2, '2010-09-02 23:37:24', '0001-01-01 00:00:00'),
(354, 3, 1, 0, '#include <iostream>\r\nusing namespace std;\r\nint  main()\r\n{\r\n    int a,b;\r\n    cin >> a >> b;\r\n    cout << a+b ;\r\n    return 0;\r\n}', '', 0, 368640, 1, 2, '2010-09-02 23:38:04', '0001-01-01 00:00:00'),
(355, 6, 253, 0, '#include <stdio.h>\r\n#include <math.h>\r\n#include <algorithm>\r\nusing std::sort;\r\n#define N 505\r\n#define M 25500\r\nstruct Edge\r\n{\r\n   int u,v;\r\n   double d;\r\n}et[M];\r\n\r\nstruct Node\r\n{\r\n   int x,y;\r\n}que[N];\r\nint n,m;\r\nint p[N],rank[N];\r\n\r\nvoid init()\r\n{\r\n     for(int i=1;i<=n;++i)\r\n     {\r\n         p[i]=i;\r\n         rank[i]=1;\r\n     }\r\n}\r\n\r\nint find(int x)\r\n{\r\n     int r=x,k;\r\n     while(r!=p[r])\r\n         r=p[r];\r\n     while(x!=p[x])\r\n     {\r\n         k=p[x];\r\n         p[x]=r;\r\n         x=k;\r\n     }\r\n     return r;\r\n}\r\n\r\nchar merge(int x,int y)\r\n{\r\n     x=find(x),y=find(y);\r\n     if(x==y) return 0;\r\n     \r\n     if(rank[x]>rank[y])\r\n        p[y]=x;\r\n     else\r\n     {\r\n        p[x]=y;\r\n        if(rank[x]==rank[y])\r\n           p[y]++;\r\n     }\r\n     return 1;\r\n}\r\n\r\ndouble dis(Node a,Node b)\r\n{\r\n     return sqrt(  1.0*(a.x-b.x)*(a.x-b.x) + 1.0*(a.y-b.y)*(a.y-b.y)  );\r\n}\r\n\r\nbool cmp(const Edge& a,const Edge& b)\r\n{\r\n    return a.d<b.d;\r\n}\r\n\r\nvoid solve()\r\n{\r\n     double ans;\r\n     int i,j,k;\r\n     scanf("%d %d",&m,&n);\r\n     init();\r\n     for(i=1;i<=n;++i)\r\n         scanf("%d %d",&que[i].x,&que[i].y);\r\n     \r\n     k=0;\r\n     for(i=1;i<=n;++i)\r\n     {\r\n         for(j=i+1;j<=n;++j)\r\n         {\r\n             et[k].u=i,et[k].v=j;\r\n             et[k++].d=dis(que[i],que[j]);\r\n         }\r\n     }\r\n     \r\n     sort(et,et+k,cmp);\r\n     for(i=1;i<=k;++i)\r\n     {\r\n         if(merge(et[i].u,et[i].v))\r\n         {\r\n            n--;\r\n            ans=et[i].d;\r\n            if(m==n-1) break;\r\n         }\r\n     }\r\n     printf("%.2lf\\n",ans);\r\n}\r\n\r\nint main()\r\n{\r\n    int T;\r\n    scanf("%d",&T);\r\n    while(T--)\r\n       solve();\r\n    return 0;\r\n}\r\n', '', 0, 671744, 7, 2, '2010-09-06 20:13:27', '0001-01-01 00:00:00'),
(356, 6, 253, 0, '#include <stdio.h>\r\n#include <math.h>\r\n#include <algorithm>\r\nusing std::sort;\r\n#define N 505\r\n#define M 50000\r\nstruct Edge\r\n{\r\n   int u,v;\r\n   double d;\r\n}et[M];\r\n\r\nstruct Node\r\n{\r\n   int x,y;\r\n}que[N];\r\nint n,m;\r\nint p[N],rank[N];\r\n\r\nvoid init()\r\n{\r\n     for(int i=1;i<=n;++i)\r\n     {\r\n         p[i]=i;\r\n         rank[i]=1;\r\n     }\r\n}\r\n\r\nint find(int x)\r\n{\r\n     int r=x,k;\r\n     while(r!=p[r])\r\n         r=p[r];\r\n     while(x!=p[x])\r\n     {\r\n         k=p[x];\r\n         p[x]=r;\r\n         x=k;\r\n     }\r\n     return r;\r\n}\r\n\r\nchar merge(int x,int y)\r\n{\r\n     x=find(x),y=find(y);\r\n     if(x==y) return 0;\r\n     \r\n     if(rank[x]>rank[y])\r\n        p[y]=x;\r\n     else\r\n     {\r\n        p[x]=y;\r\n        if(rank[x]==rank[y])\r\n           p[y]++;\r\n     }\r\n     return 1;\r\n}\r\n\r\ndouble dis(Node a,Node b)\r\n{\r\n     return sqrt(  1.0*(a.x-b.x)*(a.x-b.x) + 1.0*(a.y-b.y)*(a.y-b.y)  );\r\n}\r\n\r\nbool cmp(const Edge& a,const Edge& b)\r\n{\r\n    return a.d<b.d;\r\n}\r\n\r\nvoid solve()\r\n{\r\n     double ans;\r\n     int i,j,k;\r\n     scanf("%d %d",&m,&n);\r\n     init();\r\n     for(i=1;i<=n;++i)\r\n         scanf("%d %d",&que[i].x,&que[i].y);\r\n     \r\n     k=0;\r\n     for(i=1;i<=n;++i)\r\n     {\r\n         for(j=i+1;j<=n;++j)\r\n         {\r\n             et[k].u=i,et[k].v=j;\r\n             et[k++].d=dis(que[i],que[j]);\r\n         }\r\n     }\r\n     \r\n     sort(et,et+k,cmp);\r\n     for(i=1;i<=k;++i)\r\n     {\r\n         if(merge(et[i].u,et[i].v))\r\n         {\r\n            n--;\r\n            ans=et[i].d;\r\n            if(m==n-1) break;\r\n         }\r\n     }\r\n     printf("%.2lf\\n",ans);\r\n}\r\n\r\nint main()\r\n{\r\n    int T;\r\n    scanf("%d",&T);\r\n    while(T--)\r\n       solve();\r\n    return 0;\r\n}\r\n', 'Main.c:3:21: fatal error: algorithm: No such file or directory\r\ncompilation terminated.\r\n', 0, 0, 2, 1, '2010-09-06 20:15:24', '0001-01-01 00:00:00'),
(357, 6, 253, 0, '#include <stdio.h>\r\n#include <math.h>\r\n#include <algorithm>\r\nusing std::sort;\r\n#define N 505\r\n#define M 50000\r\nstruct Edge\r\n{\r\n   int u,v;\r\n   double d;\r\n}et[M];\r\n\r\nstruct Node\r\n{\r\n   int x,y;\r\n}que[N];\r\nint n,m;\r\nint p[N],rank[N];\r\n\r\nvoid init()\r\n{\r\n     for(int i=1;i<=n;++i)\r\n     {\r\n         p[i]=i;\r\n         rank[i]=1;\r\n     }\r\n}\r\n\r\nint find(int x)\r\n{\r\n     int r=x,k;\r\n     while(r!=p[r])\r\n         r=p[r];\r\n     while(x!=p[x])\r\n     {\r\n         k=p[x];\r\n         p[x]=r;\r\n         x=k;\r\n     }\r\n     return r;\r\n}\r\n\r\nchar merge(int x,int y)\r\n{\r\n     x=find(x),y=find(y);\r\n     if(x==y) return 0;\r\n     \r\n     if(rank[x]>rank[y])\r\n        p[y]=x;\r\n     else\r\n     {\r\n        p[x]=y;\r\n        if(rank[x]==rank[y])\r\n           p[y]++;\r\n     }\r\n     return 1;\r\n}\r\n\r\ndouble dis(Node a,Node b)\r\n{\r\n     return sqrt(  1.0*(a.x-b.x)*(a.x-b.x) + 1.0*(a.y-b.y)*(a.y-b.y)  );\r\n}\r\n\r\nbool cmp(const Edge& a,const Edge& b)\r\n{\r\n    return a.d<b.d;\r\n}\r\n\r\nvoid solve()\r\n{\r\n     double ans;\r\n     int i,j,k;\r\n     scanf("%d %d",&m,&n);\r\n     init();\r\n     for(i=1;i<=n;++i)\r\n         scanf("%d %d",&que[i].x,&que[i].y);\r\n     \r\n     k=0;\r\n     for(i=1;i<=n;++i)\r\n     {\r\n         for(j=i+1;j<=n;++j)\r\n         {\r\n             et[k].u=i,et[k].v=j;\r\n             et[k++].d=dis(que[i],que[j]);\r\n         }\r\n     }\r\n     \r\n     sort(et,et+k,cmp);\r\n     for(i=1;i<=k;++i)\r\n     {\r\n         if(merge(et[i].u,et[i].v))\r\n         {\r\n            n--;\r\n            ans=et[i].d;\r\n            if(m==n-1) break;\r\n         }\r\n     }\r\n     printf("%.2lf\\n",ans);\r\n}\r\n\r\nint main()\r\n{\r\n    int T;\r\n    scanf("%d",&T);\r\n    while(T--)\r\n       solve();\r\n    return 0;\r\n}\r\n', '', 0, 1064960, 7, 2, '2010-09-06 20:16:05', '0001-01-01 00:00:00'),
(358, 6, 253, 0, '#include <stdio.h>\r\n#include <math.h>\r\n#include <algorithm>\r\nusing std::sort;\r\n#define N 600\r\n#define M 50000\r\nstruct Edge\r\n{\r\n   int u,v;\r\n   double d;\r\n}et[M];\r\n\r\nstruct Node\r\n{\r\n   int x,y;\r\n}que[N];\r\nint n,m;\r\nint p[N],rank[N];\r\n\r\nvoid init()\r\n{\r\n     for(int i=1;i<=n;++i)\r\n     {\r\n         p[i]=i;\r\n         rank[i]=1;\r\n     }\r\n}\r\n\r\nint find(int x)\r\n{\r\n     int r=x,k;\r\n     while(r!=p[r])\r\n         r=p[r];\r\n     while(x!=p[x])\r\n     {\r\n         k=p[x];\r\n         p[x]=r;\r\n         x=k;\r\n     }\r\n     return r;\r\n}\r\n\r\nchar merge(int x,int y)\r\n{\r\n     x=find(x),y=find(y);\r\n     if(x==y) return 0;\r\n     \r\n     if(rank[x]>rank[y])\r\n        p[y]=x;\r\n     else\r\n     {\r\n        p[x]=y;\r\n        if(rank[x]==rank[y])\r\n           p[y]++;\r\n     }\r\n     return 1;\r\n}\r\n\r\ndouble dis(Node a,Node b)\r\n{\r\n     return sqrt(  1.0*(a.x-b.x)*(a.x-b.x) + 1.0*(a.y-b.y)*(a.y-b.y)  );\r\n}\r\n\r\nbool cmp(const Edge& a,const Edge& b)\r\n{\r\n    return a.d<b.d;\r\n}\r\n\r\nvoid solve()\r\n{\r\n     double ans;\r\n     int i,j,k;\r\n     scanf("%d %d",&m,&n);\r\n     init();\r\n     for(i=1;i<=n;++i)\r\n         scanf("%d %d",&que[i].x,&que[i].y);\r\n     \r\n     k=0;\r\n     for(i=1;i<=n;++i)\r\n     {\r\n         for(j=i+1;j<=n;++j)\r\n         {\r\n             et[k].u=i,et[k].v=j;\r\n             et[k++].d=dis(que[i],que[j]);\r\n         }\r\n     }\r\n     \r\n     sort(et,et+k,cmp);\r\n     for(i=1;i<=k;++i)\r\n     {\r\n         if(merge(et[i].u,et[i].v))\r\n         {\r\n            n--;\r\n            ans=et[i].d;\r\n            if(m==n-1) break;\r\n         }\r\n     }\r\n     printf("%.2lf\\n",ans);\r\n}\r\n\r\nint main()\r\n{\r\n    int T;\r\n    scanf("%d",&T);\r\n    while(T--)\r\n       solve();\r\n    return 0;\r\n}\r\n', '', 1000, 1069056, 5, 2, '2010-09-06 20:17:21', '0001-01-01 00:00:00'),
(359, 6, 253, 0, '#include <stdio.h>\r\n#include <math.h>\r\n#include <algorithm>\r\nusing std::sort;\r\n#define N 600\r\n#define M 50000\r\nstruct Edge\r\n{\r\n   int u,v;\r\n   double d;\r\n}et[M];\r\n\r\nstruct Node\r\n{\r\n   int x,y;\r\n}que[N];\r\nint n,m;\r\nint p[N],rank[N];\r\n\r\nvoid init()\r\n{\r\n     for(int i=1;i<=n;++i)\r\n     {\r\n         p[i]=i;\r\n         rank[i]=1;\r\n     }\r\n}\r\n\r\nint find(int x)\r\n{\r\n     int r=x,k;\r\n     while(r!=p[r])\r\n         r=p[r];\r\n     while(x!=p[x])\r\n     {\r\n         k=p[x];\r\n         p[x]=r;\r\n         x=k;\r\n     }\r\n     return r;\r\n}\r\n\r\nchar merge(int x,int y)\r\n{\r\n     x=find(x),y=find(y);\r\n     if(x==y) return 0;\r\n     \r\n     if(rank[x]>rank[y])\r\n        p[y]=x;\r\n     else\r\n     {\r\n        p[x]=y;\r\n        if(rank[x]==rank[y])\r\n           p[y]++;\r\n     }\r\n     return 1;\r\n}\r\n\r\ndouble dis(Node a,Node b)\r\n{\r\n     return 1.0*(a.x-b.x)*(a.x-b.x) + 1.0*(a.y-b.y)*(a.y-b.y)  ;\r\n}\r\n\r\nbool cmp(const Edge& a,const Edge& b)\r\n{\r\n    return a.d<b.d;\r\n}\r\n\r\nvoid solve()\r\n{\r\n     double ans;\r\n     int i,j,k;\r\n     scanf("%d %d",&m,&n);\r\n     init();\r\n     for(i=1;i<=n;++i)\r\n         scanf("%d %d",&que[i].x,&que[i].y);\r\n     \r\n     k=0;\r\n     for(i=1;i<=n;++i)\r\n     {\r\n         for(j=i+1;j<=n;++j)\r\n         {\r\n             et[k].u=i,et[k].v=j;\r\n             et[k++].d=dis(que[i],que[j]);\r\n         }\r\n     }\r\n     \r\n     sort(et,et+k,cmp);\r\n     for(i=1;i<=k;++i)\r\n     {\r\n         if(merge(et[i].u,et[i].v))\r\n         {\r\n            n--;\r\n            ans=et[i].d;\r\n            if(m==n-1) break;\r\n         }\r\n     }\r\n     printf("%.2lf\\n",sqrt(ans));\r\n}\r\n\r\nint main()\r\n{\r\n    int T;\r\n    scanf("%d",&T);\r\n    while(T--)\r\n       solve();\r\n    return 0;\r\n}\r\n', '', 1000, 1069056, 5, 2, '2010-09-06 20:21:02', '0001-01-01 00:00:00'),
(360, 6, 253, 0, '#include <stdio.h>\r\n#include <math.h>\r\n#include <algorithm>\r\nusing std::sort;\r\n#define N 505\r\n#define M 25500\r\nstruct Edge\r\n{\r\n   int u,v;\r\n   double d;\r\n}et[M];\r\n\r\nstruct Node\r\n{\r\n   int x,y;\r\n}que[N];\r\nint n,m;\r\nint p[N],rank[N];\r\n\r\nvoid init()\r\n{\r\n     for(int i=1;i<=n;++i)\r\n     {\r\n         p[i]=i;\r\n         rank[i]=1;\r\n     }\r\n}\r\n\r\nint find(int x)\r\n{\r\n     int r=x,k;\r\n     while(r!=p[r])\r\n         r=p[r];\r\n     while(x!=p[x])\r\n     {\r\n         k=p[x];\r\n         p[x]=r;\r\n         x=k;\r\n     }\r\n     return r;\r\n}\r\n\r\nchar merge(int x,int y)\r\n{\r\n     x=find(x),y=find(y);\r\n     if(x==y) return 0;\r\n     \r\n     if(rank[x]>rank[y])\r\n        p[y]=x;\r\n     else\r\n     {\r\n        p[x]=y;\r\n        if(rank[x]==rank[y])\r\n           rank[y]++;\r\n     }\r\n     return 1;\r\n}\r\n\r\ndouble dis(Node a,Node b)\r\n{\r\n     return 1.0*(a.x-b.x)*(a.x-b.x) + 1.0*(a.y-b.y)*(a.y-b.y)  ;\r\n}\r\n\r\nbool cmp(const Edge& a,const Edge& b)\r\n{\r\n    return a.d<b.d;\r\n}\r\n\r\nvoid solve()\r\n{\r\n     double ans;\r\n     int i,j,k;\r\n     scanf("%d %d",&m,&n);\r\n     init();\r\n     for(i=1;i<=n;++i)\r\n         scanf("%d %d",&que[i].x,&que[i].y);\r\n     \r\n     k=0;\r\n     for(i=1;i<=n;++i)\r\n     {\r\n         for(j=i+1;j<=n;++j)\r\n         {\r\n             et[k].u=i,et[k].v=j;\r\n             et[k++].d=dis(que[i],que[j]);\r\n         }\r\n     }\r\n     \r\n     sort(et,et+k,cmp);\r\n     for(i=1;i<=k;++i)\r\n     {\r\n         if(merge(et[i].u,et[i].v))\r\n         {\r\n            n--;\r\n            ans=et[i].d;\r\n            if(m==n-1) break;\r\n         }\r\n     }\r\n     printf("%.2lf\\n",sqrt(ans));\r\n}\r\n\r\nint main()\r\n{\r\n    int T;\r\n    scanf("%d",&T);\r\n    while(T--)\r\n       solve();\r\n    return 0;\r\n}\r\n', '', 0, 671744, 7, 2, '2010-09-06 20:34:29', '0001-01-01 00:00:00'),
(361, 6, 253, 0, '#include <stdio.h>\r\n#include <math.h>\r\n#include <algorithm>\r\nusing std::sort;\r\n#define N 600\r\n#define M 50000\r\nstruct Edge\r\n{\r\n   int u,v;\r\n   double d;\r\n}et[M];\r\n\r\nstruct Node\r\n{\r\n   int x,y;\r\n}que[N];\r\nint n,m;\r\nint p[N],rank[N];\r\n\r\nvoid init()\r\n{\r\n     for(int i=1;i<=n;++i)\r\n     {\r\n         p[i]=i;\r\n         rank[i]=1;\r\n     }\r\n}\r\n\r\nint find(int x)\r\n{\r\n     int r=x,k;\r\n     while(r!=p[r])\r\n         r=p[r];\r\n     while(x!=p[x])\r\n     {\r\n         k=p[x];\r\n         p[x]=r;\r\n         x=k;\r\n     }\r\n     return r;\r\n}\r\n\r\nchar merge(int x,int y)\r\n{\r\n     x=find(x),y=find(y);\r\n     if(x==y) return 0;\r\n     \r\n     if(rank[x]>rank[y])\r\n        p[y]=x;\r\n     else\r\n     {\r\n        p[x]=y;\r\n        if(rank[x]==rank[y])\r\n           rank[y]++;\r\n     }\r\n     return 1;\r\n}\r\n\r\ndouble dis(Node a,Node b)\r\n{\r\n     return 1.0*(a.x-b.x)*(a.x-b.x) + 1.0*(a.y-b.y)*(a.y-b.y)  ;\r\n}\r\n\r\nbool cmp(const Edge& a,const Edge& b)\r\n{\r\n    return a.d<b.d;\r\n}\r\n\r\nvoid solve()\r\n{\r\n     double ans;\r\n     int i,j,k;\r\n     scanf("%d %d",&m,&n);\r\n     init();\r\n     for(i=1;i<=n;++i)\r\n         scanf("%d %d",&que[i].x,&que[i].y);\r\n     \r\n     k=0;\r\n     for(i=1;i<=n;++i)\r\n     {\r\n         for(j=i+1;j<=n;++j)\r\n         {\r\n             et[k].u=i,et[k].v=j;\r\n             et[k++].d=dis(que[i],que[j]);\r\n         }\r\n     }\r\n     \r\n     sort(et,et+k,cmp);\r\n     for(i=1;i<=k;++i)\r\n     {\r\n         if(merge(et[i].u,et[i].v))\r\n         {\r\n            n--;\r\n            ans=et[i].d;\r\n            if(m==n-1) break;\r\n         }\r\n     }\r\n     printf("%.2lf\\n",sqrt(ans));\r\n}\r\n\r\nint main()\r\n{\r\n    int T;\r\n    scanf("%d",&T);\r\n    while(T--)\r\n       solve();\r\n    return 0;\r\n}', '', 15, 1069056, 7, 2, '2010-09-06 20:35:25', '0001-01-01 00:00:00'),
(362, 6, 253, 0, '#include <stdio.h>\r\n#include <math.h>\r\n#include <algorithm>\r\nusing std::sort;\r\n#define N 600\r\n#define M 100000\r\nstruct Edge\r\n{\r\n   int u,v;\r\n   double d;\r\n}et[M];\r\n\r\nstruct Node\r\n{\r\n   int x,y;\r\n}que[N];\r\nint n,m;\r\nint p[N],rank[N];\r\n\r\nvoid init()\r\n{\r\n     for(int i=1;i<=n;++i)\r\n     {\r\n         p[i]=i;\r\n         rank[i]=1;\r\n     }\r\n}\r\n\r\nint find(int x)\r\n{\r\n     int r=x,k;\r\n     while(r!=p[r])\r\n         r=p[r];\r\n     while(x!=p[x])\r\n     {\r\n         k=p[x];\r\n         p[x]=r;\r\n         x=k;\r\n     }\r\n     return r;\r\n}\r\n\r\nchar merge(int x,int y)\r\n{\r\n     x=find(x),y=find(y);\r\n     if(x==y) return 0;\r\n     \r\n     if(rank[x]>rank[y])\r\n        p[y]=x;\r\n     else\r\n     {\r\n        p[x]=y;\r\n        if(rank[x]==rank[y])\r\n           rank[y]++;\r\n     }\r\n     return 1;\r\n}\r\n\r\ndouble dis(Node a,Node b)\r\n{\r\n     return 1.0*(a.x-b.x)*(a.x-b.x) + 1.0*(a.y-b.y)*(a.y-b.y)  ;\r\n}\r\n\r\nbool cmp(const Edge& a,const Edge& b)\r\n{\r\n    return a.d<b.d;\r\n}\r\n\r\nvoid solve()\r\n{\r\n     double ans;\r\n     int i,j,k;\r\n     scanf("%d %d",&m,&n);\r\n     init();\r\n     for(i=1;i<=n;++i)\r\n         scanf("%d %d",&que[i].x,&que[i].y);\r\n     \r\n     k=0;\r\n     for(i=1;i<=n;++i)\r\n     {\r\n         for(j=i+1;j<=n;++j)\r\n         {\r\n             et[k].u=i,et[k].v=j;\r\n             et[k++].d=dis(que[i],que[j]);\r\n         }\r\n     }\r\n     \r\n     sort(et,et+k,cmp);\r\n     for(i=1;i<=k;++i)\r\n     {\r\n         if(merge(et[i].u,et[i].v))\r\n         {\r\n            n--;\r\n            ans=et[i].d;\r\n            if(m==n-1) break;\r\n         }\r\n     }\r\n     printf("%.2lf\\n",sqrt(ans));\r\n}\r\n\r\nint main()\r\n{\r\n    int T;\r\n    scanf("%d",&T);\r\n    while(T--)\r\n       solve();\r\n    return 0;\r\n}', '', 124, 1875968, 4, 2, '2010-09-06 20:38:31', '0001-01-01 00:00:00');
INSERT INTO `tbl_submitions` (`id`, `user_id`, `problem_id`, `exercise_id`, `source`, `result`, `used_time`, `used_memory`, `status`, `compiler_id`, `created`, `modified`) VALUES
(363, 6, 253, 0, '#include <stdio.h>\r\n#include <math.h>\r\n#include <algorithm>\r\nusing std::sort;\r\n#define N 505\r\n#define M 25500\r\nstruct Edge\r\n{\r\n   int u,v;\r\n   double d;\r\n}et[M];\r\n\r\nstruct Node\r\n{\r\n   int x,y;\r\n}que[N];\r\nint n,m;\r\nint p[N],rank[N];\r\n\r\nvoid init()\r\n{\r\n     for(int i=1;i<=n;++i)\r\n     {\r\n         p[i]=i;\r\n         rank[i]=1;\r\n     }\r\n}\r\n\r\nint find(int x)\r\n{\r\n     int r=x,k;\r\n     while(r!=p[r])\r\n         r=p[r];\r\n     while(x!=p[x])\r\n     {\r\n         k=p[x];\r\n         p[x]=r;\r\n         x=k;\r\n     }\r\n     return r;\r\n}\r\n\r\nchar merge(int x,int y)\r\n{\r\n     x=find(x),y=find(y);\r\n     if(x==y) return 0;\r\n     \r\n     if(rank[x]>rank[y])\r\n        p[y]=x;\r\n     else\r\n     {\r\n        p[x]=y;\r\n        if(rank[x]==rank[y])\r\n           rank[y]++;\r\n     }\r\n     return 1;\r\n}\r\n\r\ndouble dis(Node a,Node b)\r\n{\r\n     return 1.0*(a.x-b.x)*(a.x-b.x) + 1.0*(a.y-b.y)*(a.y-b.y)  ;\r\n}\r\n\r\nbool cmp(const Edge& a,const Edge& b)\r\n{\r\n    return a.d<b.d;\r\n}\r\n\r\nvoid solve()\r\n{\r\n     double ans;\r\n     int i,j,k;\r\n     scanf("%d %d",&m,&n);\r\n     init();\r\n     for(i=1;i<=n;++i)\r\n         scanf("%d %d",&que[i].x,&que[i].y);\r\n     \r\n     k=0;\r\n     for(i=1;i<=n;++i)\r\n     {\r\n         for(j=i+1;j<=n;++j)\r\n         {\r\n             et[k].u=i,et[k].v=j;\r\n             et[k++].d=dis(que[i],que[j]);\r\n         }\r\n     }\r\n     \r\n     sort(et,et+k,cmp);\r\n     for(i=0;i<k;++i)\r\n     {\r\n         if(merge(et[i].u,et[i].v))\r\n         {\r\n            n--;\r\n            ans=et[i].d;\r\n            if(m==n) break;\r\n         }\r\n     }\r\n     printf("%.2lf\\n",sqrt(ans));\r\n}\r\n\r\nint main()\r\n{\r\n    int T;\r\n    scanf("%d",&T);\r\n    while(T--)\r\n       solve();\r\n    return 0;\r\n}\r\n', '', 0, 675840, 7, 2, '2010-09-06 20:52:29', '0001-01-01 00:00:00'),
(364, 6, 253, 0, '#include <stdio.h>\r\n#include <math.h>\r\n#include <algorithm>\r\nusing std::sort;\r\n#define N 505\r\n#define M 150000\r\nstruct Edge\r\n{\r\n   int u,v;\r\n   double d;\r\n}et[M];\r\n\r\nstruct Node\r\n{\r\n   int x,y;\r\n}que[N];\r\nint n,m;\r\nint p[N],rank[N];\r\n\r\nvoid init()\r\n{\r\n     for(int i=1;i<=n;++i)\r\n     {\r\n         p[i]=i;\r\n         rank[i]=1;\r\n     }\r\n}\r\n\r\nint find(int x)\r\n{\r\n     int r=x,k;\r\n     while(r!=p[r])\r\n         r=p[r];\r\n     while(x!=p[x])\r\n     {\r\n         k=p[x];\r\n         p[x]=r;\r\n         x=k;\r\n     }\r\n     return r;\r\n}\r\n\r\nchar merge(int x,int y)\r\n{\r\n     x=find(x),y=find(y);\r\n     if(x==y) return 0;\r\n     \r\n     if(rank[x]>rank[y])\r\n        p[y]=x;\r\n     else\r\n     {\r\n        p[x]=y;\r\n        if(rank[x]==rank[y])\r\n           rank[y]++;\r\n     }\r\n     return 1;\r\n}\r\n\r\ndouble dis(Node a,Node b)\r\n{\r\n     return 1.0*(a.x-b.x)*(a.x-b.x) + 1.0*(a.y-b.y)*(a.y-b.y)  ;\r\n}\r\n\r\nbool cmp(const Edge& a,const Edge& b)\r\n{\r\n    return a.d<b.d;\r\n}\r\n\r\nvoid solve()\r\n{\r\n     double ans;\r\n     int i,j,k;\r\n     scanf("%d %d",&m,&n);\r\n     init();\r\n     for(i=1;i<=n;++i)\r\n         scanf("%d %d",&que[i].x,&que[i].y);\r\n     \r\n     k=0;\r\n     for(i=1;i<=n;++i)\r\n     {\r\n         for(j=i+1;j<=n;++j)\r\n         {\r\n             et[k].u=i,et[k].v=j;\r\n             et[k++].d=dis(que[i],que[j]);\r\n         }\r\n     }\r\n     \r\n     sort(et,et+k,cmp);\r\n     for(i=0;i<k;++i)\r\n     {\r\n         if(merge(et[i].u,et[i].v))\r\n         {\r\n            n--;\r\n            ans=et[i].d;\r\n            if(m==n) break;\r\n         }\r\n     }\r\n     printf("%.2lf\\n",sqrt(ans));\r\n}\r\n\r\nint main()\r\n{\r\n    int T;\r\n    scanf("%d",&T);\r\n    while(T--)\r\n       solve();\r\n    return 0;\r\n}\r\n', '', 140, 2670592, 1, 2, '2010-09-06 20:53:53', '0001-01-01 00:00:00'),
(365, 6, 253, 0, '#include <stdio.h>\r\n#include <math.h>\r\n#include <algorithm>\r\nusing std::sort;\r\n#define N 505\r\n#define M 150000\r\nstruct Edge\r\n{\r\n   int u,v;\r\n   double d;\r\n}et[M];\r\n\r\nstruct Node\r\n{\r\n   int x,y;\r\n}que[N];\r\nint n,m;\r\nint p[N],rank[N];\r\n\r\nvoid init()\r\n{\r\n     for(int i=1;i<=n;++i)\r\n     {\r\n         p[i]=i;\r\n         rank[i]=1;\r\n     }\r\n}\r\n\r\nint find(int x)\r\n{\r\n     int r=x,k;\r\n     while(r!=p[r])\r\n         r=p[r];\r\n     while(x!=p[x])\r\n     {\r\n         k=p[x];\r\n         p[x]=r;\r\n         x=k;\r\n     }\r\n     return r;\r\n}\r\n\r\nchar merge(int x,int y)\r\n{\r\n     x=find(x),y=find(y);\r\n     if(x==y) return 0;\r\n     \r\n     if(rank[x]>rank[y])\r\n        p[y]=x;\r\n     else\r\n     {\r\n        p[x]=y;\r\n        if(rank[x]==rank[y])\r\n           rank[y]++;\r\n     }\r\n     return 1;\r\n}\r\n\r\ndouble dis(Node a,Node b)\r\n{\r\n     return 1.0*(a.x-b.x)*(a.x-b.x) + 1.0*(a.y-b.y)*(a.y-b.y)  ;\r\n}\r\n\r\nbool cmp(const Edge& a,const Edge& b)\r\n{\r\n    return a.d<b.d;\r\n}\r\n\r\nvoid solve()\r\n{\r\n     double ans;\r\n     int i,j,k;\r\n     scanf("%d %d",&m,&n);\r\n     init();\r\n     for(i=1;i<=n;++i)\r\n         scanf("%d %d",&que[i].x,&que[i].y);\r\n     \r\n     k=0;\r\n     for(i=1;i<=n;++i)\r\n     {\r\n         for(j=i+1;j<=n;++j)\r\n         {\r\n             et[k].u=i,et[k].v=j;\r\n             et[k++].d=dis(que[i],que[j]);\r\n         }\r\n     }\r\n     \r\n     sort(et,et+k,cmp);\r\n     for(i=0;i<k;++i)\r\n     {\r\n         if(merge(et[i].u,et[i].v))\r\n         {\r\n            n--;\r\n            ans=et[i].d;\r\n            if(m==n) break;\r\n         }\r\n     }\r\n     printf("%.2lf\\n",sqrt(ans));\r\n}\r\n\r\nint main()\r\n{\r\n    int T;\r\n    scanf("%d",&T);\r\n    while(T--)\r\n       solve();\r\n    return 0;\r\n}\r\n', '', 140, 2666496, 1, 2, '2010-09-06 20:54:25', '0001-01-01 00:00:00'),
(366, 6, 253, 0, '#include <stdio.h>\r\n#include <math.h>\r\n#include <algorithm>\r\nusing std::sort;\r\n#define N 505\r\n#define M 150000\r\nstruct Edge\r\n{\r\n   int u,v;\r\n   double d;\r\n}et[M];\r\n\r\nstruct Node\r\n{\r\n   int x,y;\r\n}que[N];\r\nint n,m;\r\nint p[N],rank[N];\r\n\r\nvoid init()\r\n{\r\n     for(int i=1;i<=n;++i)\r\n     {\r\n         p[i]=i;\r\n         rank[i]=1;\r\n     }\r\n}\r\n\r\nint find(int x)\r\n{\r\n     int r=x,k;\r\n     while(r!=p[r])\r\n         r=p[r];\r\n     while(x!=p[x])\r\n     {\r\n         k=p[x];\r\n         p[x]=r;\r\n         x=k;\r\n     }\r\n     return r;\r\n}\r\n\r\nchar merge(int x,int y)\r\n{\r\n     x=find(x),y=find(y);\r\n     if(x==y) return 0;\r\n     \r\n     if(rank[x]>rank[y])\r\n        p[y]=x;\r\n     else\r\n     {\r\n        p[x]=y;\r\n        if(rank[x]==rank[y])\r\n           rank[y]++;\r\n     }\r\n     return 1;\r\n}\r\n\r\ndouble dis(Node a,Node b)\r\n{\r\n     return 1.0*(a.x-b.x)*(a.x-b.x) + 1.0*(a.y-b.y)*(a.y-b.y)  ;\r\n}\r\n\r\nbool cmp(const Edge& a,const Edge& b)\r\n{\r\n    return a.d<b.d;\r\n}\r\n\r\nvoid solve()\r\n{\r\n     double ans;\r\n     int i,j,k;\r\n     scanf("%d %d",&m,&n);\r\n     init();\r\n     for(i=1;i<=n;++i)\r\n         scanf("%d %d",&que[i].x,&que[i].y);\r\n     \r\n     k=0;\r\n     for(i=1;i<=n;++i)\r\n     {\r\n         for(j=i+1;j<=n;++j)\r\n         {\r\n             et[k].u=i,et[k].v=j;\r\n             et[k++].d=dis(que[i],que[j]);\r\n         }\r\n     }\r\n     \r\n     sort(et,et+k,cmp);\r\n     for(i=0;i<k;++i)\r\n     {\r\n         if(merge(et[i].u,et[i].v))\r\n         {\r\n            n--;\r\n            ans=et[i].d;\r\n            if(m==n) break;\r\n         }\r\n     }\r\n     printf("%.2lf\\n",sqrt(ans));\r\n}\r\n\r\nint main()\r\n{\r\n    int T;\r\n    scanf("%d",&T);\r\n    while(T--)\r\n       solve();\r\n    return 0;\r\n}\r\n', '', 156, 2670592, 1, 2, '2010-09-06 20:56:44', '0001-01-01 00:00:00'),
(367, 6, 39, 0, '#include <stdio.h>\r\n#define N 1000\r\n#define INF 1<<30\r\nint  n;\r\nint  map[N][N],dis[N],cnt[N];\r\nchar used[N];\r\n\r\nvoid init()\r\n{\r\n    int i,j,tmp;\r\n    for(i=1;i<=n;++i)\r\n        scanf("%d",cnt+i);\r\n    \r\n    for(i=1;i<=n;++i)\r\n    {\r\n        for(j=1;j<=n;++j)\r\n        {\r\n            scanf("%d",&tmp);\r\n            map[i][j]=tmp+cnt[i]+cnt[j];\r\n        }\r\n    }\r\n}\r\n\r\nint prim()\r\n{ \r\n     int i,j,v;\r\n     int minv;\r\n     for(i=1;i<=n;i++)\r\n     {\r\n        dis[i]=map[1][i];\r\n        used[i]=0;\r\n     }\r\n     used[1]=1;\r\n     \r\n     int sum=0;\r\n     for(i=1;i<n;i++)\r\n     {\r\n        minv=INF;\r\n        for(j=1;j<=n;j++)\r\n          if(!used[j]&&dis[j]<minv)\r\n          {\r\n              v=j;\r\n              minv=dis[j];\r\n          }\r\n        used[v]=1;\r\n        sum+=minv;\r\n        for(j=1;j<=n;j++)\r\n         if(!used[j]&&map[v][j]<dis[j])\r\n           dis[j]=map[v][j];\r\n     }\r\n     return sum;\r\n}\r\n\r\nint main()\r\n{\r\n    int T;\r\n    scanf("%d",&T);\r\n    while(T--)\r\n    {\r\n        scanf("%d",&n);\r\n        init();\r\n        printf("%d\\n",prim());\r\n    }\r\n    return 0;\r\n}', '', 140, 4268032, 1, 1, '2010-09-06 22:06:39', '0001-01-01 00:00:00'),
(368, 3, 42, 0, '#include<iostream>\r\n#include<cstdlib> \r\nusing namespace std;\r\nint main()\r\n{\r\n   printf("**************************\\n"); \r\n   printf("         Very    Good!\\n"); \r\n   printf("**************************\\n");  \r\n   system("pause"); \r\n   return 0;    \r\n} \r\n', 'Main.cpp: In function ''int main()'':\r\nMain.cpp:6:41: error: ''printf'' was not declared in this scope\r\n', 0, 0, 2, 2, '2010-09-11 13:44:39', '0001-01-01 00:00:00'),
(369, 3, 42, 0, '#include<stdio.h> \r\n#include<stdlib.h> \r\n\r\nint main()\r\n{\r\n   printf("**************************\\n"); \r\n   printf("         Very    Good!\\n"); \r\n   printf("**************************\\n");  \r\n\r\n   return 0;    \r\n} \r\n', '', 0, 258048, 3, 1, '2010-09-11 13:45:36', '0001-01-01 00:00:00'),
(370, 3, 42, 0, '#include<stdio.h> \r\n#include<stdlib.h> \r\n\r\nint main()\r\n{\r\n   printf("**************************\\n"); \r\n   printf("         Very    Good!\\n"); \r\n   printf("**************************");  \r\n\r\n   return 0;    \r\n} \r\n', '', 0, 258048, 1, 1, '2010-09-11 13:45:51', '0001-01-01 00:00:00'),
(371, 1, 335, 0, '#include<stdio.h>\r\nint countTable[256] =\r\n\r\n{\r\n\r\n0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8\r\n\r\n}; \r\nint main()\r\n{\r\n	int a,b;\r\n	while(scanf("%d%d",&a,&b)==2)\r\n	{\r\n		int k=a^b;\r\n		printf("%d\\n",countTable[k&255]+countTable[(k>>8)&255]+countTable[(k>>16)&255]+countTable[(k>>24)&255]);\r\n	}\r\n	return 0;\r\n}', '', 62, 262144, 1, 1, '2010-09-15 21:54:56', '0001-01-01 00:00:00'),
(372, 1, 335, 0, '#include<stdio.h>\r\nint bit_count(unsigned int v)\r\n{\r\n    int num=0;\r\n    while(v)\r\n    {\r\n        if(v%2==1)\r\n           num++;\r\n        v=v/2;\r\n    }\r\n    return num; \r\n}\r\n\r\nint main()\r\n{\r\n	int a,b;\r\n	while(scanf("%d%d",&a,&b)==2)\r\n	{\r\n		int k=a^b;\r\n		printf("%d\\n",bit_count(k));\r\n	}\r\n	return 0;\r\n}', '', 78, 258048, 1, 1, '2010-09-15 22:16:21', '0001-01-01 00:00:00'),
(373, 1, 336, 0, '#include <stdio.h>\r\n#include <iostream>\r\n#include <fstream>\r\n#include <time.h>\r\n#include <algorithm>\r\nstruct co\r\n{\r\n	int a;\r\n	int count;\r\n} a[50000];\r\nbool operator<(const co &a1,const co &a2)\r\n{\r\n	return a1.count<a2.count ||((a1.count==a2.count )&&(a1.a<a2.a));\r\n}\r\nint bit_count(unsigned int v)\r\n{\r\n    int num=0;\r\n    while(v)\r\n    {\r\n        if(v%2==1)\r\n           num++;\r\n        v=v/2;\r\n    }\r\n    return num; \r\n}\r\n\r\nusing namespace std;\r\nint main(int argc, char* argv[])\r\n{\r\n	//freopen("c:/ti.txt","r",stdin);\r\n	//freopen("c:/to.txt","w",stdout);\r\n	int n;\r\n	while(scanf("%d",&n)==1)\r\n	{\r\n		for (int i=0;i<n;i++)\r\n		{\r\n			scanf("%d",&a[i].a);\r\n			a[i].count=bit_count(a[i].a);\r\n		}\r\n		sort(a,a+n);\r\n		for (int i=0;i<n;i++)\r\n		{\r\n			if(i!=0)printf(" ");;\r\n			printf("%d",a[i].a);\r\n		}\r\n		printf("\\n");\r\n	}\r\n\r\n}\r\n', '', 108, 770048, 1, 2, '2010-09-15 22:49:13', '0001-01-01 00:00:00'),
(374, 18, 335, 2, '#include<iostream> \r\nusing namespace std;\r\nint main()\r\n{\r\n	int a,b,c;\r\n	while(1){\r\n	cin>>a>>b;\r\n	c=a^b;\r\n	int count=0;\r\n	while (c)\r\n	{\r\n    if (c & 1) ++count;\r\n    c >>= 1;\r\n	}\r\n	cout<<count<<endl;\r\n	}\r\n}', '', 100, 364544, 5, 2, '2010-09-16 08:18:43', '0001-01-01 00:00:00'),
(375, 22, 335, 2, '#include<iostream>\r\n\r\nusing namespace std;\r\n\r\n#define POW(c) (1<<(c))\r\n#define MASK(c) (((unsigned long)-1) / (POW(POW(c)) + 1))\r\n#define ROUND(n, c) (((n) & MASK(c)) + ((n) >> POW(c) & MASK(c)))\r\n\r\nint bit_count(unsigned int n)\r\n{\r\nn = ROUND(n, 0);\r\nn = ROUND(n, 1);\r\nn = ROUND(n, 2);\r\nn = ROUND(n, 3);\r\nn = ROUND(n, 4);\r\nreturn n;\r\n}\r\n\r\nint main(int argc, char* argv[])\r\n{\r\n	int a,b;\r\n	while(cin>>a>>b)\r\n	{\r\n		cout<<bit_count(a^b)<<endl;\r\n	}    \r\n	return 0;\r\n}\r\n', '', 100, 368640, 5, 2, '2010-09-16 08:36:18', '0001-01-01 00:00:00'),
(376, 14, 335, 2, '#include<stdio.h>\r\n\r\nint main()\r\n{\r\n	int num1,num2;\r\n	\r\n	while(scanf("%d %d",&num1,&num2)!=EOF)\r\n	{\r\n		int i=0;\r\n		int count=0;\r\n		for(;i<sizeof(int)*8;++i)\r\n		{	\r\n			if( (num1%2) != (num2%2) )\r\n				++count;\r\n\r\n			num1 >>= 1;\r\n			num2 >>= 1;\r\n\r\n			if( num1 ==0 && num2 ==0)\r\n				break;\r\n		}\r\n\r\n		printf("%d\\n",count);\r\n	}\r\n		\r\n	return 0;\r\n}', '', 93, 258048, 4, 1, '2010-09-16 08:38:52', '0001-01-01 00:00:00'),
(377, 18, 335, 2, '#include<iostream> \r\nusing namespace std;\r\nint main()\r\n{\r\n	int a,b,c;\r\n	while(1){\r\n	scanf("%d %d",&a,&b);\r\n	c=a^b;\r\n	int count=0;\r\n	while (c)\r\n	{\r\n    if (c & 1) ++count;\r\n    c >>= 1;\r\n	}\r\n	cout<<count<<endl;\r\n	}\r\n}', 'Main.cpp: In function ''int main()'':\r\nMain.cpp:7:21: error: ''scanf'' was not declared in this scope\r\n', 0, 0, 2, 2, '2010-09-16 08:40:00', '0001-01-01 00:00:00'),
(378, 19, 335, 2, '#include <iostream> \r\nusing namespace std;\r\nint main(){\r\n	int a,b;\r\n	while(scanf("%d %d",&a,&b)==2){\r\n		int i=0;\r\n		do{\r\n			if((a%2)!=(b%2))\r\n				i++;\r\n			a/=2,b/=2;\r\n		}while(a+b);\r\n		cout<<i<<endl;\r\n	}\r\n	return 0;\r\n}\r\n', 'Main.cpp: In function ''int main()'':\r\nMain.cpp:5:27: error: ''scanf'' was not declared in this scope\r\n', 0, 0, 2, 2, '2010-09-16 08:42:06', '0001-01-01 00:00:00'),
(379, 22, 335, 2, '#include<stdio.h>\r\n\r\n#define POW(c) (1<<(c))\r\n#define MASK(c) (((unsigned long)-1) / (POW(POW(c)) + 1))\r\n#define ROUND(n, c) (((n) & MASK(c)) + ((n) >> POW(c) & MASK(c)))\r\n\r\nint bit_count(unsigned int n)\r\n{\r\nn = ROUND(n, 0);\r\nn = ROUND(n, 1);\r\nn = ROUND(n, 2);\r\nn = ROUND(n, 3);\r\nn = ROUND(n, 4);\r\nreturn n;\r\n}\r\n\r\nint main()\r\n{\r\n	int a,b;\r\n	while(scanf("%d%d",&a,&b)==2)\r\n	{\r\n		printf("%d\\n",bit_count(a^b));\r\n	}    \r\n	return 0;\r\n}', '', 46, 258048, 1, 1, '2010-09-16 08:43:09', '0001-01-01 00:00:00'),
(380, 25, 335, 2, '#include <stdio.h>\r\n#define POW(c) (1<<(c))\r\n#define MASK(c) (((unsigned long)-1) / (POW(POW(c)) + 1))\r\n#define ROUND(n, c) (((n) & MASK(c)) + ((n) >> POW(c) & MASK(c)))\r\n\r\nint bit_count(unsigned int n)\r\n{\r\nn = ROUND(n, 0);\r\nn = ROUND(n, 1);\r\nn = ROUND(n, 2);\r\nn = ROUND(n, 3);\r\nn = ROUND(n, 4);\r\nreturn n;\r\n}\r\n\r\nint main()\r\n{\r\n	int a,b,c;\r\n	while(scanf("%d%d",&a,&b) == 2 )\r\n	{\r\n		c = (a|b)-(a&b);\r\n		printf("%d\\n",bit_count(c));\r\n	}\r\n	return 0;\r\n}', '', 62, 262144, 1, 2, '2010-09-16 08:45:15', '0001-01-01 00:00:00'),
(381, 14, 335, 2, '#include<stdio.h>\r\n\r\nint main()\r\n{\r\n	int num1,num2;\r\n	\r\n	while(scanf("%d %d",&num1,&num2)!=EOF)\r\n	{\r\n		int i=0;\r\n		int count=0;\r\n		for(;i<sizeof(int)*8;++i)\r\n		{	\r\n			if( ((unsigned)num1%2) != ((unsigned)num2%2) )\r\n				++count;\r\n\r\n			num1 >>= 1;\r\n			num2 >>= 1;\r\n\r\n			if( num1 ==0 && num2 ==0)\r\n				break;\r\n		}\r\n		printf("%d\\n",count);\r\n	}\r\n	return 0;\r\n}', '', 93, 258048, 1, 1, '2010-09-16 08:47:53', '0001-01-01 00:00:00'),
(382, 23, 335, 2, '#include<stdio.h>\r\n\r\nint main(){\r\n	int a,b,count;\r\n 	while(scanf("%d%d",&a,&b)==2){\r\n		a^=b;\r\n		for(count = 0; a; a>>= 1)\r\n		{\r\n			count += a & 1;\r\n		}\r\n		printf("需要改变%d位\\n",count);\r\n	}\r\n	return count;\r\n}\r\n', '', 100, 262144, 5, 1, '2010-09-16 08:49:47', '0001-01-01 00:00:00'),
(383, 18, 335, 2, '#include<iostream> \r\nusing namespace std;\r\nint main()\r\n{\r\n	int a,b,c;\r\n	while(1){\r\n	scanf("%d %d",&a,&b);\r\n	c=a^b;\r\n	int count=0;\r\n	while (c)\r\n	{\r\n    c&= c-1;\r\n    ++count;\r\n	}\r\n	cout<<count<<endl;\r\n	}\r\n}', 'Main.cpp: In function ''int main()'':\r\nMain.cpp:7:21: error: ''scanf'' was not declared in this scope\r\n', 0, 0, 2, 2, '2010-09-16 08:54:29', '0001-01-01 00:00:00'),
(384, 25, 336, 2, '#include <iostream>\r\n#include <algorithm>\r\nusing namespace std;\r\n\r\n#define POW(c) (1<<(c))\r\n#define MASK(c) (((unsigned long)-1) / (POW(POW(c)) + 1))\r\n#define ROUND(n, c) (((n) & MASK(c)) + ((n) >> POW(c) & MASK(c)))\r\n\r\nint bit_count(unsigned int n)\r\n{\r\nn = ROUND(n, 0);\r\nn = ROUND(n, 1);\r\nn = ROUND(n, 2);\r\nn = ROUND(n, 3);\r\nn = ROUND(n, 4);\r\nreturn n;\r\n}\r\n\r\nbool cmp(int a,int b)\r\n{\r\n	if(bit_count(a) == bit_count(b))\r\n		return a < b;\r\n	else\r\n		return bit_count(a) < bit_count(b);\r\n}\r\n\r\nint a[50001];\r\nint main()\r\n{\r\n	int x,n,i;\r\n	while(scanf("%d",&n) == 1){\r\n		for(i=0;i<n;i++)\r\n			scanf("%d",&a[i]);\r\n		sort(a,a+i,cmp);\r\n		for(i=0;i<n-1;i++)\r\n			printf("%d ",a[i]);\r\n		printf("%d\\n",a[n-1]);\r\n	}\r\n	return 0;\r\n}', 'Main.cpp: In function ''int main()'':\r\nMain.cpp:31:21: error: ''scanf'' was not declared in this scope\r\nMain.cpp:36:21: error: ''printf'' was not declared in this scope\r\nMain.cpp:37:23: error: ''printf'' was not declared in this scope\r\n', 0, 0, 2, 2, '2010-09-16 08:59:57', '0001-01-01 00:00:00'),
(385, 19, 335, 2, '#include <iostream> \r\n#include <stdlib.h>\r\nusing namespace std;\r\nint main(){\r\n	int a,b;\r\n	while(scanf("%d %d",&a,&b)==2){\r\n		 unsigned int c=a^b;\r\n	for(int count=0;c;c>>=1){\r\n		count+=c&1;\r\n	}\r\n	cout<<count<<endl;\r\n	}\r\n	return 0;\r\n}\r\n', 'Main.cpp: In function ''int main()'':\r\nMain.cpp:6:27: error: ''scanf'' was not declared in this scope\r\nMain.cpp:11:8: error: name lookup of ''count'' changed for ISO ''for'' scoping\r\nMain.cpp:11:8: note: (if you use ''-fpermissive'' G++ will accept your code)\r\n', 0, 0, 2, 2, '2010-09-16 09:03:40', '0001-01-01 00:00:00'),
(386, 6, 336, 2, '#include <iostream>\r\n#include <algorithm>\r\nusing namespace std;\r\nconst int N = 50050;\r\nstruct Node\r\n{\r\n    int a,b;\r\n}que[N];\r\nint n;\r\n\r\nint  f1(int num, int count, int i)\r\n{\r\n    if(32==i)\r\n    {\r\n        return count;\r\n    }\r\n    else  \r\n    {  \r\n        if(num<0)       //最高位为1的是负数\r\n        {\r\n            ++count;\r\n        }\r\n        num = num<<1;\r\n        ++i;\r\n    }\r\n    f1(num,count,i);\r\n}\r\n\r\nint f1(int num)\r\n{\r\n    return f1(num,0,0);\r\n}\r\n\r\nvoid init()\r\n{\r\n	int u,v;\r\n    for(int i=0;i<n;++i)\r\n	{\r\n	    scanf("%d",&u);\r\n		v=f1(u);\r\n		que[i].a=u,que[i].b=v;\r\n	}\r\n}\r\n\r\nbool cmp(const Node& x,const Node& y)\r\n{\r\n    if(x.b!=y.b) return x.b<y.b;\r\n	else         return x.a<y.a;\r\n}\r\n\r\nvoid solve()\r\n{\r\n	int i;\r\n    init();\r\n	sort(que,que+n,cmp);\r\n	for(i=0;i<(n-1);++i)\r\n		printf("%d ",que[i].a);\r\n	printf("%d\\n",que[i].a);\r\n}\r\n\r\nint main()\r\n{\r\n	while(scanf("%d",&n)!=EOF)\r\n	   solve();\r\n	return 0;\r\n}\r\n', 'Main.cpp: In function ''void init()'':\r\nMain.cpp:39:19: error: ''scanf'' was not declared in this scope\r\nMain.cpp: In function ''void solve()'':\r\nMain.cpp:57:24: error: ''printf'' was not declared in this scope\r\nMain.cpp:58:24: error: ''printf'' was not declared in this scope\r\nMain.cpp: In function ''int main()'':\r\nMain.cpp:63:21: error: ''scanf'' was not declared in this scope\r\nMain.cpp:63:24: error: ''EOF'' was not declared in this scope\r\n', 0, 0, 2, 2, '2010-09-16 09:06:07', '0001-01-01 00:00:00'),
(387, 19, 335, 2, '#include <iostream> \r\n#include <stdlib.h>\r\nusing namespace std;\r\nint main(){\r\n	int a,b;\r\n	while(scanf("%d %d",&a,&b)==2){\r\n		 unsigned int c=a^b;\r\n		 for(int count=0;c;c>>=1)\r\n			 count+=c&1;\r\n	cout<<count<<endl;\r\n	}\r\n	return 0;\r\n}', 'Main.cpp: In function ''int main()'':\r\nMain.cpp:6:27: error: ''scanf'' was not declared in this scope\r\nMain.cpp:10:8: error: name lookup of ''count'' changed for ISO ''for'' scoping\r\nMain.cpp:10:8: note: (if you use ''-fpermissive'' G++ will accept your code)\r\n', 0, 0, 2, 2, '2010-09-16 09:07:53', '0001-01-01 00:00:00'),
(388, 25, 336, 2, '#include <iostream>\r\n#include <cstdlib>\r\n#include <algorithm>\r\nusing namespace std;\r\n\r\n#define POW(c) (1<<(c))\r\n#define MASK(c) (((unsigned long)-1) / (POW(POW(c)) + 1))\r\n#define ROUND(n, c) (((n) & MASK(c)) + ((n) >> POW(c) & MASK(c)))\r\n\r\nint bit_count(unsigned int n)\r\n{\r\nn = ROUND(n, 0);\r\nn = ROUND(n, 1);\r\nn = ROUND(n, 2);\r\nn = ROUND(n, 3);\r\nn = ROUND(n, 4);\r\nreturn n;\r\n}\r\n\r\nbool cmp(int a,int b)\r\n{\r\n	if(bit_count(a) == bit_count(b))\r\n		return a < b;\r\n	else\r\n		return bit_count(a) < bit_count(b);\r\n}\r\n\r\nint a[50001];\r\nint main()\r\n{\r\n	int x,n,i;\r\n	while(scanf("%d",&n) == 1){\r\n		for(i=0;i<n;i++)\r\n			scanf("%d",&a[i]);\r\n		sort(a,a+i,cmp);\r\n		for(i=0;i<n-1;i++)\r\n			printf("%d ",a[i]);\r\n		printf("%d\\n",a[n-1]);\r\n	}\r\n	return 0;\r\n}', 'Main.cpp: In function ''int main()'':\r\nMain.cpp:32:21: error: ''scanf'' was not declared in this scope\r\nMain.cpp:37:21: error: ''printf'' was not declared in this scope\r\nMain.cpp:38:23: error: ''printf'' was not declared in this scope\r\n', 0, 0, 2, 2, '2010-09-16 09:08:51', '0001-01-01 00:00:00'),
(389, 6, 336, 2, '#include <iostream>\r\n#include <stdio.h>\r\n#include <algorithm>\r\nusing namespace std;\r\nconst int N = 50050;\r\nstruct Node\r\n{\r\n    int a,b;\r\n}que[N];\r\nint n;\r\n\r\nint  f1(int num, int count, int i)\r\n{\r\n    if(32==i)\r\n    {\r\n        return count;\r\n    }\r\n    else  \r\n    {  \r\n        if(num<0)       //最高位为1的是负数\r\n        {\r\n            ++count;\r\n        }\r\n        num = num<<1;\r\n        ++i;\r\n    }\r\n    f1(num,count,i);\r\n}\r\n\r\nint f1(int num)\r\n{\r\n    return f1(num,0,0);\r\n}\r\n\r\nvoid init()\r\n{\r\n	int u,v;\r\n    for(int i=0;i<n;++i)\r\n	{\r\n	    scanf("%d",&u);\r\n		v=f1(u);\r\n		que[i].a=u,que[i].b=v;\r\n	}\r\n}\r\n\r\nbool cmp(const Node& x,const Node& y)\r\n{\r\n    if(x.b!=y.b) return x.b<y.b;\r\n	else         return x.a<y.a;\r\n}\r\n\r\nvoid solve()\r\n{\r\n	int i;\r\n    init();\r\n	sort(que,que+n,cmp);\r\n	for(i=0;i<(n-1);++i)\r\n		printf("%d ",que[i].a);\r\n	printf("%d\\n",que[i].a);\r\n}\r\n\r\nint main()\r\n{\r\n	while(scanf("%d",&n)!=EOF)\r\n	   solve();\r\n	return 0;\r\n}\r\n', '', 15, 774144, 4, 2, '2010-09-16 09:10:13', '0001-01-01 00:00:00'),
(390, 25, 336, 2, '#include <iostream>\r\n#include <cstdio>\r\n#include <algorithm>\r\nusing namespace std;\r\n\r\n#define POW(c) (1<<(c))\r\n#define MASK(c) (((unsigned long)-1) / (POW(POW(c)) + 1))\r\n#define ROUND(n, c) (((n) & MASK(c)) + ((n) >> POW(c) & MASK(c)))\r\n\r\nint bit_count(unsigned int n)\r\n{\r\nn = ROUND(n, 0);\r\nn = ROUND(n, 1);\r\nn = ROUND(n, 2);\r\nn = ROUND(n, 3);\r\nn = ROUND(n, 4);\r\nreturn n;\r\n}\r\n\r\nbool cmp(int a,int b)\r\n{\r\n	if(bit_count(a) == bit_count(b))\r\n		return a < b;\r\n	else\r\n		return bit_count(a) < bit_count(b);\r\n}\r\n\r\nint a[50001];\r\nint main()\r\n{\r\n	int x,n,i;\r\n	while(scanf("%d",&n) == 1){\r\n		for(i=0;i<n;i++)\r\n			scanf("%d",&a[i]);\r\n		sort(a,a+i,cmp);\r\n		for(i=0;i<n-1;i++)\r\n			printf("%d ",a[i]);\r\n		printf("%d\\n",a[n-1]);\r\n	}\r\n	return 0;\r\n}', '', 15, 573440, 4, 2, '2010-09-16 09:11:16', '0001-01-01 00:00:00'),
(391, 19, 335, 2, '#include <iostream> \r\n#include <stdio.h>\r\nusing namespace std;\r\nint main(){\r\n	int a,b;\r\n	while(scanf("%d %d",&a,&b)==2){\r\n		 unsigned int c=a^b;\r\n		 for(int count=0;c;c>>=1)\r\n			 count+=c&1;\r\n	cout<<count<<endl;\r\n	}\r\n	return 0;\r\n}', 'Main.cpp: In function ''int main()'':\r\nMain.cpp:10:8: error: name lookup of ''count'' changed for ISO ''for'' scoping\r\nMain.cpp:10:8: note: (if you use ''-fpermissive'' G++ will accept your code)\r\n', 0, 0, 2, 2, '2010-09-16 09:12:32', '0001-01-01 00:00:00'),
(392, 6, 336, 2, '#include <iostream>\r\n#include <stdio.h>\r\n#include <bitset>\r\n#include <algorithm>\r\nusing namespace std;\r\nconst int N = 50050;\r\nstruct Node\r\n{\r\n    int a,b;\r\n}que[N];\r\nint n;\r\n\r\nint f2(int num)\r\n{\r\n    bitset<32> bs(num);\r\n    return bs.count();\r\n}\r\n\r\nvoid init()\r\n{\r\n	int u,v;\r\n    for(int i=0;i<n;++i)\r\n	{\r\n	    scanf("%d",&u);\r\n		v=f2(u);\r\n		que[i].a=u,que[i].b=v;\r\n	}\r\n}\r\n\r\nbool cmp(const Node& x,const Node& y)\r\n{\r\n    if(x.b!=y.b) return x.b<y.b;\r\n	else         return x.a<y.a;\r\n}\r\n\r\nvoid solve()\r\n{\r\n	int i;\r\n    init();\r\n	sort(que,que+n,cmp);\r\n	for(i=0;i<(n-1);++i)\r\n		printf("%d ",que[i].a);\r\n	printf("%d\\n",que[i].a);\r\n}\r\n\r\nint main()\r\n{\r\n	while(scanf("%d",&n)!=EOF)\r\n	   solve();\r\n	return 0;\r\n}', '', 15, 774144, 4, 2, '2010-09-16 09:13:28', '0001-01-01 00:00:00'),
(393, 18, 335, 2, '#include <stdio.h>\r\n#include<iostream> \r\nusing namespace std;\r\nint main()\r\n{\r\n	int a,b,c;\r\n	while(1){\r\n	scanf("%d %d",&a,&b);\r\n	c=a^b;\r\n	int count=0;\r\n	while (c)\r\n	{\r\n    c&= c-1;\r\n    ++count;\r\n	}\r\n	cout<<count<<endl;\r\n	}\r\n}', '', 100, 364544, 5, 2, '2010-09-16 09:13:45', '0001-01-01 00:00:00'),
(394, 19, 335, 2, '#include <iostream> \r\n#include <stdio.h>\r\nusing namespace std;\r\nint main(){\r\n	int a,b;\r\n	while(scanf("%d %d",&a,&b)==2){\r\n		 unsigned int c=a^b;\r\n		 int i;\r\n		 for(i=0;c;c>>=1)\r\n			 i+=c&1;\r\n		 cout<<i<<endl;\r\n	}\r\n	return 0;\r\n}\r\n', '', 100, 368640, 5, 2, '2010-09-16 09:15:02', '0001-01-01 00:00:00'),
(395, 6, 336, 2, '#include <iostream>\r\n#include <stdio.h>\r\n#include <bitset>\r\n#include <algorithm>\r\nusing namespace std;\r\nconst int N = 50050;\r\nstruct Node\r\n{\r\n    int a,b;\r\n}que[N];\r\nint n;\r\n\r\nint f2(int num)\r\n{\r\n    bitset<32> bs(num);\r\n    return bs.count();\r\n}\r\n\r\nvoid init()\r\n{\r\n	int u,v;\r\n    for(int i=0;i<n;++i)\r\n	{\r\n	    scanf("%d",&u);\r\n		v=f2(u);\r\n		que[i].a=u,que[i].b=v;\r\n	}\r\n}\r\n\r\nbool cmp(const Node& x,const Node& y)\r\n{\r\n    if(x.b!=y.b) return x.b<y.b;\r\n	else         return x.a<y.a;\r\n}\r\n\r\nvoid solve()\r\n{\r\n	int i;\r\n    init();\r\n	sort(que,que+n,cmp);\r\n	for(i=0;i<n;++i)\r\n		printf("%d ",que[i].a);\r\n	printf("\\n");\r\n}\r\n\r\nint main()\r\n{\r\n	while(scanf("%d",&n)==1)\r\n	   solve();\r\n	return 0;\r\n}\r\n', '', 15, 774144, 3, 2, '2010-09-16 09:16:03', '0001-01-01 00:00:00'),
(396, 21, 335, 2, '\r\n#include "stdafx.h"\r\n\r\nint main(int argc, char* argv[])\r\n{\r\n	int a,b;\r\n	int count[10];\r\n	int i=0;\r\nwhile(scanf("%d%d",&a,&b)==2)\r\n{	\r\n	for(count[i] = 0; a||b; a >>= 1,b >>= 1)\r\n	{\r\n		if(!((a & 1)&(b & 1)))count[i]++;\r\n	}\r\n	i++;\r\n}\r\n\r\nfor(int j=0;j<=i;j++)\r\n{\r\n	printf("%d\\n",count[j]);\r\n}\r\n\r\n	return 0;\r\n}\r\n\r\n', 'Main.c:2:20: fatal error: stdafx.h: No such file or directory\r\ncompilation terminated.\r\n', 0, 0, 2, 1, '2010-09-16 09:16:43', '0001-01-01 00:00:00'),
(397, 10, 335, 2, '#include <stdio.h>\r\n#define POW(c) (1<<(c))\r\n#define MASK(c) (((unsigned long)-1) / (POW(POW(c)) + 1))\r\n#define ROUND(n, c) (((n) & MASK(c)) + ((n) >> POW(c) & MASK(c)))\r\n\r\nint bit_count(unsigned int n)\r\n{\r\nn = ROUND(n, 0);\r\nn = ROUND(n, 1);\r\nn = ROUND(n, 2);\r\nn = ROUND(n, 3);\r\nn = ROUND(n, 4);\r\nreturn n;\r\n}\r\n\r\nint main()\r\n{\r\n	int num1,num2;\r\n	while(2 == scanf("%d%d",&num1,&num2) )\r\n	{\r\n		printf("%d\\n",bit_count(num1^num2));\r\n	}\r\n	return 0;\r\n}\r\n', '', 62, 262144, 1, 1, '2010-09-16 09:17:01', '0001-01-01 00:00:00'),
(398, 16, 335, 0, '#include<stdio.h>\r\nint main(){\r\n	int a,b,c[20],m=0;\r\n	while(scanf("%d %d",&a,&b)==2){	\r\n		int n=0;\r\n		while(a!=0||b!=0){\r\n			if((a&1)!=(b&1))\r\n				n++;\r\n			a>>=1;b>>=1;\r\n		}\r\n		c[m]=n;\r\n		m++;\r\n	}\r\n	for(int i=0;i!=m;i++)\r\n		printf("%d\\n",c[i]);	\r\n	return 0;\r\n}', 'Main.c: In function ''main'':\r\nMain.c:14:2: error: ''for'' loop initial declarations are only allowed in C99 mode\r\nMain.c:14:2: note: use option -std=c99 or -std=gnu99 to compile your code\r\n', 0, 0, 2, 1, '2010-09-16 09:17:18', '0001-01-01 00:00:00'),
(399, 6, 336, 2, '#include <iostream>\r\n#include <stdio.h>\r\n#include <bitset>\r\n#include <algorithm>\r\nusing namespace std;\r\nconst int N = 50050;\r\nstruct Node\r\n{\r\n    int a,b;\r\n}que[N];\r\nint n;\r\n\r\nint f2(int num)\r\n{\r\n    bitset<32> bs(num);\r\n    return bs.count();\r\n}\r\n\r\nvoid init()\r\n{\r\n	int u,v;\r\n    for(int i=0;i<n;++i)\r\n	{\r\n	    scanf("%d",&u);\r\n		v=f2(u);\r\n		que[i].a=u,que[i].b=v;\r\n	}\r\n}\r\n\r\nbool cmp(const Node& x,const Node& y)\r\n{\r\n    if(x.b!=y.b) return x.b<y.b;\r\n	else         return x.a<y.a;\r\n}\r\n\r\nvoid solve()\r\n{\r\n	int i;\r\n    init();\r\n	sort(que,que+n,cmp);\r\n	for(i=0;i<(n-1);++i)\r\n		printf("%d ",que[i].a);\r\n	printf("%d\\n",que[i].a);\r\n}\r\n\r\nint main()\r\n{\r\n	while(scanf("%d",&n)==1)\r\n	   solve();\r\n	return 0;\r\n}\r\n', '', 15, 770048, 4, 2, '2010-09-16 09:17:35', '0001-01-01 00:00:00'),
(400, 26, 335, 2, '#include <stdio.h>\r\n\r\n#define N 8\r\n\r\nint a[N],b[N],ch[N];\r\n\r\nint change(int c)\r\n{\r\n	int i=0;\r\n	while(c!=0)\r\n	{\r\n		ch[i] = c%2;\r\n		c = c/2;\r\n		i++;\r\n	}\r\n	return 0;\r\n}\r\nint main()\r\n{\r\n	int a1,b1,i;\r\n	\r\n	while(scanf("%d%d",&a1,&b1) == 2)\r\n	{\r\n	int counter = 0;\r\n	printf("\\n");\r\n	change(a1);\r\n	for(i = 0;i!=N;i++)\r\n		a[i]=ch[i];\r\n	change(b1);\r\n	for(i = 0;i!=N;i++)\r\n		b[i]=ch[i];\r\n	for(i = 0;i!=N;i++)\r\n	{\r\n       if(a[i] != b [i])\r\n		   counter++;\r\n	}\r\n	printf("%d",counter);\r\n	printf("\\n");\r\n	}\r\n	return 0;\r\n}', '', 0, 258048, 4, 1, '2010-09-16 09:17:39', '0001-01-01 00:00:00'),
(401, 19, 335, 2, '#include <iostream> \r\n#include <stdio.h>\r\nusing namespace std;\r\nint main(){\r\n	int a,b;\r\n	while(scanf("%d %d",&a,&b)==2){\r\n		 unsigned int c=a^b;\r\n		 int i;\r\n		 for(i=0;c;c&=c-1)\r\n			 i++;\r\n		 cout<<i<<endl;\r\n	}\r\n	return 0;\r\n}', '', 100, 368640, 5, 2, '2010-09-16 09:17:40', '0001-01-01 00:00:00'),
(402, 17, 335, 2, '#include<iostream>\r\n#include<stdio.h>\r\n#include<math.h>\r\nusing namespace std;\r\n#define N 200\r\nint a[N],b[N];\r\nint bit_count( int n,int n1)\r\n{\r\n  \r\n  int count,cout1;\r\n  int i,j,num;\r\n  i=j=0;\r\n  num=0; \r\n  for(count = 0,cout1=0; n,n1; n >>= 1,n1>>=1)\r\n  {\r\n      count = n & 1;\r\n	  cout1 = n1 & 1 ;\r\n	  if(count!=cout1)\r\n		  num++;\r\n  }\r\n  \r\n  return num;\r\n}\r\n\r\nint main()\r\n{\r\n	int fir,sec;\r\n	\r\n	while(scanf("%d%d",&fir,&sec)!=EOF){\r\n    cout<< bit_count(fir,sec)<<endl;\r\n\r\n	}\r\n\r\n	return 0;\r\n}', 'Main.c:1:19: fatal error: iostream: No such file or directory\r\ncompilation terminated.\r\n', 0, 0, 2, 1, '2010-09-16 09:18:04', '0001-01-01 00:00:00'),
(403, 21, 335, 2, '\r\n#include "stdafx.h"\r\n\r\nint main(int argc, char* argv[])\r\n{\r\n	int a,b;\r\n	int count[10];\r\n	int i=0;\r\nwhile(scanf("%d%d",&a,&b)==2)\r\n{	\r\n	for(count[i] = 0; a||b; a >>= 1,b >>= 1)\r\n	{\r\n		if(!((a & 1)&(b & 1)))count[i]++;\r\n	}\r\n	i++;\r\n}\r\n\r\nfor(int j=0;j<=i;j++)\r\n{\r\n	printf("%d\\n",count[j]);\r\n}\r\n\r\n	return 0;\r\n}\r\n\r\n', 'Main.c:2:20: fatal error: stdafx.h: No such file or directory\r\ncompilation terminated.\r\n', 0, 0, 2, 1, '2010-09-16 09:18:21', '0001-01-01 00:00:00'),
(404, 16, 335, 0, '#include<stdio.h>\r\nint main(){\r\n	int a,b,c[20],m=0;\r\n	while(scanf("%d %d",&a,&b)==2){	\r\n		int n=0;\r\n		while(a!=0||b!=0){\r\n			if((a&1)!=(b&1))\r\n				n++;\r\n			a>>=1;b>>=1;\r\n		}\r\n		c[m]=n;\r\n		m++;\r\n	}\r\n	for(int i=0;i!=m;i++)\r\n		printf("%d\\n",c[i]);	\r\n	return 0;\r\n}', '', 100, 258048, 5, 2, '2010-09-16 09:18:24', '0001-01-01 00:00:00'),
(405, 17, 335, 2, '#include<iostream>\r\n#include<stdio.h>\r\n#include<math.h>\r\nusing namespace std;\r\n#define N 200\r\nint a[N],b[N];\r\nint bit_count( int n,int n1)\r\n{\r\n  \r\n  int count,cout1;\r\n  int i,j,num;\r\n  i=j=0;\r\n  num=0; \r\n  for(count = 0,cout1=0; n,n1; n >>= 1,n1>>=1)\r\n  {\r\n      count = n & 1;\r\n	  cout1 = n1 & 1 ;\r\n	  if(count!=cout1)\r\n		  num++;\r\n  }\r\n  \r\n  return num;\r\n}\r\n\r\nint main()\r\n{\r\n	int fir,sec;\r\n	\r\n	while(scanf("%d%d",&fir,&sec)!=EOF){\r\n    cout<< bit_count(fir,sec)<<endl;\r\n\r\n	}\r\n\r\n	return 0;\r\n}', '', 100, 368640, 5, 2, '2010-09-16 09:18:41', '0001-01-01 00:00:00'),
(406, 12, 335, 2, '#include<stdio.h>\r\n\r\n\r\n\r\nint bit_count(unsigned int n)\r\n{\r\nint count;\r\nfor(count = 0; n; n >>= 1)\r\n{\r\n       count += n & 1;\r\n}\r\nreturn count;\r\n}\r\n\r\n\r\nint main()\r\n\r\n{\r\n	int a,b;\r\n	int c,d;\r\n	printf("请输入两个二进制的数\\n");\r\n	while(scanf("%d%d",&a,&b)==2)\r\n	{\r\n		c=bit_count(a);\r\n		d=bit_count(b);\r\n		printf("改变的次数为%d\\n",d-c);\r\n	}\r\n\r\n	return 0;\r\n}\r\n\r\n\r\n\r\n', '', 0, 258048, 4, 1, '2010-09-16 09:19:38', '0001-01-01 00:00:00'),
(407, 8, 335, 2, '#include<stdio.h>\r\nint main()\r\n{\r\n	int a,b;\r\n	while(scanf("%d %d",&a,&b)==2)\r\n	{\r\n		int count=0;\r\n		a=a^b;\r\n		while(a!=0)\r\n		{\r\n			if((a&1)==1) count++;\r\n			a>>=1;\r\n		}\r\n		printf("%d\\n",count);\r\n	}\r\n	return 0;\r\n}', '', 100, 258048, 5, 2, '2010-09-16 09:20:57', '0001-01-01 00:00:00'),
(408, 26, 335, 2, '#include <stdio.h>\r\n\r\n#define N 8\r\n\r\nint a[N],b[N],ch[N];\r\n\r\nint change(int c)\r\n{\r\n	int i=0;\r\n	while(c!=0)\r\n	{\r\n		ch[i] = c%2;\r\n		c = c/2;\r\n		i++;\r\n	}\r\n	return 0;\r\n}\r\nint main()\r\n{\r\n	int a1,b1,i;\r\n	\r\n	while(scanf("%d%d",&a1,&b1) == 2)\r\n	{\r\n	int counter = 0;\r\n	printf("\\n");\r\n	change(a1);\r\n	for(i = 0;i!=N;i++)\r\n		a[i]=ch[i];\r\n	change(b1);\r\n	for(i = 0;i!=N;i++)\r\n		b[i]=ch[i];\r\n	for(i = 0;i!=N;i++)\r\n	{\r\n       if(a[i] != b [i])\r\n		   counter++;\r\n	}\r\n	printf("%d",counter);\r\n	printf("\\n");\r\n	}\r\n	return 0;\r\n}', '', 0, 262144, 4, 1, '2010-09-16 09:21:08', '0001-01-01 00:00:00'),
(409, 15, 335, 2, '#include <stdio.h>\r\nint main()\r\n{\r\n\r\n	int M[32]={0}, N[32]={0};\r\n    int a,b;\r\n    \r\n    printf("请输入两个十进制数：");\r\n    scanf("%d%d",&a,&b);\r\n		int i=0;\r\n    while(a>=1)\r\n{\r\n    M[i]=a%2;\r\n    a=a/2;\r\n    i++;\r\n}\r\n\r\n\r\n\r\n int j=0;\r\n while(b>=1)\r\n{\r\n  N[j]=b%2;\r\n  b=b/2;\r\n  j++;\r\n}\r\n\r\nint c=0;\r\nfor(i=0;i<32;++i)\r\n{\r\n	\r\n    while(M[i]!=N[i])\r\n    ++c;\r\n}\r\n\r\nprintf("需要改变%d位数：",c);\r\nreturn 0;\r\n}', '', 100, 258048, 5, 1, '2010-09-16 09:21:42', '0001-01-01 00:00:00'),
(410, 17, 335, 2, '#include<stdio.h>\r\n#include<math.h>\r\nint bit_count( int n,int n1)\r\n{\r\n  \r\n  int count,cout1;\r\n  int num;\r\n  num=0; \r\n  for(count = 0,cout1=0; n,n1; n >>= 1,n1>>=1)\r\n  {\r\n      count = n & 1;\r\n	  cout1 = n1 & 1 ;\r\n	  if(count!=cout1)\r\n		  num++;\r\n  }\r\n  return num;\r\n}\r\n\r\nint main()\r\n{\r\n	int fir,sec;\r\n	\r\n	while(scanf("%d%d",&fir,&sec)!=EOF){\r\n     printf("%d\\n", bit_count(fir,sec));\r\n	}\r\n\r\n	return 0;\r\n}', '', 100, 258048, 5, 1, '2010-09-16 09:21:58', '0001-01-01 00:00:00'),
(411, 25, 336, 2, '#include <iostream>\r\n#include <cstdio>\r\n#include <algorithm>\r\nusing namespace std;\r\n/*\r\n#define POW(c) (1<<(c))\r\n#define MASK(c) (((unsigned long)-1) / (POW(POW(c)) + 1))\r\n#define ROUND(n, c) (((n) & MASK(c)) + ((n) >> POW(c) & MASK(c)))\r\n\r\nint bit_count(unsigned int n)\r\n{\r\nn = ROUND(n, 0);\r\nn = ROUND(n, 1);\r\nn = ROUND(n, 2);\r\nn = ROUND(n, 3);\r\nn = ROUND(n, 4);\r\nreturn n;\r\n}\r\n\r\nint bit_count(unsigned int n)\r\n{\r\nint count;\r\nfor(count = 0; n; n >>= 1)\r\n{\r\n       count += n & 1;\r\n}\r\nreturn count;\r\n}\r\n*/\r\nint bit_count(unsigned int n)\r\n{\r\nint count;\r\nfor(count = 0; n; n &= n - 1)\r\n{\r\n       count++;\r\n}\r\nreturn count;\r\n}\r\n\r\n\r\nbool cmp(int a,int b)\r\n{\r\n	if(bit_count((unsigned int)a) == bit_count((unsigned int)b))\r\n		return a < b;\r\n	else\r\n		return bit_count((unsigned int)a) < bit_count((unsigned int)b);\r\n}\r\n\r\nint a[50001];\r\nint main()\r\n{\r\n	int n,i;\r\n	while(scanf("%d",&n) == 1){\r\n		for(i=0;i<n;i++)\r\n			scanf("%d",&a[i]);\r\n		sort(a,a+i,cmp);\r\n		for(i=0;i<n-1;i++)\r\n			printf("%d ",a[i]);\r\n		printf("%d\\n",a[n-1]);\r\n	}\r\n	return 0;\r\n}', '', 62, 573440, 4, 2, '2010-09-16 09:22:58', '0001-01-01 00:00:00'),
(412, 6, 335, 2, '#include <stdio.h>\r\n\r\nint main()\r\n{\r\n	int i,j,num;\r\n	while(scanf("%d %d",&i,&j)!=EOF)\r\n	{\r\n	   i = i ^ j;\r\n	   num = 0;\r\n	   while(i)\r\n	   {\r\n		   i &= (i - 1);\r\n		   num++;\r\n	  }\r\n	   printf("%d\\n",num);\r\n	}\r\n	return 0;\r\n}', '', 62, 262144, 1, 1, '2010-09-16 09:23:03', '0001-01-01 00:00:00'),
(413, 19, 335, 2, '#include <iostream> \r\n#include <stdio.h>\r\nusing namespace std;\r\nint main(){\r\n	int a,b;\r\n	while(scanf("%d %d",&a,&b)==2){\r\n		 unsigned int c=a^b;\r\n		 int i;\r\n		 for(i=0;c;c&=c-1)\r\n			 i++;\r\n		 printf("%d\\n",i);\r\n	}\r\n	return 0;\r\n}', 'Main.c:1:21: fatal error: iostream: No such file or directory\r\ncompilation terminated.\r\n', 0, 0, 2, 1, '2010-09-16 09:23:18', '0001-01-01 00:00:00'),
(414, 21, 335, 2, 'int main(int argc, char* argv[])\r\n{\r\n	int a,b;\r\n	int count[10];\r\n	int i=0;\r\nwhile(scanf("%d%d",&a,&b)==2)\r\n{	\r\n	for(count[i] = 0; a||b; a >>= 1,b >>= 1)\r\n	{\r\n		if(!((a & 1)&(b & 1)))count[i]++;\r\n	}\r\n	i++;\r\n}\r\n\r\nfor(int j=0;j<=i;j++)\r\n{\r\n	printf("%d\\n",count[j]);\r\n}\r\n\r\n	return 0;\r\n}\r\n', 'Main.c: In function ''main'':\r\nMain.c:6:7: warning: incompatible implicit declaration of built-in function ''scanf''\r\nMain.c:15:1: error: ''for'' loop initial declarations are only allowed in C99 mode\r\nMain.c:15:1: note: use option -std=c99 or -std=gnu99 to compile your code\r\nMain.c:17:2: warning: incompatible implicit declaration of built-in function ''printf''\r\n', 0, 0, 2, 1, '2010-09-16 09:23:41', '0001-01-01 00:00:00'),
(415, 19, 335, 2, '#include <iostream> \r\n#include <stdio.h>\r\nusing namespace std;\r\nint main(){\r\n	int a,b;\r\n	while(scanf("%d %d",&a,&b)==2){\r\n		 unsigned int c=a^b;\r\n		 int i;\r\n		 for(i=0;c;c&=c-1)\r\n			 i++;\r\n		 printf("%d\\n",i);\r\n	}\r\n	return 0;\r\n}', '', 46, 364544, 1, 2, '2010-09-16 09:24:17', '0001-01-01 00:00:00'),
(416, 25, 3, 1, '#include <iostream>\r\n#include <cstdio>\r\n#include <algorithm>\r\nusing namespace std;\r\nint main()\r\n{\r\n	return 0;\r\n}', 'Main.java:1: illegal character: \\35\r\n#include <iostream>\r\n^\r\nMain.java:2: illegal character: \\35\r\n#include <cstdio>\r\n^\r\nMain.java:3: illegal character: \\35\r\n#include <algorithm>\r\n^\r\nMain.java:5: class, interface, or enum expected\r\nint main()\r\n^\r\nMain.java:8: class, interface, or enum expected\r\n}\Z\0\0\0\0\0\0\0\0\0\r\n^\r\n5 errors\r\n', 0, 0, 2, 4, '2010-09-16 09:27:52', '0001-01-01 00:00:00'),
(417, 8, 335, 2, '#include<stdio.h>\r\nint main()\r\n{\r\n	int a,b;\r\n	int c[100],i=0,j;\r\n	while(scanf("%d %d",&a,&b)==2)\r\n	{\r\n		int count=0;\r\n		a=a^b;\r\n		while(a!=0)\r\n		{\r\n			if((a&1)==1) count++;\r\n			a>>=1;\r\n		}\r\n		c[i++]=count;\r\n	}\r\n    for(j=0;j<i;j++)\r\n    	printf("%d\\n",c[j]);\r\n  	return 0;\r\n}', '', 100, 258048, 5, 2, '2010-09-16 09:28:12', '0001-01-01 00:00:00'),
(418, 21, 335, 2, 'int main(int argc, char* argv[])\r\n{\r\n	int a,b;\r\nwhile(scanf("%d%d",&a,&b)==2)\r\n{	\r\n	for(int count= 0; a||b; a >>= 1,b >>= 1)\r\n	{\r\n		if(!((a & 1)&(b & 1)))count++;\r\n	}\r\n	printf("%d\\n",count);\r\n}\r\n	return 0;\r\n}', 'Main.c: In function ''main'':\r\nMain.c:4:7: warning: incompatible implicit declaration of built-in function ''scanf''\r\nMain.c:6:2: error: ''for'' loop initial declarations are only allowed in C99 mode\r\nMain.c:6:2: note: use option -std=c99 or -std=gnu99 to compile your code\r\nMain.c:10:2: warning: incompatible implicit declaration of built-in function ''printf''\r\n', 0, 0, 2, 1, '2010-09-16 09:28:47', '0001-01-01 00:00:00'),
(419, 8, 335, 2, '#include<stdio.h>\r\nint main()\r\n{\r\n	int a,b;\r\n	int c[100],i=0,j;\r\n	while(scanf("%d %d",&a,&b)==2)\r\n	{\r\n		int count=0;\r\n		a=a^b;\r\n		while(a!=0)\r\n		{\r\n			if((a&1)==1) count++;\r\n			a>>=1;\r\n		}\r\n		c[i++]=count;\r\n	}\r\n    for(j=0;j<i;j++)\r\n    	printf("%d\\n",c[j]);\r\n  	return 0;\r\n}', '', 100, 258048, 5, 1, '2010-09-16 09:29:08', '0001-01-01 00:00:00'),
(420, 17, 335, 2, '#include<stdio.h>\r\nint bit_count( int n,int n1)\r\n{\r\n  \r\n  int count,cout1;\r\n  int num;\r\n  num=0; \r\n  for(count = 0,cout1=0; n,n1; n >>= 1,n1>>=1)\r\n  {\r\n      count = n & 1;\r\n	  cout1 = n1 & 1;\r\n	  if(count^cout1!=0)\r\n		  num++;\r\n  }\r\n  return num;\r\n}\r\nint main()\r\n{\r\n	int fir,sec;\r\n	while(scanf("%d%d",&fir,&sec)==2){\r\n    printf("%d\\n", bit_count(fir,sec));\r\n	}\r\n	return 0;\r\n}', '', 100, 258048, 5, 1, '2010-09-16 09:29:57', '0001-01-01 00:00:00'),
(421, 25, 336, 2, '#include <iostream>\r\n#include <cstdio>\r\n#include <algorithm>\r\nusing namespace std;\r\n\r\n#define POW(c) (1<<(c))\r\n#define MASK(c) (((unsigned long)-1) / (POW(POW(c)) + 1))\r\n#define ROUND(n, c) (((n) & MASK(c)) + ((n) >> POW(c) & MASK(c)))\r\n\r\nint bit_count(unsigned int n)\r\n{\r\nn = ROUND(n, 0);\r\nn = ROUND(n, 1);\r\nn = ROUND(n, 2);\r\nn = ROUND(n, 3);\r\nn = ROUND(n, 4);\r\nreturn n;\r\n}\r\n/*\r\nint bit_count(unsigned int n)\r\n{\r\nint count;\r\nfor(count = 0; n; n >>= 1)\r\n{\r\n       count += n & 1;\r\n}\r\nreturn count;\r\n}\r\n\r\nint bit_count(unsigned int n)\r\n{\r\nint count;\r\nfor(count = 0; n; n &= n - 1)\r\n{\r\n       count++;\r\n}\r\nreturn count;\r\n}*/\r\n\r\n\r\nbool cmp(int a,int b)\r\n{\r\n	if(bit_count((unsigned int)a) == bit_count((unsigned int)b))\r\n		return a < b;\r\n	else\r\n		return bit_count((unsigned int)a) < bit_count((unsigned int)b);\r\n}\r\n\r\nint a[50001];\r\nint main()\r\n{\r\n	int n,i;\r\n	while(scanf("%d",&n) == 1){\r\n		if(n == 0)\r\n			printf("\\n");\r\n		else{\r\n		for(i=0;i<n;i++)\r\n			scanf("%d",&a[i]);\r\n		sort(a,a+i,cmp);\r\n		for(i=0;i<n-1;i++)\r\n			printf("%d ",a[i]);\r\n		printf("%d\\n",a[n-1]);\r\n	}}\r\n	return 0;\r\n}', '', 139, 573440, 1, 2, '2010-09-16 09:31:39', '0001-01-01 00:00:00'),
(422, 22, 336, 2, '#include<stdio.h>\r\n#include<algorithm>\r\n#include<vector>\r\n\r\n#define POW(c) (1<<(c))\r\n#define MASK(c) (((unsigned long)-1) / (POW(POW(c)) + 1))\r\n#define ROUND(n, c) (((n) & MASK(c)) + ((n) >> POW(c) & MASK(c)))\r\n\r\nstd::vector<int> array;\r\n\r\nint bit_count(unsigned int n)\r\n{\r\nn = ROUND(n, 0);\r\nn = ROUND(n, 1);\r\nn = ROUND(n, 2);\r\nn = ROUND(n, 3);\r\nn = ROUND(n, 4);\r\nreturn n;\r\n}\r\n\r\nbool compare(const int& x,const int& y)\r\n{\r\n	int a,b;\r\n	a=bit_count(x);\r\n	b=bit_count(y);\r\n	if(a==b)\r\n		return x<y;\r\n	else\r\n		return a<b;\r\n}\r\n\r\nint main()\r\n{\r\n	int n,c;\r\n	while(scanf("%d",&n)==1)\r\n	{\r\n		for(int i=0;i<n;i++)\r\n		{\r\n			scanf("%d",&c);\r\n			array.push_back(c);\r\n		}\r\n		std::sort(array.begin(),array.end(),compare);\r\n		n--;\r\n		for(i=0;i<n;i++)\r\n		{\r\n			printf("%d ",array[i]);\r\n		}\r\n		printf("%d\\n",array[n]);\r\n		array.clear();\r\n	}    \r\n	return 0;\r\n}', 'Main.cpp: In function ''int main()'':\r\nMain.cpp:44:7: error: name lookup of ''i'' changed for ISO ''for'' scoping\r\nMain.cpp:44:7: note: (if you use ''-fpermissive'' G++ will accept your code)\r\n', 0, 0, 2, 2, '2010-09-16 09:31:59', '0001-01-01 00:00:00'),
(423, 21, 335, 2, 'int main()\r\n{\r\n	int a,b;\r\nwhile(scanf("%d%d",&a,&b)==2)\r\n{	\r\n	for(int count= 0; a||b; a >>= 1,b >>= 1)\r\n	{\r\n		if(!((a & 1)&(b & 1)))count++;\r\n	}\r\n	printf("%d\\n",count);\r\n}\r\n	return 0;\r\n}', 'Main.c: In function ''main'':\r\nMain.c:4:7: warning: incompatible implicit declaration of built-in function ''scanf''\r\nMain.c:6:2: error: ''for'' loop initial declarations are only allowed in C99 mode\r\nMain.c:6:2: note: use option -std=c99 or -std=gnu99 to compile your code\r\nMain.c:10:2: warning: incompatible implicit declaration of built-in function ''printf''\r\n', 0, 0, 2, 1, '2010-09-16 09:32:30', '0001-01-01 00:00:00'),
(424, 6, 336, 2, '#include <iostream>\r\n#include <stdio.h>\r\n#include <bitset>\r\n#include <algorithm>\r\nusing namespace std;\r\nconst int N = 50050;\r\nstruct Node\r\n{\r\n    int a,b;\r\n}que[N];\r\nint n;\r\n\r\nint f2(int num)\r\n{\r\n    bitset<32> bs(num);\r\n    return bs.count();\r\n}\r\n\r\nvoid init()\r\n{\r\n	int u,v;\r\n    for(int i=0;i<n;++i)\r\n	{\r\n	    scanf("%d",&u);\r\n		v=f2(u);\r\n		que[i].a=u,que[i].b=v;\r\n	}\r\n}\r\n\r\nbool cmp(const Node& x,const Node& y)\r\n{\r\n    if(x.b!=y.b) return x.b<y.b;\r\n	else         return x.a<y.a;\r\n}\r\n\r\nvoid solve()\r\n{\r\n	int i;\r\n    if(n>0)\r\n	{\r\n	  init();\r\n	  sort(que,que+n,cmp);\r\n	  for(i=0;i<(n-1);++i)\r\n		  printf("%d ",que[i].a);\r\n	  printf("%d\\n",que[i].a);\r\n	}\r\n	else if(n==0) printf("\\n");\r\n}\r\n\r\nint main()\r\n{\r\n	while(scanf("%d",&n)==1)\r\n	   solve();\r\n	return 0;\r\n}\r\n', '', 77, 774144, 1, 2, '2010-09-16 09:32:54', '0001-01-01 00:00:00'),
(425, 13, 335, 2, '#include <stdio.h>\r\n\r\nint main()\r\n{\r\n	unsigned int a,b,i=0;\r\n	int c[10];\r\n\r\n	while(scanf("%d%d",&a,&b)==2)\r\n	{\r\n        for(c[i]=0;a||b;a>>=1,b>>=1)\r\n		{\r\n			if(!((a&1)&&(b&1)))\r\n				c[i]++;\r\n		}\r\n\r\n		printf("%d",c[i]);\r\n		i++;\r\n	}\r\n\r\n	return 0;\r\n}\r\n', '', 0, 262144, 4, 1, '2010-09-16 09:36:48', '0001-01-01 00:00:00'),
(426, 8, 335, 2, '#include<stdio.h>\r\nint main()\r\n{\r\n	int a,b;\r\n	int c[100],i=0,j;\r\n	while(scanf("%d %d",&a,&b)==2)\r\n	{\r\n		int count=0;\r\n		a=a^b;\r\n		while(a!=0)\r\n		{\r\n			if((a&1)==1) count++;\r\n			a>>=1;\r\n		}\r\n		c[i++]=count;\r\n	}\r\n    for(j=0;j<i;j++)\r\n    	printf("%d\\n",c[j]);\r\n  	return 0;\r\n}\r\n\r\n', '', 0, 0, 2, 3, '2010-09-16 09:37:10', '0001-01-01 00:00:00'),
(427, 11, 335, 2, '#include <stdio.h>\r\n\r\nint f(int x,int y)\r\n{\r\n	int M = x^y;\r\n	int count = 0;\r\n	while(M != 0)\r\n	{\r\n		M &= (M-1);\r\n		count ++;\r\n	}\r\n	return count;\r\n}\r\nint main()\r\n{\r\n	int a,b;\r\n	while(2==scanf("%d%d",&a,&b))\r\n	{\r\n	printf("%d\\n", f(a,b)); \r\n	}\r\n	return 0;\r\n}', '', 78, 262144, 1, 1, '2010-09-16 09:39:42', '0001-01-01 00:00:00'),
(428, 8, 335, 2, '#include<stdio.h>\r\nint main()\r\n{\r\n	int a,b,d;\r\n	int c[100],i=0,j;\r\n	while(scanf("%d %d",&a,&b)==2)\r\n	{\r\n		int count=0;\r\n		d=a^b;\r\n		while(d!=0)\r\n		{\r\n			if((d&1)==1) count++;\r\n			d>>=1;\r\n		}\r\n		c[i++]=count;\r\n	}\r\n    for(j=0;j<i;j++)\r\n    	printf("%d\\n",c[j]);\r\n  	return 0;\r\n}\r\n\r\n', '', 100, 262144, 5, 1, '2010-09-16 09:39:45', '0001-01-01 00:00:00'),
(429, 9, 335, 2, '#include<stdio.h> \r\n#include<string.h> \r\n#include<math.h>\r\nint main() \r\n{ \r\nint a,x[30],i; \r\nscanf("%d",&a); \r\nfor(i=0;a!=0;i++) \r\n{ \r\nx[i]=a%2; \r\na=a/2; \r\n} \r\nfor(--i;i>=0;i--) \r\n{ \r\nprintf("%d",x[i]); \r\n}\r\n\r\n\r\nputchar(''\\n''); \r\nint b,m[30],l; \r\nscanf("%d",&b); \r\nfor(l=0;b!=0;l++) \r\n{ \r\nm[l]=b%2; \r\nb=b/2; \r\n} \r\nfor(--l;l>=0;l--) \r\n{ \r\nprintf("%d",m[l]); \r\n} \r\nputchar(''\\n''); \r\nint count=0;\r\nfor(int p=0;p<31;++p)\r\n{\r\n	while(x[p]!=m[p])\r\n		++count;\r\n}\r\nprintf("输出位数%d",count);\r\n\r\nreturn 0;\r\n}', 'Main.c: In function ''main'':\r\nMain.c:33:1: error: ''for'' loop initial declarations are only allowed in C99 mode\r\nMain.c:33:1: note: use option -std=c99 or -std=gnu99 to compile your code\r\n', 0, 0, 2, 1, '2010-09-16 09:40:08', '0001-01-01 00:00:00'),
(430, 22, 336, 2, '#include<stdio.h>\r\n#include<algorithm>\r\n#include<vector>\r\n\r\n#define POW(c) (1<<(c))\r\n#define MASK(c) (((unsigned long)-1) / (POW(POW(c)) + 1))\r\n#define ROUND(n, c) (((n) & MASK(c)) + ((n) >> POW(c) & MASK(c)))\r\n\r\nstd::vector<int> array;\r\n\r\nint bit_count(unsigned int n)\r\n{\r\nn = ROUND(n, 0);\r\nn = ROUND(n, 1);\r\nn = ROUND(n, 2);\r\nn = ROUND(n, 3);\r\nn = ROUND(n, 4);\r\nreturn n;\r\n}\r\n\r\nbool compare(const int& x,const int& y)\r\n{\r\n	int a,b;\r\n	a=bit_count(x);\r\n	b=bit_count(y);\r\n	if(a==b)\r\n		return x<y;\r\n	else\r\n		return a<b;\r\n}\r\n\r\nint main()\r\n{\r\n	int n,c,i;\r\n	while(scanf("%d",&n)==1)\r\n	{\r\n		for(i=0;i<n;i++)\r\n		{\r\n			scanf("%d",&c);\r\n			array.push_back(c);\r\n		}\r\n		std::sort(array.begin(),array.end(),compare);\r\n		n--;\r\n		for(i=0;i<n;i++)\r\n		{\r\n			printf("%d ",array[i]);\r\n		}\r\n		printf("%d\\n",array[n]);\r\n		array.clear();\r\n	}    \r\n	return 0;\r\n}', '', 31, 544768, 4, 2, '2010-09-16 09:42:48', '0001-01-01 00:00:00');
INSERT INTO `tbl_submitions` (`id`, `user_id`, `problem_id`, `exercise_id`, `source`, `result`, `used_time`, `used_memory`, `status`, `compiler_id`, `created`, `modified`) VALUES
(431, 25, 93, 0, '#include <iostream>\r\n#include <cstdio>\r\n#include <algorithm>\r\nusing namespace std;\r\ntypedef struct data{\r\n	int n;\r\n	int c;\r\n} Data;\r\nData a[50000];\r\n\r\nbool cmp(Data x,Data y)\r\n{\r\n	return x.n < y.n;\r\n} \r\nint main()\r\n{\r\n	int n,i,m;\r\n	while(scanf("%d%d",&m,&n) == 2){\r\n		if((m+n)==0)\r\n			printf("\\n");\r\n		else\r\n		{\r\n			for(i=0;i<m+n;i++)\r\n				scanf("%d%d",&a[i].n,&a[i].c);\r\n			sort(a,a+m+n,cmp);\r\n			for(i=0;i<m+n-1;i++)\r\n				printf("%d %d\\n",a[i].n,a[i].c);\r\n			printf("%d %d",a[i].n,a[i].c);\r\n		}\r\n\r\n	}\r\n	return 0;\r\n}', '', 0, 774144, 3, 2, '2010-09-16 09:43:37', '0001-01-01 00:00:00'),
(432, 19, 336, 2, '#include <iostream>\r\n#include <stdio.h>\r\n\r\nusing namespace std;\r\n\r\nint main(){\r\n	int n,a[50000],b[50000];\r\n	while(scanf("%d",&n)==1){\r\n		int i,j;\r\n		for(i=0;i!=n;i++){\r\n			scanf("%d",a+i);\r\n			int m=a[i];\r\n			for(b[i]=0;m;m&=m-1)\r\n				b[i]++;\r\n		}\r\n		for(i=0;i!=n;i++){\r\n			for(j=0;j!=n-i-1;j++)\r\n				if(b[j]>b[j+1]){\r\n					int c;\r\n					c=b[j+1],b[j+1]=b[j],b[j]=c;\r\n					c=a[j+1],a[j+1]=a[j],a[j]=c;\r\n				}\r\n				else if(b[j]==b[j+1])\r\n					if(a[j]>a[j+1]){\r\n						int c;\r\n					    c=a[j+1],a[j+1]=a[j],a[j]=c;\r\n					}\r\n		}\r\n		for(i=0;i!=n;i++){\r\n			if(i==0)\r\n				printf("%d",a[i]);\r\n			else\r\n				printf(" %d",a[i]);\r\n		}\r\n		printf("\\n");\r\n	}\r\n	return 0;\r\n}\r\n\r\n', '', 200, 733184, 5, 2, '2010-09-16 09:43:39', '0001-01-01 00:00:00'),
(433, 25, 93, 0, '#include <iostream>\r\n#include <cstdio>\r\n#include <algorithm>\r\nusing namespace std;\r\ntypedef struct data{\r\n	int n;\r\n	int c;\r\n} Data;\r\nData a[50000];\r\n\r\nbool cmp(Data x,Data y)\r\n{\r\n	return x.n < y.n;\r\n} \r\nint main()\r\n{\r\n	int n,i,m;\r\n	while(scanf("%d%d",&m,&n) == 2){\r\n		if((m+n)==0)\r\n			printf("\\n");\r\n		else\r\n		{\r\n			for(i=0;i<m+n;i++)\r\n				scanf("%d%d",&a[i].n,&a[i].c);\r\n			sort(a,a+m+n,cmp);\r\n			for(i=0;i<m+n-1;i++)\r\n				printf("%d %d\\n",a[i].n,a[i].c);\r\n			printf("%d %d",a[i].n,a[i].c);\r\n		}\r\n\r\n	}\r\n	return 0;\r\n}', '', 0, 774144, 3, 2, '2010-09-16 09:44:13', '0001-01-01 00:00:00'),
(434, 18, 335, 2, '#include<stdio.h>\r\n\r\nint main()\r\n{\r\n	int a,b,c;\r\n	while(1){\r\n	scanf("%d %d",&a,&b);\r\n	c=a^b;\r\n	int count=0;\r\n	while (c)\r\n	{\r\n    c&= c-1;\r\n    ++count;\r\n	}\r\n	printf("%d\\n",count);\r\n\r\n	}\r\n}', '', 100, 258048, 5, 1, '2010-09-16 09:44:23', '0001-01-01 00:00:00'),
(435, 25, 93, 0, '#include <iostream>\r\n#include <cstdio>\r\n#include <algorithm>\r\nusing namespace std;\r\ntypedef struct data{\r\n	int n;\r\n	int c;\r\n} Data;\r\nData a[50000];\r\n\r\nbool cmp(Data x,Data y)\r\n{\r\n	return x.n < y.n;\r\n} \r\nint main()\r\n{\r\n	int n,i,m;\r\n	while(scanf("%d%d",&m,&n) == 2){\r\n		if((m+n)==0)\r\n			printf("\\n");\r\n		else\r\n		{\r\n			for(i=0;i<m+n;i++)\r\n				scanf("%d%d",&a[i].n,&a[i].c);\r\n			sort(a,a+m+n,cmp);\r\n			for(i=0;i<m+n;i++)\r\n				printf("%d %d\\n",a[i].n,a[i].c);\r\n		}\r\n\r\n	}\r\n	return 0;\r\n}', '', 0, 774144, 1, 2, '2010-09-16 09:44:52', '0001-01-01 00:00:00'),
(436, 17, 335, 2, '#include<stdio.h>\r\nint bit_count( int n,int n1)\r\n{\r\n  \r\n  int count,cout1;\r\n  int num;\r\n  num=0; \r\n  count=cout1=0;\r\n  for(; n,n1; n >>= 1,n1>>=1)\r\n  {\r\n      count = n & 1;\r\n	  cout1 = n1 & 1;\r\n	  if(count^cout1!=0)\r\n		 num++;\r\n  }\r\n  return num;\r\n}\r\nint main()\r\n{\r\n	int fir,sec;\r\n	while(scanf("%d%d",&fir,&sec)==2){\r\n    printf("%d\\n", bit_count(fir,sec));\r\n	}\r\n	return 0;\r\n}', '', 100, 258048, 5, 1, '2010-09-16 09:45:20', '0001-01-01 00:00:00'),
(437, 18, 335, 2, '#include<stdio.h>\r\n\r\nint main()\r\n{\r\n	int a,b,c;\r\n	while(1){\r\n	scanf("%d  %d",&a,&b);\r\n	c=a^b;\r\n	int count=0;\r\n	while (c)\r\n	{\r\n    c&= c-1;\r\n    ++count;\r\n	}\r\n	printf("%d\\n",count);\r\n\r\n	}\r\n}', '', 100, 258048, 5, 1, '2010-09-16 09:46:12', '0001-01-01 00:00:00'),
(438, 22, 336, 2, '#include<stdio.h>\r\n#include<algorithm>\r\n#include<vector>\r\n\r\n#define POW(c) (1<<(c))\r\n#define MASK(c) (((unsigned long)-1) / (POW(POW(c)) + 1))\r\n#define ROUND(n, c) (((n) & MASK(c)) + ((n) >> POW(c) & MASK(c)))\r\n\r\nstd::vector<int> array;\r\n\r\nint bit_count(unsigned int n)\r\n{\r\nn = ROUND(n, 0);\r\nn = ROUND(n, 1);\r\nn = ROUND(n, 2);\r\nn = ROUND(n, 3);\r\nn = ROUND(n, 4);\r\nreturn n;\r\n}\r\n\r\nbool compare(const int& x,const int& y)\r\n{\r\n	int a,b;\r\n	a=bit_count(x);\r\n	b=bit_count(y);\r\n	if(a==b)\r\n		return x<y;\r\n	else\r\n		return a<b;\r\n}\r\n\r\nint main()\r\n{\r\n	int n,c,i;\r\n	while(scanf("%d",&n)==1)\r\n	{\r\n		for(i=0;i<n;i++)\r\n		{\r\n			scanf("%d",&c);\r\n			array.push_back(c);\r\n		}\r\n		std::sort(array.begin(),array.end(),compare);\r\n		n--;\r\n		for(i=0;i<n;i++)\r\n		{\r\n			printf("%d ",array[i]);\r\n		}\r\n		if(n>=0)printf("%d\\n",array[n]);\r\n		array.clear();\r\n	}    \r\n	return 0;\r\n}\r\n', '', 31, 544768, 3, 2, '2010-09-16 09:46:48', '0001-01-01 00:00:00'),
(439, 8, 335, 2, '#include<stdio.h>\r\nint main()\r\n{\r\n	int a,b;\r\n	int c[100],i=0,j;\r\n	while(scanf("%d %d",&a,&b)==2)\r\n	{\r\n		a=a^b;\r\n		for(int count=0;a;a>>=1)\r\n			count+=a&1;\r\n		c[i++]=count;\r\n	}\r\n    for(j=0;j<i;j++)\r\n    	printf("%d\\n",c[j]);\r\n  	return 0;\r\n}\r\n\r\n', 'Main.c: In function ''main'':\r\nMain.c:9:3: error: ''for'' loop initial declarations are only allowed in C99 mode\r\nMain.c:9:3: note: use option -std=c99 or -std=gnu99 to compile your code\r\n', 0, 0, 2, 1, '2010-09-16 09:47:15', '0001-01-01 00:00:00'),
(440, 17, 335, 2, '#include<stdio.h>\r\nint bit_count( int n,int n1)\r\n{\r\n  \r\n  int num;\r\n  num=0; \r\n\r\n  for(; n,n1; n >>= 1,n1>>=1)\r\n  {\r\n     \r\n	  if(n&1^n1&1!=0)\r\n		 num++;\r\n  }\r\n  return num;\r\n}\r\nint main()\r\n{\r\n	int fir,sec;\r\n	while(scanf("%d%d",&fir,&sec)==2){\r\n    printf("%d\\n", bit_count(fir,sec));\r\n	}\r\n	return 0;\r\n}', '', 100, 262144, 5, 1, '2010-09-16 09:48:09', '0001-01-01 00:00:00'),
(441, 16, 335, 2, '#include<stdio.h>\r\nint main(){\r\n	int a,b,c[20],m=0;\r\n	while(scanf("%d %d",&a,&b)==2){	\r\n		int x=a^b;	\r\n		int n;\r\n		for(n=0;x;x&= x-1)			\r\n				n++;\r\n		c[m]=n;\r\n		m++;}	\r\n	for(int i=0;i!=m;i++)\r\n		printf("%d\\n",c[i]);	\r\n	return 0;\r\n}', '', 15, 262144, 7, 2, '2010-09-16 09:49:04', '0001-01-01 00:00:00'),
(442, 16, 335, 2, '#include<stdio.h>\r\nint main(){\r\n	int a,b,c[20],m=0;\r\n	while(scanf("%d %d",&a,&b)==2){	\r\n		int x=a^b;	\r\n		int n;\r\n		for(n=0;x;x&= x-1)			\r\n				n++;\r\n		c[m]=n;\r\n		m++;}	\r\n	for(int i=0;i!=m;i++)\r\n		printf("%d\\n",c[i]);	\r\n	return 0;\r\n}', '', 15, 258048, 7, 2, '2010-09-16 09:51:04', '0001-01-01 00:00:00'),
(443, 23, 336, 2, '#include<stdio.h>\r\n#include<algorithm>\r\n\r\n#define POW(c) (1<<(c))\r\n#define MASK(c) (((unsigned long)-1) / (POW(POW(c)) + 1))\r\n#define ROUND(n, c) (((n) & MASK(c)) + ((n) >> POW(c) & MASK(c)))\r\n\r\nint bit_count(unsigned int n)\r\n{\r\nn = ROUND(n, 0);\r\nn = ROUND(n, 1);\r\nn = ROUND(n, 2);\r\nn = ROUND(n, 3);\r\nn = ROUND(n, 4);\r\nreturn n;\r\n}\r\nbool cmp(int a,int b){\r\n	return bit_count(a)<bit_count(b);\r\n}\r\nint a[50001];\r\nint main(){\r\n    int i,j=0;\r\n	\r\n	while(scanf("%d",&i)==1){\r\n		for(;j<i;j++)	scanf("%d",&a[j]);\r\n		std::sort(a,a+i,cmp);\r\n		printf("%d ", i);\r\n		for(j=0;j<i;j++) printf("%d ",a[j]);\r\n	}\r\n	return 0;\r\n}\r\n', '', 15, 454656, 4, 2, '2010-09-16 09:51:34', '0001-01-01 00:00:00'),
(444, 22, 336, 2, '#include<stdio.h>\r\n#include<algorithm>\r\n#include<vector>\r\n\r\n#define POW(c) (1<<(c))\r\n#define MASK(c) (((unsigned long)-1) / (POW(POW(c)) + 1))\r\n#define ROUND(n, c) (((n) & MASK(c)) + ((n) >> POW(c) & MASK(c)))\r\n\r\nstd::vector<int> array;\r\n\r\nint bit_count(unsigned int n)\r\n{\r\nn = ROUND(n, 0);\r\nn = ROUND(n, 1);\r\nn = ROUND(n, 2);\r\nn = ROUND(n, 3);\r\nn = ROUND(n, 4);\r\nreturn n;\r\n}\r\n\r\nbool compare(const int& x,const int& y)\r\n{\r\n	int a,b;\r\n	a=bit_count(x);\r\n	b=bit_count(y);\r\n	if(a==b)\r\n		return x<y;\r\n	else\r\n		return a<b;\r\n}\r\n\r\nint main()\r\n{\r\n	int n,c,i;\r\n	while(scanf("%d",&n)==1)\r\n	{\r\n		for(i=0;i<n;i++)\r\n		{\r\n			scanf("%d",&c);\r\n			array.push_back(c);\r\n		}\r\n		std::sort(array.begin(),array.end(),compare);\r\n		for(i=0;i<n;i++)\r\n		{\r\n			if(i)printf(" ");\r\n			printf("%d",array[i]);\r\n		}\r\n		printf("\\n");\r\n		array.clear();\r\n	}    \r\n	return 0;\r\n}', '', 139, 811008, 1, 2, '2010-09-16 09:53:14', '0001-01-01 00:00:00'),
(445, 15, 335, 2, '#include <stdio.h>\r\nint main()\r\n{\r\n\r\n	int M[32]={0}, N[32]={0};\r\n    int a,b;\r\n    \r\n    printf("请输入两个十进制数：");\r\n    scanf("%d%d",&a,&b);\r\n	\r\n    //scanf("%d%d",&c,&d);\r\n	\r\n    //scanf("%d%d",&e,&f);\r\n    int i=0;\r\n    while(a>=1)\r\n{\r\n    M[i]=a%2;\r\n    a=a/2;\r\n    ++i;\r\n}\r\n\r\n\r\n\r\n int j=0;\r\n while(b>=1)\r\n{\r\n  N[j]=b%2;\r\n  b=b/2;\r\n  ++j;\r\n}\r\n\r\n int w=0;\r\n if(i<=j)\r\n w=j;\r\nelse\r\n w=i;\r\nint q=0;\r\nfor(int v=0;v<=w;++v)\r\n{\r\n	while(M[v]!=N[v])\r\n    ++q;\r\n}\r\n\r\nprintf("需要改变%d位数：",q);\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nreturn 0;\r\n}', 'Main.c: In function ''main'':\r\nMain.c:38:1: error: ''for'' loop initial declarations are only allowed in C99 mode\r\nMain.c:38:1: note: use option -std=c99 or -std=gnu99 to compile your code\r\n', 0, 0, 2, 1, '2010-09-16 09:53:26', '0001-01-01 00:00:00'),
(446, 14, 336, 2, '#include<stdio.h>\r\n#include<stdlib.h>\r\n#define NUM 100\r\n\r\nstruct test\r\n{\r\n	int num;\r\n	int count;\r\n} numArray[NUM];\r\n\r\n\r\n\r\nint compare(const void *p1,const void *p2)\r\n{\r\n	if( ((test *)p1)-> count != ((test *)p2)->count )\r\n		return  ((test *)p1)-> count - ((test *)p2)-> count;\r\n	else \r\n		return ((test *)p1) ->num  - ((test *)p2)->num ;\r\n}\r\n\r\n\r\nint main()\r\n{\r\n	\r\n	int n=0;\r\n	while(scanf("%d",&n)!=EOF)\r\n	{\r\n		int i=0,testNum = 0;\r\n		for(;i<n;++i)\r\n		{\r\n			scanf("%d",&(numArray[i].num));\r\n			numArray[i].count =0;\r\n\r\n			testNum=numArray[i].num;\r\n			\r\n			for(int j=0;j<sizeof(int)*8;++j)\r\n			{	\r\n				if( ((unsigned)testNum % 2) == 1 )\r\n					++numArray[i].count;\r\n\r\n				testNum >>= 1;\r\n				\r\n	\r\n				if( testNum == 0)\r\n					break;\r\n			}\r\n\r\n		}\r\n\r\n\r\n\r\n        qsort(numArray,n,sizeof(numArray[0]),compare);\r\n		for(i=0;i<n;++i)\r\n			printf("%d ",numArray[i].num);\r\n\r\n		printf("\\n");\r\n\r\n	}\r\n	return 0;\r\n}\r\n\r\n', 'Main.c: In function ''compare'':\r\nMain.c:15:8: error: ''test'' undeclared (first use in this function)\r\nMain.c:15:8: note: each undeclared identifier is reported only once for each function it appears in\r\nMain.c:15:14: error: expected expression before '')'' token\r\nMain.c:15:38: error: expected expression before '')'' token\r\nMain.c:16:19: error: expected expression before '')'' token\r\nMain.c:16:42: error: expected expression before '')'' token\r\nMain.c:18:18: error: expected expression before '')'' token\r\nMain', 0, 0, 2, 1, '2010-09-16 09:53:42', '0001-01-01 00:00:00'),
(447, 20, 335, 2, '#include <stdio.h>\r\n\r\nint f(int a,int b)\r\n{\r\n	int m = a^b;\r\n	int count = 0;\r\n	while(m != 0)\r\n	{\r\n		m &= (m-1);\r\n		count ++;\r\n	}\r\n	return count;\r\n}\r\nint main()\r\n{\r\n	int a,b,c[100],n;\r\n	int i=0;\r\n	printf("Please enter two number:\\n");\r\n	while(scanf("%d\\t%d\\n",&a,&b)==2)\r\n	{\r\n			n = f(a,b);\r\n		c[i]=n;\r\n		i++;\r\n	}\r\n	printf("The number of byte you should change is:\\n"); \r\n	for(int j=0;j!=i;j++)\r\n		printf("%d\\n",c[j]);\r\n	return 0;\r\n}', 'Main.c: In function ''main'':\r\nMain.c:26:2: error: ''for'' loop initial declarations are only allowed in C99 mode\r\nMain.c:26:2: note: use option -std=c99 or -std=gnu99 to compile your code\r\n', 0, 0, 2, 1, '2010-09-16 09:54:24', '0001-01-01 00:00:00'),
(448, 20, 335, 2, '#include <stdio.h>\r\n\r\nint f(int a,int b)\r\n{\r\n	int m = a^b;\r\n	int count = 0;\r\n	while(m != 0)\r\n	{\r\n		m &= (m-1);\r\n		count ++;\r\n	}\r\n	return count;\r\n}\r\nint main()\r\n{\r\n	int a,b,c[100],n;\r\n	int i=0;\r\n	printf("Please enter two number:\\n");\r\n	while(scanf("%d\\t%d\\n",&a,&b)==2)\r\n	{\r\n			n = f(a,b);\r\n		c[i]=n;\r\n		i++;\r\n	}\r\n	printf("The number of byte you should change is:\\n"); \r\n	for(int j=0;j!=i;j++)\r\n		printf("%d\\n",c[j]);\r\n	return 0;\r\n}', '', 0, 262144, 4, 2, '2010-09-16 09:54:47', '0001-01-01 00:00:00'),
(449, 14, 336, 2, '#include<stdio.h>\r\n#include<stdlib.h>\r\n#define NUM 100\r\n\r\nstruct test\r\n{\r\n	int num;\r\n	int count;\r\n} numArray[NUM];\r\n\r\n\r\n\r\nint compare(const void *p1,const void *p2)\r\n{\r\n	if( ((struct test *)p1)-> count != ((struct test *)p2)->count )\r\n		return  ((struct test *)p1)-> count - ((struct test *)p2)-> count;\r\n	else \r\n		return ((struct test *)p1) ->num  - ((struct test *)p2)->num ;\r\n}\r\n\r\n\r\nint main()\r\n{\r\n	\r\n	int n=0;\r\n	while(scanf("%d",&n)!=EOF)\r\n	{\r\n		int i=0,testNum = 0;\r\n		for(;i<n;++i)\r\n		{\r\n			scanf("%d",&(numArray[i].num));\r\n			numArray[i].count =0;\r\n\r\n			testNum=numArray[i].num;\r\n			\r\n			for(int j=0;j<sizeof(int)*8;++j)\r\n			{	\r\n				if( ((unsigned)testNum % 2) == 1 )\r\n					++numArray[i].count;\r\n\r\n				testNum >>= 1;\r\n				\r\n	\r\n				if( testNum == 0)\r\n					break;\r\n			}\r\n\r\n		}\r\n\r\n\r\n\r\n        qsort(numArray,n,sizeof(numArray[0]),compare);\r\n		for(i=0;i<n;++i)\r\n			printf("%d ",numArray[i].num);\r\n\r\n		printf("\\n");\r\n\r\n	}\r\n	return 0;\r\n}\r\n\r\n', 'Main.c: In function ''main'':\r\nMain.c:36:4: error: ''for'' loop initial declarations are only allowed in C99 mode\r\nMain.c:36:4: note: use option -std=c99 or -std=gnu99 to compile your code\r\n', 0, 0, 2, 1, '2010-09-16 09:55:51', '0001-01-01 00:00:00'),
(450, 23, 336, 2, '#include<stdio.h>\r\n#include<algorithm>\r\n\r\n#define POW(c) (1<<(c))\r\n#define MASK(c) (((unsigned long)-1) / (POW(POW(c)) + 1))\r\n#define ROUND(n, c) (((n) & MASK(c)) + ((n) >> POW(c) & MASK(c)))\r\n\r\nint bit_count(unsigned int n)\r\n{\r\n	n = ROUND(n, 0);\r\n	n = ROUND(n, 1);\r\n	n = ROUND(n, 2);\r\n	n = ROUND(n, 3);\r\n	n = ROUND(n, 4);\r\n	return n;\r\n}\r\nbool cmp(int a,int b){\r\n	return bit_count(a)<bit_count(b);\r\n}\r\nint a[50001];\r\nint main(){\r\n    int i,j=0;\r\n	\r\n	while(scanf("%d",&i)==1){\r\n		for(;j<i;j++)	scanf("%d",&a[j]);\r\n		if(i){std::sort(a,a+i,cmp);\r\n		printf("%d ", i);\r\n		for(j=0;j<i;j++) printf("%d ",a[j]);\r\n		}\r\n	}\r\n	return 0;\r\n}\r\n\r\n', '', 15, 458752, 4, 2, '2010-09-16 09:56:28', '0001-01-01 00:00:00'),
(451, 14, 336, 2, '#include<stdio.h>\r\n#include<stdlib.h>\r\n#define NUM 100\r\n\r\nstruct test\r\n{\r\n	int num;\r\n	int count;\r\n} numArray[NUM];\r\n\r\n\r\n\r\nint compare(const void *p1,const void *p2)\r\n{\r\n	if( ((struct test *)p1)-> count != ((struct test *)p2)->count )\r\n		return  ((struct test *)p1)-> count - ((struct test *)p2)-> count;\r\n	else \r\n		return ((struct test *)p1) ->num  - ((struct test *)p2)->num ;\r\n}\r\n\r\n\r\nint main()\r\n{\r\n	\r\n	int n=0;\r\n	while(scanf("%d",&n)!=EOF)\r\n	{\r\n		int i=0,testNum = 0;\r\n		for(;i<n;++i)\r\n		{\r\n			int j=0;\r\n			scanf("%d",&(numArray[i].num));\r\n			numArray[i].count =0;\r\n\r\n			testNum=numArray[i].num;\r\n			\r\n			for(;j<sizeof(int)*8;++j)\r\n			{	\r\n				if( ((unsigned)testNum % 2) == 1 )\r\n					++numArray[i].count;\r\n\r\n				testNum >>= 1;\r\n				\r\n	\r\n				if( testNum == 0)\r\n					break;\r\n			}\r\n\r\n		}\r\n\r\n\r\n\r\n        qsort(numArray,n,sizeof(numArray[0]),compare);\r\n		for(i=0;i<n;++i)\r\n			printf("%d ",numArray[i].num);\r\n\r\n		printf("\\n");\r\n\r\n	}\r\n	return 0;\r\n}\r\n\r\n', '', 0, 262144, 7, 1, '2010-09-16 09:57:25', '0001-01-01 00:00:00'),
(452, 23, 336, 2, '#include<stdio.h>\r\n#include<algorithm>\r\n\r\n#define POW(c) (1<<(c))\r\n#define MASK(c) (((unsigned long)-1) / (POW(POW(c)) + 1))\r\n#define ROUND(n, c) (((n) & MASK(c)) + ((n) >> POW(c) & MASK(c)))\r\n\r\nint bit_count(unsigned int n)\r\n{\r\n	n = ROUND(n, 0);\r\n	n = ROUND(n, 1);\r\n	n = ROUND(n, 2);\r\n	n = ROUND(n, 3);\r\n	n = ROUND(n, 4);\r\n	return n;\r\n}\r\nbool cmp(int a,int b){\r\n	return bit_count(a)<bit_count(b);\r\n}\r\nunsigned int a[50001];\r\nint main(){\r\n    int i,j=0;\r\n	\r\n	while(scanf("%d",&i)==1){\r\n		for(;j<i;j++)	scanf("%d",&a[j]);\r\n		if(i){std::sort(a,a+i,cmp);\r\n		printf("%d ", i);\r\n		for(j=0;j<i;j++) printf("%d ",a[j]);\r\n		}\r\n	}\r\n	return 0;\r\n}', '', 31, 458752, 4, 2, '2010-09-16 09:59:19', '0001-01-01 00:00:00'),
(453, 14, 336, 2, '#include<stdio.h>\r\n#include<stdlib.h>\r\n#define NUM 50000\r\n\r\nstruct test\r\n{\r\n	int num;\r\n	int count;\r\n} numArray[NUM];\r\n\r\n\r\n\r\nint compare(const void *p1,const void *p2)\r\n{\r\n	if( ((struct test *)p1)-> count != ((struct test *)p2)->count )\r\n		return  ((struct test *)p1)-> count - ((struct test *)p2)-> count;\r\n	else \r\n		return ((struct test *)p1) ->num  - ((struct test *)p2)->num ;\r\n}\r\n\r\n\r\nint main()\r\n{\r\n	\r\n	int n=0;\r\n	while(scanf("%d",&n)!=EOF)\r\n	{\r\n		int i=0,testNum = 0;\r\n		for(;i<n;++i)\r\n		{\r\n			int j=0;\r\n			scanf("%d",&(numArray[i].num));\r\n			numArray[i].count =0;\r\n\r\n			testNum=numArray[i].num;\r\n			\r\n			for(;j<sizeof(int)*8;++j)\r\n			{	\r\n				if( ((unsigned)testNum % 2) == 1 )\r\n					++numArray[i].count;\r\n\r\n				testNum >>= 1;\r\n				\r\n	\r\n				if( testNum == 0)\r\n					break;\r\n			}\r\n\r\n		}\r\n\r\n\r\n\r\n        qsort(numArray,n,sizeof(numArray[0]),compare);\r\n		for(i=0;i<n;++i)\r\n			printf("%d ",numArray[i].num);\r\n\r\n		printf("\\n");\r\n\r\n	}\r\n	return 0;\r\n}\r\n\r\n', '', 0, 655360, 3, 1, '2010-09-16 09:59:54', '0001-01-01 00:00:00'),
(454, 14, 336, 2, '#include<stdio.h>\r\n#include<stdlib.h>\r\n#define NUM 50000\r\n\r\nstruct test\r\n{\r\n	int num;\r\n	int count;\r\n} numArray[NUM];\r\n\r\n\r\n\r\nint compare(const void *p1,const void *p2)\r\n{\r\n	if( ((struct test *)p1)-> count != ((struct test *)p2)->count )\r\n		return  ((struct test *)p1)-> count - ((struct test *)p2)-> count;\r\n	else \r\n		return ((struct test *)p1) ->num  - ((struct test *)p2)->num ;\r\n}\r\n\r\n\r\nint main()\r\n{\r\n	\r\n	int n=0;\r\n	while(scanf("%d",&n)!=EOF)\r\n	{\r\n		int i=0,testNum = 0;\r\n		for(;i<n;++i)\r\n		{\r\n			int j=0;\r\n			scanf("%d",&(numArray[i].num));\r\n			numArray[i].count =0;\r\n\r\n			testNum=numArray[i].num;\r\n			\r\n			for(;j<sizeof(int)*8;++j)\r\n			{	\r\n				if( ((unsigned)testNum % 2) == 1 )\r\n					++numArray[i].count;\r\n\r\n				testNum >>= 1;\r\n				\r\n	\r\n				if( testNum == 0)\r\n					break;\r\n			}\r\n\r\n		}\r\n\r\n\r\n\r\n        qsort(numArray,n,sizeof(numArray[0]),compare);\r\n		for(i=0;i<n;++i)\r\n		{\r\n			if(i!=0)\r\n				printf(" ");\r\n			\r\n			printf("%d",numArray[i].num);\r\n		}\r\n		printf("\\n");\r\n\r\n	}\r\n	return 0;\r\n}\r\n\r\n', '', 92, 659456, 1, 1, '2010-09-16 10:02:13', '0001-01-01 00:00:00'),
(455, 23, 336, 2, '#include<stdio.h>\r\n#include<algorithm>\r\n\r\n#define POW(c) (1<<(c))\r\n#define MASK(c) (((unsigned long)-1) / (POW(POW(c)) + 1))\r\n#define ROUND(n, c) (((n) & MASK(c)) + ((n) >> POW(c) & MASK(c)))\r\n\r\nint bit_count(unsigned int n)\r\n{\r\n	n = ROUND(n, 0);\r\n	n = ROUND(n, 1);\r\n	n = ROUND(n, 2);\r\n	n = ROUND(n, 3);\r\n	n = ROUND(n, 4);\r\n	return n;\r\n}\r\nbool cmp(int a,int b){\r\n	if(bit_count(a)==bit_count(b)) return a<=b;\r\n	else return bit_count(a)<bit_count(b);\r\n}\r\nunsigned int a[50001];\r\nint main(){\r\n    int i,j=0;\r\n	\r\n	while(scanf("%d",&i)==1){\r\n		for(;j<i;j++)	scanf("%d",&a[j]);\r\n		if(i){std::sort(a,a+i,cmp);\r\n		printf("%d ", i);\r\n		for(j=0;j<i;j++) printf("%d ",a[j]);\r\n		}\r\n	}\r\n	return 0;\r\n}\r\n\r\n\r\n\r\n', '', 31, 458752, 4, 2, '2010-09-16 10:05:40', '0001-01-01 00:00:00'),
(456, 20, 335, 2, '#include <stdio.h>\r\n\r\nint f(int a,int b)\r\n{\r\n	int m = a^b;\r\n	int count = 0;\r\n	while(m != 0)\r\n	{\r\n		m &= (m-1);\r\n		count ++;\r\n	}\r\n	return count;\r\n}\r\nint main()\r\n{\r\n	int a,b,c[100],n;\r\n	while(scanf("%d%d",&a,&b)==2)\r\n	{\r\n		n = f(a,b);\r\n		printf("%d\\n",n);\r\n	}\r\n	return 0;\r\n}', '', 62, 262144, 1, 2, '2010-09-16 10:06:12', '0001-01-01 00:00:00'),
(457, 23, 336, 2, '#include<stdio.h>\r\n#include<algorithm>\r\n\r\n#define POW(c) (1<<(c))\r\n#define MASK(c) (((unsigned long)-1) / (POW(POW(c)) + 1))\r\n#define ROUND(n, c) (((n) & MASK(c)) + ((n) >> POW(c) & MASK(c)))\r\n\r\nint bit_count(unsigned int n)\r\n{\r\n	n = ROUND(n, 0);\r\n	n = ROUND(n, 1);\r\n	n = ROUND(n, 2);\r\n	n = ROUND(n, 3);\r\n	n = ROUND(n, 4);\r\n	return n;\r\n}\r\nbool cmp(int a,int b){\r\n	if(bit_count(a)==bit_count(b)) return a<=b;\r\n	else return bit_count(a)<bit_count(b);\r\n}\r\nunsigned int a[50001];\r\nint main(){\r\n    int i,j=0;\r\n	\r\n	while(scanf("%d",&i)==1){\r\n		for(;j<i;j++)	scanf("%d",&a[j]);\r\n		if(i>1) std::sort(a,a+i,cmp);\r\n		printf("%d ", i);\r\n		for(j=0;j<i;j++) printf("%d ",a[j]);\r\n		\r\n	}\r\n	return 0;\r\n}\r\n\r\n\r\n\r\n', '', 31, 454656, 4, 2, '2010-09-16 10:07:05', '0001-01-01 00:00:00'),
(458, 23, 336, 2, '#include<stdio.h>\r\n#include<algorithm>\r\n\r\n#define POW(c) (1<<(c))\r\n#define MASK(c) (((unsigned long)-1) / (POW(POW(c)) + 1))\r\n#define ROUND(n, c) (((n) & MASK(c)) + ((n) >> POW(c) & MASK(c)))\r\n\r\nint bit_count(unsigned int n)\r\n{\r\n	n = ROUND(n, 0);\r\n	n = ROUND(n, 1);\r\n	n = ROUND(n, 2);\r\n	n = ROUND(n, 3);\r\n	n = ROUND(n, 4);\r\n	return n;\r\n}\r\nbool cmp(int a,int b){\r\n	if(bit_count(a)==bit_count(b)) return a<=b;\r\n	else return bit_count(a)<bit_count(b);\r\n}\r\nunsigned int a[50001];\r\nint main(){\r\n    int i,j;\r\n	\r\n	while(scanf("%d",&i)==1){\r\n		for(j=0;j<i;j++)	scanf("%d",&a[j]);\r\n		if(i>1) std::sort(a,a+i,cmp);\r\n		printf("%d ", i);\r\n		for(j=0;j<i;j++) printf("%d ",a[j]);\r\n		\r\n	}\r\n	return 0;\r\n}\r\n\r\n\r\n\r\n', '', 15, 458752, 4, 2, '2010-09-16 10:09:33', '0001-01-01 00:00:00'),
(459, 23, 336, 2, '#include<stdio.h>\r\n#include<algorithm>\r\n\r\n#define POW(c) (1<<(c))\r\n#define MASK(c) (((unsigned long)-1) / (POW(POW(c)) + 1))\r\n#define ROUND(n, c) (((n) & MASK(c)) + ((n) >> POW(c) & MASK(c)))\r\n\r\nint bit_count(unsigned int n)\r\n{\r\n	n = ROUND(n, 0);\r\n	n = ROUND(n, 1);\r\n	n = ROUND(n, 2);\r\n	n = ROUND(n, 3);\r\n	n = ROUND(n, 4);\r\n	return n;\r\n}\r\nbool cmp(int a,int b){\r\n	if(bit_count(a)==bit_count(b)) return a<b;\r\n	else return bit_count(a)<bit_count(b);\r\n}\r\nint a[50010];\r\nint main(){\r\n    int i,j;\r\n	\r\n	while(scanf("%d",&i)==1){\r\n		for(j=0;j<i;j++)	\r\n			scanf("%d",&a[j]);\r\n		\r\n		if(i>1) \r\n		{\r\n		   std::sort(a,a+i,cmp);\r\n		   for(j=0;j<(i-1);j++) \r\n			   printf("%d ",a[j]);\r\n		   printf("%d\\n",a[j]);\r\n		}\r\n		else if(i==1) printf("%d\\n",a[0]);\r\n		else if(i==0) printf("\\n");\r\n	}\r\n	return 0;\r\n}\r\n', '', 139, 458752, 1, 2, '2010-09-16 10:13:42', '0001-01-01 00:00:00'),
(460, 24, 335, 2, '#include <stdio.h>\r\n\r\nint bit_test(unsigned int n);\r\nint main()\r\n{\r\n	unsigned int i,j;\r\n	unsigned int m;\r\n 	int n,n1;\r\n 	while(scanf("%d  %d",&i,&j) != EOF)\r\n 	{\r\n	 	m = i ^ j;\r\n 		n = bit_test(m);\r\n	 	printf("%d\\n",n);\r\n 	}\r\n 	return 0;\r\n}\r\n\r\nint bit_test(unsigned int n)\r\n{\r\n 	int count;\r\n 	int count1;\r\n 	for(count = 0; n; n &= n - 1)\r\n 	{\r\n       	count++;\r\n	 }\r\n 	return count;\r\n}', '', 78, 262144, 1, 1, '2010-09-16 13:50:35', '0001-01-01 00:00:00'),
(461, 17, 335, 2, '#include <iostream>\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n	int i = 0, j = 0;\r\n	while(scanf("%d%d",&i,&j)==2){\r\n	i = i ^ j;\r\n	int num = 0;\r\n	while(i)\r\n	{\r\n		i &= (i - 1);\r\n		num++;\r\n	}\r\n	cout << num << endl;\r\n	}\r\n	return 0;\r\n}', 'Main.cpp: In function ''int main()'':\r\nMain.cpp:7:26: error: ''scanf'' was not declared in this scope\r\n', 0, 0, 2, 2, '2010-09-16 14:52:42', '0001-01-01 00:00:00'),
(462, 17, 335, 2, '#include <iostream>\r\n#include<stdio.h>\r\nusing namespace std;\r\nint main()\r\n{\r\n	int i = 0, j = 0;\r\n	while(scanf("%d%d",&i,&j)==2){\r\n	i = i ^ j;\r\n	int num = 0;\r\n	while(i)\r\n	{\r\n		i &= (i - 1);\r\n		num++;\r\n	}\r\n	cout << num << endl;\r\n	}\r\n	return 0;\r\n}', '', 93, 368640, 1, 2, '2010-09-16 14:53:59', '0001-01-01 00:00:00'),
(463, 8, 335, 2, '#include<stdio.h>\r\nint main()\r\n{\r\n	int a,b;\r\n	while(scanf("%d%d",&a,&b)==2)\r\n	{\r\n		int count=0;\r\n		a=a^b;\r\n		while(a)\r\n		{\r\n			a=a&(a-1);\r\n			count++;\r\n		}\r\n		printf("%d\\n",count);\r\n	}   	\r\n  	return 0;\r\n}\r\n', '', 78, 258048, 1, 1, '2010-09-16 15:03:21', '0001-01-01 00:00:00'),
(464, 8, 336, 2, '#include<stdio.h>\r\nint countnumber(int n)\r\n{\r\n		int count=0;\r\n		while(n)\r\n		{\r\n			n=n&(n-1);\r\n			count++;\r\n		}\r\n  	return count;\r\n}\r\n\r\nint main()\r\n{\r\n	int n,i,j;\r\n	int c[50001],d[50001];\r\n	while(scanf("%d",&n)==1)\r\n	{\r\n		for(i=0;i<n;i++){\r\n			scanf("%d",&c[i]);\r\n		    d[i]=countnumber(c[i]);\r\n		}\r\n		for(i=1;i<n;i++)\r\n		{\r\n			for(j=0;j<n-i;j++)\r\n			{\r\n				if(d[j]>d[j+1]){\r\n				    int b=c[j];\r\n				    c[j]=c[j+1];\r\n			    	c[j+1]=b;\r\n				}\r\n			}\r\n		}\r\n		for(i=0;i<n;i++) printf("%d  ",c[i]);\r\n		printf("\\n");\r\n	}\r\n	return 0;\r\n}\r\n', '', 200, 622592, 5, 1, '2010-09-16 15:37:29', '0001-01-01 00:00:00'),
(465, 8, 336, 2, '#include<stdio.h>\r\nint countnumber(int n)\r\n{\r\n		int count=0;\r\n		while(n)\r\n		{\r\n			n=n&(n-1);\r\n			count++;\r\n		}\r\n  	return count;\r\n}\r\n\r\nint main()\r\n{\r\n	int n,i,j;\r\n	int c[50001],d[50001];\r\n	while(scanf("%d",&n)==1)\r\n	{\r\n		for(i=0;i<n;i++){\r\n			scanf("%d",&c[i]);\r\n		    d[i]=countnumber(c[i]);\r\n		}\r\n		for(i=1;i<n;i++)\r\n		{\r\n			for(j=0;j<n-i;j++)\r\n			{\r\n				if(d[j]>d[j+1]){\r\n				    int b=c[j];\r\n				    c[j]=c[j+1];\r\n			    	c[j+1]=b;\r\n					b=d[j];\r\n				    d[j]=d[j+1];\r\n			    	d[j+1]=b;\r\n				}\r\n			}\r\n		}\r\n		for(i=0;i<n;i++) printf("%d  ",c[i]);\r\n		printf("\\n");\r\n	}\r\n	return 0;\r\n}\r\n', '', 200, 622592, 5, 1, '2010-09-16 15:57:33', '0001-01-01 00:00:00'),
(466, 3, 43, 0, '#include<stdio.h>\r\nint main()\r\n{\r\n    int i,j,k,max;\r\n    scanf("%d%d%d",&i,&j,&k);\r\n    i>j?max=i:max=j; \r\n	max>k?max=max:max=k; \r\n    printf("%d\\n",max);\r\n    return 0;\r\n}', 'Main.c: In function ''main'':\r\nMain.c:6:5: error: lvalue required as left operand of assignment\r\nMain.c:7:2: error: lvalue required as left operand of assignment\r\n', 0, 0, 2, 1, '2010-09-16 18:55:11', '0001-01-01 00:00:00'),
(467, 3, 43, 0, '\r\n#include<stdio.h>\r\nint main()\r\n{\r\n    int i,j,k,max;\r\n    scanf("%d%d%d",&i,&j,&k);\r\n    i>j?max=i:max=j; \r\n	max>k?max=max:max=k; \r\n    printf("%d\\n",max);\r\n    return 0;\r\n}', 'Main.c: In function ''main'':\r\nMain.c:7:5: error: lvalue required as left operand of assignment\r\nMain.c:8:2: error: lvalue required as left operand of assignment\r\n', 0, 0, 2, 1, '2010-09-16 18:55:38', '0001-01-01 00:00:00'),
(468, 3, 43, 0, '\r\n#include<stdio.h>\r\nint main()\r\n{\r\n    int i,j,k,max;\r\n    scanf("%d%d%d",&i,&j,&k);\r\n    i>j?max=i:max=j; \r\n	max>k?max=max:max=k; \r\n    printf("%d\\n",max);\r\n    return 0;\r\n}', '', 0, 258048, 3, 2, '2010-09-16 18:55:53', '0001-01-01 00:00:00'),
(469, 3, 43, 0, '\r\n#include<iostream>\r\nusing namespace std;\r\nint main()\r\n{\r\n    int i,j,k,max;\r\n    cin>>i>>j>>k;\r\n    i>j?max=i:max=j; \r\n	max>k?max=max:max=k; \r\n    cout<<max<<endl;\r\n    return 0;\r\n}', '', 0, 368640, 3, 2, '2010-09-16 18:57:05', '0001-01-01 00:00:00'),
(470, 3, 43, 0, '\r\n#include<iostream>\r\nusing namespace std;\r\nint main()\r\n{\r\n    int i,j,k,max;\r\n    cin>>i>>j>>k;\r\n    i>j?max=i:max=j; \r\n	max>k?max=max:max=k; \r\n    cout<<max;\r\n    return 0;\r\n}', '', 0, 368640, 1, 2, '2010-09-16 18:57:18', '0001-01-01 00:00:00'),
(471, 3, 46, 0, '#include<iostream>\r\nusing namespace std;\r\nint main()\r\n{\r\n    double i,j;\r\n    cin>>i; \r\n    j=(i-32)*5.0/9;\r\n	cout<<"c="<<j<<endl;  \r\n	return 0;\r\n}', '', 15, 368640, 4, 2, '2010-09-16 19:00:44', '0001-01-01 00:00:00'),
(472, 3, 46, 0, '#include<stdio.h>\r\nint main()\r\n{\r\n    double i,j;\r\n    scanf("%lf",&i); \r\n    j=(i-32)*5.0/9;\r\n	printf("c=%.2lf\\n",j);  \r\n	return 0;\r\n}', '', 0, 258048, 3, 1, '2010-09-16 19:02:31', '0001-01-01 00:00:00'),
(473, 3, 46, 0, '#include<stdio.h>\r\nint main()\r\n{\r\n    double i,j;\r\n    scanf("%lf",&i); \r\n    j=(i-32)*5.0/9;\r\n	printf("c=%.2lf",j);  \r\n	return 0;\r\n}', '', 0, 258048, 1, 1, '2010-09-16 19:02:46', '0001-01-01 00:00:00'),
(474, 1, 337, 0, '#include <string.h>\r\n#include <stdio.h>\r\n/*\r\n矩阵最大的维数，比如你可能用到100*100的矩阵，那就定义这么大，虽然实际上用到的可能小一点。\r\n*/\r\n#define MAX_DIMENSION 104 \r\n/*\r\n矩阵每个元素的类型。\r\n*/\r\ntypedef unsigned int MATRIX_TYPE;\r\n/*\r\n矩阵乘法运算时和加法运算时，为避免溢出，在取模之前用这个类型暂存。\r\n*/\r\ntypedef long long MAX_INT_TYPE; //temporary var to avoid overflowing\r\n/*\r\n矩阵类型的定义。\r\n*/\r\ntypedef MATRIX_TYPE Matrix[MAX_DIMENSION][MAX_DIMENSION];\r\nMatrix gm[33];\r\nint isse[33];\r\n/*\r\n实际运算时矩阵的维数，注意在这个模板中这是全局变量，也就是说有矩阵的维数都是一样的。\r\n你可以在程序中设置，以符合你的需求，但是不能超过MAX_DIMENSION\r\n*/\r\nint ndim=MAX_DIMENSION;\r\n/*\r\n程序会判断是否需要取模，如果为<1的值，那么不取模运算，否则运算结果 矩阵加法 乘法中有取模。\r\n可在程序中设置这个变量的值\r\n*/\r\nunsigned int mod=1;//mod\r\nvoid m_zero(Matrix  x)\r\n{\r\n    memset(x, 0, sizeof(MATRIX_TYPE)*MAX_DIMENSION*MAX_DIMENSION);\r\n}\r\nvoid m_one(Matrix  x)\r\n{\r\n    int i;\r\n    m_zero(x);\r\n    for(i=0;i<ndim;++i)x[i][i]=1;\r\n}\r\nvoid m_copy(Matrix  src,Matrix  dest)\r\n{\r\n    memcpy(dest,src, sizeof(MATRIX_TYPE)*MAX_DIMENSION*MAX_DIMENSION);\r\n}\r\n//z=x+y;\r\nvoid m_add(Matrix  x,Matrix  y,Matrix  z)\r\n{\r\n    int i,j;\r\n    for(i=0;i<ndim;i++)\r\n        for(j=0;j<ndim;j++)\r\n            if(mod<=1)z[i][j]=x[i][j]+y[i][j];\r\n            else z[i][j]=(x[i][j]+(MAX_INT_TYPE)y[i][j])%mod;//module\r\n}\r\n//c=a*b\r\nvoid m_multiple(Matrix  a,Matrix b,Matrix c)\r\n{\r\n    int i,j,k;\r\n    MAX_INT_TYPE t;\r\n\r\n    for(i=0;i<ndim;i++)\r\n        for(j=0;j<ndim;j++)\r\n        {\r\n            t=0;\r\n            if(mod<=1)\r\n                for(k=0;k<ndim;k++) t+=a[i][k]*b[k][j];//module\r\n            else\r\n			{\r\n				MATRIX_TYPE *p=a[i];\r\n                for(k=0;k<ndim;k++,p++){\r\n                    t+=((*p)*(MAX_INT_TYPE)b[k][j])%mod;\r\n                }//module\r\n			}\r\n            c[i][j]=t%mod;\r\n        }\r\n}\r\n\r\n//y=x^n\r\nvoid m_pow_y(Matrix x, unsigned int n, unsigned * y, unsigned * yout)\r\n{\r\n    Matrix temp,temp_x;\r\n		\r\n		int i=1;\r\n    for(;n;)\r\n    {\r\n        if ((n & 1) != 0)\r\n        {\r\n        	int j=0,k=0;\r\n        	for(j=0;j<ndim;j++)\r\n        	{\r\n		        MAX_INT_TYPE t=0;\r\n				MATRIX_TYPE *p=gm[i][j],*yp=y;\r\n				for(k=0;k<ndim;k++,++p,++yp){\r\n					t+=(*p)*(MAX_INT_TYPE)(*yp)%mod;\r\n				}//module\r\n				yout[j]=t%mod;\r\n			}\r\n			memcpy(y,yout,ndim*sizeof(unsigned));\r\n        }\r\n        if ((n >>= 1))\r\n        {\r\n			if(!isse[i+1])\r\n			{\r\n	            m_multiple(gm[i],gm[i],gm[i+1]);\r\n				isse[i+1]=1;\r\n			}\r\n			i++;\r\n        }\r\n    }\r\n}\r\n\r\n\r\n#include <stdio.h>\r\n\r\n/*\r\nvoid output(Matrix  x)\r\n{\r\n    for(int i=0;i<ndim;++i)\r\n    {\r\n        for(int j=0;j<ndim;++j)\r\n            printf("%d ",x[i][j]);\r\n        printf("\\n");\r\n    }\r\n}\r\n*/\r\n\r\n//注意 矩阵大小设定成2X2修改文件头\r\n//#define MAX_DIMENSION 2\r\nvoid solve_hdu_1588()\r\n{\r\n    int k,b,n,M;\r\n	int j;\r\n\r\n	memset(isse,0,32*sizeof(int));\r\n    //Fib的矩阵\r\n    Matrix a,fb,fk,sum;\r\n	m_zero(a);\r\n	for(k=0;k<26;k++)\r\n	{\r\n		a[k][k+52+26]=1;\r\n		for(j=0;j<=k+26;j++)\r\n			a[k][j]=1;\r\n	}\r\n	for(k=26;k<52;k++)\r\n	{\r\n		a[k][k+26]=1;\r\n		for(j=51;j>=k-26;--j)\r\n			a[k][j]=1;\r\n	}\r\n	for(k=0;k<26;k++)\r\n	{\r\n		for(j=0;j<k+26;j++)\r\n			a[k+52][j+52]=1;\r\n	}\r\n	for(k=26;k<52;k++)\r\n	{\r\n		for(j=51;j>k-26;--j)\r\n			a[k+52][j+52]=1;\r\n	}\r\n	unsigned res[104],res2[104];\r\n	int icase;\r\n	scanf("%d",&icase);\r\n	m_one(gm[0]);\r\n	m_copy(a,gm[1]);\r\n	isse[0]=1;\r\n	isse[1]=1;\r\n    while(icase-- && scanf("%d",&n)==1)\r\n    {\r\n		int i;\r\n        mod=1000000007;\r\n		for(k=0;k<104;k++)\r\n		{\r\n			res[k]=(k<52)?0:1;\r\n		}\r\n        //计算a^b\r\n        m_pow_y(a,n-1,res,res2);\r\n			long long ret=0;\r\n			for(i=0;i<52;++i)\r\n			{\r\n					ret+=res[i];\r\n			}\r\n					ret%=mod;\r\n\r\n		printf("%lld\\n",ret);\r\n\r\n\r\n    }\r\n}\r\nint main()\r\n{\r\n\r\n    solve_hdu_1588();\r\n    return 0;\r\n}\r\n', '', 1902, 1912832, 1, 2, '2010-09-24 20:40:20', '0001-01-01 00:00:00'),
(475, 7, 2, 0, '/**********************************************************************\r\nAuthor: mwkfeng\r\nCreated Time: 2010-9-28 16:06\r\nLast Modified Time:\r\nFile Name: joj1002 Redraiment的遭遇.cpp\r\nDescription: \r\n**********************************************************************/\r\n\r\n#include<iostream>\r\n\r\nusing namespace std;\r\n\r\nchar close[66];\r\nint main()\r\n{\r\n    memset(close, 0, sizeof(close));\r\n    int top = 1;\r\n    int now = 0;\r\n    int tot = 0;\r\n    int i;\r\n    for(i = 1; i <= 62; i++)\r\n    {\r\n          now++;\r\n          if(now==top)\r\n          {\r\n                      close[i] = 1;\r\n                      top++;\r\n                      now = 0;\r\n                      tot++;\r\n          }\r\n    }   \r\n    int month, day;\r\n    while(scanf("%d/%d", &month, &day)==2)\r\n    {\r\n             if(month==0 && day==0)\r\n                    break;\r\n             \r\n             if(month < 7)\r\n                      printf("0\\n");\r\n             else if(month==7 || month==8)\r\n             {\r\n                  int tmp = (month-7)*31+day;\r\n                  int ans = 0;\r\n                  for(i = tmp; i <= 62 ;i++)\r\n                  {\r\n                        ans += close[i];\r\n                  }\r\n                  printf("%d\\n", ans);\r\n             }\r\n             else\r\n             {\r\n                 printf("%d\\n", tot);\r\n             }\r\n    }\r\n    return 0;\r\n}\r\n', 'Main.cpp: In function ''int main()'':\r\nMain.cpp:16:35: error: ''memset'' was not declared in this scope\r\nMain.cpp:33:38: error: ''scanf'' was not declared in this scope\r\nMain.cpp:39:35: error: ''printf'' was not declared in this scope\r\nMain.cpp:48:37: error: ''printf'' was not declared in this scope\r\nMain.cpp:52:36: error: ''printf'' was not declared in this scope\r\n', 0, 0, 2, 2, '2010-09-28 16:20:39', '0001-01-01 00:00:00'),
(476, 7, 2, 0, '/**********************************************************************\r\nAuthor: mwkfeng\r\nCreated Time: 2010-9-28 16:06\r\nLast Modified Time:\r\nFile Name: joj1002 Redraiment的遭遇.cpp\r\nDescription: \r\n**********************************************************************/\r\n\r\n#include<iostream>\r\n#include<cstdio>\r\n#include<cstdlib>\r\n#include<cstring>\r\n#include<cmath>\r\n#include<algorithm>\r\nusing namespace std;\r\n\r\nchar close[66];\r\nint main()\r\n{\r\n    memset(close, 0, sizeof(close));\r\n    int top = 1;\r\n    int now = 0;\r\n    int tot = 0;\r\n    int i;\r\n    for(i = 1; i <= 62; i++)\r\n    {\r\n          now++;\r\n          if(now==top)\r\n          {\r\n                      close[i] = 1;\r\n                      top++;\r\n                      now = 0;\r\n                      tot++;\r\n          }\r\n    }   \r\n    int month, day;\r\n    while(scanf("%d/%d", &month, &day)==2)\r\n    {\r\n             if(month==0 && day==0)\r\n                    break;\r\n             \r\n             if(month < 7)\r\n                      printf("0\\n");\r\n             else if(month==7 || month==8)\r\n             {\r\n                  int tmp = (month-7)*31+day;\r\n                  int ans = 0;\r\n                  for(i = tmp; i <= 62 ;i++)\r\n                  {\r\n                        ans += close[i];\r\n                  }\r\n                  printf("%d\\n", ans);\r\n             }\r\n             else\r\n             {\r\n                 printf("%d\\n", tot);\r\n             }\r\n    }\r\n    return 0;\r\n}\r\n', '', 0, 368640, 1, 2, '2010-09-28 16:21:37', '0001-01-01 00:00:00'),
(477, 7, 3, 0, '/**************************************************\r\nAuthor: mwkfeng\r\nCreate Time: 2010-9-28 16:28\r\nLast Modified Time: \r\nFile Name: joj0003 Assistance Required.cpp\r\nDescription:\r\n***************************************************/\r\n\r\n#include<stdio.h>\r\n#include<math.h>\r\n\r\n\r\n\r\nint main()\r\n{\r\n    Init();\r\n    int n;\r\n    while(scanf("%d", &n)==1)\r\n    {\r\n	if(n==0) break;\r\n	printf("%d\\n", prime[n]);\r\n    }\r\n    return 0;\r\n}', 'Main.cpp: In function ''int main()'':\r\nMain.cpp:16:10: error: ''Init'' was not declared in this scope\r\nMain.cpp:21:17: error: ''prime'' was not declared in this scope\r\n', 0, 0, 2, 2, '2010-09-28 19:38:17', '0001-01-01 00:00:00'),
(478, 7, 3, 0, '/**************************************************\r\nAuthor: mwkfeng\r\nCreate Time: 2010-9-28 16:28\r\nLast Modified Time: \r\nFile Name: joj0003 Assistance Required.cpp\r\nDescription:\r\n***************************************************/\r\n\r\n#include<cstdio>\r\n#include<cmath>\r\n#include<cstring>\r\n\r\nusing namespace std;\r\nconst int maxp = 30000;\r\nconst int maxn = 4050;\r\n\r\nchar del[maxp];\r\nint p[maxn];\r\nint np;\r\n\r\nvoid Init()\r\n{\r\n    memset(del, 0, sizeof(del));\r\n    np = 0;\r\n    int i, j;\r\n    for(i = 2; i < maxp; i++)\r\n    {\r\n	if(del[i]==0)\r\n	{\r\n	    np++;\r\n	    p[np] = i;\r\n	    int cnt = 0;\r\n	    for(j = i+1; j < maxp; j++)\r\n	    {\r\n		if(del[j]==0) cnt++;\r\n		if(cnt==i)\r\n		{\r\n		    cnt = 0;\r\n		    del[j] = 1;\r\n		}\r\n	    }\r\n	}\r\n    }\r\n    return ;\r\n}\r\n\r\nint main()\r\n{\r\n    Init();\r\n    int n;\r\n    while(scanf("%d", &n)==1)\r\n    {\r\n	if(n==0) break;\r\n	printf("%d\\n", p[n]);\r\n    }\r\n    return 0;\r\n}', '', 156, 307200, 4, 2, '2010-09-28 19:50:29', '0001-01-01 00:00:00'),
(479, 7, 3, 0, '/**************************************************\r\nAuthor: mwkfeng\r\nCreate Time: 2011-9-28 16:28\r\nLast Modified Time: \r\nFile Name: joj0003 Assistance Required.cpp\r\nDescription:\r\n***************************************************/\r\n\r\n#include<cstdio>\r\n#include<cmath>\r\n#include<cstring>\r\n\r\nusing namespace std;\r\nconst int maxp = 35000;\r\nconst int maxn = 4050;\r\n\r\nchar del[maxp];\r\nint p[maxn];\r\nint np;\r\n\r\nvoid Init()\r\n{\r\n    memset(del, 0, sizeof(del));\r\n    np = 0;\r\n    int i, j;\r\n    for(i = 2; i < maxp; i++)\r\n    {\r\n	if(del[i]==0)\r\n	{\r\n	    np++;\r\n	    p[np] = i;\r\n	    int cnt = 0;\r\n	    for(j = i+1; j < maxp; j++)\r\n	    {\r\n		if(del[j]==0) cnt++;\r\n		if(cnt==i)\r\n		{\r\n		    cnt = 0;\r\n		    del[j] = 1;\r\n		}\r\n	    }\r\n	}\r\n    }\r\n    return ;\r\n}\r\n\r\nint main()\r\n{\r\n    Init();\r\n    int n;\r\n    while(scanf("%d", &n)==1)\r\n    {\r\n	if(n==0) break;\r\n	printf("%d\\n", p[n]);\r\n    }\r\n    return 0;\r\n}', 'Main.c:9:17: fatal error: cstdio: No such file or directory\r\ncompilation terminated.\r\n', 0, 0, 2, 1, '2010-09-28 19:53:59', '0001-01-01 00:00:00'),
(480, 7, 3, 0, '/**************************************************\r\nAuthor: mwkfeng\r\nCreate Time: 2011-9-28 16:28\r\nLast Modified Time: \r\nFile Name: joj0003 Assistance Required.cpp\r\nDescription:\r\n***************************************************/\r\n\r\n#include<cstdio>\r\n#include<cmath>\r\n#include<cstring>\r\n\r\nusing namespace std;\r\nconst int maxp = 35000;\r\nconst int maxn = 4050;\r\n\r\nchar del[maxp];\r\nint p[maxn];\r\nint np;\r\n\r\nvoid Init()\r\n{\r\n    memset(del, 0, sizeof(del));\r\n    np = 0;\r\n    int i, j;\r\n    for(i = 2; i < maxp; i++)\r\n    {\r\n	if(del[i]==0)\r\n	{\r\n	    np++;\r\n	    p[np] = i;\r\n	    int cnt = 0;\r\n	    for(j = i+1; j < maxp; j++)\r\n	    {\r\n		if(del[j]==0) cnt++;\r\n		if(cnt==i)\r\n		{\r\n		    cnt = 0;\r\n		    del[j] = 1;\r\n		}\r\n	    }\r\n	}\r\n    }\r\n    return ;\r\n}\r\n\r\nint main()\r\n{\r\n    Init();\r\n    int n;\r\n    while(scanf("%d", &n)==1)\r\n    {\r\n	if(n==0) break;\r\n	printf("%d\\n", p[n]);\r\n    }\r\n    return 0;\r\n}', '', 234, 307200, 1, 2, '2010-09-28 19:54:26', '0001-01-01 00:00:00'),
(481, 7, 4, 0, '/**************************************************\r\nAuthor: mwkfeng\r\nCreate Time: 2010-9-28 20:04\r\nLast Modified Time:\r\nFile Name: joj0004 The Bottom of a Graph \r\nDescription:\r\n***************************************************/\r\n\r\n#include<cstdio>\r\n#include<cmath>\r\n#include<cstring>\r\n\r\nusing namespace std;\r\nconst int maxv = 5050;\r\nconst int maxe = 50050;\r\nstruct edge_t\r\n{\r\n    int s, t, next;\r\n};\r\nedge_t edge[maxe], redge[maxe];\r\nint head[maxv], rhead[maxv];\r\nint ne, nv;\r\n\r\nchar vstd[maxv];\r\n\r\nint ord[maxv];\r\nint nord;\r\nint grp[maxv];\r\nint ngrp;\r\n\r\nint ans[maxv];\r\nint nans;\r\n\r\nvoid DFS(int cur)\r\n{\r\n    vstd[cur] = 1;\r\n    for(int i = head[cur]; i != -1; i = edge[i].next)\r\n    {\r\n	int next = edge[i].t;\r\n	if(vstd[next]==0)\r\n	    DFS(next);\r\n    }\r\n    ord[++nord] = cur;\r\n}\r\n\r\nvoid RDFS(int cur)\r\n{\r\n    vstd[cur] = 1;\r\n    grp[cur] = ngrp;\r\n    for(int i = rhead[cur]; i != -1; i=redge[i].next)\r\n    {\r\n	int next = redge[i].t;\r\n	if(vstd[next]==0)\r\n	    RDFS(next);\r\n    }\r\n}\r\n\r\nvoid Kos()\r\n{\r\n    int i;\r\n    memset(vstd, 0, sizeof(vstd));\r\n    memset(ord, 0, sizeof(ord));\r\n    nord = 0;\r\n    for(i = 1; i <= nv; i++)\r\n    {\r\n	if(vstd[i]==0)\r\n	    DFS(i);\r\n    }\r\n    memset(vstd, 0, sizeof(vstd));\r\n    memset(grp, 0, sizeof(grp));\r\n    ngrp = 0;\r\n    for(i = nord; i >= 1; i--)\r\n    {\r\n	if(vstd[ord[i]]==0)\r\n	{\r\n	    ngrp++;\r\n	    RDFS(ord[i]);\r\n	}\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n    int i, j, s, t;\r\n    while(scanf("%d", &nv)==1)\r\n    {\r\n	if(nv==0)break;\r\n\r\n	scanf("%d", &ne);\r\n\r\n	memset(head, -1, sizeof(head));\r\n	memset(rhead, -1, sizeof(rhead));\r\n	for(i = 1; i <= ne; i++)\r\n	{\r\n	    scanf("%d %d", &s, &t);\r\n	    edge[i].s = s;\r\n	    edge[i].t = t;\r\n	    edge[i].next = head[s];\r\n	    head[s] = i;\r\n	    redge[i].s = t;\r\n	    redge[i].t = s;\r\n	    redge[i].next = rhead[t];\r\n	    rhead[t] = i;\r\n	}\r\n\r\n	Kos();\r\n	\r\n	memset(ans, 0, sizeof(ans));\r\n	nans = 0;\r\n	for(i = 1; i <= nv; i++)\r\n	{\r\n	    bool bl = true;\r\n	    for(j = head[i]; j != -1; j=edge[j].next)\r\n	    {\r\n		int next = edge[j].t;\r\n		if(grp[next]!=grp[i])\r\n		{\r\n		    bl = false;\r\n		    break;\r\n		}\r\n	    }\r\n	    if(bl)\r\n		ans[++nans] = i;\r\n	}\r\n\r\n	bool first = true;\r\n	for(i = 1; i <= nans; i++)\r\n	{\r\n	    if(first)\r\n		printf("%d", ans[i]), first = false;\r\n	    else\r\n		printf(" %d", ans[i]);\r\n	}\r\n	printf("\\n");\r\n    }\r\n    return 0;\r\n}', '', 46, 1646592, 4, 2, '2010-09-28 21:19:25', '0001-01-01 00:00:00'),
(482, 7, 4, 0, '/**************************************************\r\nAuthor: mwkfeng\r\nCreate Time: 2010-9-28 20:04\r\nLast Modified Time:\r\nFile Name: joj0004 The Bottom of a Graph \r\nDescription:\r\n***************************************************/\r\n\r\n#include<cstdio>\r\n#include<cmath>\r\n#include<cstring>\r\n\r\nusing namespace std;\r\nconst int maxv = 5050;\r\nconst int maxe = 500050;\r\nstruct edge_t\r\n{\r\n    int s, t, next;\r\n};\r\nedge_t edge[maxe], redge[maxe];\r\nint head[maxv], rhead[maxv];\r\nint ne, nv;\r\n\r\nchar vstd[maxv];\r\n\r\nint ord[maxv];\r\nint nord;\r\nint grp[maxv];\r\nint ngrp;\r\n\r\nint ans[maxv];\r\nint nans;\r\n\r\nvoid DFS(int cur)\r\n{\r\n    vstd[cur] = 1;\r\n    for(int i = head[cur]; i != -1; i = edge[i].next)\r\n    {\r\n	int next = edge[i].t;\r\n	if(vstd[next]==0)\r\n	    DFS(next);\r\n    }\r\n    ord[++nord] = cur;\r\n}\r\n\r\nvoid RDFS(int cur)\r\n{\r\n    vstd[cur] = 1;\r\n    grp[cur] = ngrp;\r\n    for(int i = rhead[cur]; i != -1; i=redge[i].next)\r\n    {\r\n	int next = redge[i].t;\r\n	if(vstd[next]==0)\r\n	    RDFS(next);\r\n    }\r\n}\r\n\r\nvoid Kos()\r\n{\r\n    int i;\r\n    memset(vstd, 0, sizeof(vstd));\r\n    memset(ord, 0, sizeof(ord));\r\n    nord = 0;\r\n    for(i = 1; i <= nv; i++)\r\n    {\r\n	if(vstd[i]==0)\r\n	    DFS(i);\r\n    }\r\n    memset(vstd, 0, sizeof(vstd));\r\n    memset(grp, 0, sizeof(grp));\r\n    ngrp = 0;\r\n    for(i = nord; i >= 1; i--)\r\n    {\r\n	if(vstd[ord[i]]==0)\r\n	{\r\n	    ngrp++;\r\n	    RDFS(ord[i]);\r\n	}\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n    int i, j, s, t;\r\n    while(scanf("%d", &nv)==1)\r\n    {\r\n	if(nv==0)break;\r\n\r\n	scanf("%d", &ne);\r\n\r\n	memset(head, -1, sizeof(head));\r\n	memset(rhead, -1, sizeof(rhead));\r\n	for(i = 1; i <= ne; i++)\r\n	{\r\n	    scanf("%d %d", &s, &t);\r\n	    edge[i].s = s;\r\n	    edge[i].t = t;\r\n	    edge[i].next = head[s];\r\n	    head[s] = i;\r\n	    redge[i].s = t;\r\n	    redge[i].t = s;\r\n	    redge[i].next = rhead[t];\r\n	    rhead[t] = i;\r\n	}\r\n\r\n	Kos();\r\n	\r\n	memset(ans, 0, sizeof(ans));\r\n	nans = 0;\r\n	for(i = 1; i <= nv; i++)\r\n	{\r\n	    bool bl = true;\r\n	    for(j = head[i]; j != -1; j=edge[j].next)\r\n	    {\r\n		int next = edge[j].t;\r\n		if(grp[next]!=grp[i])\r\n		{\r\n		    bl = false;\r\n		    break;\r\n		}\r\n	    }\r\n	    if(bl)\r\n		ans[++nans] = i;\r\n	}\r\n\r\n	bool first = true;\r\n	for(i = 1; i <= nans; i++)\r\n	{\r\n	    if(first)\r\n		printf("%d", ans[i]), first = false;\r\n	    else\r\n		printf(" %d", ans[i]);\r\n	}\r\n	printf("\\n");\r\n    }\r\n    return 0;\r\n}', '', 46, 12460032, 4, 2, '2010-09-28 21:29:14', '0001-01-01 00:00:00'),
(483, 7, 4, 0, '/**************************************************\r\nAuthor: mwkfeng\r\nCreate Time: 2010-9-28 20:04\r\nLast Modified Time:\r\nFile Name: joj0004 The Bottom of a Graph \r\nDescription:\r\n***************************************************/\r\n\r\n#include<cstdio>\r\n#include<cmath>\r\n#include<cstring>\r\n\r\nusing namespace std;\r\nconst int maxv = 5050;\r\nconst int maxe = 500050;\r\nstruct edge_t\r\n{\r\n    int s, t, next;\r\n};\r\nedge_t edge[maxe], redge[maxe];\r\nint head[maxv], rhead[maxv];\r\nint ne, nv;\r\n\r\nchar vstd[maxv];\r\nchar inv[maxv];\r\n\r\nint ord[maxv];\r\nint nord;\r\nint grp[maxv];\r\nint ngrp;\r\n\r\nint ans[maxv];\r\nint nans;\r\n\r\nvoid DFS(int cur)\r\n{\r\n    vstd[cur] = 1;\r\n    for(int i = head[cur]; i != -1; i = edge[i].next)\r\n    {\r\n	int next = edge[i].t;\r\n	if(vstd[next]==0)\r\n	    DFS(next);\r\n    }\r\n    ord[++nord] = cur;\r\n}\r\n\r\nvoid RDFS(int cur)\r\n{\r\n    vstd[cur] = 1;\r\n    grp[cur] = ngrp;\r\n    for(int i = rhead[cur]; i != -1; i=redge[i].next)\r\n    {\r\n	int next = redge[i].t;\r\n	if(vstd[next]==0)\r\n	    RDFS(next);\r\n    }\r\n}\r\n\r\nvoid Kos()\r\n{\r\n    int i;\r\n    memset(vstd, 0, sizeof(vstd));\r\n    memset(ord, 0, sizeof(ord));\r\n    nord = 0;\r\n    for(i = 1; i <= nv; i++)\r\n    {\r\n	if(vstd[i]==0)\r\n	    DFS(i);\r\n    }\r\n    memset(vstd, 0, sizeof(vstd));\r\n    memset(grp, 0, sizeof(grp));\r\n    ngrp = 0;\r\n    for(i = nord; i >= 1; i--)\r\n    {\r\n	if(vstd[ord[i]]==0)\r\n	{\r\n	    ngrp++;\r\n	    RDFS(ord[i]);\r\n	}\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n    int i, j, s, t;\r\n    while(scanf("%d", &nv)==1)\r\n    {\r\n	if(nv==0)break;\r\n\r\n	scanf("%d", &ne);\r\n\r\n	memset(head, -1, sizeof(head));\r\n	memset(rhead, -1, sizeof(rhead));\r\n	for(i = 1; i <= ne; i++)\r\n	{\r\n	    scanf("%d %d", &s, &t);\r\n	    edge[i].s = s;\r\n	    edge[i].t = t;\r\n	    edge[i].next = head[s];\r\n	    head[s] = i;\r\n	    redge[i].s = t;\r\n	    redge[i].t = s;\r\n	    redge[i].next = rhead[t];\r\n	    rhead[t] = i;\r\n	}\r\n\r\n	Kos();\r\n	\r\n	memset(ans, 0, sizeof(ans));\r\n	nans = 0;\r\n	memset(inv, 0, sizeof(inv));\r\n	for(i = 1; i <= nv; i++)\r\n	{\r\n	    for(j = head[i]; j != -1; j=edge[j].next)\r\n	    {\r\n		int next = edge[j].t;\r\n		if(grp[i]!=grp[next])\r\n		    inv[grp[i]] = 1;\r\n	    }\r\n	}\r\n	for(i = 1; i <= nv; i++)\r\n	{\r\n	    if(inv[grp[i]]==0)\r\n		ans[++nans] = i;\r\n	}\r\n\r\n	bool first = true;\r\n	for(i = 1; i <= nans; i++)\r\n	{\r\n	    if(first)\r\n		printf("%d", ans[i]), first = false;\r\n	    else\r\n		printf(" %d", ans[i]);\r\n	}\r\n	printf("\\n");\r\n    }\r\n    return 0;\r\n}', '', 31, 12472320, 1, 2, '2010-09-28 21:47:40', '0001-01-01 00:00:00'),
(484, 7, 335, 0, '#include<iostream>\r\n\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n  int a, b;\r\n  while(cin >> a >> b )\r\n  {\r\n      int len = 0;\r\n      int i;\r\n      for(i = 31; i >= 0; i--)\r\n      {\r\n	  if((1<<i)&a)\r\n	  {\r\n	      len = i;\r\n	      break;\r\n	  }\r\n      }\r\n      for(i = 31; i >= 0; i--)\r\n      {\r\n	  if((1<<i)&b)\r\n	  {\r\n	      if(i > len) len = i;\r\n	      break;\r\n	  }\r\n      }\r\n      long long t = a^b;\r\n      int cnt = 0;\r\n      for(i = 0; i <= len; i++)\r\n      {\r\n	  if((1<<i)&t)\r\n	  {\r\n	      cnt++;\r\n	  }\r\n      }\r\n      cout << cnt << endl;\r\n  }\r\n  return 0;\r\n}', '', 100, 368640, 5, 2, '2010-09-28 23:00:44', '0001-01-01 00:00:00');
INSERT INTO `tbl_submitions` (`id`, `user_id`, `problem_id`, `exercise_id`, `source`, `result`, `used_time`, `used_memory`, `status`, `compiler_id`, `created`, `modified`) VALUES
(485, 7, 335, 0, '#include<cstdio>\r\n\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n  int a, b;\r\n  while(scanf("%d %d", &a, &b)==2)\r\n  {\r\n      int len = 0;\r\n      int i;\r\n      for(i = 31; i >= 0; i--)\r\n      {\r\n	  if((1<<i)&a)\r\n	  {\r\n	      len = i;\r\n	      break;\r\n	  }\r\n      }\r\n      for(i = 31; i >= 0; i--)\r\n      {\r\n	  if((1<<i)&b)\r\n	  {\r\n	      if(i > len) len = i;\r\n	      break;\r\n	  }\r\n      }\r\n      long long t = a^b;\r\n      int cnt = 0;\r\n      for(i = 0; i <= len; i++)\r\n      {\r\n	  if((1<<i)&t)\r\n	  {\r\n	      cnt++;\r\n	  }\r\n      }\r\n	printf("%d\\n", cnt);\r\n  }\r\n  return 0;\r\n}', '', 78, 262144, 1, 2, '2010-09-28 23:02:17', '0001-01-01 00:00:00'),
(486, 7, 336, 0, '/**************************************************\r\nAuthor: mwkfeng\r\nCreate Time: 2010-9-28 23:00\r\nLast Modified Time: \r\nFile Name: joj0336_按1个数排序.cpp\r\nDescription:\r\n***************************************************/\r\n\r\n#include<cstdio>\r\n#include<algorithm>\r\n\r\nusing namespace std;\r\nconst int maxn = 50050;\r\n\r\nstruct nod_t\r\n{\r\n   int n;\r\n   int bits;\r\n};\r\nnod_t nod[maxn];\r\n\r\nint bitcnt(const int& n)\r\n{\r\n    int cnt = 0;\r\n    for(int i = 0; i < 32; i++)\r\n    {\r\n 	if((1<<i)&n)\r\n           cnt++;\r\n    }\r\n    return cnt;\r\n}\r\n\r\nbool cmp(const nod_t& a, const nod_t& b)\r\n{\r\n    if(a.bits < b.bits) return true;\r\n     if(a.bits == b.bits) \r\n     {\r\n	   if(a.n < b.n) return true;\r\n	}\r\n  return false;\r\n}\r\n\r\nint main()\r\n{ \r\n  int n;\r\n  int t;\r\n  int i;\r\n  while(scanf("%d", &n)==1)\r\n{\r\n     for(i = 0; i < n; i++)\r\n     {\r\n          scanf("%d", &t);\r\n          nod[i].n = t;\r\n          nod[i].bits = bitcnt(t);\r\n     }\r\n     sort(nod, nod+n, cmp);\r\n     \r\n     bool first = true;\r\n     for(i = 0; i < n; i++)\r\n     {\r\n          if(first)  printf("%d", nod[i].n), first = false;\r\n          else      printf(" %d", nod[i].n);\r\n     }\r\n     printf("\\n");\r\n}\r\n  return 0;\r\n}', '', 92, 659456, 1, 2, '2010-09-28 23:21:11', '0001-01-01 00:00:00'),
(487, 1, 338, 0, '#include <stdio.h>\r\n#include <iostream>\r\n#include <fstream>\r\n#include <time.h>\r\n#include <string.h>\r\n#include <algorithm>\r\nusing namespace std;\r\nint main(int argc, char* argv[])\r\n{\r\n	//freopen("c:/ti.txt","r",stdin);\r\n	//ofstream co("c:/to1.txt");\r\n	int n,k;\r\n	int count_i[1000];\r\n	while(scanf("%d%d",&n,&k)==2)\r\n	{\r\n		memset(count_i,0,sizeof(int)*1000);\r\n		int kn=0;\r\n		while(kn++<n)\r\n		{\r\n			int num;\r\n			scanf("%d",&num);\r\n			count_i[num]++;\r\n		}\r\n		kn=0;\r\n		int kmin=-1,kmax=-1;\r\n		for(int i=0;i<1000;++i)\r\n		{\r\n			kn+=count_i[i];\r\n			if(kmin<0 && kn>k) kmin=i;\r\n			if(kmax<0 && kn>(n-k)-1) kmax=i;\r\n		}\r\n		printf("%d\\n",kmax-kmin);\r\n\r\n	}\r\n	return 0;\r\n\r\n}', '', 374, 368640, 1, 2, '2010-09-29 21:27:26', '0001-01-01 00:00:00'),
(488, 1, 339, 0, '#include <stdio.h>\r\n#include <iostream>\r\n#include <fstream>\r\n#include <time.h>\r\n#include <algorithm>\r\n#include <vector>\r\n#include <functional>\r\nusing namespace std;\r\nint main(int argc, char* argv[])\r\n{\r\n	//gen_main();\r\n	//freopen("c:/ti.txt","r",stdin);\r\n	//freopen("c:/to.txt","w",stdout);\r\n	int n,k;\r\n	int i;\r\n	std::vector<int> nindex(100);\r\n	std::vector<int> nheap(100);\r\n	while(scanf("%d%d",&n,&k)==2)\r\n	{\r\n		nindex.resize(k);\r\n		int imax=-1;\r\n		for(i=0;i<k;++i)\r\n		{\r\n			scanf("%d",&(nindex[i]));\r\n			if(imax<nindex[i])imax=nindex[i];\r\n		}\r\n		nheap.resize(imax+2);\r\n\r\n		int num;\r\n		for(i=0;i<=imax;++i)\r\n		{\r\n			scanf("%d",&num);\r\n			*(nheap.begin()+i)=num;\r\n		}\r\n		make_heap(nheap.begin(),nheap.end()-1,greater<int>());\r\n		for(;i<n;++i)\r\n		{\r\n			scanf("%d",&num);\r\n			*(nheap.end()-1)=num;\r\n			push_heap(nheap.begin(),nheap.end(),greater<int>());\r\n			pop_heap(nheap.begin(),nheap.end(),greater<int>());\r\n		}\r\n\r\n		sort_heap(nheap.begin(),nheap.end()-1,greater<int>());\r\n\r\n		for(std::vector<int>::iterator itb=nindex.begin(),ite=nindex.end();itb!=ite;++itb)\r\n		{\r\n			printf("%d\\n",nheap[*itb]);\r\n		}\r\n	}\r\n	return 0;\r\n\r\n\r\n}', '', 499, 372736, 1, 2, '2010-09-29 23:23:13', '0001-01-01 00:00:00'),
(489, 1, 339, 0, '#include <stdio.h>\r\n#include <iostream>\r\n#include <fstream>\r\n#include <time.h>\r\n#include <algorithm>\r\n#include <vector>\r\n#include <functional>\r\nusing namespace std;\r\nint main(int argc, char* argv[])\r\n{\r\n	//gen_main();\r\n//	freopen("c:/ti.txt","r",stdin);\r\n//	freopen("c:/to1.txt","w",stdout);\r\n	int n,k;\r\n	int i;\r\n	std::vector<int> nindex(100);\r\n	std::vector<int> nheap(100);\r\n	while(scanf("%d%d",&n,&k)==2)\r\n	{\r\n		nindex.resize(k);\r\n		int imax=-1;\r\n		for(i=0;i<k;++i)\r\n		{\r\n			scanf("%d",&(nindex[i]));\r\n			if(imax<nindex[i])imax=nindex[i];\r\n		}\r\n		nheap.resize(n);\r\n\r\n		int num;\r\n		for(i=0;i<n;++i)\r\n		{\r\n			scanf("%d",&num);\r\n			*(nheap.begin()+i)=num;\r\n		}\r\n		sort(nheap.begin(),nheap.end(),greater<int>());\r\n		for(std::vector<int>::iterator itb=nindex.begin(),ite=nindex.end();itb!=ite;++itb)\r\n		{\r\n			printf("%d\\n",nheap[*itb]);\r\n		}\r\n	}\r\n	return 0;\r\n\r\n}', '', 311, 1261568, 1, 2, '2010-09-29 23:34:11', '0001-01-01 00:00:00'),
(490, 29, 1, 0, '#include<stdio.h>\r\nint main()\r\n{\r\nint a,b;\r\nwhile(scanf("%d%d",&a,&b)==2 )\r\n{\r\nprintf("%d\\n",a+b);\r\n}\r\nreturn 0;\r\n}', '', 0, 262144, 3, 1, '2010-09-29 23:50:51', '0001-01-01 00:00:00'),
(491, 29, 1, 0, '#include <stdio.h>\r\n\r\nint main()\r\n{\r\n    int a,b;\r\n    scanf("%d %d",&a, &b);\r\n    printf("%d\\n",a+b);\r\n    return 0;\r\n}', '', 0, 262144, 3, 1, '2010-09-29 23:51:43', '0001-01-01 00:00:00'),
(492, 27, 335, 2, '#include<stdio.h>\r\nint main()\r\n{\r\n	int a,b;\r\n	while(scanf("%d%d",&a,&b)==2)\r\n	{\r\n		int count=0;\r\n		a=a^b;\r\n		while(a)\r\n		{\r\n			a=a&(a-1);\r\n			count++;\r\n		}\r\n		printf("%d\\n",count);\r\n	}   	\r\n  	return 0;\r\n}\r\n', '', 78, 262144, 1, 1, '2010-09-30 08:10:37', '0001-01-01 00:00:00'),
(493, 17, 336, 2, '#include <iostream>\r\n#include <vector>\r\nusing namespace std;\r\n#define N 50000\r\n/* 统计一个整数的二进制序列中"1"的个数 */\r\nint getBitCount_method1( int n)\r\n{\r\nint count = 0;\r\nfor (int i = 1; i <= 32; ++i)\r\n{\r\n   if ( n & 0x00000001) //取n的二进制序列的最低位\r\n   {\r\n    ++count;\r\n   }\r\n   n = n >> 1;\r\n}\r\n\r\nreturn count;\r\n}\r\n\r\n\r\nvoid quickSort(int a[], int startIndex, int endIndex)\r\n{\r\nif ( endIndex <= startIndex )\r\n{\r\n   return;\r\n}\r\nif ( endIndex - startIndex == 1 )\r\n{\r\n   if ( a[startIndex] > a[endIndex] )\r\n   {\r\n    int tmp = a[startIndex];\r\n    a[startIndex] = a[endIndex];\r\n    a[endIndex] = tmp;\r\n   }\r\n   return;\r\n}\r\n\r\nint centerIndex = startIndex;\r\nint i = startIndex;\r\nint j = endIndex;\r\nwhile ( i <= j )\r\n{\r\n   while ( (i <= endIndex) && (a[i] <= a[centerIndex]) )\r\n   {\r\n    ++i;\r\n   }\r\n   while ( a[j] > a[centerIndex] )\r\n   {\r\n    --j;\r\n   }\r\n   if ( i <= j )\r\n   {\r\n    int tmp = a[i];\r\n    a[i] = a[j];\r\n    a[j] = tmp;\r\n   }\r\n}\r\nint tmp = a[j];\r\na[j] = a[centerIndex];\r\na[centerIndex] = tmp;\r\ncenterIndex = j;\r\nquickSort(a, startIndex, centerIndex -1);\r\nquickSort(a, centerIndex+1, endIndex);\r\n}\r\n\r\n/* 一种基数排序,这是33个vector，因为一个整数"1"的个数顶多为0~32 */\r\nvector<int> getSortVec(int a[], int count[], int n)\r\n{\r\nvector<int> rstVec;\r\nvector<int> vecArray[33]; \r\nfor (int i = 0; i < n; ++i)\r\n{\r\n   vecArray[count[i]].push_back(a[i]); \r\n}\r\n\r\n\r\nfor (int i = 0; i <= 32; ++i)\r\n{\r\n   for (int j = 0; j < vecArray[i].size(); ++j)\r\n   {\r\n    rstVec.push_back(vecArray[i][j]);\r\n   }\r\n}\r\n\r\nreturn rstVec;\r\n}\r\n\r\nint main()\r\n{\r\n    int n;\r\n    int i;\r\n    int a[N];\r\n    while(scanf("%d",&n)!=EOF)\r\n    {\r\n       for(i=0;i<n;i++)\r\n         scanf("%d",&a[i]);\r\nquickSort(a, 0, n-1); //首先进行快速排序(相当于基数排序的 辅助字段排序\r\nint count[N];\r\n\r\n//计算排好序的数组中每个数字二进制中"1"的个数\r\nfor (int i = 0; i < n; ++i)\r\n{\r\n   count[i] = getBitCount_method1(a[i]);\r\n}\r\n\r\nvector<int> rstVec = getSortVec(a, count, n);\r\n\r\nfor (int i = 0; i <rstVec.size(); ++i)\r\n{ \r\n	if(i==rstVec.size()-1)\r\n     cout << rstVec[i] ;\r\n   else \r\n    cout << rstVec[i] << " ";\r\n}\r\ncout << endl;\r\n\r\n}\r\nreturn 0;\r\n}\r\n', 'Main.cpp: In function ''int main()'':\r\nMain.cpp:94:24: error: ''scanf'' was not declared in this scope\r\nMain.cpp:94:27: error: ''EOF'' was not declared in this scope\r\n', 0, 0, 2, 2, '2010-09-30 08:17:09', '0001-01-01 00:00:00'),
(494, 17, 336, 2, '#include <iostream>\r\n#include <vector>\r\nusing namespace std;\r\n#define N 50000\r\n/* 统计一个整数的二进制序列中"1"的个数 */\r\nint getBitCount_method1( int n)\r\n{\r\nint count = 0;\r\nfor (int i = 1; i <= 32; ++i)\r\n{\r\n   if ( n & 0x00000001) //取n的二进制序列的最低位\r\n   {\r\n    ++count;\r\n   }\r\n   n = n >> 1;\r\n}\r\n\r\nreturn count;\r\n}\r\n\r\n\r\nvoid quickSort(int a[], int startIndex, int endIndex)\r\n{\r\nif ( endIndex <= startIndex )\r\n{\r\n   return;\r\n}\r\nif ( endIndex - startIndex == 1 )\r\n{\r\n   if ( a[startIndex] > a[endIndex] )\r\n   {\r\n    int tmp = a[startIndex];\r\n    a[startIndex] = a[endIndex];\r\n    a[endIndex] = tmp;\r\n   }\r\n   return;\r\n}\r\n\r\nint centerIndex = startIndex;\r\nint i = startIndex;\r\nint j = endIndex;\r\nwhile ( i <= j )\r\n{\r\n   while ( (i <= endIndex) && (a[i] <= a[centerIndex]) )\r\n   {\r\n    ++i;\r\n   }\r\n   while ( a[j] > a[centerIndex] )\r\n   {\r\n    --j;\r\n   }\r\n   if ( i <= j )\r\n   {\r\n    int tmp = a[i];\r\n    a[i] = a[j];\r\n    a[j] = tmp;\r\n   }\r\n}\r\nint tmp = a[j];\r\na[j] = a[centerIndex];\r\na[centerIndex] = tmp;\r\ncenterIndex = j;\r\nquickSort(a, startIndex, centerIndex -1);\r\nquickSort(a, centerIndex+1, endIndex);\r\n}\r\n\r\n/* 一种基数排序,这是33个vector，因为一个整数"1"的个数顶多为0~32 */\r\nvector<int> getSortVec(int a[], int count[], int n)\r\n{\r\nvector<int> rstVec;\r\nvector<int> vecArray[33]; \r\nfor (int i = 0; i < n; ++i)\r\n{\r\n   vecArray[count[i]].push_back(a[i]); \r\n}\r\n\r\n\r\nfor ( i = 0; i <= 32; ++i)\r\n{\r\n   for (int j = 0; j < vecArray[i].size(); ++j)\r\n   {\r\n    rstVec.push_back(vecArray[i][j]);\r\n   }\r\n}\r\n\r\nreturn rstVec;\r\n}\r\n\r\nint main()\r\n{\r\n    int n;\r\n	int i;\r\n    int a[N];\r\n    while(scanf("%d",&n)!=EOF)\r\n    {\r\n       for(i=0;i<n;i++)\r\n         scanf("%d",&a[i]);\r\nquickSort(a, 0, n-1); //首先进行快速排序(相当于基数排序的 辅助字段排序\r\nint count[N];\r\n\r\n//计算排好序的数组中每个数字二进制中"1"的个数\r\nfor ( i = 0; i < n; ++i)\r\n{\r\n   count[i] = getBitCount_method1(a[i]);\r\n}\r\n\r\nvector<int> rstVec = getSortVec(a, count, n);\r\n\r\nfor ( i = 0; i <rstVec.size(); ++i)\r\n{ \r\n	if(i==rstVec.size()-1)\r\n     cout << rstVec[i] ;\r\n   else \r\n    cout << rstVec[i] << " ";\r\n}\r\ncout << endl;\r\n\r\n}\r\nreturn 0;\r\n}\r\n', 'Main.cpp: In function ''std::vector<int> getSortVec(int*, int*, int)'':\r\nMain.cpp:78:7: error: name lookup of ''i'' changed for ISO ''for'' scoping\r\nMain.cpp:78:7: note: (if you use ''-fpermissive'' G++ will accept your code)\r\nMain.cpp: In function ''int main()'':\r\nMain.cpp:94:24: error: ''scanf'' was not declared in this scope\r\nMain.cpp:94:27: error: ''EOF'' was not declared in this scope\r\n', 0, 0, 2, 2, '2010-09-30 08:19:58', '0001-01-01 00:00:00'),
(495, 6, 338, 3, '#include <iostream>\r\n#include <stdio.h>\r\nusing namespace std;\r\n\r\n#define maxn 1<<15\r\nint n,k;\r\nint c[maxn];\r\n\r\nint lowbit(int x){\r\n    return x&-x;\r\n}\r\n\r\nvoid insert(int x,int t){\r\n       while(x<maxn){\r\n          c[x]+=t;\r\n          x+=lowbit(x);    \r\n       }\r\n}\r\nint find(int k){\r\n    int cnt=0,ans=0;\r\n    for(int i=15;i>=0;i--){\r\n        ans+=(1<<i);\r\n        if(ans>=maxn || cnt+c[ans]>=k)ans-=(1<<i);\r\n        else cnt+=c[ans];\r\n    }\r\n    return ans+1;\r\n}\r\nvoid input()\r\n{\r\n       int t;\r\n       if(n==1) \r\n       {\r\n          scanf("%d",&t);\r\n          printf("0\\n");\r\n       }\r\n       else\r\n       {\r\n          memset(c,0,sizeof(c));\r\n          for(int i=0;i<n;i++)\r\n          {    \r\n            scanf("%d",&t);\r\n            insert(t,1);\r\n          }\r\n          printf("%d\\n",find(k)-find(n-k+1));\r\n       }\r\n}\r\nint main()\r\n{\r\n    int cases;\r\n    while(scanf("%d%d",&n,&k)!=EOF)\r\n       input();\r\n    return 0;\r\n}', 'Main.cpp: In function ''void input()'':\r\nMain.cpp:38:31: error: ''memset'' was not declared in this scope\r\n', 0, 0, 2, 2, '2010-09-30 08:30:16', '0001-01-01 00:00:00'),
(496, 6, 338, 3, '#include <iostream>\r\n#include <stdio.h>\r\n#include <string.h>\r\nusing namespace std;\r\n\r\n#define maxn 1<<15\r\nint n,k;\r\nint c[maxn];\r\n\r\nint lowbit(int x){\r\n    return x&-x;\r\n}\r\n\r\nvoid insert(int x,int t){\r\n       while(x<maxn){\r\n          c[x]+=t;\r\n          x+=lowbit(x);    \r\n       }\r\n}\r\nint find(int k){\r\n    int cnt=0,ans=0;\r\n    for(int i=15;i>=0;i--){\r\n        ans+=(1<<i);\r\n        if(ans>=maxn || cnt+c[ans]>=k)ans-=(1<<i);\r\n        else cnt+=c[ans];\r\n    }\r\n    return ans+1;\r\n}\r\nvoid input()\r\n{\r\n       int t;\r\n       if(n==1) \r\n       {\r\n          scanf("%d",&t);\r\n          printf("0\\n");\r\n       }\r\n       else\r\n       {\r\n          memset(c,0,sizeof(c));\r\n          for(int i=0;i<n;i++)\r\n          {    \r\n            scanf("%d",&t);\r\n            insert(t,1);\r\n          }\r\n          printf("%d\\n",find(k)-find(n-k+1));\r\n       }\r\n}\r\nint main()\r\n{\r\n    int cases;\r\n    while(scanf("%d%d",&n,&k)!=EOF)\r\n       input();\r\n    return 0;\r\n}\r\n', '', 400, 495616, 5, 2, '2010-09-30 08:31:11', '0001-01-01 00:00:00'),
(497, 17, 338, 3, '#include <iostream>\r\n#include <vector>\r\nusing namespace std;\r\n#define N 50000\r\nvoid quickSort(int a[], int startIndex, int endIndex)\r\n{\r\nif ( endIndex <= startIndex )\r\n{\r\n   return;\r\n}\r\nif ( endIndex - startIndex == 1 )\r\n{\r\n   if ( a[startIndex] > a[endIndex] )\r\n   {\r\n    int tmp = a[startIndex];\r\n    a[startIndex] = a[endIndex];\r\n    a[endIndex] = tmp;\r\n   }\r\n   return;\r\n}\r\n\r\nint centerIndex = startIndex;\r\nint i = startIndex;\r\nint j = endIndex;\r\nwhile ( i <= j )\r\n{\r\n   while ( (i <= endIndex) && (a[i] <= a[centerIndex]) )\r\n   {\r\n    ++i;\r\n   }\r\n   while ( a[j] > a[centerIndex] )\r\n   {\r\n    --j;\r\n   }\r\n   if ( i <= j )\r\n   {\r\n    int tmp = a[i];\r\n    a[i] = a[j];\r\n    a[j] = tmp;\r\n   }\r\n}\r\nint tmp = a[j];\r\na[j] = a[centerIndex];\r\na[centerIndex] = tmp;\r\ncenterIndex = j;\r\nquickSort(a, startIndex, centerIndex -1);\r\nquickSort(a, centerIndex+1, endIndex);\r\n}\r\n\r\nint main()\r\n{\r\n    int n;\r\n	int i;\r\n	int k;\r\n    int a[N];\r\n    while(scanf("%d%d",&n,&k)!=EOF)\r\n    {\r\n       for(i=0;i<n;i++)\r\n         scanf("%d",&a[i]);\r\n       quickSort(a, 0, n-1); \r\n       cout << a[k-1]-a[n-k]<<endl;\r\n	}\r\nreturn 0;\r\n}\r\n', 'Main.cpp: In function ''int main()'':\r\nMain.cpp:56:29: error: ''scanf'' was not declared in this scope\r\nMain.cpp:56:32: error: ''EOF'' was not declared in this scope\r\n', 0, 0, 2, 2, '2010-09-30 08:39:11', '0001-01-01 00:00:00'),
(498, 6, 339, 3, '#include <iostream>\r\n#include <stdio.h>\r\n#include <string.h>\r\nusing namespace std;\r\n\r\n#define maxn 1<<13\r\nint n,r;\r\nint c[maxn],q[6000];\r\n\r\nint lowbit(int x){\r\n    return x&-x;\r\n}\r\n\r\nvoid insert(int x,int t){\r\n       while(x<maxn){\r\n          c[x]+=t;\r\n          x+=lowbit(x);    \r\n       }\r\n}\r\n\r\nint find(int k)\r\n{\r\n    int cnt=0,ans=0;\r\n    for(int i=13;i>=0;i--){\r\n        ans+=(1<<i);\r\n        if(ans>=maxn || cnt+c[ans]>=k)ans-=(1<<i);\r\n        else cnt+=c[ans];\r\n    }\r\n    return ans+1;\r\n}\r\n\r\nvoid input()\r\n{\r\n       int i,t;\r\n       for(i=0;i<r;++i)\r\n           scanf("%d",q+i);\r\n       memset(c,0,sizeof(c));\r\n       for(i=0;i<n;i++)\r\n       {    \r\n           scanf("%d",&t);\r\n           insert(t,1);\r\n       }\r\n       \r\n       for(i=0;i<r;++i)\r\n           printf("%d\\n",find(n-q[i]));\r\n}\r\nint main()\r\n{\r\n    while(scanf("%d%d",&n,&r)!=EOF)\r\n       input();\r\n    return 0;\r\n}', '', 600, 421888, 5, 2, '2010-09-30 08:39:35', '0001-01-01 00:00:00'),
(499, 14, 338, 3, '#include<stdio.h>\r\n\r\nint intarray[1001];\r\n\r\n\r\n\r\nint main()\r\n{\r\n	int n,k,num;\r\n	while( scanf("%d ",&n) )\r\n	{\r\n		int i,mincount=0,maxcount=0;\r\n		if(0 == n)\r\n			break;\r\n		scanf("%d",&k);\r\n		for(i=0;i<n;++i)\r\n		{	\r\n			scanf("%d",&num);\r\n			++intarray[num];\r\n		}\r\n\r\n		for(i=0;i<=n;++i)\r\n		{\r\n			mincount += intarray[i];\r\n			if(mincount >=k)\r\n			{\r\n				mincount=i;\r\n				break;\r\n			}\r\n		}\r\n		\r\n		for(i=999;i>=n;--i)\r\n		{\r\n			maxcount += intarray[i];\r\n			if(maxcount >=k)\r\n			{	\r\n				maxcount=i;\r\n				break;\r\n			}\r\n		}\r\n		printf("%d\\n",maxcount-mincount);\r\n	}\r\n\r\n	\r\n	\r\n	\r\n	\r\n	return 0;\r\n\r\n}', '', 400, 266240, 5, 1, '2010-09-30 08:41:30', '0001-01-01 00:00:00'),
(500, 17, 338, 3, '#include<stdio.h>\r\n#define N 50000\r\nvoid quickSort(int a[], int startIndex, int endIndex)\r\n{\r\nint tmp;\r\nint i,j;\r\nint centerIndex;\r\nif ( endIndex <= startIndex )\r\n{\r\n   return;\r\n}\r\nif ( endIndex - startIndex == 1 )\r\n{\r\n   if ( a[startIndex] > a[endIndex] )\r\n   {\r\n     tmp = a[startIndex];\r\n    a[startIndex] = a[endIndex];\r\n    a[endIndex] = tmp;\r\n   }\r\n   return;\r\n}\r\n\r\n centerIndex = startIndex;\r\n i = startIndex;\r\n j = endIndex;\r\nwhile ( i <= j )\r\n{\r\n   while ( (i <= endIndex) && (a[i] <= a[centerIndex]) )\r\n   {\r\n    ++i;\r\n   }\r\n   while ( a[j] > a[centerIndex] )\r\n   {\r\n    --j;\r\n   }\r\n   if ( i <= j )\r\n   {\r\n    int tmp = a[i];\r\n    a[i] = a[j];\r\n    a[j] = tmp;\r\n   }\r\n}\r\n tmp = a[j];\r\na[j] = a[centerIndex];\r\na[centerIndex] = tmp;\r\ncenterIndex = j;\r\nquickSort(a, startIndex, centerIndex -1);\r\nquickSort(a, centerIndex+1, endIndex);\r\n}\r\n\r\nint main()\r\n{\r\n    int n;\r\n	int i;\r\n	int k;\r\n    int a[N];\r\n    while(scanf("%d%d",&n,&k)!=EOF)\r\n    {\r\n       for(i=0;i<n;i++)\r\n         scanf("%d",&a[i]);\r\n       quickSort(a, 0, n-1); \r\n	   printf("%d\\n",a[k-1]-a[n-k]);\r\n	}\r\nreturn 0;\r\n}\r\n', '', 400, 421888, 5, 1, '2010-09-30 08:44:18', '0001-01-01 00:00:00'),
(501, 6, 339, 3, '#include <stdio.h>\r\n#include <string.h>\r\n\r\n#define low(x) x&(-x)\r\n#define maxn 1<<17\r\nint n,r;\r\nint c[maxn],q[110000];\r\n\r\nvoid insert(int x,int t)\r\n{\r\n       while(x<maxn)\r\n       {\r\n          c[x]+=t;\r\n          x+=low(x);    \r\n       }\r\n}\r\n\r\nint find(int k)\r\n{\r\n    int cnt=0,ans=0;\r\n    for(int i=17;i>=0;i--)\r\n    {\r\n        ans+=(1<<i);\r\n        if(ans>=maxn || cnt+c[ans]>=k)ans-=(1<<i);\r\n        else cnt+=c[ans];\r\n    }\r\n    return ans+1;\r\n}\r\n\r\nvoid input()\r\n{\r\n       int i,t;\r\n       for(i=0;i<r;++i) \r\n           scanf("%d",q+i);\r\n       memset(c,0,sizeof(c));\r\n       for(i=0;i<n;i++)\r\n       {    \r\n           scanf("%d",&t);\r\n           insert(t,1);\r\n       }\r\n       \r\n       for(i=0;i<r;++i)\r\n           printf("%d\\n",find(n-q[i]));\r\n}\r\nint main()\r\n{\r\n    while(scanf("%d%d",&n,&r)!=EOF)\r\n       input();\r\n    return 0;\r\n}', '', 0, 1224704, 7, 2, '2010-09-30 08:45:18', '0001-01-01 00:00:00'),
(502, 6, 339, 3, '#include <stdio.h>\r\n#include <string.h>\r\n\r\n#define low(x) x&(-x)\r\n#define maxn 1<<17\r\n#define N 110000\r\n\r\nint n,r;\r\nint c[maxn],q[N];\r\n\r\nvoid insert(int x,int t)\r\n{\r\n       while(x<maxn)\r\n       {\r\n          c[x]+=t;\r\n          x+=low(x);    \r\n       }\r\n}\r\n\r\nint find(int k)\r\n{\r\n    int cnt=0,ans=0;\r\n    for(int i=17;i>=0;i--)\r\n    {\r\n        ans+=(1<<i);\r\n        if(ans>=maxn || cnt+c[ans]>=k)ans-=(1<<i);\r\n        else cnt+=c[ans];\r\n    }\r\n    return ans+1;\r\n}\r\n\r\nvoid input()\r\n{\r\n       int i,t;\r\n       for(i=0;i<r;++i) \r\n           scanf("%d",q+i);\r\n       memset(c,0,sizeof(c));\r\n       for(i=0;i<n;i++)\r\n       {    \r\n           scanf("%d",&t);\r\n           insert(t,1);\r\n       }\r\n       \r\n       for(i=0;i<r;++i)\r\n           printf("%d\\n",find(n-q[i]));\r\n}\r\nint main()\r\n{\r\n    while(scanf("%d%d",&n,&r)!=EOF)\r\n       input();\r\n    return 0;\r\n}', '', 0, 1224704, 7, 2, '2010-09-30 08:47:24', '0001-01-01 00:00:00'),
(503, 25, 338, 3, '#include <iostream>\r\n#include <cstdio>\r\n#include <string>\r\n\r\nusing namespace std;\r\nint a[1001];\r\nint main()\r\n{\r\n	int i,k,n,num,l,s;\r\n	while(scanf("%d%d",&n,&k) == 2)\r\n	{\r\n		memset(&a,0,sizeof(a));\r\n		for(i = 0;i < n; i++)\r\n		{\r\n			scanf("%d",&num);\r\n			a[num]++;\r\n		}\r\n		num = i = 0;\r\n		while(num < k+1)\r\n			num += a[i++];\r\n		s = i-1;\r\n		num = 0;\r\n		i = 1000;\r\n		while(num < k+1)\r\n			num += a[i--];\r\n		l = i+1;\r\n		printf("%d\\n",l-s);\r\n	}\r\n\r\n	return 0;\r\n}', 'Main.cpp: In function ''int main()'':\r\nMain.cpp:12:24: error: ''memset'' was not declared in this scope\r\n', 0, 0, 2, 2, '2010-09-30 08:48:06', '0001-01-01 00:00:00'),
(504, 6, 339, 3, '#include <stdio.h>\r\n#include <string.h>\r\n\r\n#define low(x) x&(-x)\r\n#define maxn 1<<15\r\n#define N 110000\r\n\r\nint n,r;\r\nint c[maxn],q[N];\r\n\r\nvoid insert(int x,int t)\r\n{\r\n       while(x<maxn)\r\n       {\r\n          c[x]+=t;\r\n          x+=low(x);    \r\n       }\r\n}\r\n\r\nint find(int k)\r\n{\r\n    int cnt=0,ans=0;\r\n    for(int i=15;i>=0;i--)\r\n    {\r\n        ans+=(1<<i);\r\n        if(ans>=maxn || cnt+c[ans]>=k)ans-=(1<<i);\r\n        else cnt+=c[ans];\r\n    }\r\n    return ans+1;\r\n}\r\n\r\nvoid input()\r\n{\r\n       int i,t;\r\n       for(i=0;i<r;++i) \r\n           scanf("%d",q+i);\r\n       memset(c,0,sizeof(c));\r\n       for(i=0;i<n;i++)\r\n       {    \r\n           scanf("%d",&t);\r\n           insert(t,1);\r\n       }\r\n       \r\n       for(i=0;i<r;++i)\r\n           printf("%d\\n",find(n-q[i]));\r\n}\r\nint main()\r\n{\r\n    while(scanf("%d%d",&n,&r)!=EOF)\r\n       input();\r\n    return 0;\r\n}', '', 0, 827392, 7, 2, '2010-09-30 08:48:32', '0001-01-01 00:00:00'),
(505, 25, 338, 3, '#include <iostream>\r\n#include <cstdio>\r\n#include <cstring>\r\n\r\nusing namespace std;\r\nint a[1001];\r\nint main()\r\n{\r\n	int i,k,n,num,l,s;\r\n	while(scanf("%d%d",&n,&k) == 2)\r\n	{\r\n		memset(&a,0,sizeof(a));\r\n		for(i = 0;i < n; i++)\r\n		{\r\n			scanf("%d",&num);\r\n			a[num]++;\r\n		}\r\n		num = i = 0;\r\n		while(num < k+1)\r\n			num += a[i++];\r\n		s = i-1;\r\n		num = 0;\r\n		i = 1000;\r\n		while(num < k+1)\r\n			num += a[i--];\r\n		l = i+1;\r\n		printf("%d\\n",l-s);\r\n	}\r\n\r\n	return 0;\r\n}', '', 374, 372736, 1, 2, '2010-09-30 08:49:57', '0001-01-01 00:00:00'),
(506, 30, 338, 3, '#include <stdio.h>\r\nvoid main()\r\n{\r\n	int n,k,i,m;\r\n	int numl,nums;\r\n	while(scanf("%d %d",&n,&k)==2)\r\n	{\r\n	int num[1000]={0};\r\n	for(i=0;i<n;i++)\r\n	{\r\n		scanf("%d",&m);\r\n		num[m]++;\r\n	}\r\n	m=0;\r\n	for(i=1;;i++)\r\n	{\r\n		m+=num[i];\r\n		if(m>k)\r\n		{\r\n			nums=i;\r\n			break;\r\n		}\r\n	}\r\n	m=0;\r\n	for(i=999;;i--)\r\n	{\r\n		m+=num[i];\r\n		if(m>k)\r\n		{\r\n			numl=i;\r\n			break;\r\n		}\r\n	}\r\n	printf("%d\\n",numl-nums);\r\n	}\r\n}', 'Main.cpp:2:11: error: ''::main'' must return ''int''\r\n', 0, 0, 2, 2, '2010-09-30 08:53:30', '0001-01-01 00:00:00'),
(507, 30, 338, 3, '#include <stdio.h>\r\nint main()\r\n{\r\n	int n,k,i,m;\r\n	int numl,nums;\r\n	while(scanf("%d %d",&n,&k)==2)\r\n	{\r\n	int num[1000]={0};\r\n	for(i=0;i<n;i++)\r\n	{\r\n		scanf("%d",&m);\r\n		num[m]++;\r\n	}\r\n	m=0;\r\n	for(i=1;;i++)\r\n	{\r\n		m+=num[i];\r\n		if(m>k)\r\n		{\r\n			nums=i;\r\n			break;\r\n		}\r\n	}\r\n	m=0;\r\n	for(i=999;;i--)\r\n	{\r\n		m+=num[i];\r\n		if(m>k)\r\n		{\r\n			numl=i;\r\n			break;\r\n		}\r\n	}\r\n	printf("%d\\n",numl-nums);\r\n	}\r\n	return 0;\r\n}', '', 358, 258048, 4, 2, '2010-09-30 08:54:50', '0001-01-01 00:00:00'),
(508, 30, 338, 3, '#include <stdio.h>\r\nint main()\r\n{\r\n	int n,k,i,m;\r\n	int numl,nums;\r\n	while(scanf("%d %d",&n,&k)==2)\r\n	{\r\n	int num[1000]={0};\r\n	for(i=0;i<n;i++)\r\n	{\r\n		scanf("%d",&m);\r\n		num[m]++;\r\n	}\r\n	m=0;\r\n	for(i=1;;i++)\r\n	{\r\n		m+=num[i];\r\n		if(m>k)\r\n		{\r\n			nums=i;\r\n			break;\r\n		}\r\n	}\r\n	m=0;\r\n	for(i=999;;i--)\r\n	{\r\n		m+=num[i];\r\n		if(m>k)\r\n		{\r\n			numl=i;\r\n			break;\r\n		}\r\n	}\r\n	printf("%d\\n",numl-nums);\r\n	}\r\n	return 0;\r\n}', '', 374, 258048, 4, 2, '2010-09-30 08:56:07', '0001-01-01 00:00:00'),
(509, 6, 339, 3, '#include <iostream>\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <time.h>\r\n\r\n#define N 600005\r\nstruct Node\r\n{\r\n    int l,r;\r\n    int fix,key;\r\n    int cnt,size;\r\n}p[N];\r\nint root,mp;\r\nint n,r;\r\nint q[N];\r\n\r\nvoid update(int x)\r\n{\r\n    p[x].size=p[ p[x].l ].size+p[ p[x].r ].size+p[x].cnt;\r\n}\r\n\r\nvoid rot_l(int &x)\r\n{\r\n    int y=p[x].r;\r\n    p[x].r=p[y].l;\r\n    p[y].l=x;\r\n    update(x);\r\n    x=y;\r\n    update(y);\r\n}\r\n\r\nvoid rot_r(int &x)\r\n{\r\n    int y=p[x].l;\r\n    p[x].l=p[y].r;\r\n    p[y].r=x;\r\n    update(x);\r\n    x=y;\r\n    update(y);\r\n}\r\n\r\nvoid insert(int &k,int t)\r\n{\r\n    if(k==0)\r\n    {\r\n       k=++mp;\r\n       p[k].l=p[k].r=0;\r\n       p[k].key=t,p[k].fix=rand();\r\n       p[k].size=p[k].cnt=1;\r\n    }\r\n    else\r\n    {\r\n       if(t==p[k].key) p[k].cnt++;\r\n       else if(t<p[k].key)\r\n       {\r\n          insert(p[k].l,t);\r\n          if(p[ p[k].l ].fix>p[k].fix)\r\n             rot_r(k);\r\n       }\r\n       else \r\n       {\r\n          insert(p[k].r,t);\r\n          if(p[ p[k].r ].fix>p[k].fix )\r\n             rot_l(k);\r\n       }\r\n       update(k);\r\n    }\r\n}\r\n\r\nint find(int k,int r)\r\n{\r\n    if(r<=p[ p[k].l ].size) return find(p[k].l,r);\r\n    else if(r<=(p[p[k].l].size+p[k].cnt)) return p[k].key;\r\n    else return  find(p[k].r,r-p[p[k].l].size-p[k].cnt);\r\n}\r\n\r\nvoid init()\r\n{\r\n    int i,t;\r\n    srand(time(0));\r\n    root=mp=0;\r\n    for(i=0;i<r;++i)\r\n        scanf("%d",q+i);\r\n    for(i=0;i<n;++i)\r\n    {\r\n        scanf("%d",&t);\r\n        insert(root,t);\r\n    }\r\n}\r\n\r\nvoid solve()\r\n{\r\n    int i,cnt=0;\r\n    init();\r\n    for(i=0;i<r;++i)\r\n        printf("%d\\n",find(root,n-q[i]));\r\n    \r\n}\r\n    \r\nint main()\r\n{\r\n    while(scanf("%d %d",&n,&r)!=EOF)\r\n        solve();\r\n    return 0;\r\n}', '', 0, 16777216, 6, 2, '2010-09-30 08:57:37', '0001-01-01 00:00:00'),
(510, 6, 339, 3, '#include <iostream>\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <time.h>\r\n\r\n#define N 100100\r\nstruct Node\r\n{\r\n    int l,r;\r\n    int fix,key;\r\n    int cnt,size;\r\n}p[N];\r\nint root,mp;\r\nint n,r;\r\nint q[300];\r\n\r\nvoid update(int x)\r\n{\r\n    p[x].size=p[ p[x].l ].size+p[ p[x].r ].size+p[x].cnt;\r\n}\r\n\r\nvoid rot_l(int &x)\r\n{\r\n    int y=p[x].r;\r\n    p[x].r=p[y].l;\r\n    p[y].l=x;\r\n    update(x);\r\n    x=y;\r\n    update(y);\r\n}\r\n\r\nvoid rot_r(int &x)\r\n{\r\n    int y=p[x].l;\r\n    p[x].l=p[y].r;\r\n    p[y].r=x;\r\n    update(x);\r\n    x=y;\r\n    update(y);\r\n}\r\n\r\nvoid insert(int &k,int t)\r\n{\r\n    if(k==0)\r\n    {\r\n       k=++mp;\r\n       p[k].l=p[k].r=0;\r\n       p[k].key=t,p[k].fix=rand();\r\n       p[k].size=p[k].cnt=1;\r\n    }\r\n    else\r\n    {\r\n       if(t==p[k].key) p[k].cnt++;\r\n       else if(t<p[k].key)\r\n       {\r\n          insert(p[k].l,t);\r\n          if(p[ p[k].l ].fix>p[k].fix)\r\n             rot_r(k);\r\n       }\r\n       else \r\n       {\r\n          insert(p[k].r,t);\r\n          if(p[ p[k].r ].fix>p[k].fix )\r\n             rot_l(k);\r\n       }\r\n       update(k);\r\n    }\r\n}\r\n\r\nint find(int k,int r)\r\n{\r\n    if(r<=p[ p[k].l ].size) return find(p[k].l,r);\r\n    else if(r<=(p[p[k].l].size+p[k].cnt)) return p[k].key;\r\n    else return  find(p[k].r,r-p[p[k].l].size-p[k].cnt);\r\n}\r\n\r\nvoid init()\r\n{\r\n    int i,t;\r\n    srand(time(0));\r\n    root=mp=0;\r\n    for(i=0;i<r;++i)\r\n        scanf("%d",q+i);\r\n    for(i=0;i<n;++i)\r\n    {\r\n        scanf("%d",&t);\r\n        insert(root,t);\r\n    }\r\n}\r\n\r\nvoid solve()\r\n{\r\n    int i,cnt=0;\r\n    init();\r\n    for(i=0;i<r;++i)\r\n        printf("%d\\n",find(root,n-q[i]));\r\n    \r\n}\r\n    \r\nint main()\r\n{\r\n    while(scanf("%d %d",&n,&r)!=EOF)\r\n        solve();\r\n    return 0;\r\n}', '', 421, 2777088, 1, 2, '2010-09-30 08:58:49', '0001-01-01 00:00:00'),
(511, 21, 338, 3, '#include<stdio.h>\r\n\r\nvoid main()\r\n{int n,k;\r\nscanf("%d%d",&n,&k);\r\n\r\nint a[1000]={0};\r\nint b[1000]={0};\r\nint max=0,min=0;\r\n\r\nfor(int w=0;w<n;w++)\r\n{\r\nscanf("%d",&a[w]);\r\n}\r\n\r\n    for(int i=0; i<=k; i++)\r\n    {\r\n		//max\r\n        int j;\r\n        for (j=0; b[j] != 0; j++);\r\n        max = j++;\r\n        for(; j<n; j++)\r\n        {\r\n            if (b[j] == 0 && a[max] < a[j])\r\n            {\r\n                max = j;\r\n            }\r\n        }\r\n        b[max] = 1;\r\n	\r\n		//min\r\n		int l;\r\n        for (l=0; b[l] != 0; l++);\r\n        min = l++;\r\n        for(; l<n; l++)\r\n        {\r\n            if (b[l] == 0 && a[min] > a[l])\r\n            {\r\n                min = l;\r\n            }\r\n        }\r\n        b[min] = 1;\r\n    }\r\n    printf("%d\\n", a[max]-a[min]);\r\n}', 'Main.c: In function ''main'':\r\nMain.c:11:1: error: ''for'' loop initial declarations are only allowed in C99 mode\r\nMain.c:11:1: note: use option -std=c99 or -std=gnu99 to compile your code\r\nMain.c:16:5: error: ''for'' loop initial declarations are only allowed in C99 mode\r\n', 0, 0, 2, 1, '2010-09-30 09:02:19', '0001-01-01 00:00:00'),
(512, 30, 338, 3, '#include <stdio.h>\r\nint main()\r\n{\r\n	int n,k,i,m;\r\n	int numl,nums;\r\n	while(scanf("%d %d",&n,&k)==2)\r\n	{\r\n	int num[1000]={0};\r\n	for(i=0;i<n;i++)\r\n	{\r\n		scanf("%d",&m);\r\n		num[m]++;\r\n	}\r\n	m=0;\r\n	for(i=0;;i++)\r\n	{\r\n		m+=num[i];\r\n		if(m>k)\r\n		{\r\n			nums=i;\r\n			break;\r\n		}\r\n	}\r\n	m=0;\r\n	for(i=999;;i--)\r\n	{\r\n		m+=num[i];\r\n		if(m>k)\r\n		{\r\n			numl=i;\r\n			break;\r\n		}\r\n	}\r\n	printf("%d\\n",numl-nums);\r\n	}\r\n	return 0;\r\n}', '', 374, 258048, 1, 2, '2010-09-30 09:04:48', '0001-01-01 00:00:00'),
(513, 6, 338, 3, '#include <iostream>\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <time.h>\r\n\r\n#define N 100100\r\nstruct Node\r\n{\r\n    int l,r;\r\n    int fix,key;\r\n    int cnt,size;\r\n}p[N];\r\nint root,mp;\r\nint n,r;\r\n\r\nvoid update(int x)\r\n{\r\n    p[x].size=p[ p[x].l ].size+p[ p[x].r ].size+p[x].cnt;\r\n}\r\n\r\nvoid rot_l(int &x)\r\n{\r\n    int y=p[x].r;\r\n    p[x].r=p[y].l;\r\n    p[y].l=x;\r\n    update(x);\r\n    x=y;\r\n    update(y);\r\n}\r\n\r\nvoid rot_r(int &x)\r\n{\r\n    int y=p[x].l;\r\n    p[x].l=p[y].r;\r\n    p[y].r=x;\r\n    update(x);\r\n    x=y;\r\n    update(y);\r\n}\r\n\r\nvoid insert(int &k,int t)\r\n{\r\n    if(k==0)\r\n    {\r\n       k=++mp;\r\n       p[k].l=p[k].r=0;\r\n       p[k].key=t,p[k].fix=rand();\r\n       p[k].size=p[k].cnt=1;\r\n    }\r\n    else\r\n    {\r\n       if(t==p[k].key) p[k].cnt++;\r\n       else if(t<p[k].key)\r\n       {\r\n          insert(p[k].l,t);\r\n          if(p[ p[k].l ].fix>p[k].fix)\r\n             rot_r(k);\r\n       }\r\n       else \r\n       {\r\n          insert(p[k].r,t);\r\n          if(p[ p[k].r ].fix>p[k].fix )\r\n             rot_l(k);\r\n       }\r\n       update(k);\r\n    }\r\n}\r\n\r\nint find(int k,int r)\r\n{\r\n    if(r<=p[ p[k].l ].size) return find(p[k].l,r);\r\n    else if(r<=(p[p[k].l].size+p[k].cnt)) return p[k].key;\r\n    else return  find(p[k].r,r-p[p[k].l].size-p[k].cnt);\r\n}\r\n\r\nvoid init()\r\n{\r\n    int i,t;\r\n    srand(time(0));\r\n    root=mp=0;\r\n    for(i=0;i<n;++i)\r\n    {\r\n        scanf("%d",&t);\r\n        insert(root,t);\r\n    }\r\n}\r\n\r\nvoid solve()\r\n{\r\n    if(n==1) \r\n    {\r\n       int t;\r\n       scanf("%d",&t);\r\n       printf("0\\n");\r\n    }\r\n    else\r\n    {\r\n       init();\r\n       printf("%d\\n",find(root,r)-find(root,n-r+1)); \r\n    }\r\n}\r\n    \r\nint main()\r\n{\r\n    while(scanf("%d %d",&n,&r)!=EOF)\r\n        solve();\r\n    return 0;\r\n}', '', 400, 2772992, 5, 2, '2010-09-30 09:05:00', '0001-01-01 00:00:00'),
(514, 16, 335, 2, '#include<stdio.h>\r\nint main(){\r\n int a,b,c[20],m=0;\r\n while(scanf("%d %d",&a,&b)==2){ \r\n  int x=a^b; \r\n  int n;\r\n  for(n=0;x;x>>=1)\r\n	  n +=x&1;\r\n  c[m]=n;\r\n  m++;} \r\n for(int i=0;i!=m;i++)\r\n  printf("%d\\n",c[i]); \r\n return 0;\r\n}\r\n', '', 100, 262144, 5, 2, '2010-09-30 09:05:32', '0001-01-01 00:00:00'),
(515, 6, 338, 3, '#include <stdio.h>\r\n#include <string.h>\r\nint v[1005];\r\nint n,r;\r\n\r\nvoid init()\r\n{ \r\n    int i,t;\r\n    memset(v,0,sizeof(v));\r\n    for(i=0;i<n;++i)\r\n    {\r\n        scanf("%d",&t);\r\n        v[ t ]++;\r\n    }\r\n} \r\n\r\nvoid solve()\r\n{\r\n    if(n==1) \r\n    {\r\n       int t;\r\n       scanf("%d",&t);\r\n       printf("0\\n");\r\n    }\r\n    else\r\n    {\r\n       int cnt=0,t1,t2,i;\r\n       init();\r\n       for(i=1;i<=1000;++i)\r\n       {\r\n           cnt+=v[i];\r\n           if(cnt>=r)\r\n           {\r\n              t1=i;\r\n              break;\r\n           } \r\n       }\r\n       //printf("%d\\n",t1);\r\n       \r\n       cnt=0;\r\n       for(i=1000;i>=1;--i)\r\n       {\r\n           cnt+=v[i];\r\n           if(cnt>=r)\r\n           {\r\n              t2=i;\r\n              break;\r\n           } \r\n       }\r\n       //printf("%d\\n",t2);\r\n       printf("%d\\n",t1-t2);\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n    while(scanf("%d %d",&n,&r)!=EOF)\r\n       solve();\r\n    return 0;\r\n}', '', 390, 266240, 4, 2, '2010-09-30 09:13:08', '0001-01-01 00:00:00'),
(516, 6, 338, 3, '#include <stdio.h>\r\n#include <string.h>\r\nint v[1005];\r\nint n,r;\r\n\r\nvoid init()\r\n{ \r\n    int i,t;\r\n    memset(v,0,sizeof(v));\r\n    for(i=0;i<n;++i)\r\n    {\r\n        scanf("%d",&t);\r\n        v[ t ]++;\r\n    }\r\n} \r\n\r\nvoid solve()\r\n{\r\n    if(n==1) \r\n    {\r\n       int t;\r\n       scanf("%d",&t);\r\n       printf("0\\n");\r\n    }\r\n    else\r\n    {\r\n       int cnt=0,t1,t2,i;\r\n       init();\r\n       r++;\r\n       for(i=1;i<=1000;++i)\r\n       {\r\n           cnt+=v[i];\r\n           if(cnt>=r)\r\n           {\r\n              t1=i;\r\n              break;\r\n           } \r\n       }\r\n       \r\n       cnt=0;\r\n       for(i=1000;i>=1;--i)\r\n       {\r\n           cnt+=v[i];\r\n           if(cnt>=r)\r\n           {\r\n              t2=i;\r\n              break;\r\n           } \r\n       }\r\n       printf("%d\\n",t2-t1);\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n    while(scanf("%d %d",&n,&r)!=EOF)\r\n       solve();\r\n    return 0;\r\n}', '', 374, 266240, 4, 2, '2010-09-30 09:18:49', '0001-01-01 00:00:00'),
(517, 30, 339, 3, '#include <stdio.h>\r\nvoid swap(int &x, int &y)\r\n{\r\n    int temp = x;\r\n    x = y;\r\n    y = temp;\r\n}\r\n \r\nvoid Adjust(int *a, int parent, int high)\r\n{\r\n    int l = 2 * parent + 1;\r\n    int r = l + 1;\r\n    int flag = parent;\r\n \r\n    if (l<=high && a[l]>a[flag]) {\r\n        flag = l;\r\n    }\r\n    if (r<=high && a[r]>a[flag]) {\r\n        flag = r;\r\n    }\r\n    if (flag != parent) {\r\n        swap(a[parent], a[flag]);\r\n        Adjust(a, flag, high);\r\n    }\r\n}\r\n \r\nvoid HeapSort(int *a, int n)\r\n{\r\n    int i;\r\n \r\n    for (i=n-1; i>=0; i--) {\r\n        Adjust(a, i, n - 1);\r\n    }\r\n    for (i=n-1; i>=0; i--) {\r\n        swap(a[0], a[i]);\r\n        Adjust(a, 0, i - 1);\r\n    }\r\n}  \r\n\r\nint main(){\r\n	int n,r,i;\r\n	while(scanf("%d %d",&n,&r)==2)\r\n	{\r\n		int num[100000],R[200];\r\n		for(i=0;i<r;i++)\r\n			scanf("%d",R+i);\r\n		for(i=0;i<n;i++)\r\n			scanf("%d",num+i);\r\n		HeapSort(num,n);\r\n		for(i=0;i<r;i++)\r\n			printf("%d\\n",num[n-R[i]-1]);\r\n	}\r\n	return 0;\r\n}\r\n', '', 0, 626688, 7, 2, '2010-09-30 09:19:42', '0001-01-01 00:00:00'),
(518, 6, 338, 3, '#include <stdio.h>\r\n#include <string.h>\r\nint v[1005];\r\nint n,r;\r\n\r\nvoid init()\r\n{ \r\n    int i,t;\r\n    memset(v,0,sizeof(v));\r\n    for(i=0;i<n;++i)\r\n    {\r\n        scanf("%d",&t);\r\n        v[ t ]++;\r\n    }\r\n} \r\n\r\nvoid solve()\r\n{\r\n\r\n       int cnt=0,t1,t2,i;\r\n       init();\r\n       r++;\r\n       for(i=0;i<=1000;++i)\r\n       {\r\n           cnt+=v[i];\r\n           if(cnt>=r)\r\n           {\r\n              t1=i;\r\n              break;\r\n           } \r\n       }\r\n       \r\n       cnt=0;\r\n       for(i=1000;i>=0;--i)\r\n       {\r\n           cnt+=v[i];\r\n           if(cnt>=r)\r\n           {\r\n              t2=i;\r\n              break;\r\n           } \r\n       }\r\n       printf("%d\\n",t2-t1);\r\n\r\n}\r\n\r\nint main()\r\n{\r\n    while(scanf("%d %d",&n,&r)!=EOF)\r\n       solve();\r\n    return 0;\r\n}', '', 374, 266240, 1, 2, '2010-09-30 09:22:18', '0001-01-01 00:00:00'),
(519, 25, 339, 3, '#include <iostream>\r\n#include <cstdio>\r\n#include <cstring>\r\n#include <algorithm>\r\n\r\nusing namespace std;\r\n\r\nint a[100001];\r\nint r[201];\r\nint cmp(const void* x,const void* y)\r\n{\r\n	return *(int*)y - *(int*)x;\r\n}\r\n\r\nint main()\r\n{\r\n	int i,k,n;\r\n	while(scanf("%d%d",&n,&k) == 2)\r\n	{\r\n		memset(&a,0,sizeof(a));\r\n		memset(&r,0,sizeof(r));\r\n		for(i = 0;i < k; i++)\r\n			scanf("%d",&r[i]);\r\n		for(i = 0;i < n; i++)\r\n			scanf("%d",&a[i]);\r\n		qsort(&a,n,sizeof(int),&cmp);\r\n		for(i = 0; i < k; i++)\r\n			printf("%d\\n",a[r[i]]);\r\n	}\r\n\r\n	return 0;\r\n}', '', 78, 770048, 7, 2, '2010-09-30 09:23:57', '0001-01-01 00:00:00'),
(520, 30, 339, 3, '#include <stdio.h>\r\nint num[100000];\r\nvoid swap(int &x, int &y)\r\n{\r\n    int temp = x;\r\n    x = y;\r\n    y = temp;\r\n}\r\n \r\nvoid Adjust(int *a, int parent, int high)\r\n{\r\n    int l = 2 * parent + 1;\r\n    int r = l + 1;\r\n    int flag = parent;\r\n \r\n    if (l<=high && a[l]>a[flag]) {\r\n        flag = l;\r\n    }\r\n    if (r<=high && a[r]>a[flag]) {\r\n        flag = r;\r\n    }\r\n    if (flag != parent) {\r\n        swap(a[parent], a[flag]);\r\n        Adjust(a, flag, high);\r\n    }\r\n}\r\n \r\nvoid HeapSort(int *a, int n)\r\n{\r\n    int i;\r\n \r\n    for (i=n-1; i>=0; i--) {\r\n        Adjust(a, i, n - 1);\r\n    }\r\n    for (i=n-1; i>=0; i--) {\r\n        swap(a[0], a[i]);\r\n        Adjust(a, 0, i - 1);\r\n    }\r\n}  \r\n\r\nint main(){\r\n	int n,r,i;\r\n	while(scanf("%d %d",&n,&r)==2)\r\n	{\r\n		int R[200];\r\n		for(i=0;i<r;i++)\r\n			scanf("%d",R+i);\r\n		for(i=0;i<n;i++)\r\n			scanf("%d",num+i);\r\n		HeapSort(num,n);\r\n		for(i=0;i<r;i++)\r\n			printf("%d\\n",num[n-R[i]-1]);\r\n	}\r\n	return 0;\r\n}\r\n', '', 15, 659456, 7, 2, '2010-09-30 09:27:37', '0001-01-01 00:00:00'),
(521, 25, 339, 3, '#include <iostream>\r\n#include <cstdio>\r\n#include <cstring>\r\n#include <algorithm>\r\n\r\nusing namespace std;\r\n\r\nint a[100001];\r\nint r[201];\r\nint cmp(const void* x,const void* y)\r\n{\r\n	return *(int*)y - *(int*)x;\r\n}\r\n\r\nint main()\r\n{\r\n	int i,k,n;\r\n	while(scanf("%d%d",&n,&k) == 2)\r\n	{\r\n		memset(&a,0,sizeof(a));\r\n		memset(&r,0,sizeof(r));\r\n		for(i = 0;i < k; i++)\r\n			scanf("%d",&r[i]);\r\n		for(i = 0;i < n; i++)\r\n			scanf("%d",&a[i]);\r\n		qsort(&a,n-1,sizeof(int),&cmp);\r\n		for(i = 0; i < k; i++)\r\n			printf("%d\\n",a[r[i]]);\r\n	}\r\n\r\n	return 0;\r\n}', '', 78, 765952, 7, 2, '2010-09-30 09:28:57', '0001-01-01 00:00:00'),
(522, 22, 338, 3, '#include<stdio.h>\r\n#include<cstring>\r\n\r\n#define N 1001\r\n\r\nint c[N];\r\n\r\nint main()\r\n{\r\n	long n,k,min,max;\r\n	int x,i;\r\n	while(scanf("%ld%ld",&n,&k)==2)\r\n	{\r\n		memset(&c,0,sizeof(c));\r\n		for(i=0;i<n;i++)\r\n		{\r\n			scanf("%d",&x);\r\n			c[x]++;\r\n		}\r\n		max=min=0;\r\n		i=0;\r\n		while(1)\r\n		{\r\n			min+=c[i];\r\n			if(min>k)break;\r\n			i++;\r\n		}\r\n		min=i;\r\n		i=N;\r\n		while(1)\r\n		{\r\n			max+=c[i];\r\n			if(max>k)break;\r\n			i--;\r\n		}\r\n		max=i;\r\n		printf("%ld\\n",max-min);\r\n	}\r\n	return 0;			\r\n}\r\n', '', 374, 266240, 1, 2, '2010-09-30 09:33:23', '0001-01-01 00:00:00'),
(523, 23, 338, 3, '#include<stdio.h>\r\n#include<cstring>\r\n\r\nint num[5010],count[1001];\r\nint main(){\r\n	memset(&count,0,sizeof(count));\r\n	int n,k,m,j;\r\n	scanf("%d%d",&n,&k);\r\n	for(int i=0;i<n;i++){\r\n		scanf("%d",&num[i]);\r\n		count[num[i]]++;\r\n	}\r\n	m=k,j=1000,i=0;\r\n	while(m)\r\n		if(count[j--]!=0) m--;\r\n	while(k)\r\n		if(count[i++]!=0) k--;\r\n\r\n	printf("%d",j-i+2);\r\n	return 0;\r\n}', 'Main.cpp: In function ''int main()'':\r\nMain.cpp:13:13: error: name lookup of ''i'' changed for ISO ''for'' scoping\r\nMain.cpp:13:13: note: (if you use ''-fpermissive'' G++ will accept your code)\r\n', 0, 0, 2, 2, '2010-09-30 09:33:56', '0001-01-01 00:00:00'),
(524, 30, 339, 3, '#include <stdio.h>\r\n#include <algorithm>\r\nint num[100000];\r\nint main()\r\n{\r\n	int n,r,i;\r\n	while(scanf("%d %d",&n,&r)==2)\r\n	{\r\n		int R[200];\r\n		for(i=0;i<r;i++)\r\n			scanf("%d",R+i);\r\n		for(i=0;i<n;i++)\r\n			scanf("%d",num+i);\r\n		std::sort(num,num+n);\r\n		for(i=0;i<r;i++)\r\n			printf("%d\\n",num[n-1-R[i]]);\r\n	}\r\n	return 0;\r\n}\r\n\r\n', '', 0, 655360, 7, 2, '2010-09-30 09:35:35', '0001-01-01 00:00:00'),
(525, 14, 338, 3, '#include<stdio.h>\r\n\r\nint intarray[1001];\r\n\r\n\r\n\r\nint main()\r\n{\r\n	int n,k,num;\r\n	while( scanf("%d ",&n) )\r\n	{\r\n		int i,mincount=0,maxcount=0;\r\n		\r\n		if(0 == n)\r\n			break;\r\n		scanf("%d",&k);\r\n		for(i=0;i<n;++i)\r\n		{	\r\n			scanf("%d",&num);\r\n			++intarray[num];\r\n		}\r\n\r\n		for(i=0;i<=999;++i)\r\n		{\r\n			mincount += intarray[i];\r\n			if(mincount >= k+1 )\r\n			{\r\n				mincount=i;\r\n				break;\r\n			}\r\n			\r\n		}\r\n		for(i=999;i>=0;--i)\r\n		{\r\n			maxcount += intarray[i];\r\n			if(maxcount >= k+1)\r\n			{\r\n				maxcount= i;\r\n				break;\r\n			}\r\n\r\n		}\r\n\r\n		printf("%d\\n",maxcount - mincount);\r\n	}\r\n\r\n	\r\n	\r\n	\r\n	\r\n	return 0;\r\n\r\n}', '', 400, 262144, 5, 1, '2010-09-30 09:35:40', '0001-01-01 00:00:00'),
(526, 30, 339, 3, '#include <stdio.h>\r\n#include <algorithm>\r\nint num[200000];\r\nint main()\r\n{\r\n	int n,r,i;\r\n	while(scanf("%d %d",&n,&r)==2)\r\n	{\r\n		int R[200];\r\n		for(i=0;i<r;i++)\r\n			scanf("%d",R+i);\r\n		for(i=0;i<n;i++)\r\n			scanf("%d",num+i);\r\n		std::sort(num,num+n);\r\n		for(i=0;i<r;i++)\r\n			printf("%d\\n",num[n-1-R[i]]);\r\n	}\r\n	return 0;\r\n}\r\n', '', 0, 1060864, 7, 2, '2010-09-30 09:36:59', '0001-01-01 00:00:00'),
(527, 30, 339, 3, '#include <stdio.h>\r\n#include <algorithm>\r\nint num[200000];\r\nint main()\r\n{\r\n	int n,r,i;\r\n	while(scanf("%d %d",&n,&r)==2)\r\n	{\r\n		int R[400];\r\n		for(i=0;i<r;i++)\r\n			scanf("%d",R+i);\r\n		for(i=0;i<n;i++)\r\n			scanf("%d",num+i);\r\n		std::sort(num,num+n);\r\n		for(i=0;i<r;i++)\r\n			printf("%d\\n",num[n-1-R[i]]);\r\n	}\r\n	return 0;\r\n}', '', 202, 1060864, 1, 2, '2010-09-30 09:38:19', '0001-01-01 00:00:00'),
(528, 21, 338, 3, '#include<stdio.h>\r\n\r\nvoid main()\r\n{int n,k;\r\nscanf("%d%d",&n,&k);\r\n\r\nint a[200]={0};\r\nint b[200]={0};\r\nint c[200]={0};\r\nint max=0,min=0;\r\n\r\nfor(int w=0;w<n;w++)scanf("%d",&a[w]);\r\n\r\n\r\n    for(int i=0; i<=k; i++)\r\n    {\r\n		//max\r\n        int j;\r\n        for (j=0; b[j] != 0; j++);\r\n        max = j++;\r\n        for(; j<n; j++)\r\n        {\r\n            if (b[j] == 0 && a[max] < a[j])\r\n            {\r\n                max = j;\r\n            }\r\n        }\r\n        b[max] = 1;\r\n	\r\n		//min\r\n		int l;\r\n        for (l=0; c[l] != 0; l++);\r\n        min = l++;\r\n        for(; l<n; l++)\r\n        {\r\n            if (c[l] == 0 && a[min] > a[l])\r\n            {\r\n                min = l;\r\n            }\r\n        }\r\n        c[min] = 1;\r\n    }\r\n    printf("%d\\n", a[max]-a[min]);\r\n\r\n}', 'Main.c: In function ''main'':\r\nMain.c:12:1: error: ''for'' loop initial declarations are only allowed in C99 mode\r\nMain.c:12:1: note: use option -std=c99 or -std=gnu99 to compile your code\r\nMain.c:15:5: error: ''for'' loop initial declarations are only allowed in C99 mode\r\n', 0, 0, 2, 1, '2010-09-30 09:39:28', '0001-01-01 00:00:00'),
(529, 17, 338, 3, '#include<stdio.h>\r\n#define N 5002\r\n#define MAXN 1001\r\nint max(int b[],int n)\r\n{   \r\n	int i;\r\n    int v;\r\n	for(i = 0, v = MAXN - 1; v >= 0; v--)  \r\n	 {  \r\n		if(n==0){\r\n		   i += b[v];\r\n	       if(i>n)\r\n			   break;\r\n		}\r\n		else\r\n		{\r\n			i += b[v];\r\n            if(i >= n)         \r\n             break;\r\n		}\r\n	 }  \r\n	return v;\r\n}\r\nint min(int b[],int n)\r\n{\r\n	int j;\r\n	int c;	\r\n	for(j=0,c=0; c<=MAXN-1; c++)\r\n	{ \r\n		if(n==0)\r\n		{\r\n		  j += b[c];\r\n		  if(j>n)\r\n			break;\r\n		}\r\n		\r\n		else{\r\n		 j += b[c];\r\n		 if(j>=n)\r\n			break;\r\n		}\r\n	}\r\n	return c;\r\n}\r\nint main()\r\n{\r\n\r\n    int k,i,j;\r\n	int n;\r\n	int km,kc;;\r\n	int a[N];	\r\n	while(scanf("%d%d",&n,&k)!=EOF)\r\n	{ \r\n	  int count[N]={0};\r\n      for(i=0;i<n;i++)\r\n	  {\r\n		  scanf("%d",&a[i]);\r\n	      count[a[i]]++;\r\n	  }\r\n    km=max(count,k);\r\n	kc=min(count,k);\r\n	 printf("%d\\n",km-kc);\r\n	}\r\n return 0;\r\n}', '', 15, 262144, 7, 1, '2010-09-30 09:40:08', '0001-01-01 00:00:00'),
(530, 25, 339, 3, '#include <iostream>\r\n#include <cstdio>\r\n#include <cstring>\r\n#include <algorithm>\r\n\r\nusing namespace std;\r\n\r\nint a[100001];\r\nint r[5000];\r\nint cmp(const void* x,const void* y)\r\n{\r\n	return *(int*)y - *(int*)x;\r\n}\r\n\r\nint main()\r\n{\r\n	int i,k,n;\r\n	while(scanf("%d%d",&n,&k) == 2)\r\n	{\r\n		memset(&a,0,sizeof(a));\r\n		memset(&r,0,sizeof(r));\r\n		for(i = 0;i < k; i++)\r\n			scanf("%d",&r[i]);\r\n		for(i = 0;i < n; i++)\r\n			scanf("%d",&a[i]);\r\n		qsort(&a,n,sizeof(int),&cmp);\r\n		for(i = 0; i < k; i++)\r\n			printf("%d\\n",a[r[i]]);\r\n	}\r\n\r\n	return 0;\r\n}', '', 202, 790528, 1, 2, '2010-09-30 09:40:56', '0001-01-01 00:00:00'),
(531, 17, 338, 3, '#include<stdio.h>\r\n#define N 50002\r\n#define MAXN 1001\r\nint max(int b[],int n)\r\n{   \r\n	int i;\r\n    int v;\r\n	for(i = 0, v = MAXN - 1; v >= 0; v--)  \r\n	 {  \r\n		if(n==0){\r\n		   i += b[v];\r\n	       if(i>n)\r\n			   break;\r\n		}\r\n		else\r\n		{\r\n			i += b[v];\r\n            if(i >= n)         \r\n             break;\r\n		}\r\n	 }  \r\n	return v;\r\n}\r\nint min(int b[],int n)\r\n{\r\n	int j;\r\n	int c;	\r\n	for(j=0,c=0; c<=MAXN-1; c++)\r\n	{ \r\n		if(n==0)\r\n		{\r\n		  j += b[c];\r\n		  if(j>n)\r\n			break;\r\n		}\r\n		\r\n		else{\r\n		 j += b[c];\r\n		 if(j>=n)\r\n			break;\r\n		}\r\n	}\r\n	return c;\r\n}\r\nint main()\r\n{\r\n\r\n    int k,i,j;\r\n	int n;\r\n	int km,kc;\r\n	int a[N];	\r\n	while(scanf("%d%d",&n,&k)!=EOF)\r\n	{ \r\n	  int count[N]={0};\r\n      for(i=0;i<n;i++)\r\n	  {\r\n		  scanf("%d",&a[i]);\r\n	      count[a[i]]++;\r\n	  }\r\n    km=max(count,k);\r\n	kc=min(count,k);\r\n	 printf("%d\\n",km-kc);\r\n	}\r\n return 0;\r\n}', '', 390, 622592, 4, 1, '2010-09-30 09:41:56', '0001-01-01 00:00:00'),
(532, 30, 1, 0, '#include <stdio.h>\r\nint main(){\r\nint a,b;\r\nscanf("%d %d",&a,&b);\r\nprintf("%d\\n",a+b);\r\nreturn 0;\r\n}', '', 0, 262144, 3, 2, '2010-09-30 09:42:03', '0001-01-01 00:00:00'),
(533, 12, 338, 3, '#include<stdio.h>\r\n\r\nvoid createheap(int a[],int n,int h)\r\n{\r\nint i,j;\r\nint temp;\r\n\r\ni=h;\r\nj=2*i+1;\r\ntemp=a[i];\r\n\r\nwhile(j<n)\r\n{\r\n   if(j<n-1&&a[j]<a[j+1])\r\n    j++;\r\n   if(temp>a[j])\r\n    break;\r\n   else\r\n   {\r\n    a[i]=a[j];\r\n    i=j;\r\n    j=2*i+1;\r\n   }\r\n}\r\n\r\na[i]=temp;\r\n}\r\n\r\n\r\nvoid heap(int a[],int n)\r\n{\r\nint i;\r\n\r\nfor(i=(n-2)/2;i>=0;--i)\r\ncreateheap(a,n,i);\r\n}\r\n\r\n\r\nvoid main()\r\n{\r\nint a[10],i,n,temp,k;\r\n\r\nscanf("%d",&n);\r\nscanf("%d",&k);\r\n\r\nfor(i=0;i<n;++i)\r\n   scanf("%d",&a[i]);\r\nheap(a,n);\r\n\r\nfor(i=n-1;i>=n-k;i--)\r\n{\r\n   temp=a[i];\r\n   a[i]=a[0];\r\n   a[0]=temp;\r\n  \r\n   createheap(a,i,0);\r\n}\r\n\r\n   printf("%d\\n ",a[n-k]);\r\n\r\n}', '', 0, 258048, 7, 1, '2010-09-30 09:43:58', '0001-01-01 00:00:00'),
(534, 30, 1, 0, '#include <stdio.h>\r\n\r\nint main()\r\n{\r\n    int a,b;\r\n    scanf("%d %d",&a, &b);\r\n    printf("%d\\n",a+b);\r\n    return 0;\r\n}', '', 0, 258048, 3, 2, '2010-09-30 09:45:05', '0001-01-01 00:00:00'),
(535, 23, 338, 3, '#include<stdio.h>\r\n#include<cstring>\r\n\r\nint num[5010],count[1001];\r\nint main(){\r\n	memset(&count,0,sizeof(count));\r\n	int n,k,m,j;\r\n	scanf("%d%d",&n,&k);\r\n	for(int i=0;i<n;i++){\r\n		scanf("%d",&num[i]);\r\n		count[num[i]]++;\r\n	}\r\n	m=k,j=1000,i=0;\r\n	if(k!=0){\r\n		while(m)\r\n			if(count[j--]!=0) m--;\r\n		while(k)\r\n			if(count[i++]!=0) k--;\r\n				\r\n				printf("%d",j-i+2);}\r\n	else printf("%d",0);\r\n	return 0;\r\n}', 'Main.cpp: In function ''int main()'':\r\nMain.cpp:13:13: error: name lookup of ''i'' changed for ISO ''for'' scoping\r\nMain.cpp:13:13: note: (if you use ''-fpermissive'' G++ will accept your code)\r\n', 0, 0, 2, 2, '2010-09-30 09:46:19', '0001-01-01 00:00:00');
INSERT INTO `tbl_submitions` (`id`, `user_id`, `problem_id`, `exercise_id`, `source`, `result`, `used_time`, `used_memory`, `status`, `compiler_id`, `created`, `modified`) VALUES
(536, 14, 338, 3, '#include<stdio.h>\r\n\r\nint intarray[1001];\r\n\r\n\r\n\r\nint main()\r\n{\r\n	int n,k,num;\r\n	while( scanf("%d",&n) == 1 )\r\n	{\r\n		int i,mincount=0,maxcount=0;\r\n		\r\n		if(0 == n)\r\n			break;\r\n		scanf("%d",&k);\r\n		for(i=0;i<n;++i)\r\n		{	\r\n			scanf("%d",&num);\r\n			++intarray[num];\r\n		}\r\n\r\n		for(i=0;i<=999;++i)\r\n		{\r\n			mincount += intarray[i];\r\n			if(mincount >= k+1 )\r\n			{\r\n				mincount=i;\r\n				break;\r\n			}\r\n			\r\n		}\r\n		for(i=999;i>=0;--i)\r\n		{\r\n			maxcount += intarray[i];\r\n			if(maxcount >= k+1)\r\n			{\r\n				maxcount= i;\r\n				break;\r\n			}\r\n\r\n		}\r\n\r\n		printf("%d\\n",maxcount - mincount);\r\n	}\r\n\r\n	\r\n	\r\n	\r\n	\r\n	return 0;\r\n\r\n}', '', 374, 266240, 4, 1, '2010-09-30 09:49:33', '0001-01-01 00:00:00'),
(537, 30, 339, 3, '#include <stdio.h>\r\nint num[100000];\r\nvoid swap(int &x, int &y)\r\n{\r\n    int temp = x;\r\n    x = y;\r\n    y = temp;\r\n}\r\n \r\nvoid Adjust(int *a, int parent, int high)\r\n{\r\n    int l = 2 * parent + 1;\r\n    int r = l + 1;\r\n    int flag = parent;\r\n \r\n    if (l<=high && a[l]>a[flag]) {\r\n        flag = l;\r\n    }\r\n    if (r<=high && a[r]>a[flag]) {\r\n        flag = r;\r\n    }\r\n    if (flag != parent) {\r\n        swap(a[parent], a[flag]);\r\n        Adjust(a, flag, high);\r\n    }\r\n}\r\n \r\nvoid HeapSort(int *a, int n)\r\n{\r\n    int i;\r\n \r\n    for (i=n-1; i>=0; i--) {\r\n        Adjust(a, i, n - 1);\r\n    }\r\n    for (i=n-1; i>=0; i--) {\r\n        swap(a[0], a[i]);\r\n        Adjust(a, 0, i - 1);\r\n    }\r\n}  \r\n\r\nint main(){\r\n	int n,r,i;\r\n	while(scanf("%d %d",&n,&r)==2)\r\n	{\r\n		int R[400];\r\n		for(i=0;i<r;i++)\r\n			scanf("%d",R+i);\r\n		for(i=0;i<n;i++)\r\n			scanf("%d",num+i);\r\n		HeapSort(num,n);\r\n		for(i=0;i<r;i++)\r\n			printf("%d\\n",num[n-R[i]-1]);\r\n	}\r\n	return 0;\r\n}\r\n', '', 342, 659456, 1, 2, '2010-09-30 09:49:51', '0001-01-01 00:00:00'),
(538, 23, 338, 3, '#include<stdio.h>\r\n#include<cstring>\r\n\r\nint num[5010],count[1001];\r\nint main(){\r\n	memset(&count,0,sizeof(count));\r\n	int n,k,m,j;\r\n	scanf("%d%d",&n,&k);\r\n	for(int i=0;i<n;i++){\r\n		scanf("%d",&num[i]);\r\n		count[num[i]]++;\r\n	}\r\n	m=k,j=1000,i=0;\r\n	while(m>=0)\r\n			if(count[j--]!=0) m--;\r\n	while(k>=0)\r\n			if(count[i++]!=0) k--;\r\n    printf("%d",j-i+2);\r\n	return 0;\r\n}', 'Main.cpp: In function ''int main()'':\r\nMain.cpp:13:13: error: name lookup of ''i'' changed for ISO ''for'' scoping\r\nMain.cpp:13:13: note: (if you use ''-fpermissive'' G++ will accept your code)\r\n', 0, 0, 2, 2, '2010-09-30 09:55:52', '0001-01-01 00:00:00'),
(539, 23, 338, 3, '#include<stdio.h>\r\n#include<cstring>\r\n\r\nint num[50010],count[1001];\r\nint main(){\r\n	memset(&count,0,sizeof(count));\r\n	int n,k,m,j;\r\n	scanf("%d%d",&n,&k);\r\n	for(int i=0;i<n;i++){\r\n		scanf("%d",&num[i]);\r\n		count[num[i]]++;\r\n	}\r\n	m=k,j=1000,i=0;\r\n	while(m>=0)\r\n			if(count[j--]!=0) m--;\r\n	while(k>=0)\r\n			if(count[i++]!=0) k--;\r\n    printf("%d",j-i+2);\r\n	return 0;\r\n}', 'Main.cpp: In function ''int main()'':\r\nMain.cpp:13:13: error: name lookup of ''i'' changed for ISO ''for'' scoping\r\nMain.cpp:13:13: note: (if you use ''-fpermissive'' G++ will accept your code)\r\n', 0, 0, 2, 2, '2010-09-30 09:56:53', '0001-01-01 00:00:00'),
(540, 23, 338, 3, '#include<stdio.h>\r\n#include<cstring>\r\n\r\nint num[50010],count[1001];\r\nint main(){\r\n	memset(&count,0,sizeof(count));\r\n	int n,k,m,j;\r\n	scanf("%d%d",&n,&k);\r\n	for(int i=0;i<n;i++){\r\n		scanf("%d",&num[i]);\r\n		count[num[i]]++;\r\n	}\r\n	m=k,j=1000,i=0;\r\n	while(m>=0)\r\n			if(count[j--]!=0) m--;\r\n	while(k>=0)\r\n			if(count[i++]!=0) k--;\r\n    printf("%d",j-i+2);\r\n	return 0;\r\n}', 'Main.cpp: In function ''int main()'':\r\nMain.cpp:13:13: error: name lookup of ''i'' changed for ISO ''for'' scoping\r\nMain.cpp:13:13: note: (if you use ''-fpermissive'' G++ will accept your code)\r\n', 0, 0, 2, 2, '2010-09-30 09:57:05', '0001-01-01 00:00:00'),
(541, 23, 338, 3, '#include<stdio.h>\r\n#include<cstring>\r\n\r\nint num[50010],count[1001];\r\nint main(){\r\n    int n,k,m,j;\r\n	scanf("%d%d",&n,&k);\r\n	memset(&count,0,sizeof(count));\r\n	for(int i=0;i<n;i++){\r\n		scanf("%d",&num[i]);\r\n		count[num[i]]++;\r\n	}\r\n    m=k,j=1001,i=-1;\r\n	while(m>=0)\r\n		if(count[++i]!=0) --m;\r\n    while(k>=0)\r\n		if(count[--j]!=0) --k;\r\n\r\n	printf("%d",j-i);\r\n	return 0;\r\n}', 'Main.cpp: In function ''int main()'':\r\nMain.cpp:13:16: error: name lookup of ''i'' changed for ISO ''for'' scoping\r\nMain.cpp:13:16: note: (if you use ''-fpermissive'' G++ will accept your code)\r\n', 0, 0, 2, 2, '2010-09-30 19:57:43', '0001-01-01 00:00:00'),
(542, 6, 342, 0, '/* Solution to "Unequalled Consumption"\r\n *\r\n * The solution is by Lagrange interpolation and binary search.\r\n *\r\n * Complexity: O(n^2*(lcm(v_1,...,v_n) + q*v_1*log(P)))\r\n *\r\n * Author: Per Austrin\r\n *\r\n *\r\n * Solution:\r\n *\r\n * Let w_1, ... w_n be the weights of the candy types (as in the\r\n * problem statement).  Let F_k(m) be the number of different candy\r\n * boxes that can be made with total weight m, using only the first k\r\n * candy types.  What we''re after is the smallest positive m such that\r\n * F_n(m) >= P.  The typical DP solution for this problem would be to\r\n * utilize the recurrence F_k(m) = F_k(m-w_k) + F_{k-1}(m) and then\r\n * compute F_n(m) for increasingly higher values of m until F_n(m) >=\r\n * P, but this won''t work, because P is too big, and the answer can be\r\n * even bigger than P (though not by much).\r\n *\r\n * Let M = lcm(w_1, ...,w_n), and define P_{k, r}(x) = F_k(x*M + r).\r\n * The key observation (which I think is the most difficult part of\r\n * the entire problem) is that P_{k,r}(x) is in fact a polynomial of\r\n * degree k-1.  Thus, it is determined by its values on x = 0...k-1,\r\n * which correspond to evaluations of F_k on values between 0 and k*M\r\n * (assuming 0 <= r < M).  These values can be computed using DP,\r\n * since k*M <= n*M <= 25200.  For large values of x, P_{k,r}(x) (and\r\n * by extension F_k(m)) can be computed using e.g. Lagrange\r\n * interpolation.\r\n *\r\n * One small problem still remains: even though we can quickly compute\r\n * the number of different chocolate boxes for a specific weight, we\r\n * don''t want to test all weights in order to find the smallest which\r\n * yields P different boxes.  However, from the recurrence used for\r\n * the DP it is easy to see that for values of m with a fixed residue\r\n * r moduli w_k, F_k(m) is non-decreasing.  Thus, we can simply do one\r\n * binary search for each possible value of r, finding the smallest m\r\n * for each residue, and then picking the overall smallest as our\r\n * answer.\r\n *\r\n * The only case when the answer is impossible is when n = 1 and P > 1.\r\n *\r\n */\r\n\r\n#include <cassert>\r\n#include <cmath>\r\n#include <cstdio>\r\n#include <cstring>\r\n\r\nconst long long maxans = 100000000000000001LL;\r\n\r\ntemplate <class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\r\ntemplate <class T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\r\ntemplate <class T> T abs(T a)      { return a < 0 ? -a : a; }\r\n\r\nint n, mod, v[10];\r\nlong long wtbl[20000][5];\r\n\r\n// standard dp solution for small weights\r\nlong long ways_brute(int c, int x) {\r\n  if (x < 0) return 0;\r\n  if (c == 0) return x % v[0] == 0;\r\n  if (wtbl[x][c-1] == -1)\r\n    wtbl[x][c-1] = ways_brute(c-1, x) + ways_brute(c, x-v[c]);\r\n  return wtbl[x][c-1];\r\n}\r\n\r\n// lagrange interpolation for big weights\r\nlong long ways(long long x) {\r\n  int r = x % mod;\r\n  long long k = x / mod, res = 0;\r\n  if (k < n) return ways_brute(n-1, x);\r\n  for (int i = 0; i < n; ++i) {\r\n    long long num = ways_brute(n-1, r + mod*i), den = 1, d;\r\n    for (int j = 0; j < n; ++j) {\r\n      if (i != j) {\r\n	num *= k-j;\r\n	den *= i-j;\r\n	d = gcd(abs(num), abs(den));\r\n	num /= d;\r\n	den /= d;\r\n      }\r\n    }\r\n    if (den < 0) num = -num, den = -den;\r\n    assert(den == 1);\r\n    res += num;\r\n  }\r\n  return res;\r\n}\r\n\r\nint main(void) {\r\n  int cse = 0, q;\r\n  while (scanf("%d", &n) == 1 && n) {\r\n    printf("Set %d\\n", ++cse);\r\n\r\n    mod = 1;\r\n    for (int i = 0; i < n; ++i) {\r\n      scanf("%d", v+i);\r\n      mod = lcm(mod, v[i]);\r\n    }\r\n    memset(wtbl, -1, sizeof(wtbl));\r\n\r\n    scanf("%d", &q);\r\n    for (int i = 0; i < q; ++i) {\r\n      long long res = maxans, P;\r\n      scanf("%lld", &P);\r\n\r\n      // ways(n) is not increasing, hence we cannot apply a binary\r\n      // search straight off, but ways(n) is increasing for n with a\r\n      // fixed residue modulo any of the weights, so we do one binary\r\n      // search for each residue mod v[0].\r\n      for (int i = 0; i < *v; ++i) {\r\n	long long lo = -1, hi = 2;\r\n	// first find a range for the binary search\r\n	while ((lo+1) * *v + i < res && ways(hi * *v + i) < P)\r\n	  lo = hi, hi <<= 1;\r\n	if ((lo+1) * *v + i >= res) continue;\r\n\r\n	while (hi - lo > 1) {\r\n	  long long m = (lo + hi)/2, w = ways(m * *v + i);\r\n	  if (w < P) lo = m;\r\n	  else hi = m;\r\n	}\r\n	// don''t allow zero, we want positive answers.\r\n	if (hi * *v + i == 0) ++hi;\r\n	res <?= hi * *v + i;\r\n      }\r\n\r\n      if (res == maxans) printf("no candy for you\\n");			     \r\n      else printf("%lld\\n", res);\r\n    }\r\n  }\r\n  return 0;\r\n}\r\n', 'Main.cpp: In function ''int main()'':\r\nMain.cpp:127:7: error: expected primary-expression before ''?'' token\r\nMain.cpp:127:8: error: expected primary-expression before ''='' token\r\nMain.cpp:127:21: error: expected '':'' before '';'' token\r\nMain.cpp:127:21: error: expected primary-expression before '';'' token\r\n', 0, 0, 2, 2, '2010-09-30 21:55:55', '0001-01-01 00:00:00'),
(543, 6, 342, 0, '/* Solution to "Unequalled Consumption"\r\n *\r\n * The solution is by Lagrange interpolation and binary search.\r\n *\r\n * Complexity: O(n^2*(lcm(v_1,...,v_n) + q*v_1*log(P)))\r\n *\r\n * Author: Per Austrin\r\n *\r\n *\r\n * Solution:\r\n *\r\n * Let w_1, ... w_n be the weights of the candy types (as in the\r\n * problem statement).  Let F_k(m) be the number of different candy\r\n * boxes that can be made with total weight m, using only the first k\r\n * candy types.  What we''re after is the smallest positive m such that\r\n * F_n(m) >= P.  The typical DP solution for this problem would be to\r\n * utilize the recurrence F_k(m) = F_k(m-w_k) + F_{k-1}(m) and then\r\n * compute F_n(m) for increasingly higher values of m until F_n(m) >=\r\n * P, but this won''t work, because P is too big, and the answer can be\r\n * even bigger than P (though not by much).\r\n *\r\n * Let M = lcm(w_1, ...,w_n), and define P_{k, r}(x) = F_k(x*M + r).\r\n * The key observation (which I think is the most difficult part of\r\n * the entire problem) is that P_{k,r}(x) is in fact a polynomial of\r\n * degree k-1.  Thus, it is determined by its values on x = 0...k-1,\r\n * which correspond to evaluations of F_k on values between 0 and k*M\r\n * (assuming 0 <= r < M).  These values can be computed using DP,\r\n * since k*M <= n*M <= 25200.  For large values of x, P_{k,r}(x) (and\r\n * by extension F_k(m)) can be computed using e.g. Lagrange\r\n * interpolation.\r\n *\r\n * One small problem still remains: even though we can quickly compute\r\n * the number of different chocolate boxes for a specific weight, we\r\n * don''t want to test all weights in order to find the smallest which\r\n * yields P different boxes.  However, from the recurrence used for\r\n * the DP it is easy to see that for values of m with a fixed residue\r\n * r moduli w_k, F_k(m) is non-decreasing.  Thus, we can simply do one\r\n * binary search for each possible value of r, finding the smallest m\r\n * for each residue, and then picking the overall smallest as our\r\n * answer.\r\n *\r\n * The only case when the answer is impossible is when n = 1 and P > 1.\r\n *\r\n */\r\n\r\n#include <cassert>\r\n#include <cmath>\r\n#include <cstdio>\r\n#include <cstring>\r\n\r\nconst long long maxans = 100000000000000001LL;\r\n\r\ntemplate <class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\r\ntemplate <class T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\r\ntemplate <class T> T abs(T a)      { return a < 0 ? -a : a; }\r\n\r\nint n, mod, v[10];\r\nlong long wtbl[20000][5];\r\n\r\n// standard dp solution for small weights\r\nlong long ways_brute(int c, int x) {\r\n  if (x < 0) return 0;\r\n  if (c == 0) return x % v[0] == 0;\r\n  if (wtbl[x][c-1] == -1)\r\n    wtbl[x][c-1] = ways_brute(c-1, x) + ways_brute(c, x-v[c]);\r\n  return wtbl[x][c-1];\r\n}\r\n\r\n// lagrange interpolation for big weights\r\nlong long ways(long long x) {\r\n  int r = x % mod;\r\n  long long k = x / mod, res = 0;\r\n  if (k < n) return ways_brute(n-1, x);\r\n  for (int i = 0; i < n; ++i) {\r\n    long long num = ways_brute(n-1, r + mod*i), den = 1, d;\r\n    for (int j = 0; j < n; ++j) {\r\n      if (i != j) {\r\n	num *= k-j;\r\n	den *= i-j;\r\n	d = gcd(abs(num), abs(den));\r\n	num /= d;\r\n	den /= d;\r\n      }\r\n    }\r\n    if (den < 0) num = -num, den = -den;\r\n    assert(den == 1);\r\n    res += num;\r\n  }\r\n  return res;\r\n}\r\n\r\nint main(void) {\r\n  int cse = 0, q ;\r\n  while (scanf("%d", &n) == 1 && n) {\r\n    printf("Set %d\\n", ++cse);\r\n\r\n    mod = 1;\r\n    for (int i = 0; i < n; ++i) {\r\n      scanf("%d", v+i);\r\n      mod = lcm(mod, v[i]);\r\n    }\r\n    memset(wtbl, -1, sizeof(wtbl));\r\n\r\n    scanf("%d", &q);\r\n    for (int i = 0; i < q; ++i) {\r\n      long long res = maxans, P ,tmp;\r\n      scanf("%lld", &P);\r\n\r\n      // ways(n) is not increasing, hence we cannot apply a binary\r\n      // search straight off, but ways(n) is increasing for n with a\r\n      // fixed residue modulo any of the weights, so we do one binary\r\n      // search for each residue mod v[0].\r\n      for (int i = 0; i < *v; ++i) {\r\n	long long lo = -1, hi = 2;\r\n	// first find a range for the binary search\r\n	while ((lo+1) * *v + i < res && ways(hi * *v + i) < P)\r\n	  lo = hi, hi <<= 1;\r\n	if ((lo+1) * *v + i >= res) continue;\r\n\r\n	while (hi - lo > 1) {\r\n	  long long m = (lo + hi)/2, w = ways(m * *v + i);\r\n	  if (w < P) lo = m;\r\n	  else hi = m;\r\n	}\r\n	// don''t allow zero, we want positive answers.\r\n	if (hi * *v + i == 0) ++hi;\r\n	tmp = hi * *v + i;\r\n    res = res < tmp ? res : tmp;\r\n      }\r\n\r\n      if (res == maxans) printf("no candy for you\\n");			     \r\n      else printf("%lld\\n", res);\r\n    }\r\n  }\r\n  return 0;\r\n}', '', 15, 1077248, 1, 2, '2010-09-30 22:06:06', '0001-01-01 00:00:00'),
(544, 6, 340, 0, '/* Solution to "Reduced ID Numbers" from NWERC 05\r\n * Author: Per Austrin */\r\n#include <cstdio>\r\nint main(void) \r\n{ \r\n  int i, j, k, n, m, *v = 314+new int[100000];\r\n  for (scanf("%d", &n); n-- && scanf("%d", &m); printf("%d\\n", k))\r\n    for (*v=i=(k=1)-1; i++<m && scanf("%d", v-i);)\r\n      for (j=i; j<=i && (v[v[-j]%k]-k?v[v[-j]%k]=k:*(v+k++)=(j=-1)++); ++j);\r\n  return 0;\r\n}', '', 78, 647168, 1, 2, '2010-09-30 23:23:28', '0001-01-01 00:00:00'),
(545, 6, 340, 0, '#include <stdio.h>\r\n#include <memory>\r\n#include <algorithm>\r\n#include <bitset>\r\n\r\nusing namespace std;\r\n\r\nint cases, count1;\r\nint i, k, l;\r\nint num[300];\r\n//if m == a - b, then a%m == b%m. so when testing m, we can skip all diff\r\n\r\nint m, numModM;\r\n\r\nint main() \r\n{\r\n    bitset< 1000000 > diff;\r\n    bitset< 1000000 > left1;\r\n    scanf("%d", &cases);\r\n    for (i=0; i<cases; i++)\r\n    {\r\n        if(i > 0)\r\n            diff.reset();\r\n        scanf("%d", &count1);\r\n        \r\n        for (k=0; k<count1; k++)\r\n        {\r\n            scanf("%d", &num[k]);\r\n        }\r\n        sort(num, num+count1);\r\n        for(k=0; k<count1; k++)\r\n        {\r\n            for (l=k; l>=0; l--)\r\n            {\r\n                diff.set(num[k] - num[l]);\r\n            }\r\n        }\r\n        for (m=count1; ; m++)\r\n        {\r\n            if (!diff.test(m))\r\n            {\r\n                memset(&left1, 0, sizeof(bool)*m);\r\n                for (k=0; k<count1; k++)\r\n                {\r\n                    numModM = num[k] % m;\r\n                    if (left1.test(numModM))\r\n                        break;\r\n                    else\r\n                        left1.set(numModM);\r\n                }\r\n                if (k == count1)\r\n                {\r\n                    printf("%d\\n", m);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return 0;\r\n}', 'Main.cpp: In function ''int main()'':\r\nMain.cpp:42:49: error: ''memset'' was not declared in this scope\r\n', 0, 0, 2, 2, '2010-09-30 23:32:44', '0001-01-01 00:00:00'),
(546, 6, 340, 0, '#include <stdio.h>\r\n#include <string.h>\r\n#include <algorithm>\r\n#include <bitset>\r\n\r\nusing namespace std;\r\n\r\nint cases, count1;\r\nint i, k, l;\r\nint num[300];\r\n//if m == a - b, then a%m == b%m. so when testing m, we can skip all diff\r\n\r\nint m, numModM;\r\n\r\nint main() \r\n{\r\n    bitset< 1000000 > diff;\r\n    bitset< 1000000 > left1;\r\n    scanf("%d", &cases);\r\n    for (i=0; i<cases; i++)\r\n    {\r\n        if(i > 0)\r\n            diff.reset();\r\n        scanf("%d", &count1);\r\n        \r\n        for (k=0; k<count1; k++)\r\n        {\r\n            scanf("%d", &num[k]);\r\n        }\r\n        sort(num, num+count1);\r\n        for(k=0; k<count1; k++)\r\n        {\r\n            for (l=k; l>=0; l--)\r\n            {\r\n                diff.set(num[k] - num[l]);\r\n            }\r\n        }\r\n        for (m=count1; ; m++)\r\n        {\r\n            if (!diff.test(m))\r\n            {\r\n                memset(&left1, 0, sizeof(bool)*m);\r\n                for (k=0; k<count1; k++)\r\n                {\r\n                    numModM = num[k] % m;\r\n                    if (left1.test(numModM))\r\n                        break;\r\n                    else\r\n                        left1.set(numModM);\r\n                }\r\n                if (k == count1)\r\n                {\r\n                    printf("%d\\n", m);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return 0;\r\n}\r\n', '', 31, 507904, 1, 2, '2010-09-30 23:33:18', '0001-01-01 00:00:00'),
(547, 6, 340, 0, '#include <iostream>\r\n#include <cstring>\r\n#include <cstdio>\r\n#include <cmath>\r\n\r\nusing namespace std;\r\nconst int N = 1000008;\r\nint p[N];\r\nbool vis[N];\r\nint n,m;\r\nint main()\r\n{\r\n    int T,i,j,k,t;\r\n    scanf("%d",&T);\r\n    while (T--)\r\n    {\r\n        memset(vis,0,sizeof(vis));\r\n        scanf("%d",&n);\r\n        for (i=1;i<=n;i++)\r\n            scanf("%d",&p[i]);\r\n        if (n==1)\r\n        {\r\n            printf("1\\n");\r\n            continue;\r\n        }\r\n        for (i=1;i<=n;i++)\r\n            for (j=i+1;j<=n;j++)\r\n            {\r\n                t=(p[i]-p[j]);\r\n                if(t<0) t=-t;\r\n                for (k=1;k<=sqrt(t+.0);k++)\r\n                    if (t%k==0)\r\n                    {\r\n                        vis[k]=vis[t/k]=1;\r\n                    }\r\n            }\r\n        for (i=1;;i++)\r\n            if (!vis[i])\r\n            {\r\n                printf("%d\\n",i);\r\n                break;\r\n            }\r\n    }\r\n    return 0;\r\n}', '', 327, 5378048, 1, 2, '2010-09-30 23:42:44', '0001-01-01 00:00:00'),
(548, 3, 44, 0, '#include<stdio.h>\r\n#include<string.h>\r\nint main()\r\n{  \r\n   int i;\r\n   char str[1000];\r\n   scanf("%s",&str);\r\n   int stre=strlen(str);\r\n   for(i=0;i<stre;i++)\r\n   {\r\n       str[i]=str[i]+4;\r\n   }   \r\n   printf("%s",str);\r\n   return 0;\r\n}', '', 0, 258048, 4, 1, '2010-10-03 22:09:30', '0001-01-01 00:00:00'),
(549, 3, 44, 0, '#include<stdio.h>\r\n#include<string.h>\r\nint main()\r\n{  \r\n   int i;\r\n   char str[1000];\r\n   scanf("%s",&str);\r\n   int stre=strlen(str);\r\n   for(i=0;i<stre;i++)\r\n   {\r\n       str[i]=str[i]+4;\r\n   }   \r\n   printf("%s\\n",str);\r\n   return 0;\r\n}', '', 0, 258048, 4, 1, '2010-10-03 22:10:31', '0001-01-01 00:00:00'),
(550, 3, 44, 0, '#include<iostream>\r\n#include<cstring>\r\nusing namespace std;\r\nint main()\r\n{  \r\n   int i;\r\n   char str[1000];\r\n   scanf("%s",&str);\r\n   int stre=strlen(str);\r\n   for(i=0;i<stre;i++)\r\n   {\r\n       str[i]=str[i]+4;\r\n   }   \r\n   printf("%s\\n",str);\r\n   return 0;\r\n}', 'Main.cpp: In function ''int main()'':\r\nMain.cpp:8:19: error: ''scanf'' was not declared in this scope\r\nMain.cpp:14:21: error: ''printf'' was not declared in this scope\r\n', 0, 0, 2, 2, '2010-10-03 22:11:53', '0001-01-01 00:00:00'),
(551, 3, 44, 0, '#include<iostream>\r\n#include<cstring>\r\nusing namespace std;\r\nint main()\r\n{  \r\n   int i;\r\n   char str[1000];\r\n   cin>>str;\r\n   int stre=strlen(str);\r\n   for(i=0;i<stre;i++)\r\n   {\r\n       str[i]=str[i]+4;\r\n   }   \r\n   cout<<str<<endl;\r\n   return 0;\r\n}', '', 0, 368640, 4, 2, '2010-10-03 22:12:44', '0001-01-01 00:00:00'),
(552, 3, 44, 0, '#include<iostream>\r\n#include<cstring>\r\nusing namespace std;\r\nint main()\r\n{  \r\n   int i;\r\n   char str[1000];\r\n   cin>>str;\r\n   int stre=strlen(str);\r\n   for(i=0;i<stre;i++)\r\n   {\r\n	   if(str[i]>=87||str[i]>=119)\r\n       {\r\n	      if(str[i]==87)\r\n		  {\r\n		     str[i]=''A'';\r\n		  }\r\n		  else if(str[i]==88)\r\n		  {\r\n		      str[i]=''B'';\r\n		  }\r\n		  else if(str[i]==89)\r\n          {\r\n		     str[i]=''C'';\r\n		  }\r\n		  else if(str[i]==90)\r\n		  {\r\n		      str[i]=''D'';\r\n		  }\r\n		  else if(str[i]==119)\r\n		  {\r\n		     str[i]=''a'';\r\n		  }\r\n		  else if(str[i]==120)\r\n          {\r\n		     str[i]=''b'';\r\n		  }\r\n		  else if(str[i]==121)\r\n		  {\r\n		     str[i]=''c'';\r\n		  }\r\n		  else\r\n		  {\r\n		     str[i]=''d'';\r\n		  }\r\n	   }\r\n	   else\r\n       str[i]=str[i]+4;\r\n   }   \r\n   cout<<str<<endl;\r\n   return 0;\r\n}', '', 0, 364544, 4, 2, '2010-10-03 22:24:40', '0001-01-01 00:00:00'),
(553, 17, 336, 2, '#include <iostream>\r\n#include <vector>\r\nusing namespace std;\r\n#define N 50000\r\n\r\nint getBitCount_method1( int n)\r\n{\r\nint i;\r\nint count = 0;\r\nfor ( i = 1; i <= 32; ++i)\r\n{\r\n   if ( n & 0x00000001) \r\n   {\r\n    ++count;\r\n   }\r\n   n = n >> 1;\r\n}\r\n\r\nreturn count;\r\n}\r\n\r\n\r\nvoid quickSort(int a[], int startIndex, int endIndex)\r\n{\r\n int tmp;\r\n int i,j,centerIndex;\r\n \r\n if ( endIndex <= startIndex )\r\n {\r\n   return;\r\n }\r\n\r\n if ( endIndex - startIndex == 1 )\r\n {\r\n   if ( a[startIndex] > a[endIndex] )\r\n   {\r\n     tmp = a[startIndex];\r\n    a[startIndex] = a[endIndex];\r\n    a[endIndex] = tmp;\r\n   }\r\n   return;\r\n  }\r\n\r\ncenterIndex = startIndex;\r\ni = startIndex;\r\nj = endIndex;\r\nwhile ( i <= j )\r\n{\r\n   while ( (i <= endIndex) && (a[i] <= a[centerIndex]) )\r\n   {\r\n    ++i;\r\n   }\r\n   while ( a[j] > a[centerIndex] )\r\n   {\r\n    --j;\r\n   }\r\n   if ( i <= j )\r\n   {\r\n    int tmp = a[i];\r\n    a[i] = a[j];\r\n    a[j] = tmp;\r\n   }\r\n}\r\ntmp = a[j];\r\na[j] = a[centerIndex];\r\na[centerIndex] = tmp;\r\ncenterIndex = j;\r\nquickSort(a, startIndex, centerIndex -1);\r\nquickSort(a, centerIndex+1, endIndex);\r\n}\r\n\r\n\r\nvector<int> getSortVec(int a[], int count[], int n)\r\n{\r\nvector<int> rstVec;\r\nvector<int> vecArray[33]; \r\nint i;\r\nint j;\r\nfor ( i = 0; i < n; ++i)\r\n{\r\n   vecArray[count[i]].push_back(a[i]); \r\n}\r\n\r\n\r\nfor ( i = 0; i <= 32; ++i)\r\n{\r\n   for ( j = 0; j < vecArray[i].size(); ++j)\r\n   {\r\n    rstVec.push_back(vecArray[i][j]);\r\n   }\r\n}\r\n\r\nreturn rstVec;\r\n}\r\n\r\nint main()\r\n{\r\n    int n;\r\n	int i;\r\n    int a[N];\r\n    while(scanf("%d",&n)!=EOF)\r\n    {\r\n       for(i=0;i<n;i++)\r\n         scanf("%d",&a[i]);\r\n        quickSort(a, 0, n-1); \r\n      int count[N];\r\n\r\n\r\nfor ( i = 0; i < n; ++i)\r\n{\r\n   count[i] = getBitCount_method1(a[i]);\r\n}\r\n\r\nvector<int> rstVec = getSortVec(a, count, n);\r\n\r\nfor ( i = 0; i<rstVec.size(); ++i)\r\n{ \r\n	if(i==rstVec.size()-1)\r\n     cout << rstVec[i] ;\r\n   else \r\n    cout << rstVec[i] << " ";\r\n}\r\ncout << endl;\r\n\r\n}\r\nreturn 0;\r\n}\r\n', 'Main.cpp: In function ''int main()'':\r\nMain.cpp:101:24: error: ''scanf'' was not declared in this scope\r\nMain.cpp:101:27: error: ''EOF'' was not declared in this scope\r\n', 0, 0, 2, 2, '2010-10-05 15:09:10', '0001-01-01 00:00:00'),
(554, 17, 336, 2, '#include <iostream>\r\n#include <vector>\r\nusing namespace std;\r\n#define N 50000\r\n\r\nint getBitCount_method1( int n)\r\n{\r\nint i;\r\nint count = 0;\r\nfor ( i = 1; i <= 32; ++i)\r\n{\r\n   if ( n & 0x00000001) \r\n   {\r\n    ++count;\r\n   }\r\n   n = n >> 1;\r\n}\r\n\r\nreturn count;\r\n}\r\n\r\n\r\nvoid quickSort(int a[], int startIndex, int endIndex)\r\n{\r\n int tmp;\r\n int i,j,centerIndex;\r\n \r\n if ( endIndex <= startIndex )\r\n {\r\n   return;\r\n }\r\n\r\n if ( endIndex - startIndex == 1 )\r\n {\r\n   if ( a[startIndex] > a[endIndex] )\r\n   {\r\n     tmp = a[startIndex];\r\n    a[startIndex] = a[endIndex];\r\n    a[endIndex] = tmp;\r\n   }\r\n   return;\r\n  }\r\n\r\ncenterIndex = startIndex;\r\ni = startIndex;\r\nj = endIndex;\r\nwhile ( i <= j )\r\n{\r\n   while ( (i <= endIndex) && (a[i] <= a[centerIndex]) )\r\n   {\r\n    ++i;\r\n   }\r\n   while ( a[j] > a[centerIndex] )\r\n   {\r\n    --j;\r\n   }\r\n   if ( i <= j )\r\n   {\r\n    int tmp = a[i];\r\n    a[i] = a[j];\r\n    a[j] = tmp;\r\n   }\r\n}\r\ntmp = a[j];\r\na[j] = a[centerIndex];\r\na[centerIndex] = tmp;\r\ncenterIndex = j;\r\nquickSort(a, startIndex, centerIndex -1);\r\nquickSort(a, centerIndex+1, endIndex);\r\n}\r\n\r\n\r\nvector<int> getSortVec(int a[], int count[], int n)\r\n{\r\nvector<int> rstVec;\r\nvector<int> vecArray[33]; \r\n\r\nfor ( int i = 0; i < n; ++i)\r\n{\r\n   vecArray[count[i]].push_back(a[i]); \r\n}\r\n\r\n\r\nfor ( int i = 0; i <= 32; ++i)\r\n{\r\n   for (int  j = 0; j < vecArray[i].size(); ++j)\r\n   {\r\n    rstVec.push_back(vecArray[i][j]);\r\n   }\r\n}\r\n\r\nreturn rstVec;\r\n}\r\n\r\nint main()\r\n{\r\n    int n;\r\n	int i;\r\n    int a[N];\r\n    while(cin>>n)\r\n    {\r\n       for(i=0;i<n;i++)\r\n         cin>>a[i];\r\n        quickSort(a, 0, n-1); \r\n      int count[N];\r\n\r\n\r\nfor ( i = 0; i < n; ++i)\r\n{\r\n   count[i] = getBitCount_method1(a[i]);\r\n}\r\n\r\nvector<int> rstVec = getSortVec(a, count, n);\r\n\r\nfor ( i = 0; i<rstVec.size(); ++i)\r\n{ \r\n	if(i==rstVec.size()-1)\r\n     cout << rstVec[i] ;\r\n   else \r\n    cout << rstVec[i] << " ";\r\n}\r\ncout << endl;\r\n\r\n}\r\nreturn 0;\r\n}\r\n', '', 186, 1732608, 1, 2, '2010-10-05 15:14:04', '0001-01-01 00:00:00'),
(555, 17, 338, 3, '#include<stdio.h>\r\n#define N 50002\r\n#define MAXN 1001\r\nint max(int b[],int n)\r\n{   \r\n	int i;\r\n    int v;\r\n	for(i = 0, v = MAXN - 1; v >= 0; v--)  \r\n	 {  \r\n\r\n			i += b[v];\r\n            if(i >= n+1)         \r\n             break;\r\n		\r\n	 }  \r\n	return v;\r\n}\r\nint min(int b[],int n)\r\n{\r\n	int j;\r\n	int c;	\r\n	for(j=0,c=0; c<=MAXN-1; c++)\r\n	{ \r\n\r\n		\r\n\r\n		 j += b[c];\r\n		 if(j>=n+1)\r\n			break;\r\n		\r\n	}\r\n	return c;\r\n}\r\nint main()\r\n{\r\n\r\n    int k,i;\r\n	int n;\r\n	int km,kc;\r\n	int a[N];	\r\n	while(scanf("%d%d",&n,&k)!=EOF)\r\n	{ \r\n	  int count[N]={0};\r\n      for(i=0;i<n;i++)\r\n	  {\r\n		  scanf("%d",&a[i]);\r\n	      count[a[i]]++;\r\n	  }\r\n    km=max(count,k);\r\n	kc=min(count,k);\r\n	 printf("%d\\n",km-kc);\r\n	}\r\n return 0;\r\n}', '', 390, 622592, 1, 1, '2010-10-05 15:18:38', '0001-01-01 00:00:00'),
(556, 17, 339, 3, '#include<stdio.h>\r\n#include<string.h>\r\n#define M 201\r\n#define N 100000\r\n\r\n\r\nvoid heapify(int* arr, int parent, int heapsize)\r\n{\r\n int temp;\r\n int left =2 * parent ;\r\n int right = left + 1;\r\n int index = parent;\r\n\r\n if(left <= heapsize && arr[left-1] < arr[index-1])\r\n {\r\n  index = left;\r\n }\r\n if(right <= heapsize && arr[right-1] < arr[index-1])\r\n {\r\n  index = right;\r\n }\r\n if(index != parent)\r\n {\r\n\r\n   temp;\r\n  temp = arr[parent-1];\r\n  arr[parent-1] = arr[index-1];\r\n  arr[index-1] = temp;\r\n  heapify(arr, index, heapsize);\r\n  }\r\n  return;\r\n}\r\n\r\nint main()\r\n{\r\n   int n,k;\r\n   int count[M];\r\n   int arr[N];\r\n   int i,j;\r\n   while(scanf("%d%d",&n,&k)!=EOF)\r\n  {\r\n	 \r\n	 for( i=0;i<k;++i)\r\n		 scanf("%d",&count[i]);\r\n     \r\n	 for(i=0;i<n;i++)\r\n		 scanf("%d",&arr[i]);\r\n\r\n\r\n	 for( j=0;j<k;j++)\r\n	{\r\n     \r\n	   for ( i = count[j] /2; i >= 1; --i)\r\n      {\r\n        heapify(arr, i, count[j]);\r\n      }\r\n      \r\n      for ( i = count[j]; i <= n; ++i)\r\n      {\r\n        if (arr[i] > arr[0])\r\n       {\r\n        arr[0] = arr[i];\r\n        heapify(arr, 1, count[j]);\r\n       }\r\n      }\r\n      \r\n	 printf(" %d\\n", arr[0]);\r\n    }\r\n  \r\n   \r\n   }\r\n return 0;\r\n}\r\n', '', 0, 626688, 7, 1, '2010-10-05 17:06:18', '0001-01-01 00:00:00'),
(557, 17, 339, 3, '#include<stdio.h>\r\n#include<string.h>\r\n#define M 1001\r\n#define N 100000\r\n\r\nvoid heapify(int* arr, int parent, int heapsize)\r\n{\r\n int left =2 * parent ;\r\n int right = left + 1;\r\n int index = parent;\r\n\r\n if(left <= heapsize && arr[left-1] < arr[index-1])\r\n {\r\n  index = left;\r\n }\r\n if(right <= heapsize && arr[right-1] < arr[index-1])\r\n {\r\n  index = right;\r\n }\r\n if(index != parent)\r\n {\r\n\r\n  int temp;\r\n  temp = arr[parent-1];\r\n  arr[parent-1] = arr[index-1];\r\n  arr[index-1] = temp;\r\n\r\n  heapify(arr, index, heapsize);\r\n  }\r\n  return;\r\n}\r\n\r\nint main()\r\n{\r\n   int n,k;\r\n   int arr2[N];\r\n   while(scanf("%d%d",&n,&k)!=EOF)\r\n  {\r\n	  int count[M]={0};\r\n	  int arr[N]={0};\r\n	 for(int i=0;i<k;++i)\r\n	 {\r\n		 scanf("%d",&count[i]);\r\n         count[i]++;\r\n	 }\r\n	 for(int i=0;i<n;i++)\r\n	 {\r\n              scanf("%d",&arr[i]);\r\n              arr2[i]=arr[i];\r\n     }\r\n	 for(int j=0;j<k;j++)\r\n	 {\r\n           for(int i=0;i<n;i++)\r\n	        {\r\n                arr[i]=arr2[i];\r\n             }\r\n\r\n	     for (int i = count[j] / 2; i >= 1; --i)\r\n          {\r\n             heapify(arr, i, count[j]);\r\n          }\r\n       \r\n		 for (int i = count[j]; i <= n; ++i)\r\n         {\r\n           if (arr[i] > arr[0])\r\n          {\r\n           arr[0] = arr[i];\r\n           heapify(arr, 1, count[j]);\r\n       }\r\n     }\r\n      printf("%d\\n", arr[0]);\r\n    }\r\n   }\r\n return 0;\r\n}\r\n', 'Main.c: In function ''main'':\r\nMain.c:41:3: error: ''for'' loop initial declarations are only allowed in C99 mode\r\nMain.c:41:3: note: use option -std=c99 or -std=gnu99 to compile your code\r\nMain.c:46:11: error: redefinition of ''i''\r\nMain.c:41:11: note: previous definition of ''i'' was here\r\nMain.c:46:3: error: ''for'' loop initial declarations are only allowed in C99 mode\r\nMain.c:51:3: error: ''for'' loop initial declarations are only allowed in C99 mode\r\nMain.c:53:12: error: ''for'' loop initial declaration', 0, 0, 2, 1, '2010-10-06 10:18:38', '0001-01-01 00:00:00'),
(558, 17, 339, 3, '#include<stdio.h>\r\n#include<string.h>\r\n#include<stdlib.h>\r\n#define M 1001\r\n#define N 100000\r\n\r\nvoid heapify(int* arr, int parent, int heapsize)\r\n{\r\n int temp;\r\n int left =2 * parent ;\r\n int right = left + 1;\r\n int index = parent;\r\n\r\n if(left <= heapsize && arr[left-1] < arr[index-1])\r\n {\r\n  index = left;\r\n }\r\n if(right <= heapsize && arr[right-1] < arr[index-1])\r\n {\r\n  index = right;\r\n }\r\n if(index != parent)\r\n {\r\n\r\n  temp = arr[parent-1];\r\n  arr[parent-1] = arr[index-1];\r\n  arr[index-1] = temp;\r\n\r\n  heapify(arr, index, heapsize);\r\n  }\r\n  return;\r\n}\r\n\r\nint main()\r\n{\r\n   int n,k;\r\n   int i,j;\r\n   int arr2[N];\r\n   int arr[N];\r\n   int count[M];\r\n   while(scanf("%d%d",&n,&k)!=EOF)\r\n  {  \r\n	  \r\n	  memset(arr,0,N*sizeof(int)); \r\n	  memset(count,0,M*sizeof(int)); \r\n	 for( i=0;i<k;++i)\r\n	 {\r\n		 scanf("%d",&count[i]);\r\n         count[i]++;\r\n	 }\r\n	 for( i=0;i<n;i++)\r\n	 {\r\n              scanf("%d",&arr[i]);\r\n              arr2[i]=arr[i];\r\n     }\r\n	 for( j=0;j<k;j++)\r\n	 {\r\n           for( i=0;i<n;i++)\r\n	        {\r\n                arr[i]=arr2[i];\r\n             }\r\n\r\n	     for ( i = count[j] / 2; i >= 1; --i)\r\n          {\r\n             heapify(arr, i, count[j]);\r\n          }\r\n       \r\n		 for ( i = count[j]; i <= n; ++i)\r\n         {\r\n           if (arr[i] > arr[0])\r\n          {\r\n           arr[0] = arr[i];\r\n           heapify(arr, 1, count[j]);\r\n       }\r\n     }\r\n      printf("%d\\n", arr[0]);\r\n    }\r\n   }\r\n return 0;\r\n}\r\n', '', 717, 1028096, 5, 1, '2010-10-06 10:22:53', '0001-01-01 00:00:00'),
(559, 17, 339, 3, '#include <stdio.h>\r\n#include <string.h>\r\nint d[5000100], N, K;\r\nint d2[100000];\r\nint count[1001];\r\nint main()\r\n{\r\n   int i, j;\r\n   int cnt,mid,min,max;\r\n   while(scanf("%d%d", &N, &K)&& N | K)\r\n  {  \r\n	 for(i=0;i<K;i++)\r\n		 scanf("%d",count+i);\r\n     for(i = 0; i < N; i++)\r\n     {\r\n      scanf("%d", d + i);\r\n      d2[i]=d[i];\r\n	 }\r\n  \r\n  for(j=0;j<K;j++)\r\n  {\r\n	for(i=0;i<N;i++)\r\n	{  \r\n	  d[i]=d2[i];\r\n      if(i == 0)\r\n      min = max = d[0];\r\n      else\r\n     {\r\n      if(d[i] < min) min = d[i];\r\n      if(d[i] > max) max = d[i];\r\n     }\r\n    }\r\n\r\n    min--;\r\n   while(max - min > 1)\r\n  {\r\n     mid = ((__int64)max + (__int64)min) / 2;\r\n     cnt = 0;\r\n    for(i = 0; i < N; i++)\r\n   {\r\n     if(d[i] <= mid)\r\n     ++cnt;\r\n    }\r\n	\r\n   if(cnt >= N-count[j]) max = mid;\r\n   else min = mid;\r\n   }\r\n   printf("%d %d\\n",count[j], max); \r\n   }\r\n \r\n  }\r\n\r\nreturn 0;\r\n}\r\n', '', 0, 16777216, 6, 1, '2010-10-06 10:40:32', '0001-01-01 00:00:00'),
(560, 17, 339, 3, '#include<stdio.h>\r\n#include<string.h>\r\n#include<stdlib.h>\r\n#define M 1001\r\n#define N 100000\r\n\r\nvoid heapify(int* arr, int parent, int heapsize)\r\n{\r\n int temp;\r\n int left =2 * parent ;\r\n int right = left + 1;\r\n int index = parent;\r\n\r\n if(left <= heapsize && arr[left-1] < arr[index-1])\r\n {\r\n  index = left;\r\n }\r\n if(right <= heapsize && arr[right-1] < arr[index-1])\r\n {\r\n  index = right;\r\n }\r\n if(index != parent)\r\n {\r\n\r\n  temp = arr[parent-1];\r\n  arr[parent-1] = arr[index-1];\r\n  arr[index-1] = temp;\r\n\r\n  heapify(arr, index, heapsize);\r\n  }\r\n  return;\r\n}\r\n\r\nint main()\r\n{\r\n   int n,k;\r\n   int i,j;\r\n   int arr2[N];\r\n   int arr[N];\r\n   int count[M];\r\n   while(scanf("%d%d",&n,&k)!=EOF)\r\n  {  \r\n	  \r\n	  memset(arr,0,N*sizeof(int)); \r\n	  memset(count,0,M*sizeof(int)); \r\n	 for( i=0;i<k;++i)\r\n           scanf("%d",&count[i]);\r\n	 \r\n	 for( i=0;i<n;i++)\r\n	 {\r\n              scanf("%d",&arr[i]);\r\n              arr2[i]=arr[i];\r\n     }\r\n	 \r\n	 for( j=0;j<k;j++)\r\n	 {\r\n           for( i=0;i<n;i++)\r\n	        {\r\n                arr[i]=arr2[i];\r\n             }\r\n\r\n	     for ( i = count[j] +1/ 2; i >= 1; --i)\r\n          {\r\n             heapify(arr, i, count[j]+1);\r\n          }\r\n       \r\n		 for ( i = count[j]+1; i <= n; ++i)\r\n         {\r\n           if (arr[i] > arr[0])\r\n          {\r\n           arr[0] = arr[i];\r\n           heapify(arr, 1, count[j]+1);\r\n       }\r\n     }\r\n      printf("%d\\n", arr[0]);\r\n    }\r\n   }\r\n return 0;\r\n}\r\n\r\n', '', 686, 1028096, 5, 1, '2010-10-06 11:00:36', '0001-01-01 00:00:00'),
(561, 17, 339, 3, '#include<stdio.h>\r\n#include<stdlib.h>\r\n#define N 100000\r\n#define M 1001\r\nint comp(const void* e1,const void * e2){  \r\n\r\nreturn *((int*)e2)-*((int*)e1);\r\n\r\n}\r\nint main()\r\n{\r\n   int n,k;\r\n   int i,j;\r\n   int arr[N];\r\n   int count[M];\r\n   while(scanf("%d%d",&n,&k)!=EOF)\r\n  {  \r\n	  \r\n	 for( i=0;i<k;++i)\r\n	 {\r\n		 scanf("%d",&count[i]);\r\n	 }\r\n	 for( i=0;i<n;i++)\r\n	 {\r\n              scanf("%d",&arr[i]);\r\n     }\r\n qsort(arr,n,sizeof(arr[0]),comp);   \r\n for(i=0;i< k;i++)  \r\n {      \r\n	printf("%d\\n",arr[count[i]]);        \r\n }\r\n   }\r\nreturn 0;\r\n} \r\n\r\n', '', 217, 634880, 1, 1, '2010-10-06 11:13:20', '0001-01-01 00:00:00'),
(562, 7, 36, 0, '/**************************************************\r\nAuthor: mwkfeng\r\nCreate Time: 2010-10-6 22:35\r\nLast Modified Time: \r\nFile Name: joj0036_Ugly_numbers.cpp\r\nDescription:\r\n***************************************************/\r\n\r\n#include<cstdio>\r\n#include<cmath>\r\n#include<cstring>\r\n\r\nusing namespace std;\r\nconst int maxn = 1550;\r\nint n;\r\nint unum[maxn];\r\n\r\nint main()\r\n{\r\n    int i;\r\n    n = 1;\r\n    unum[n] = 1;\r\n    int p2 = 1, p3 = 1, p5 = 1;\r\n\r\n    while(n<=1500)\r\n    {\r\n	n++;\r\n	int t2 = 2*unum[p2], t3 = 3*unum[p3], t5 = 5*unum[p5];\r\n\r\n	int mint = t2;\r\n	if(t3 < mint) mint = t3;\r\n	if(t5 < mint) mint = t5;\r\n\r\n	if(mint==t2)\r\n	{\r\n	    p2++;\r\n	    unum[n] = t2;\r\n	}\r\n	if(mint==t3)\r\n	{\r\n	    p3++;\r\n	    unum[n] = t3;\r\n	}\r\n	if(mint==t5)\r\n	{\r\n	    p5++;\r\n	    unum[n] = t5;\r\n	}\r\n    }\r\n\r\n    printf("The 1500''th ugly number is %d.\\n",unum[1500]);\r\n    return 0;\r\n}', '', 0, 266240, 1, 2, '2010-10-06 23:02:56', '0001-01-01 00:00:00'),
(563, 34, 343, 0, '#', 'e:/shpchen/oj/jojserver/tools/gcc/bin/../lib/gcc/mingw32/4.5.0/../../..\\libmingw32.a(main.o):main.c:(.text+0xd2): undefined reference to `WinMain@16''\r\ncollect2: ld returned 1 exit status\r\n', 0, 0, 2, 1, '2010-10-09 17:24:53', '0001-01-01 00:00:00'),
(564, 6, 251, 0, '#include <iostream>\r\n#include <string>\r\n#include <vector>\r\n#include <algorithm>\r\n#include <functional>\r\n#include <numeric>\r\n#include <cstdio>\r\n#include <cstdlib>\r\n#include <cmath>\r\n#include <vector>\r\n#include <string>\r\nusing namespace std;\r\n\r\nint gcd(int a, int b) {\r\n	int n;\r\n	while( b ) {\r\n		n = b;\r\n		b = a%b;\r\n		a = n;\r\n	}\r\n	return abs(a);\r\n}\r\n\r\nchar buf[1000000];\r\n\r\nvoid writefraction(int a, int b) {\r\n	int n = gcd(a, b);\r\n	if( b < 0 ) n = -n;\r\n	a /= n; b /= n;\r\n	cout << a;\r\n	if( b != 1 ) cout << ''/'' << b;\r\n	cout << endl;\r\n}\r\n\r\nint main() {\r\n	int i, j, k, x1, y1, z1, x2, y2, z2, n;\r\n	int num, den;\r\n	int eq, sgn;\r\n	int prob, first=1;\r\n	char *tok, ch;\r\n\r\n	for( scanf( "%d ", &prob ); prob; prob-- ) {\r\n		if( !first ) putchar( ''\\n'' );\r\n		first = 0;\r\n		gets(buf);\r\n		eq = sgn = 1;\r\n		x1 = y1 = z1 = 0;\r\n		for( tok = strtok(buf, " "); tok; tok = strtok(0, " ")) {\r\n             //printf("%s\\n",tok);\r\n			if( strcmp(tok, "=") == 0 ) {eq = -1; sgn = 1; continue;}\r\n			if( *tok == ''+'' ) //if( !*(++tok) ) continue;\r\n			if( *tok == ''-'' ) {sgn = -sgn;} //if( !*(++tok) ) continue;}\r\n			printf("111\\n");\r\n			if( isalpha(tok[0]) ) n = 1; else n = atoi(tok);\r\n			char ch = tok[strlen(tok)-1];\r\n			if( ch == ''x'' ) x1 += n*eq*sgn;\r\n			else if( ch == ''y'' ) y1 += n*eq*sgn;\r\n			else z1 += n*eq*sgn;\r\n			sgn = 1;\r\n		}\r\n		gets(buf);\r\n		eq = sgn = 1;\r\n		x2 = y2 = z2 = 0;\r\n		for( tok = strtok(buf, " "); tok; tok = strtok(0, " ")) {\r\n			if( strcmp(tok, "=") == 0 ) {eq = -1; sgn = 1; continue;}\r\n			if( *tok == ''+'' ) //if( !*(++tok) ) continue;\r\n			if( *tok == ''-'' ) {sgn = -sgn;} //if( !*(++tok) ) continue;}\r\n			if( isalpha(tok[0]) ) n = 1; else n = atoi(tok);\r\n			ch = tok[strlen(tok)-1];\r\n			if( ch == ''x'' ) x2 += n*eq*sgn;\r\n			else if( ch == ''y'' ) y2 += n*eq*sgn;\r\n			else z2 += n*eq*sgn;\r\n			sgn = 1;\r\n		}\r\n		gets(buf);\r\n		num = -(z1*y2-z2*y1);\r\n		den =   x1*y2-x2*y1;\r\n		if (den == 0) {\r\n			if( y1 || y2 || !(x1 || x2) || (z2*x1 != z1*x2) )\r\n				cout << "don''t know" << endl;\r\n			else\r\n				if( x1 ) writefraction(-z1, x1); else writefraction(-z2, x2);\r\n		} else\r\n			writefraction(num, den);\r\n		num = -(z1*x2-z2*x1);\r\n		den =   y1*x2-y2*x1;\r\n		if (den == 0) {\r\n			if( x1 || x2 || !(y1 || y2) || (z2*y1 != z1*y2) )\r\n				cout << "don''t know" << endl;\r\n			else\r\n				if( y1 ) writefraction(-z1, y1); else writefraction(-z2, y2);\r\n		} else\r\n			writefraction(num, den);\r\n	}\r\n	return 0;\r\n}', 'Main.cpp: In function ''int main()'':\r\nMain.cpp:48:29: error: ''strtok'' was not declared in this scope\r\nMain.cpp:50:23: error: ''strcmp'' was not declared in this scope\r\nMain.cpp:55:28: error: ''strlen'' was not declared in this scope\r\nMain.cpp:65:23: error: ''strcmp'' was not declared in this scope\r\nMain.cpp:69:23: error: ''strlen'' was not declared in this scope\r\n', 0, 0, 2, 2, '2010-10-11 13:17:27', '0001-01-01 00:00:00'),
(565, 6, 251, 0, '#include <iostream>\r\n#include <string>\r\n#include <vector>\r\n#include <algorithm>\r\n#include <functional>\r\n#include <numeric>\r\n#include <cstdio>\r\n#include <cstdlib>\r\n#include <cmath>\r\n#include <vector>\r\n#include <string.h>\r\nusing namespace std;\r\n\r\nint gcd(int a, int b) {\r\n	int n;\r\n	while( b ) {\r\n		n = b;\r\n		b = a%b;\r\n		a = n;\r\n	}\r\n	return abs(a);\r\n}\r\n\r\nchar buf[1000000];\r\n\r\nvoid writefraction(int a, int b) {\r\n	int n = gcd(a, b);\r\n	if( b < 0 ) n = -n;\r\n	a /= n; b /= n;\r\n	cout << a;\r\n	if( b != 1 ) cout << ''/'' << b;\r\n	cout << endl;\r\n}\r\n\r\nint main() {\r\n	int i, j, k, x1, y1, z1, x2, y2, z2, n;\r\n	int num, den;\r\n	int eq, sgn;\r\n	int prob, first=1;\r\n	char *tok, ch;\r\n\r\n	for( scanf( "%d ", &prob ); prob; prob-- ) {\r\n		if( !first ) putchar( ''\\n'' );\r\n		first = 0;\r\n		gets(buf);\r\n		eq = sgn = 1;\r\n		x1 = y1 = z1 = 0;\r\n		for( tok = strtok(buf, " "); tok; tok = strtok(0, " ")) {\r\n             //printf("%s\\n",tok);\r\n			if( strcmp(tok, "=") == 0 ) {eq = -1; sgn = 1; continue;}\r\n			if( *tok == ''+'' ) //if( !*(++tok) ) continue;\r\n			if( *tok == ''-'' ) {sgn = -sgn;} //if( !*(++tok) ) continue;}\r\n			printf("111\\n");\r\n			if( isalpha(tok[0]) ) n = 1; else n = atoi(tok);\r\n			char ch = tok[strlen(tok)-1];\r\n			if( ch == ''x'' ) x1 += n*eq*sgn;\r\n			else if( ch == ''y'' ) y1 += n*eq*sgn;\r\n			else z1 += n*eq*sgn;\r\n			sgn = 1;\r\n		}\r\n		gets(buf);\r\n		eq = sgn = 1;\r\n		x2 = y2 = z2 = 0;\r\n		for( tok = strtok(buf, " "); tok; tok = strtok(0, " ")) {\r\n			if( strcmp(tok, "=") == 0 ) {eq = -1; sgn = 1; continue;}\r\n			if( *tok == ''+'' ) //if( !*(++tok) ) continue;\r\n			if( *tok == ''-'' ) {sgn = -sgn;} //if( !*(++tok) ) continue;}\r\n			if( isalpha(tok[0]) ) n = 1; else n = atoi(tok);\r\n			ch = tok[strlen(tok)-1];\r\n			if( ch == ''x'' ) x2 += n*eq*sgn;\r\n			else if( ch == ''y'' ) y2 += n*eq*sgn;\r\n			else z2 += n*eq*sgn;\r\n			sgn = 1;\r\n		}\r\n		gets(buf);\r\n		num = -(z1*y2-z2*y1);\r\n		den =   x1*y2-x2*y1;\r\n		if (den == 0) {\r\n			if( y1 || y2 || !(x1 || x2) || (z2*x1 != z1*x2) )\r\n				cout << "don''t know" << endl;\r\n			else\r\n				if( x1 ) writefraction(-z1, x1); else writefraction(-z2, x2);\r\n		} else\r\n			writefraction(num, den);\r\n		num = -(z1*x2-z2*x1);\r\n		den =   y1*x2-y2*x1;\r\n		if (den == 0) {\r\n			if( x1 || x2 || !(y1 || y2) || (z2*y1 != z1*y2) )\r\n				cout << "don''t know" << endl;\r\n			else\r\n				if( y1 ) writefraction(-z1, y1); else writefraction(-z2, y2);\r\n		} else\r\n			writefraction(num, den);\r\n	}\r\n	return 0;\r\n}\r\n', '', 0, 1363968, 4, 2, '2010-10-11 13:17:56', '0001-01-01 00:00:00'),
(566, 6, 251, 0, '#include <iostream>\r\n#include <string>\r\n#include <vector>\r\n#include <algorithm>\r\n#include <functional>\r\n#include <numeric>\r\n#include <cstdio>\r\n#include <cstdlib>\r\n#include <cmath>\r\n#include <vector>\r\n#include <string.h>\r\nusing namespace std;\r\n\r\nint gcd(int a, int b) {\r\n	int n;\r\n	while( b ) {\r\n		n = b;\r\n		b = a%b;\r\n		a = n;\r\n	}\r\n	return abs(a);\r\n}\r\n\r\nchar buf[1000000];\r\n\r\nvoid writefraction(int a, int b) {\r\n	int n = gcd(a, b);\r\n	if( b < 0 ) n = -n;\r\n	a /= n; b /= n;\r\n	cout << a;\r\n	if( b != 1 ) cout << ''/'' << b;\r\n	cout << endl;\r\n}\r\n\r\nint main() {\r\n	int i, j, k, x1, y1, z1, x2, y2, z2, n;\r\n	int num, den;\r\n	int eq, sgn;\r\n	int prob, first=1;\r\n	char *tok, ch;\r\n\r\n	for( scanf( "%d ", &prob ); prob; prob-- ) {\r\n		if( !first ) putchar( ''\\n'' );\r\n		first = 0;\r\n		gets(buf);\r\n		eq = sgn = 1;\r\n		x1 = y1 = z1 = 0;\r\n		for( tok = strtok(buf, " "); tok; tok = strtok(0, " ")) {\r\n             //printf("%s\\n",tok);\r\n			if( strcmp(tok, "=") == 0 ) {eq = -1; sgn = 1; continue;}\r\n			if( *tok == ''+'' ) if( !*(++tok) ) continue;\r\n			if( *tok == ''-'' ) {sgn = -sgn; if( !*(++tok) ) continue;}\r\n			printf("111\\n");\r\n			if( isalpha(tok[0]) ) n = 1; else n = atoi(tok);\r\n			char ch = tok[strlen(tok)-1];\r\n			if( ch == ''x'' ) x1 += n*eq*sgn;\r\n			else if( ch == ''y'' ) y1 += n*eq*sgn;\r\n			else z1 += n*eq*sgn;\r\n			sgn = 1;\r\n		}\r\n		gets(buf);\r\n		eq = sgn = 1;\r\n		x2 = y2 = z2 = 0;\r\n		for( tok = strtok(buf, " "); tok; tok = strtok(0, " ")) {\r\n			if( strcmp(tok, "=") == 0 ) {eq = -1; sgn = 1; continue;}\r\n			if( *tok == ''+'' ) if( !*(++tok) ) continue;\r\n			if( *tok == ''-'' ) {sgn = -sgn; if( !*(++tok) ) continue;}\r\n			if( isalpha(tok[0]) ) n = 1; else n = atoi(tok);\r\n			ch = tok[strlen(tok)-1];\r\n			if( ch == ''x'' ) x2 += n*eq*sgn;\r\n			else if( ch == ''y'' ) y2 += n*eq*sgn;\r\n			else z2 += n*eq*sgn;\r\n			sgn = 1;\r\n		}\r\n		gets(buf);\r\n		num = -(z1*y2-z2*y1);\r\n		den =   x1*y2-x2*y1;\r\n		if (den == 0) {\r\n			if( y1 || y2 || !(x1 || x2) || (z2*x1 != z1*x2) )\r\n				cout << "don''t know" << endl;\r\n			else\r\n				if( x1 ) writefraction(-z1, x1); else writefraction(-z2, x2);\r\n		} else\r\n			writefraction(num, den);\r\n		num = -(z1*x2-z2*x1);\r\n		den =   y1*x2-y2*x1;\r\n		if (den == 0) {\r\n			if( x1 || x2 || !(y1 || y2) || (z2*y1 != z1*y2) )\r\n				cout << "don''t know" << endl;\r\n			else\r\n				if( y1 ) writefraction(-z1, y1); else writefraction(-z2, y2);\r\n		} else\r\n			writefraction(num, den);\r\n	}\r\n	return 0;\r\n}\r\n', '', 0, 1368064, 4, 2, '2010-10-11 13:18:38', '0001-01-01 00:00:00'),
(567, 6, 251, 0, '#include <iostream>\r\n#include <string.h>\r\n#include <vector>\r\n#include <algorithm>\r\n#include <functional>\r\n#include <numeric>\r\n#include <cstdio>\r\n#include <cstdlib>\r\n#include <cmath>\r\nusing namespace std;\r\n\r\nint gcd(int a, int b) {\r\n	int n;\r\n	while( b ) {\r\n		n = b;\r\n		b = a%b;\r\n		a = n;\r\n	}\r\n	return abs(a);\r\n}\r\n\r\nchar buf[1000000];\r\n\r\nvoid writefraction(int a, int b) {\r\n	int n = gcd(a, b);\r\n	if( b < 0 ) n = -n;\r\n	a /= n; b /= n;\r\n	cout << a;\r\n	if( b != 1 ) cout << ''/'' << b;\r\n	cout << endl;\r\n}\r\n\r\nmain() {\r\n	int i, j, k, x1, y1, z1, x2, y2, z2, n;\r\n	int num, den;\r\n	int eq, sgn;\r\n	int prob, first=1;\r\n	char *tok, ch;\r\n\r\n	for( scanf( "%d ", &prob ); prob; prob-- ) {\r\n		if( !first ) putchar( ''\\n'' );\r\n		first = 0;\r\n		gets(buf);\r\n		eq = sgn = 1;\r\n		x1 = y1 = z1 = 0;\r\n		for( tok = strtok(buf, " "); tok; tok = strtok(0, " ")) {\r\n			if( strcmp(tok, "=") == 0 ) {eq = -1; sgn = 1; continue;}\r\n			if( *tok == ''+'' ) if( !*(++tok) ) continue;\r\n			if( *tok == ''-'' ) {sgn = -sgn; if( !*(++tok) ) continue;}\r\n			if( isalpha(tok[0]) ) n = 1; else n = atoi(tok);\r\n			char ch = tok[strlen(tok)-1];\r\n			if( ch == ''x'' ) x1 += n*eq*sgn;\r\n			else if( ch == ''y'' ) y1 += n*eq*sgn;\r\n			else z1 += n*eq*sgn;\r\n			sgn = 1;\r\n		}\r\n		gets(buf);\r\n		eq = sgn = 1;\r\n		x2 = y2 = z2 = 0;\r\n		for( tok = strtok(buf, " "); tok; tok = strtok(0, " ")) {\r\n			if( strcmp(tok, "=") == 0 ) {eq = -1; sgn = 1; continue;}\r\n			if( *tok == ''+'' ) if( !*(++tok) ) continue;\r\n			if( *tok == ''-'' ) {sgn = -sgn; if( !*(++tok) ) continue;}\r\n			if( isalpha(tok[0]) ) n = 1; else n = atoi(tok);\r\n			ch = tok[strlen(tok)-1];\r\n			if( ch == ''x'' ) x2 += n*eq*sgn;\r\n			else if( ch == ''y'' ) y2 += n*eq*sgn;\r\n			else z2 += n*eq*sgn;\r\n			sgn = 1;\r\n		}\r\n		gets(buf);\r\n		num = -(z1*y2-z2*y1);\r\n		den =   x1*y2-x2*y1;\r\n		if (den == 0) {\r\n			if( y1 || y2 || !(x1 || x2) || (z2*x1 != z1*x2) )\r\n				cout << "don''t know" << endl;\r\n			else\r\n				if( x1 ) writefraction(-z1, x1); else writefraction(-z2, x2);\r\n		} else\r\n			writefraction(num, den);\r\n		num = -(z1*x2-z2*x1);\r\n		den =   y1*x2-y2*x1;\r\n		if (den == 0) {\r\n			if( x1 || x2 || !(y1 || y2) || (z2*y1 != z1*y2) )\r\n				cout << "don''t know" << endl;\r\n			else\r\n				if( y1 ) writefraction(-z1, y1); else writefraction(-z2, y2);\r\n		} else\r\n			writefraction(num, den);\r\n	}\r\n}\r\n', '', 0, 1372160, 1, 2, '2010-10-11 13:19:36', '0001-01-01 00:00:00'),
(568, 34, 335, 2, '#include <stdio.h>\r\n\r\nint main()\r\n{\r\n	int a,b,t,v;\r\n	while(scanf("%d %d",&a,&b)!=EOF)\r\n	{\r\n		t=0;\r\n		v=a^b;\r\n		while(v)\r\n		{\r\n			v &= (v-1);\r\n			++t;\r\n		}\r\n		printf("%d\\n",t);\r\n	}\r\n	return 0;\r\n}', '', 62, 262144, 1, 1, '2010-10-11 13:38:26', '0001-01-01 00:00:00');
INSERT INTO `tbl_submitions` (`id`, `user_id`, `problem_id`, `exercise_id`, `source`, `result`, `used_time`, `used_memory`, `status`, `compiler_id`, `created`, `modified`) VALUES
(569, 1, 344, 0, '#include <stdio.h>\r\n#include <iostream>\r\n#include <fstream>\r\n#include <time.h>\r\n#include <algorithm>\r\n#include <vector>\r\n#include <map>\r\n#include <string>\r\n#include <functional>\r\nusing namespace std;\r\nint gen_main();\r\nint cal_main();\r\nint main(int argc, char* argv[])\r\n{\r\n	//gen_main();\r\n	//freopen("c:/ti.txt","r",stdin);\r\n	//freopen("c:/to.txt","w",stdout);\r\n	int n;\r\n	int i;\r\n	char sTemp[1024];\r\n	while(scanf("%d",&n)==1)\r\n	{\r\n		std::map<string,int> loop;\r\n		for(i=1;i<n;++i)\r\n		{\r\n			scanf("%s",sTemp);\r\n			loop[sTemp]=i;\r\n		}\r\n		scanf("%s",sTemp);\r\n		if(loop.find(sTemp)!=loop.end())printf("%d\\n",loop.size()-loop[sTemp]+1);\r\n		else printf("0\\n");\r\n	}\r\n	return 0;\r\n\r\n\r\n}\r\nint cal_man();\r\n\r\nint gen_main()\r\n{\r\n	//srand( (unsigned)time( NULL ) );//srand()函数产生一个以当前时间开始的随机种子.应该放在for等循环语句前面 不然要很长时间等待\r\n	ofstream ci("c:/ti.txt");\r\n	int icase=0;\r\n	while(icase++<10)\r\n	{\r\n		ci<<1000<<endl;\r\n		ci<<"a11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111";\r\n		for(int i=2;i<1000;++i)\r\n			ci<<" a"<<i;\r\n\r\n		ci<<" a"<<(icase)*91;\r\n		ci<<endl;\r\n	}\r\n		ci<<10000<<endl;\r\n		ci<<"a11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111";\r\n		for(int i=1;i<10000;++i)\r\n			ci<<" a"<<i;\r\n	return 0;\r\n\r\n}\r\n', '', 46, 1130496, 1, 2, '2010-10-13 23:20:32', '0001-01-01 00:00:00'),
(570, 1, 345, 0, '#include <stdio.h>\r\n#include <iostream>\r\n#include <fstream>\r\n#include <time.h>\r\n#include <algorithm>\r\n#include <vector>\r\n#include <map>\r\n#include <string>\r\n#include <functional>\r\nusing namespace std;\r\nint gen_main();\r\nint cal_main();\r\nint main(int argc, char* argv[])\r\n{\r\n	//gen_main();\r\n	//freopen("c:/ti.txt","r",stdin);\r\n	//freopen("c:/to.txt","w",stdout);\r\n	int n,i;\r\n	char sTemp[1024];\r\n	while(scanf("%d",&n)==1)\r\n	{\r\n		std::map<string,int> loop;\r\n		for(i=1;i<n;++i)\r\n		{\r\n			scanf("%s",sTemp);\r\n			loop[sTemp]=i;\r\n		}\r\n		scanf("%s",sTemp);\r\n		if(loop.find(sTemp)==loop.end())loop[sTemp]=i;\r\n		scanf("%d",&n);\r\n		std::map<string,int>::iterator itf,itff=loop.end(),itz;\r\n		for(i=0;i<n;++i)\r\n		{\r\n			scanf("%s",sTemp);\r\n			if((itf=loop.find(sTemp))!=loop.end())\r\n			{\r\n				if(itff==loop.end())\r\n				{\r\n					itff=itf;\r\n					itz=itf;\r\n				}\r\n				else if(itz->second>itf->second)itz=itf;\r\n			}\r\n		}\r\n		if(itff==loop.end())\r\n		{\r\n			printf("none none\\n");\r\n		}\r\n		else\r\n		{\r\n			printf("%s %s\\n",itz->first.c_str(),itff->first.c_str());\r\n		}\r\n	}\r\n	return 0;\r\n\r\n\r\n}\r\nint cal_man();\r\n\r\nint gen_main()\r\n{\r\n	//srand( (unsigned)time( NULL ) );//srand()函数产生一个以当前时间开始的随机种子.应该放在for等循环语句前面 不然要很长时间等待\r\n	ofstream ci("c:/ti.txt");\r\n	int icase=0;\r\n	while(icase++<10)\r\n	{\r\n		ci<<1000<<endl;\r\n		ci<<"a11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111";\r\n		for(int i=2;i<1000;++i)\r\n			ci<<" a"<<i;\r\n\r\n		ci<<" a"<<(icase)*91;\r\n		ci<<endl;\r\n		ci<<1000<<endl;\r\n		ci<<"a11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111";\r\n		for(int i=2;i<1000;++i)\r\n			ci<<" a"<<i;\r\n\r\n		ci<<" a"<<(icase)*91;\r\n		ci<<endl;\r\n	}\r\n		ci<<10000<<endl;\r\n		ci<<"a11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111";\r\n		for(int i=1;i<10000;++i)\r\n			ci<<" a"<<i;\r\n		ci<<10000<<endl;\r\n		ci<<"b11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111";\r\n		for(int i=1;i<10000;++i)\r\n			ci<<" b"<<i;\r\n	return 0;\r\n\r\n}\r\n', '', 15, 540672, 1, 2, '2010-10-14 00:06:19', '0001-01-01 00:00:00'),
(571, 10, 336, 2, '#include <stdio.h>\r\n#include <iostream>\r\n#include <vector>\r\n#include <algorithm>\r\n#include <iterator>\r\n#define POW(c) (1<<(c))\r\n#define MASK(c) (((unsigned long)-1) / (POW(POW(c)) + 1))\r\n#define ROUND(n, c) (((n) & MASK(c)) + ((n) >> POW(c) & MASK(c)))\r\nusing namespace std;\r\nint bit_count(unsigned int n)\r\n{\r\nn = ROUND(n, 0);\r\nn = ROUND(n, 1);\r\nn = ROUND(n, 2);\r\nn = ROUND(n, 3);\r\nn = ROUND(n, 4);\r\nreturn n;\r\n}\r\nbool compare(int a,int b)\r\n{\r\n   if(bit_count(a)==bit_count(b))\r\n	   return a<b;\r\n   else \r\n	   return bit_count(a)<bit_count(b);\r\n}\r\nint main()\r\n{\r\n int num,size,i=0;\r\n vector<int> temp;\r\n while(scanf("%d",&size)==1)\r\n {\r\n   while(i != size)\r\n   {\r\n  scanf("%d",&num);\r\n  temp.push_back(num);\r\n  i++;\r\n   }\r\n  sort(temp.begin(),temp.end(),compare);\r\n  for(vector<int>::iterator iter = temp.begin();\r\n      iter != temp.end();iter++)\r\n   printf("%d ",*iter);\r\n }\r\n return 0;\r\n}\r\n\r\n', 'Main.c:2:20: fatal error: iostream: No such file or directory\r\ncompilation terminated.\r\n', 0, 0, 2, 1, '2010-10-14 09:00:52', '0001-01-01 00:00:00'),
(572, 10, 336, 2, '#include <stdio.h>\r\n#include <iostream>\r\n#include <vector>\r\n#include <algorithm>\r\n#include <iterator>\r\n#define POW(c) (1<<(c))\r\n#define MASK(c) (((unsigned long)-1) / (POW(POW(c)) + 1))\r\n#define ROUND(n, c) (((n) & MASK(c)) + ((n) >> POW(c) & MASK(c)))\r\nusing namespace std;\r\nint bit_count(unsigned int n)\r\n{\r\nn = ROUND(n, 0);\r\nn = ROUND(n, 1);\r\nn = ROUND(n, 2);\r\nn = ROUND(n, 3);\r\nn = ROUND(n, 4);\r\nreturn n;\r\n}\r\nbool compare(int a,int b)\r\n{\r\n   if(bit_count(a)==bit_count(b))\r\n	   return a<b;\r\n   else \r\n	   return bit_count(a)<bit_count(b);\r\n}\r\nint main()\r\n{\r\n int num,size,i=0;\r\n vector<int> temp;\r\n while(scanf("%d",&size)==1)\r\n {\r\n   while(i != size)\r\n   {\r\n  scanf("%d",&num);\r\n  temp.push_back(num);\r\n  i++;\r\n   }\r\n  sort(temp.begin(),temp.end(),compare);\r\n  for(vector<int>::iterator iter = temp.begin();\r\n      iter != temp.end();iter++)\r\n   printf("%d ",*iter);\r\n }\r\n return 0;\r\n}\r\n\r\n', '', 46, 626688, 3, 2, '2010-10-14 09:02:15', '0001-01-01 00:00:00'),
(573, 10, 336, 2, '#include <stdio.h>\r\n#include <iostream>\r\n#include <vector>\r\n#include <algorithm>\r\n#include <iterator>\r\n#define POW(c) (1<<(c))\r\n#define MASK(c) (((unsigned long)-1) / (POW(POW(c)) + 1))\r\n#define ROUND(n, c) (((n) & MASK(c)) + ((n) >> POW(c) & MASK(c)))\r\nusing namespace std;\r\nint bit_count(unsigned int n)\r\n{\r\nn = ROUND(n, 0);\r\nn = ROUND(n, 1);\r\nn = ROUND(n, 2);\r\nn = ROUND(n, 3);\r\nn = ROUND(n, 4);\r\nreturn n;\r\n}\r\nbool compare(int a,int b)\r\n{\r\n   if(bit_count(a)==bit_count(b))\r\n	   return a<b;\r\n   else \r\n	   return bit_count(a)<bit_count(b);\r\n}\r\nint main()\r\n{\r\n int num,size,i=0;\r\n vector<int> temp;\r\n while(1 == scanf("%d",&size))\r\n {\r\n	 i = 0;\r\n	 temp.clear();\r\n   while(i != size)\r\n   {\r\n  scanf("%d",&num);\r\n  temp.push_back(num);\r\n  i++;\r\n   }\r\n  sort(temp.begin(),temp.end(),compare);\r\n  for(vector<int>::iterator iter = temp.begin();\r\n      iter != temp.end();iter++)\r\n   printf("%d ",*iter);\r\n   printf("\\n");\r\n }\r\n return 0;\r\n}\r\n\r\n', '', 31, 622592, 3, 2, '2010-10-14 09:08:09', '0001-01-01 00:00:00'),
(574, 17, 344, 4, '#include<iostream>\r\n#include<map>\r\nusing namespace std;\r\nusing std::cin;\r\nusing std::cout;\r\nint main()\r\n{\r\n	int n;\r\n	while(cin>>n)\r\n	{\r\n		int num=0;\r\n		map<string,int>snakes;\r\n		string snake;\r\n		cin >> snake;\r\n		++snakes[snake];\r\n		for(int i=2;i<=n;i++)\r\n		{\r\n			cin >> snake;\r\n			for(map<string, int>::const_iterator iter = snakes.begin(); iter != snakes.end(); iter++)\r\n			{    \r\n                  if(iter->first==snake)\r\n					num=iter.second-i; \r\n			}\r\n            ++snakes[snake];\r\n		}\r\n		cout << num <<endl;\r\n	}\r\n	return 0;\r\n}\r\n		    \r\n	\r\n		    \r\n', 'Main.cpp: In function ''int main()'':\r\nMain.cpp:22:15: error: ''struct std::map<std::basic_string<char>, int>::const_iterator'' has no member named ''second''\r\n', 0, 0, 2, 2, '2010-10-14 09:16:52', '0001-01-01 00:00:00'),
(575, 6, 344, 4, '#include <stdio.h>\r\n#include <string.h>\r\n#include <algorithm>\r\n#include <map>\r\n#include <string>\r\nusing namespace std;\r\nmap<string,int> mp;\r\nmap<string,int>::iterator it;\r\nint q[20500],ind;\r\n\r\nint get(char str[])\r\n{\r\n    string s(str);\r\n    it=mp.find(s);\r\n    if(it==mp.end())\r\n    {\r\n       mp.insert(make_pair(s,++ind));\r\n       return ind;\r\n    }\r\n    else return it->second;\r\n}\r\n\r\nint main()\r\n{\r\n    int n,i,j,ans;\r\n    char flag;\r\n    char str[105];\r\n    while(scanf("%d",&n)!=EOF)\r\n    {\r\n        ind=0;\r\n        mp.clear();\r\n		memset(q,0,sizeof(q));\r\n        for(i=1;i<=n;++i)\r\n        {\r\n            scanf("%s",str);\r\n            q[i]=get(str);\r\n        }\r\n        \r\n        ans=0;\r\n        flag=0;\r\n        for(i=1;i<=n;++i)\r\n        {\r\n            for(j=n;j>i;--j)\r\n            {\r\n                if(q[i]==q[j])\r\n                {\r\n                   ans=j-i;\r\n                   flag=1;\r\n                   break;\r\n                }\r\n            }\r\n            if(flag) break;\r\n        }    \r\n        printf("%d\\n",ans);\r\n    }\r\n    return 0;\r\n}', '', 46, 1134592, 7, 2, '2010-10-14 09:20:53', '0001-01-01 00:00:00'),
(576, 17, 344, 4, '#include<iostream>\r\n#include<map>\r\n#include<string>\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n	int n;\r\n	while(cin>>n)\r\n	{\r\n		int num=0;\r\n		map<string,int>snakes;\r\n		string snake;\r\n		cin >> snake;\r\n		++snakes[snake];\r\n		for(int i=2;i<=n;i++)\r\n		{\r\n			cin >> snake;\r\n			for(map<string, int>::const_iterator iter = snakes.begin(); iter != snakes.end(); iter++)\r\n			{    \r\n                  if(iter->first==snake)\r\n				  { \r\n					     int num2=iter->second;\r\n				         num=i-num2; \r\n				  }\r\n			}\r\n            ++snakes[snake];\r\n		}\r\n		cout << num <<endl;\r\n	}\r\n	return 0;\r\n}\r\n', '', 200, 1064960, 5, 2, '2010-10-14 09:25:05', '0001-01-01 00:00:00'),
(577, 17, 344, 4, '#include<iostream>\r\n#include<map>\r\n#include<string>\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n	int n;\r\n	while(cin>>n)\r\n	{\r\n		int num=0;\r\n		map<string,int>snakes;\r\n		string snake;\r\n		cin >> snake;\r\n		++snakes[snake];\r\n		for(int i=2;i<=n;i++)\r\n		{\r\n			cin >> snake;\r\n			for(map<string, int>::const_iterator iter = snakes.begin(); iter != snakes.end(); iter++)\r\n			{    \r\n                  if(iter->first==snake)\r\n				  { \r\n				         num=i-num2->second; \r\n				  }\r\n			}\r\n            ++snakes[snake];\r\n		}\r\n		cout << num <<endl;\r\n	}\r\n	return 0;\r\n}\r\n', 'Main.cpp: In function ''int main()'':\r\nMain.cpp:23:20: error: ''num2'' was not declared in this scope\r\n', 0, 0, 2, 2, '2010-10-14 09:26:02', '0001-01-01 00:00:00'),
(578, 17, 344, 4, '#include<iostream>\r\n#include<map>\r\n#include<string>\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n	int n;\r\n	while(cin>>n)\r\n	{\r\n		int num=0;\r\n		map<string,int>snakes;\r\n		string snake;\r\n		cin >> snake;\r\n		++snakes[snake];\r\n		for(int i=2;i<=n;i++)\r\n		{\r\n			cin >> snake;\r\n			for(map<string, int>::const_iterator iter = snakes.begin(); iter != snakes.end(); iter++)\r\n			{    \r\n                  if(iter->first==snake)\r\n				  { \r\n				     num=i-iter->second; \r\n				  }\r\n			}\r\n            ++snakes[snake];\r\n		}\r\n		cout << num <<endl;\r\n	}\r\n	return 0;\r\n}\r\n', '', 200, 1130496, 5, 2, '2010-10-14 09:27:21', '0001-01-01 00:00:00'),
(579, 25, 344, 4, '#include<iostream>\r\n#include<map>\r\n#include<string>\r\n#include<cstdio>\r\n\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n	\r\n	int a,i;\r\n	while(scanf("%d",&a) == 1)\r\n	{\r\n		map<string,int> mapName;\r\n		string str;\r\n		pair<map<string, int>::iterator,bool> Insert_Pair;\r\n		for(i = 0; i < a; ++i)\r\n		{\r\n			cin >> str;\r\n			Insert_Pair = mapName.insert(pair<string,int>(str,i));\r\n		}\r\n		map<string,int>::iterator it = mapName.find(str);\r\n		if(mapName.end() != it)\r\n			printf("%d\\n",i - it->second-1);\r\n		else\r\n			printf("0\\n");\r\n	}\r\n	return 0;\r\n}', '', 78, 1130496, 1, 2, '2010-10-14 09:27:40', '0001-01-01 00:00:00'),
(580, 15, 344, 4, '#include<iostream>\r\n#include<vector>\r\n#include<string>\r\n#include<algorithm>\r\n\r\n\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n	int a;\r\n	cin>>a;\r\n	vector<string> b;\r\n	string x;\r\n	while(cin>>x)\r\n	{\r\n		b.push_back(x);\r\n	}\r\n    \r\n	int m=0;\r\n	for(int i=0;i<a;++i)\r\n	{\r\n		for(int j=i+1;j<a;++j)\r\n		{\r\n		   if(vector[i]==vector[j])\r\n            m++;\r\n			continue;\r\n		}\r\n	}\r\n   \r\n	cout<<m;\r\n\r\n	cout<<endl;\r\n	return 0;\r\n}\r\n\r\n\r\n', 'Main.cpp: In function ''int main()'':\r\nMain.cpp:25:15: error: missing template arguments before ''['' token\r\nMain.cpp:25:26: error: missing template arguments before ''['' token\r\n', 0, 0, 2, 2, '2010-10-14 09:29:39', '0001-01-01 00:00:00'),
(581, 6, 344, 4, '#include <stdio.h>\r\n#include <string.h>\r\n#include <algorithm>\r\n#include <map>\r\n#include <string>\r\nusing namespace std;\r\nmap<string,int> mp;\r\nmap<string,int>::iterator it;\r\nint q[21000],ind;\r\n\r\nint get(char str[])\r\n{\r\n    string s(str);\r\n    it=mp.find(s);\r\n    if(it==mp.end())\r\n    {\r\n       mp.insert(make_pair(s,++ind));\r\n       return ind;\r\n    }\r\n    else return it->second;\r\n}\r\n\r\nint main()\r\n{\r\n    int n,i,j,ans;\r\n    char flag;\r\n    char str[110];\r\n	//freopen("2.txt","w",stdout);\r\n    while(scanf("%d",&n)!=EOF)\r\n    {\r\n        ind=0;\r\n        mp.clear();\r\n		memset(q,0,sizeof(q));\r\n        for(i=1;i<=n;++i)\r\n        {\r\n            scanf("%s",str);\r\n            q[i]=get(str);\r\n        }\r\n        \r\n        ans=0;\r\n        flag=0;\r\n        for(i=1;i<=n;++i)\r\n        {\r\n            for(j=n;j>i;--j)\r\n            {\r\n                if(q[i]==q[j])\r\n                {\r\n                   ans=j-i;\r\n                   flag=1;\r\n                   break;\r\n                }\r\n            }\r\n            if(flag) break;\r\n        }    \r\n        printf("%d\\n",ans);\r\n    }\r\n    return 0;\r\n}', '', 46, 1138688, 7, 2, '2010-10-14 09:30:01', '0001-01-01 00:00:00'),
(582, 16, 344, 4, '#include<stdio.h>\r\n#include<map>\r\n#include<string>\r\n#include <iostream>\r\nusing std::map;\r\nusing std::string;\r\nusing std::cin; \r\nint main(){\r\n	map<string,int> S;\r\n	int n=0,a;\r\n	string s,b;\r\n	scanf("%d",&a);\r\n	a=0;\r\n	while(cin>>s){\r\n		++S[s];\r\n		++a;\r\n		if(S[s]==2){\r\n			b=s;\r\n			n=1;\r\n				}\r\n	}\r\n	if(n){\r\n		int c,m=0;\r\n		for (map<string,int>::const_iterator it = S.begin();\r\n		     it!=S.end();++it)\r\n		{\r\n			++m;\r\n			if((it->first)==b){\r\n				c=a-m; it=S.end();}\r\n		}\r\n		printf("%d",c);\r\n	}\r\n	else printf("0");\r\n	return 0;\r\n}\r\n\r\n\r\n', '', 78, 1134592, 4, 2, '2010-10-14 09:39:03', '0001-01-01 00:00:00'),
(583, 6, 344, 4, '#include <stdio.h>\r\n#include <string.h>\r\n#include <algorithm>\r\n#include <map>\r\n#include <string>\r\nusing namespace std;\r\nmap<string,int> mp;\r\nmap<string,int>::iterator it;\r\nint q[21000],ind;\r\n\r\nint get(char str[],char& flag,int ii)\r\n{\r\n    string s(str);\r\n    it=mp.find(s);\r\n    if(it==mp.end())\r\n    {\r\n       mp.insert(make_pair(s,++ind));\r\n	   flag=0\r\n       return 0;\r\n    }\r\n    else \r\n	{\r\n	   flag=1;\r\n	   return ii-(it->second);\r\n	}\r\n}\r\n\r\nint main()\r\n{\r\n    int n,i,j,ans;\r\n    char flag;\r\n    char str[110];\r\n	//freopen("1.txt","r",stdin);\r\n	//freopen("2.txt","w",stdout);\r\n    while(scanf("%d",&n)!=EOF)\r\n    {\r\n        ind=0;\r\n        mp.clear();\r\n		memset(q,0,sizeof(q));\r\n        flag=0;\r\n		ans=0;\r\n		for(i=1;i<=n;++i)\r\n        {\r\n            scanf("%s",str);\r\n            if(!flag) \r\n			{\r\n			   t=get(str,flag,i);\r\n			   if(flag==1) ans=t;\r\n			}\r\n        }\r\n        \r\n        /*ans=0;\r\n        flag=0;\r\n        for(i=1;i<=n;++i)\r\n        {\r\n            for(j=n;j>i;--j)\r\n            {\r\n                if(q[i]==q[j])\r\n                {\r\n                   ans=j-i;\r\n                   flag=1;\r\n                   break;\r\n                }\r\n            }\r\n            if(flag) break;\r\n        }    \r\n        printf("%d\\n",ans);*/\r\n    }\r\n    return 0;\r\n}\r\n', 'Main.cpp: In function ''int get(char*, char&, int)'':\r\nMain.cpp:19:8: error: expected '';'' before ''return''\r\nMain.cpp: In function ''int main()'':\r\nMain.cpp:47:7: error: ''t'' was not declared in this scope\r\n', 0, 0, 2, 2, '2010-10-14 09:39:48', '0001-01-01 00:00:00'),
(584, 9, 344, 4, '#include <iostream>\r\n#include <string>\r\n#include <map>\r\n\r\nusing namespace std;\r\n\r\nint main(int argc,char** argv)\r\n{\r\n	map<int, string> mapSnake;\r\n	int k;\r\n	mapSnake.insert(pair<int, string>(k, "snake_k"));\r\n	map<int, string>::iterator iter;\r\n	iter = mapSnake.find(k);\r\n	if(iter != mapSnake.end())\r\n	{\r\n		cout<<"Find, the value is"<<iter->second<<endl;\r\n	}\r\n	else\r\n	{\r\n		cout<<"no circle"<<endl;\r\n	}\r\n}\r\n', '', 0, 372736, 4, 2, '2010-10-14 09:40:31', '0001-01-01 00:00:00'),
(585, 6, 344, 4, '#include <stdio.h>\r\n#include <string.h>\r\n#include <algorithm>\r\n#include <map>\r\n#include <string>\r\nusing namespace std;\r\nmap<string,int> mp;\r\nmap<string,int>::iterator it;\r\nint q[21000],ind;\r\n\r\nint get(char str[],char& flag,int ii)\r\n{\r\n    string s(str);\r\n    it=mp.find(s);\r\n    if(it==mp.end())\r\n    {\r\n       mp.insert(make_pair(s,++ind));\r\n	   flag=0\r\n       return 0;\r\n    }\r\n    else \r\n	{\r\n	   flag=1;\r\n	   return ii-(it->second);\r\n	}\r\n}\r\n\r\nint main()\r\n{\r\n    int n,i,j,ans,t;\r\n    char flag;\r\n    char str[110];\r\n	//freopen("1.txt","r",stdin);\r\n	//freopen("2.txt","w",stdout);\r\n    while(scanf("%d",&n)!=EOF)\r\n    {\r\n        ind=0;\r\n        mp.clear();\r\n		memset(q,0,sizeof(q));\r\n        flag=0;\r\n		ans=0;\r\n		for(i=1;i<=n;++i)\r\n        {\r\n            scanf("%s",str);\r\n            if(!flag) \r\n			{\r\n			   t=get(str,flag,i);\r\n			   if(flag==1) ans=t;\r\n			}\r\n        }\r\n        \r\n        /*ans=0;\r\n        flag=0;\r\n        for(i=1;i<=n;++i)\r\n        {\r\n            for(j=n;j>i;--j)\r\n            {\r\n                if(q[i]==q[j])\r\n                {\r\n                   ans=j-i;\r\n                   flag=1;\r\n                   break;\r\n                }\r\n            }\r\n            if(flag) break;\r\n        }    \r\n        printf("%d\\n",ans);*/\r\n    }\r\n    return 0;\r\n}', 'Main.cpp: In function ''int get(char*, char&, int)'':\r\nMain.cpp:19:8: error: expected '';'' before ''return''\r\n', 0, 0, 2, 2, '2010-10-14 09:40:59', '0001-01-01 00:00:00'),
(586, 6, 344, 4, '#include <stdio.h>\r\n#include <string.h>\r\n#include <algorithm>\r\n#include <map>\r\n#include <string>\r\nusing namespace std;\r\nmap<string,int> mp;\r\nmap<string,int>::iterator it;\r\nint q[21000],ind;\r\n\r\nint get(char str[],char& flag,int ii)\r\n{\r\n    string s(str);\r\n    it=mp.find(s);\r\n    if(it==mp.end())\r\n    {\r\n       mp.insert(make_pair(s,++ind));\r\n	   flag=0;\r\n       return 0;\r\n    }\r\n    else \r\n	{\r\n	   flag=1;\r\n	   return ii-(it->second);\r\n	}\r\n}\r\n\r\nint main()\r\n{\r\n    int n,i,j,ans,t;\r\n    char flag;\r\n    char str[110];\r\n	//freopen("1.txt","r",stdin);\r\n	//freopen("2.txt","w",stdout);\r\n    while(scanf("%d",&n)!=EOF)\r\n    {\r\n        ind=0;\r\n        mp.clear();\r\n		memset(q,0,sizeof(q));\r\n        flag=0;\r\n		ans=0;\r\n		for(i=1;i<=n;++i)\r\n        {\r\n            scanf("%s",str);\r\n            if(!flag) \r\n			{\r\n			   t=get(str,flag,i);\r\n			   if(flag==1) ans=t;\r\n			}\r\n        }\r\n        \r\n        /*ans=0;\r\n        flag=0;\r\n        for(i=1;i<=n;++i)\r\n        {\r\n            for(j=n;j>i;--j)\r\n            {\r\n                if(q[i]==q[j])\r\n                {\r\n                   ans=j-i;\r\n                   flag=1;\r\n                   break;\r\n                }\r\n            }\r\n            if(flag) break;\r\n        }    \r\n        printf("%d\\n",ans);*/\r\n    }\r\n    return 0;\r\n}\r\n', '', 200, 380928, 5, 2, '2010-10-14 09:41:34', '0001-01-01 00:00:00'),
(587, 16, 344, 4, '#include<stdio.h>\r\n#include<map>\r\n#include<string>\r\n#include <iostream>\r\nusing std::map;\r\nusing std::string;\r\nusing std::cin; \r\nint main(){\r\n	map<string,int> S;\r\n	int n=0,a;\r\n	string s,b;\r\n	scanf("%d",&a);\r\n	a=0;\r\n	while(cin>>s){\r\n		++S[s];\r\n		++a;\r\n		if(S[s]==2){\r\n			b=s;\r\n			n=1;\r\n				}\r\n	}\r\n	if(n){\r\n		int c,m=0;\r\n		for (map<string,int>::const_iterator it = S.begin();\r\n		     it!=S.end();++it)\r\n		{\r\n			++m;\r\n			if((it->first)==b){\r\n				c=a-m+1; it=S.end();}\r\n		}\r\n		printf("%d",c);\r\n	}\r\n	else printf("0");\r\n	return 0;\r\n}\r\n\r\n\r\n', '', 78, 1138688, 4, 2, '2010-10-14 09:43:46', '0001-01-01 00:00:00'),
(588, 15, 344, 4, '#include<iostream>\r\n#include<vector>\r\n#include<string>\r\n#include<iterator>\r\n\r\n\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n	int a;\r\n	cin>>a;\r\n	vector<string> b;\r\n	string x;\r\n	while(cin>>x)\r\n	{\r\n		b.push_back(x);\r\n	}\r\n    \r\n	int m=0,n=0;\r\n	for(vector<string>::iterator it1=b.begin();it1!=b.end()-1;++it1)\r\n	{\r\n		for(vector<string>::iterator it2=it1+1;it2!=b.end();++it2)\r\n		{\r\n		   if(*it1==*it2)\r\n             m++,\r\n		     n=it2-it1;	\r\n		   continue;\r\n		}\r\n	}\r\n   \r\n	\r\n	if(m=0)\r\n		cout<<0;\r\n	else\r\n		cout<<n;\r\n\r\n	cout<<endl;\r\n	return 0;\r\n}\r\n\r\n\r\n', '', 200, 1273856, 5, 2, '2010-10-14 09:43:59', '0001-01-01 00:00:00'),
(589, 12, 344, 4, '#include <iostream>\r\n#include <string>\r\n#include <map>\r\n\r\nusing namespace std;\r\n\r\nint main(int argc,char** argv)\r\n{\r\n	map<int, string> mapSnake;\r\n	int k;\r\n	mapSnake.insert(pair<int, string>(k, "snake_k"));\r\n	map<int, string>::iterator iter;\r\n	iter = mapSnake.find(k);\r\n	if(iter != mapSnake.end())\r\n	{\r\n		cout<<"Find, the value is"<<iter->second<<endl;\r\n	}\r\n	else\r\n	{\r\n		cout<<"no circle"<<endl;\r\n	}\r\n}\r\n', '', 0, 372736, 4, 2, '2010-10-14 09:45:38', '0001-01-01 00:00:00'),
(590, 17, 344, 4, '#include<iostream>\r\n#include<map>\r\n#include<string>\r\nusing namespace std;\r\nint main()\r\n{\r\n	int n;\r\n	while(cin>>n)\r\n	{\r\n		int num=0;\r\n		map<int,string>snakes;\r\n		string snake;\r\n		cin >> snake;\r\n		snakes.insert(pair<int, string>(1, snake));\r\n		for(int i=2;i<=n;i++)\r\n		{\r\n			cin >> snake;\r\n		    for(map<int, string>::const_iterator iter = snakes.begin(); iter != snakes.end(); iter++)\r\n			{   \r\n                  if(iter->second==snake)\r\n				  {  num=i-iter->first;\r\n\r\n				  }\r\n\r\n			}\r\n            snakes.insert(pair<int, string>(i, snake));\r\n		}\r\n		cout << num <<endl;\r\n	}\r\n	return 0;\r\n}\r\n', '', 200, 1130496, 5, 2, '2010-10-14 09:46:17', '0001-01-01 00:00:00'),
(591, 25, 345, 4, '#include<iostream>\r\n#include<map>\r\n#include<string>\r\n#include<cstdio>\r\n\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n	\r\n	int a,b,i;\r\n	while(scanf("%d",&a) == 1)\r\n	{\r\n		map<string,int> map1,map2;\r\n		string name,s1,s2;\r\n		for(i = 0; i < a; ++i)\r\n		{\r\n			cin >> name;\r\n			map1.insert(pair<string,int>(name,i));\r\n		}\r\n		scanf("%d",&b);\r\n		bool flag = true;\r\n		for(i = 0; i < b; ++i)\r\n		{\r\n			cin >> name;\r\n			if(flag)\r\n			{\r\n				map<string,int>::iterator it = map1.find(name);\r\n				if(map1.end() != it)\r\n				{\r\n					s2 = name;\r\n					flag = false;\r\n				}\r\n			}\r\n			map2.insert(pair<string,int>(name,i));\r\n		}\r\n		if(s2.length() < 1)\r\n			s2 = "none";\r\n		map<string,int>::iterator iter = map1.begin();\r\n		flag = true;\r\n		for(;map1.end() != iter;++iter)\r\n		{\r\n			if(flag)\r\n			{\r\n				map<string,int>::iterator it = map2.find(iter->first);\r\n				if(map2.end() != it)\r\n				{\r\n					s1 = iter->first;\r\n					flag = false;\r\n				}\r\n			}\r\n		}\r\n		if(s1.length() < 1)\r\n			s1 = "none";\r\n		cout << s1 << " " << s2 << endl;\r\n	}\r\n	return 0;\r\n}', '', 0, 479232, 4, 2, '2010-10-14 09:47:03', '0001-01-01 00:00:00'),
(592, 6, 344, 4, '#include <stdio.h>\r\n#include <string.h>\r\n#include <algorithm>\r\n#include <map>\r\n#include <string>\r\nusing namespace std;\r\nmap<string,int> mp;\r\n\r\nint main()\r\n{\r\n    int n,i,j,ans,t;\r\n    char flag;\r\n    char str[110];\r\n    while(scanf("%d",&n)!=EOF)\r\n    {\r\n        mp.clear();\r\n        flag=0;\r\n		ans=0;\r\n		for(i=1;i<=n;++i)\r\n        {\r\n            scanf("%s",str);\r\n			\r\n			if(!flag)\r\n			{\r\n			   string s(str);\r\n			   if(mp[s]==0) mp[s]=i;\r\n			   else        \r\n			   {\r\n				  ans=i-mp[s];\r\n				  flag=1;\r\n			   }\r\n			}\r\n        }\r\n        \r\n        printf("%d\\n",ans);\r\n    }\r\n    return 0;\r\n}\r\n', '', 200, 466944, 5, 2, '2010-10-14 09:47:34', '0001-01-01 00:00:00'),
(593, 9, 344, 4, '#include<iostream>\r\n#include<vector>\r\n#include<string>\r\n#include<iterator>\r\n\r\n\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n	int a;\r\n	cin>>a;\r\n	vector<string> b;\r\n	string x;\r\n	while(cin>>x)\r\n	{\r\n		b.push_back(x);\r\n	}\r\n    \r\n	int m=0,n=0;\r\n	for(vector<string>::iterator it1=b.begin();it1!=b.end()-1;++it1)\r\n	{\r\n		for(vector<string>::iterator it2=it1+1;it2!=b.end();++it2)\r\n		{\r\n		   if(*it1==*it2)\r\n             m++,\r\n		     n=it2-it1;	\r\n		   continue;\r\n		}\r\n	}\r\n   \r\n	\r\n	if(m=0)\r\n		cout<<0;\r\n	else\r\n		cout<<n;\r\n\r\n	cout<<endl;\r\n	return 0;\r\n}\r\n\r\n\r\n', '', 200, 1282048, 5, 2, '2010-10-14 09:48:28', '0001-01-01 00:00:00'),
(594, 17, 344, 4, '#include<iostream>\r\n#include<map>\r\n#include<string>\r\nusing namespace std;\r\nint main()\r\n{\r\n	int n;\r\n	while(cin>>n)\r\n	{\r\n		int num=0;\r\n		map<int,string>snakes;\r\n		string snake;\r\n		cin >> snake;\r\n		snakes.insert(pair<int, string>(1, snake));\r\n		for(int i=2;i<=n;i++)\r\n		{\r\n			cin >> snake;\r\n		    for(map<int, string>::const_iterator iter = snakes.begin(); iter != snakes.end(); iter++)\r\n			{   \r\n                  if(iter->second==snake)\r\n				  {  \r\n					  num=i-iter->first;\r\n					  break;\r\n				  }\r\n\r\n			}\r\n            snakes.insert(pair<int, string>(i, snake));\r\n		}\r\n		cout << num <<endl;\r\n	}\r\n	return 0;\r\n}\r\n', '', 200, 1130496, 5, 2, '2010-10-14 09:49:18', '0001-01-01 00:00:00'),
(595, 12, 344, 4, '#include<iostream>\r\n#include<vector>\r\n#include<string>\r\n#include<iterator>\r\n\r\n\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n	int a;\r\n	cin>>a;\r\n	vector<string> b;\r\n	string x;\r\n	while(cin>>x)\r\n	{\r\n		b.push_back(x);\r\n	}\r\n    \r\n	int m=0,n=0;\r\n	for(vector<string>::iterator it1=b.begin();it1!=b.end()-1;++it1)\r\n	{\r\n		for(vector<string>::iterator it2=it1+1;it2!=b.end();++it2)\r\n		{\r\n		   if(*it1==*it2)\r\n             m++,\r\n		     n=it2-it1;	\r\n		   continue;\r\n		}\r\n	}\r\n   \r\n	\r\n	if(m=0)\r\n		cout<<0;\r\n	else\r\n		cout<<n;\r\n\r\n	cout<<endl;\r\n	return 0;\r\n}\r\n\r\n\r\n', '', 200, 1273856, 5, 2, '2010-10-14 09:49:50', '0001-01-01 00:00:00'),
(596, 25, 345, 4, '#include<iostream>\r\n#include<map>\r\n#include<string>\r\n#include<cstdio>\r\n\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n	\r\n	int a,b,i;\r\n	while(scanf("%d",&a) == 1)\r\n	{\r\n		map<string,int> map1,map2;\r\n		string name,s1,s2;\r\n		for(i = 0; i < a; ++i)\r\n		{\r\n			cin >> name;\r\n			map1.insert(pair<string,int>(name,i));\r\n		}\r\n		scanf("%d",&b);\r\n		bool flag = true;\r\n		for(i = 0; i < b; ++i)\r\n		{\r\n			cin >> name;\r\n			if(flag)\r\n			{\r\n				map<string,int>::iterator it = map1.find(name);\r\n				if(map1.end() != it)\r\n				{\r\n					s2 = name;\r\n					flag = false;\r\n				}\r\n			}\r\n			map2.insert(pair<string,int>(name,i));\r\n		}\r\n		if(s2.length() < 1)\r\n			s2 = "none";\r\n		map<string,int>::iterator iter = map1.begin();\r\n		flag = true;\r\n		for(;map1.end() != iter;++iter)\r\n		{\r\n			if(flag)\r\n			{\r\n				map<string,int>::iterator it = map2.find(iter->first);\r\n				if(map2.end() != it)\r\n				{\r\n					s1 = iter->first;\r\n					flag = false;\r\n				}\r\n			}\r\n		}\r\n		if(s1.length() < 1)\r\n			s1 = "none";\r\n		cout << s1 << " " << s2 << endl;\r\n	}\r\n	return 0;\r\n}', '', 0, 483328, 4, 2, '2010-10-14 09:50:11', '0001-01-01 00:00:00'),
(597, 11, 339, 3, '// 堆排序\r\n//\r\n\r\n#include<stdio.h>\r\n\r\nvoid createheap(int a[],int n,int h)\r\n{\r\nint i,j;\r\nint temp;\r\n\r\ni=h;\r\nj=2*i+1;\r\ntemp=a[i];\r\nwhile(j<n)\r\n{\r\n   if(j<n-1&&a[j]<a[j+1])\r\n    j++;\r\n   if(temp>a[j])\r\n    break;\r\n   else\r\n   {\r\n    a[i]=a[j];\r\n    i=j;\r\n    j=2*i+1;\r\n   }\r\n}\r\n\r\na[i]=temp;\r\n}\r\n\r\n\r\nvoid heap(int a[],int n)\r\n{\r\nint i;\r\n\r\nfor(i=(n-2)/2;i>=0;--i)\r\ncreateheap(a,n,i);\r\n}\r\n\r\n\r\nvoid main()\r\n{\r\nint a[10],i,n,temp,k;\r\nprintf("输入你要输入的数字的个数\\n");\r\nscanf("%d",&n);\r\n\r\nprintf("要求第几大的数\\n");\r\nscanf("%d",&k);\r\n\r\nprintf("输入%d个数字\\n",n);\r\nfor(i=0;i<n;++i)\r\n   scanf("%d",&a[i]);\r\nheap(a,n);\r\n\r\nfor(i=n-1;i>=n-k;i--)\r\n{\r\n   temp=a[i];\r\n   a[i]=a[0];\r\n   a[0]=temp;\r\n  \r\n   createheap(a,i,0);\r\n}\r\n\r\n\r\nprintf("第%d大数是\\n",k);\r\n   printf("%d ",a[n-k]);\r\nprintf("\\n");\r\n}\r\n', '', 0, 262144, 7, 1, '2010-10-14 09:50:23', '0001-01-01 00:00:00'),
(598, 14, 344, 4, '#pragma warning(disable: 4786)\r\n#include<iostream>\r\n#include<map>\r\n#include<string>\r\n#include<iterator>\r\n#include<utility>\r\n\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n	int n=0;\r\n	string name;\r\n	map<string,int> nodemap;\r\n\r\n\r\n	while( scanf("%d",&n)==1 )\r\n	{\r\n		int i=0,count=1,length = 0;\r\n				\r\n		if(0 == n)\r\n			break;\r\n\r\n		map<string,int>::iterator iter;\r\n		for(;i<n;++i)\r\n		{\r\n			\r\n			cin >> name;\r\n			iter=nodemap.find(name);\r\n\r\n			if( (iter=nodemap.find(name)) != nodemap.end() )\r\n				break;\r\n			else\r\n				nodemap.insert(make_pair(name,count));\r\n\r\n			++count;\r\n						\r\n		}\r\n		\r\n		if( i==n)\r\n			cout<<0<<endl;\r\n\r\n		else\r\n			cout << count - (iter->second)  <<endl;\r\n	}\r\n	return 0;\r\n}\r\n\r\n', 'Main.cpp: In function ''int main()'':\r\nMain.cpp:17:22: error: ''scanf'' was not declared in this scope\r\n', 0, 0, 2, 2, '2010-10-14 09:51:04', '0001-01-01 00:00:00'),
(599, 14, 344, 4, '#pragma warning(disable: 4786)\r\n#include<iostream>\r\n#include<map>\r\n#include<string>\r\n#include<iterator>\r\n#include<utility>\r\n\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n	int n=0;\r\n	string name;\r\n	map<string,int> nodemap;\r\n\r\n\r\n	while( cin>>n )\r\n	{\r\n		int i=0,count=1,length = 0;\r\n				\r\n		if(0 == n)\r\n			break;\r\n\r\n		map<string,int>::iterator iter;\r\n		for(;i<n;++i)\r\n		{\r\n			\r\n			cin >> name;\r\n			iter=nodemap.find(name);\r\n\r\n			if( (iter=nodemap.find(name)) != nodemap.end() )\r\n				break;\r\n			else\r\n				nodemap.insert(make_pair(name,count));\r\n\r\n			++count;\r\n						\r\n		}\r\n		\r\n		if( i==n)\r\n			cout<<0<<endl;\r\n\r\n		else\r\n			cout << count - (iter->second)  <<endl;\r\n	}\r\n	return 0;\r\n}\r\n\r\n', '', 0, 544768, 4, 2, '2010-10-14 09:52:06', '0001-01-01 00:00:00'),
(600, 6, 344, 4, '#include <stdio.h>\r\n#include <string.h>\r\n#include <algorithm>\r\n#include <map>\r\n#include <string>\r\nusing namespace std;\r\nmap<string,int> mp;\r\n\r\nint main()\r\n{\r\n    int n,i,ans,t;\r\n    char flag;\r\n    char str[110];\r\n    while(scanf("%d",&n)!=EOF)\r\n    {\r\n        mp.clear();\r\n        flag=0;\r\n		ans=0;\r\n		for(i=1;i<=n;++i)\r\n        {\r\n            scanf("%s",str);\r\n			\r\n			if(!flag)\r\n			{\r\n			   t=mp[str];\r\n			   if(t==0) mp[str]=i;\r\n			   else        \r\n			   {\r\n				  ans=i-t;\r\n				  flag=1;\r\n			   }\r\n			}\r\n        }\r\n        \r\n        printf("%d\\n",ans);\r\n    }\r\n    return 0;\r\n}', '', 200, 462848, 5, 2, '2010-10-14 09:52:19', '0001-01-01 00:00:00'),
(601, 11, 339, 3, '// 堆排序\r\n//\r\n\r\n#include<stdio.h>\r\n\r\nvoid createheap(int a[],int n,int h)\r\n{\r\nint i,j;\r\nint temp;\r\n\r\ni=h;\r\nj=2*i+1;\r\ntemp=a[i];\r\nwhile(j<n)\r\n{\r\n   if(j<n-1&&a[j]<a[j+1])\r\n    j++;\r\n   if(temp>a[j])\r\n    break;\r\n   else\r\n   {\r\n    a[i]=a[j];\r\n    i=j;\r\n    j=2*i+1;\r\n   }\r\n}\r\n\r\na[i]=temp;\r\n}\r\n\r\n\r\nvoid heap(int a[],int n)\r\n{\r\nint i;\r\n\r\nfor(i=(n-2)/2;i>=0;--i)\r\ncreateheap(a,n,i);\r\n}\r\n\r\n\r\nvoid main()\r\n{\r\nint a[10],i,n,temp,k;\r\nprintf("输入你要输入的数字的个数\\n");\r\nscanf("%d",&n);\r\n\r\nprintf("要求第几大的数\\n");\r\nscanf("%d",&k);\r\n\r\nprintf("输入%d个数字\\n",n);\r\nfor(i=0;i<n;++i)\r\n   scanf("%d",&a[i]);\r\nheap(a,n);\r\n\r\nfor(i=n-1;i>=n-k;i--)\r\n{\r\n   temp=a[i];\r\n   a[i]=a[0];\r\n   a[0]=temp;\r\n  \r\n   createheap(a,i,0);\r\n}\r\n\r\n\r\nprintf("第%d大数是\\n",k);\r\n   printf("%d ",a[n-k]);\r\nprintf("\\n");\r\n}\r\n', 'Main.cpp:41:11: error: ''::main'' must return ''int''\r\n', 0, 0, 2, 2, '2010-10-14 09:52:22', '0001-01-01 00:00:00'),
(602, 13, 344, 4, '#include<iostream>\r\n#include<vector>\r\n#include<string>\r\n#include<iterator>\r\n\r\n\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n	int a;\r\n	cin>>a;\r\n	vector<string> b;\r\n	string x;\r\n	while(cin>>x)\r\n	{\r\n		b.push_back(x);\r\n	}\r\n    \r\n	int m=0,n=0;\r\n	for(vector<string>::iterator it1=b.begin();it1!=b.end()-1;++it1)\r\n	{\r\n		for(vector<string>::iterator it2=it1+1;it2!=b.end();++it2)\r\n		{\r\n		   if(*it1==*it2)\r\n             m++,\r\n		     n=it2-it1;	\r\n		   continue;\r\n		}\r\n	}\r\n   \r\n	\r\n	if(m=0)\r\n		cout<<0;\r\n	else\r\n		cout<<n;\r\n\r\n	cout<<endl;\r\n	return 0;\r\n}\r\n\r\n\r\n', 'Main.c:1:19: fatal error: iostream: No such file or directory\r\ncompilation terminated.\r\n', 0, 0, 2, 1, '2010-10-14 09:56:21', '0001-01-01 00:00:00'),
(603, 17, 344, 4, '#include<iostream>\r\n#include<map>\r\n#include<string>\r\nusing namespace std;\r\nint main()\r\n{\r\n	int n;\r\n        int i,num;\r\n        string snake;\r\n	while(cin>>n)\r\n	{\r\n		num=0;\r\n		map<int,string>snakes;\r\n		cin >> snake;\r\n		snakes.insert(pair<int, string>(1, snake));\r\n		for(i=2;i<=n;++i)\r\n		{\r\n		    cin >> snake;\r\n		    for(map<int, string>::const_iterator iter = snakes.begin(); iter != snakes.end(); ++iter)\r\n		   {   \r\n                      if(iter->second==snake)\r\n		     {  \r\n			num=i-iter->first;\r\n			break;\r\n		     }\r\n\r\n	           }\r\n                   snakes.insert(pair<int, string>(i, snake));\r\n	        }\r\n	        cout << num << endl;\r\n	}\r\n	return 0;\r\n}\r\n', '', 200, 1130496, 5, 2, '2010-10-14 15:36:17', '0001-01-01 00:00:00'),
(604, 17, 345, 4, '#include<iostream>\r\n#include<stdio.h>\r\n#include<string.h>\r\n#include<math.h>\r\nusing namespace std;\r\n#define Max 10001\r\nchar str1[Max][Max]; \r\nchar str2[Max][Max]; \r\n\r\nint main()\r\n{\r\n    int n,m;\r\n    int i,j;\r\n    int k;\r\n    while(scanf("%d",&n)!=EOF)\r\n    {\r\n		for(i=0;i<n;++i){\r\n              cin >> str1[i];\r\n         }\r\n         cin>>m;\r\n		 for(j=0;j<m;++j){\r\n           cin >> str2[j];\r\n		 }\r\n        if(strcmp(str1[n-1],str2[m-1])==0)\r\n         {\r\n			 if(n>=m){\r\n		     k=n-m;\r\n			 for(i=k,j=0;i<n;i++,j++)\r\n				 if(strcmp(str1[i],str2[j])==0)\r\n				 {			 \r\n					 cout << str1[i] <<str1[i]<<endl;\r\n			         break;\r\n				 }\r\n			 }\r\n			 else{\r\n				 k=m-n;\r\n			     for(i=0,j=k;j<m;i++,j++)\r\n				     if(strcmp(str1[i],str2[j])==0)\r\n				    {			 \r\n					  cout << str1[i] <<str1[i]<<endl;\r\n			          break;\r\n				     }\r\n			     }\r\n          \r\n          }\r\n		else \r\n			cout <<"none none"<<endl;\r\n	}\r\n	return 0;\r\n}\r\n', '', 0, 2097152, 6, 2, '2010-10-14 16:00:00', '0001-01-01 00:00:00'),
(605, 17, 345, 4, '#include<iostream>\r\n#include<stdio.h>\r\n#include<string.h>\r\n#include<math.h>\r\nusing namespace std;\r\n#define Max 10001\r\n#define N 101\r\nchar str1[Max][N]; \r\nchar str2[Max][N]; \r\n\r\nint main()\r\n{\r\n    int n,m;\r\n    int i,j;\r\n    int k;\r\n    while(scanf("%d",&n)!=EOF)\r\n    {\r\n		for(i=0;i<n;++i){\r\n              cin >> str1[i];\r\n         }\r\n         cin>>m;\r\n		 for(j=0;j<m;++j){\r\n           cin >> str2[j];\r\n		 }\r\n        if(strcmp(str1[n-1],str2[m-1])==0)\r\n         {\r\n			 if(n>=m){\r\n		     k=n-m;\r\n			 for(i=k,j=0;i<n;i++,j++)\r\n				 if(strcmp(str1[i],str2[j])==0)\r\n				 {			 \r\n					 cout << str1[i] <<str1[i]<<endl;\r\n			         break;\r\n				 }\r\n			 }\r\n			 else{\r\n				 k=m-n;\r\n			     for(i=0,j=k;j<m;i++,j++)\r\n				     if(strcmp(str1[i],str2[j])==0)\r\n				    {			 \r\n					  cout << str1[i] <<str1[i]<<endl;\r\n			          break;\r\n				     }\r\n			     }\r\n          \r\n          }\r\n		else \r\n			cout <<"none none"<<endl;\r\n	}\r\n	return 0;\r\n}\r\n', '', 0, 2097152, 6, 2, '2010-10-14 16:01:48', '0001-01-01 00:00:00'),
(606, 27, 344, 4, '#include <stdio.h>\r\n#include <map>\r\n#include <string>\r\n#include <iostream>\r\n\r\nusing namespace std;\r\nint main(int argc, char* argv[])\r\n{\r\n	int n,i;\r\n	string str;\r\n    while(scanf("%d",&n)==1){\r\n		int length=0;\r\n    	map<string,int> m;\r\n    	for(i=1;i<=n;++i){\r\n			cin>>str;\r\n    		if(m.find(str)!=m.end()){\r\n				length=i-m[str];\r\n			}else{   m.insert(pair<string,int>(str,i));  }\r\n		}\r\n    	printf("%d\\n",length);\r\n	}\r\n    return 0;\r\n}', '', 78, 1134592, 1, 2, '2010-10-14 16:01:56', '0001-01-01 00:00:00'),
(607, 6, 346, 0, '#include <stdio.h>\r\n#include <string.h>\r\n#define N 105\r\n\r\nint a[N],b[N];\r\nint p,k,r;\r\nchar ch,s[N],len;\r\n\r\nvoid set1()\r\n{\r\n    a[0]=b[0]=p=0;\r\n    while(s[p]!=''='')\r\n    {\r\n        k=1,r=0;\r\n        if(s[p]==''-'') k=-1,p++;\r\n        else if(s[p]==''+'') p++;\r\n            \r\n        while(s[p]>=''0'' && s[p]<=''9'')\r\n        {\r\n            r=r*10+s[p]-''0'';\r\n            p++;\r\n        }\r\n        \r\n        if(s[p]>=''a''&&s[p]<=''z'')\r\n        {\r\n            if(r==0) r=1;\r\n            a[++a[0]]=r*k;\r\n            ch=s[p];\r\n            p++;\r\n        }\r\n        else b[++b[0]]=-k*r;\r\n        \r\n        if (s[p]==''='') break;\r\n    }\r\n}\r\nvoid set2()\r\n{\r\n    p++;\r\n    int len=strlen(s);\r\n    while(p<len)\r\n    {\r\n        k=1,r=0;\r\n        if (s[p]==''-'') k=-1,p++;\r\n        else if (s[p]==''+'') p++;\r\n        \r\n        while(s[p]>=''0''&&s[p]<=''9'')\r\n        {\r\n            r=r*10+s[p]-''0'';\r\n            p++;\r\n        }\r\n        \r\n        if(s[p]>=''a''&&s[p]<=''z'')\r\n        {\r\n            if (r==0) r=1;\r\n            a[++a[0]]=-k*r;\r\n            ch=s[p];\r\n            p++;\r\n        }\r\n        else b[++b[0]]=k*r;\r\n    }\r\n    printf("%c=",ch);\r\n}\r\nvoid work()\r\n{\r\n    double s=0,ss=0;\r\n    for(int i=1;i<=a[0];i++) s+=a[i];\r\n    for(int i=1;i<=b[0];i++) ss+=b[i];\r\n    if(ss==0) printf("0.000\\n");\r\n    else      printf("%0.3lf\\n",ss/s);\r\n}\r\nint main()\r\n{\r\n    //freopen("1.in","r",stdin);\r\n    //freopen("1.out","w",stdout);\r\n    while(scanf("%s",s)!=EOF)\r\n    {\r\n      set1();\r\n      set2();\r\n      work();\r\n    }\r\n    return 0;\r\n}', 'Main.c: In function ''work'':\r\nMain.c:66:5: error: ''for'' loop initial declarations are only allowed in C99 mode\r\nMain.c:66:5: note: use option -std=c99 or -std=gnu99 to compile your code\r\nMain.c:67:13: error: redefinition of ''i''\r\nMain.c:66:13: note: previous definition of ''i'' was here\r\nMain.c:67:5: error: ''for'' loop initial declarations are only allowed in C99 mode\r\n', 0, 0, 2, 1, '2010-10-14 16:17:09', '0001-01-01 00:00:00'),
(608, 6, 346, 0, '#include <stdio.h>\r\n#include <string.h>\r\n#define N 105\r\n\r\nint a[N],b[N];\r\nint p,k,r;\r\nchar ch,s[N],len;\r\n\r\nvoid set1()\r\n{\r\n    a[0]=b[0]=p=0;\r\n    while(s[p]!=''='')\r\n    {\r\n        k=1,r=0;\r\n        if(s[p]==''-'') k=-1,p++;\r\n        else if(s[p]==''+'') p++;\r\n            \r\n        while(s[p]>=''0'' && s[p]<=''9'')\r\n        {\r\n            r=r*10+s[p]-''0'';\r\n            p++;\r\n        }\r\n        \r\n        if(s[p]>=''a''&&s[p]<=''z'')\r\n        {\r\n            if(r==0) r=1;\r\n            a[++a[0]]=r*k;\r\n            ch=s[p];\r\n            p++;\r\n        }\r\n        else b[++b[0]]=-k*r;\r\n        \r\n        if (s[p]==''='') break;\r\n    }\r\n}\r\nvoid set2()\r\n{\r\n    p++;\r\n    int len=strlen(s);\r\n    while(p<len)\r\n    {\r\n        k=1,r=0;\r\n        if (s[p]==''-'') k=-1,p++;\r\n        else if (s[p]==''+'') p++;\r\n        \r\n        while(s[p]>=''0''&&s[p]<=''9'')\r\n        {\r\n            r=r*10+s[p]-''0'';\r\n            p++;\r\n        }\r\n        \r\n        if(s[p]>=''a''&&s[p]<=''z'')\r\n        {\r\n            if (r==0) r=1;\r\n            a[++a[0]]=-k*r;\r\n            ch=s[p];\r\n            p++;\r\n        }\r\n        else b[++b[0]]=k*r;\r\n    }\r\n    printf("%c=",ch);\r\n}\r\nvoid work()\r\n{\r\n    double s=0,ss=0;\r\n    for(int i=1;i<=a[0];i++) s+=a[i];\r\n    for(int i=1;i<=b[0];i++) ss+=b[i];\r\n    if(ss==0) printf("0.000\\n");\r\n    else      printf("%0.3lf\\n",ss/s);\r\n}\r\nint main()\r\n{\r\n    //freopen("1.in","r",stdin);\r\n    //freopen("1.out","w",stdout);\r\n    while(scanf("%s",s)!=EOF)\r\n    {\r\n      set1();\r\n      set2();\r\n      work();\r\n    }\r\n    return 0;\r\n}', '', 0, 262144, 1, 2, '2010-10-14 16:17:31', '0001-01-01 00:00:00'),
(609, 17, 344, 4, '#include<iostream>\r\n#include<map>\r\n#include<string>\r\nusing namespace std;\r\nint main()\r\n{\r\n	int n;\r\n        int i,num;\r\n        string snake;\r\n	while(cin>>n)\r\n	{\r\n		num=0;\r\n		map<string,int>snakes;\r\n		cin >> snake;\r\n		snakes.insert(pair<string, int>(snake,1));\r\n		for(i=2;i<=n;++i)\r\n		{  \r\n		    cin >> snake;\r\n            map<string,int>::iterator iter;\r\n            iter = snakes.find(snake);\r\n            if(iter != snakes.end())\r\n			{\r\n               num=i-iter->second;\r\n            }\r\n			snakes.insert(pair<string,int>(snake,i));\r\n	        }\r\n	        cout << num << endl;\r\n	}\r\n	return 0;\r\n}\r\n', '', 93, 1130496, 1, 2, '2010-10-14 16:20:32', '0001-01-01 00:00:00'),
(610, 27, 345, 4, '#include <stdio.h>\r\n#include <map>\r\n#include <string>\r\n#include <iostream>\r\n\r\nusing namespace std;\r\nint main(int argc, char* argv[])\r\n{\r\n	int n1,n2,i,j=0;\r\n	string name;\r\n    while(scanf("%d",&n1)==1){\r\n		string same_name="none none";\r\n    	map<string,int> m;\r\n    	for(i=1;i<=n1;++i){\r\n			cin>>name;\r\n    		if(m.find(name)!=m.end()){\r\n				i--;\r\n				break;\r\n			}else{   m.insert(pair<string,int>(name,i));  }\r\n		}\r\n		scanf("%d",&n2);\r\n		for(i=1;i<=n2;++i){\r\n			cin>>name;\r\n			if(j==0 && m.find(name)!=m.end()){\r\n				same_name=name;\r\n			    j==1;\r\n			}\r\n		}\r\n		cout<<same_name<<endl;\r\n	}\r\n    return 0;\r\n}', '', 0, 479232, 4, 2, '2010-10-14 17:01:26', '0001-01-01 00:00:00'),
(611, 27, 345, 4, '#include <stdio.h>\r\n#include <map>\r\n#include <string>\r\n#include <iostream>\r\n\r\nusing namespace std;\r\nint main(int argc, char* argv[])\r\n{\r\n	int n1,n2,i,j=0;\r\n	string name;\r\n    while(scanf("%d",&n1)==1){\r\n		string same_name="none";\r\n    	map<string,int> m;\r\n    	for(i=1;i<=n1;++i){\r\n			cin>>name;\r\n    		if(m.find(name)!=m.end()){\r\n				i--;\r\n				break;\r\n			}else{   m.insert(pair<string,int>(name,i));  }\r\n		}\r\n		scanf("%d",&n2);\r\n		for(i=1;i<=n2;++i){\r\n			cin>>name;\r\n			if(j==0 && m.find(name)!=m.end()){\r\n				same_name=name;\r\n			    j==1;\r\n			}\r\n		}\r\n		cout<<same_name<<" "<<same_name<<endl;\r\n	}\r\n    return 0;\r\n}\r\n\r\n', '', 0, 479232, 4, 2, '2010-10-14 17:03:37', '0001-01-01 00:00:00'),
(612, 27, 345, 4, '#include <stdio.h>\r\n#include <map>\r\n#include <string>\r\n#include <iostream>\r\n\r\nusing namespace std;\r\nint main(int argc, char* argv[])\r\n{\r\n	int n1,n2,i,j=0;\r\n	string name;\r\n    while(scanf("%d",&n1)==1){\r\n		string same_name="none";\r\n    	map<string,int> m;\r\n    	for(i=1;i<=n1;++i){\r\n			cin>>name;\r\n    		if(m.find(name)!=m.end()){\r\n				i--;\r\n				break;\r\n			}else{   m.insert(pair<string,int>(name,i));  }\r\n		}\r\n		scanf("%d",&n2);\r\n		for(i=1;i<=n2;++i){\r\n			cin>>name;\r\n			if(j==0 && m.find(name)!=m.end()){\r\n				same_name=name;\r\n			    j=1;\r\n			}\r\n		}\r\n		cout<<same_name<<" "<<same_name<<endl;\r\n	}\r\n    return 0;\r\n}\r\n\r\n', '', 0, 479232, 4, 2, '2010-10-14 17:08:05', '0001-01-01 00:00:00'),
(613, 27, 345, 4, '#include <stdio.h>\r\n#include <map>\r\n#include <string>\r\n#include <iostream>\r\n\r\nusing namespace std;\r\nint main(int argc, char* argv[])\r\n{\r\n	int n1,n2,i;\r\n	string name;\r\n    while(scanf("%d",&n1)==1){\r\n		int j=0;\r\n		string same_name="none";\r\n    	map<string,int> m;\r\n    	for(i=1;i<=n1;++i){\r\n			cin>>name;\r\n    		if(m.find(name)!=m.end()){\r\n				i--;\r\n				break;\r\n			}else{   m.insert(pair<string,int>(name,i));  }\r\n		}\r\n		scanf("%d",&n2);\r\n		for(i=1;i<=n2;++i){\r\n			cin>>name;\r\n			if(j==0 && m.find(name)!=m.end()){\r\n				same_name=name;\r\n			    j=1;\r\n			}\r\n		}\r\n		cout<<same_name<<" "<<same_name<<endl;\r\n	}\r\n    return 0;\r\n}\r\n\r\n', '', 0, 483328, 4, 2, '2010-10-14 17:14:49', '0001-01-01 00:00:00'),
(614, 17, 345, 4, '#include<iostream>\r\n#include<stdio.h>\r\n#include<vector>\r\n#include<string>\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n    int n,m;\r\n    int i,j;\r\n    int k;\r\n	string snake;\r\n	vector<string>str1,str2;\r\n    while(scanf("%d",&n)!=EOF)\r\n    {\r\n		for(i=0;i<n;++i){\r\n              cin >> snake;\r\n			  str1.push_back(snake);\r\n         }\r\n         cin>>m;\r\n		 for(j=0;j<m;++j){\r\n           cin >> snake;\r\n		   str2.push_back(snake);\r\n		 }\r\n		 vector<string>::reverse_iterator it1,it2;\r\n         it1=str1.rbegin();\r\n		 it2=str2.rbegin();\r\n         if(*it1==*it2)\r\n          {\r\n			 if(n>=m){\r\n		     k=n-m;\r\n			 for(i=k,j=0;i<n;i++,j++)\r\n				 if(str1[i]==str2[j])\r\n				 {			 \r\n					 cout << str1[i] <<" "<<str1[i]<<endl;\r\n			         break;\r\n				 }\r\n			 }\r\n			 else{\r\n				 k=m-n;\r\n			     for(i=0,j=k;j<m;i++,j++)\r\n				     if(str1[i]==str2[j])\r\n				    {			 \r\n					  cout << str1[i] <<" "<<str1[i]<<endl;\r\n			          break;\r\n				     }\r\n			     }\r\n          \r\n          }\r\n		else \r\n			cout <<"none none"<<endl;\r\n	}\r\n	return 0;\r\n}\r\n', '', 0, 479232, 4, 2, '2010-10-16 13:23:28', '0001-01-01 00:00:00'),
(615, 17, 345, 4, '#include<iostream>\r\n#include<stdio.h>\r\n#include<vector>\r\n#include<string>\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n    int n,m;\r\n    int i,j;\r\n    int k;\r\n	string snake;\r\n	vector<string>str1,str2;\r\n    while(scanf("%d",&n)!=EOF)\r\n    {\r\n		for(i=0;i<n;++i){\r\n              cin >> snake;\r\n			  str1.push_back(snake);\r\n	\r\n         }\r\n         cin>>m;\r\n		 for(j=0;j<m;++j){\r\n           cin >> snake;\r\n		   str2.push_back(snake);\r\n		 }\r\n		 vector<string>::reverse_iterator it1,it2;\r\n         it1=str1.rbegin();\r\n		 it2=str2.rbegin();\r\n         if(*it1==*it2)\r\n          {\r\n			 if(n>=m){\r\n		     k=n-m;\r\n			 for(i=k,j=0;i<n;i++,j++)\r\n				 if(str1[i]==str2[j])\r\n				 {			 \r\n					 cout << str1[i] <<" "<<str1[i]<<endl;\r\n			         break;\r\n				 }\r\n			 }\r\n			 else{\r\n				 k=m-n;\r\n			     for(i=0,j=k;j<m;i++,j++)\r\n				     if(str1[i]==str2[j])\r\n				    {			 \r\n					  cout << str1[i] <<" "<<str1[i]<<endl;\r\n			          break;\r\n				     }\r\n			     }\r\n          \r\n          }\r\n		else \r\n			cout <<"none none"<<endl;\r\n		 str1.clear();\r\n		 str2.clear();\r\n	}\r\n	return 0;\r\n}\r\n', '', 0, 479232, 4, 2, '2010-10-16 13:34:38', '0001-01-01 00:00:00');
INSERT INTO `tbl_submitions` (`id`, `user_id`, `problem_id`, `exercise_id`, `source`, `result`, `used_time`, `used_memory`, `status`, `compiler_id`, `created`, `modified`) VALUES
(616, 17, 344, 4, '#include<iostream>\r\n#include<stdio.h>\r\n#include<vector>\r\n#include<string>\r\nusing namespace std;\r\nbool flag;\r\nint main()\r\n{\r\n    int n,m;\r\n    int i,j;\r\n    int k;\r\n	string snake;\r\n	vector<string>str1,str2;\r\n    while(scanf("%d",&n)!=EOF)\r\n    {   \r\n		flag=1;\r\n		for(i=0;i<n;++i){\r\n              cin >> snake;\r\n			  str1.push_back(snake);\r\n	\r\n         }\r\n		\r\n         cin>>m;\r\n		 for(j=0;j<m;++j){\r\n           cin >> snake;\r\n		   str2.push_back(snake);\r\n		 }\r\n		 vector<string>::reverse_iterator it1,it2;\r\n         it1=str1.rbegin();\r\n		 it2=str2.rbegin();\r\n         for(vector<string>::const_iterator it=str2.begin();it!=str2.end()-1;it++)\r\n			 {\r\n					  if(*it==*it2)\r\n					  {\r\n						 str2.pop_back();\r\n						 m=m-1;\r\n						 break;\r\n					  }\r\n	              }\r\n		 for(vector<string>::const_iterator it=str1.begin();it!=str1.end()-1;it++)\r\n			 {\r\n					  if(*it==*it1)\r\n					  {\r\n						 str1.pop_back();\r\n						 n=n-1;\r\n						 break;\r\n					  }\r\n	              }\r\n		 it1=str1.rbegin();\r\n		 it2=str2.rbegin();\r\n         if(*it1==*it2)\r\n          {\r\n			 if(n>=m){\r\n		     k=n-m;\r\n			 for(i=k,j=0;i<n;i++,j++)\r\n				 if(str1[i]==str2[j])\r\n				 {			 \r\n					 cout << str1[i] <<" "<<str1[i]<<endl;\r\n			         break;\r\n				 }\r\n			 }\r\n			 else{\r\n				 k=m-n;\r\n			     for(i=0,j=k;j<m;i++,j++)\r\n				     if(str1[i]==str2[j])\r\n				    {			 \r\n					  cout << str1[i] <<" "<<str1[i]<<endl;\r\n			          break;\r\n				     }\r\n			     }\r\n          \r\n          }\r\n		else \r\n			cout <<"none none"<<endl;\r\n		 str1.clear();\r\n		 str2.clear();\r\n	}\r\n	return 0;\r\n}\r\n', '', 31, 884736, 4, 2, '2010-10-16 14:29:07', '0001-01-01 00:00:00'),
(617, 17, 345, 4, '#include<iostream>\r\n#include<stdio.h>\r\n#include<vector>\r\n#include<string>\r\nusing namespace std;\r\nbool flag;\r\nint main()\r\n{\r\n    int n,m;\r\n    int i,j;\r\n    int k;\r\n	string snake;\r\n	vector<string>str1,str2;\r\n    while(scanf("%d",&n)!=EOF)\r\n    {   \r\n		flag=1;\r\n		for(i=0;i<n;++i){\r\n              cin >> snake;\r\n			  str1.push_back(snake);\r\n	\r\n         }\r\n		\r\n         cin>>m;\r\n		 for(j=0;j<m;++j){\r\n           cin >> snake;\r\n		   str2.push_back(snake);\r\n		 }\r\n		 vector<string>::reverse_iterator it1,it2;\r\n         it1=str1.rbegin();\r\n		 it2=str2.rbegin();\r\n         for(vector<string>::const_iterator it=str2.begin();it!=str2.end()-1;it++)\r\n			 {\r\n					  if(*it==*it2)\r\n					  {\r\n						 str2.pop_back();\r\n						 m=m-1;\r\n						 break;\r\n					  }\r\n	              }\r\n		 for(vector<string>::const_iterator it=str1.begin();it!=str1.end()-1;it++)\r\n			 {\r\n					  if(*it==*it1)\r\n					  {\r\n						 str1.pop_back();\r\n						 n=n-1;\r\n						 break;\r\n					  }\r\n	              }\r\n		 it1=str1.rbegin();\r\n		 it2=str2.rbegin();\r\n         if(*it1==*it2)\r\n          {\r\n			 if(n>=m){\r\n		     k=n-m;\r\n			 for(i=k,j=0;i<n;i++,j++)\r\n				 if(str1[i]==str2[j])\r\n				 {			 \r\n					 cout << str1[i] <<" "<<str1[i]<<endl;\r\n			         break;\r\n				 }\r\n			 }\r\n			 else{\r\n				 k=m-n;\r\n			     for(i=0,j=k;j<m;i++,j++)\r\n				     if(str1[i]==str2[j])\r\n				    {			 \r\n					  cout << str1[i] <<" "<<str1[i]<<endl;\r\n			          break;\r\n				     }\r\n			     }\r\n          \r\n          }\r\n		else \r\n			cout <<"none none"<<endl;\r\n		 str1.clear();\r\n		 str2.clear();\r\n	}\r\n	return 0;\r\n}\r\n', '', 0, 483328, 4, 2, '2010-10-16 14:29:30', '0001-01-01 00:00:00'),
(618, 6, 347, 0, '#include <stdio.h>\r\n#include <string.h>\r\n#include <algorithm>\r\n#include <math.h>\r\nusing namespace std;\r\n#define EPS 1e-6\r\n#define N 500\r\n\r\nstruct Node\r\n{\r\n   int p,s;\r\n}q1[N],q2[100000];\r\n\r\nbool cmp(const Node& a,const Node& b)\r\n{\r\n   return a.p<b.p;\r\n}\r\n\r\nint main()\r\n{\r\n    //freopen("2.in","r",stdin);\r\n    //freopen("2.out","w",stdout);\r\n    double l,h,t;\r\n    int vs,vt,a,b,i,j,n,k,tmp,m;\r\n    while(scanf("%d",&vs)!=EOF)\r\n    {\r\n        i=0;\r\n        while(1)\r\n        {\r\n           scanf("%d %d",&a,&b);\r\n           if(a==-1&&b==-1) break;\r\n           q1[++i].p=a,q1[i].s=b;\r\n        }\r\n        n=i;\r\n        scanf("%d",&vt);\r\n        \r\n        sort(q1+1,q1+1+n,cmp);\r\n        k=0;\r\n        q2[++k].p=q1[1].p,q2[k].s=q1[1].s;\r\n        if(q2[k].p==vs) vs=k;\r\n        for(i=2;i<=n;++i)\r\n        {\r\n            if(q1[i].p==q1[i-1].p+1) \r\n            {\r\n               q2[++k].p=q1[i].p,q2[k].s=q1[i].s;\r\n               if(q2[k].p==vs) vs=k;\r\n            }\r\n            else  \r\n            {\r\n               tmp=(q1[i].s-q1[i-1].s)/(q1[i].p-q1[i-1].p);\r\n               while(1)\r\n               {\r\n                    ++k;\r\n                    q2[k].p=q2[k-1].p+1,q2[k].s=q2[k-1].s+tmp;\r\n                    if(q2[k].p==vs) vs=k;\r\n                    if(q2[k].p==q1[i].p) break;\r\n               }\r\n            }\r\n        }\r\n        \r\n        m=q1[n].s/vt;\r\n        while(m--)\r\n        {\r\n           ++k;\r\n           q2[k].p=q2[k-1].p+1,q2[k].s=q2[k-1].s-vt;\r\n           if(q2[k].p==vs) vs=k;\r\n        }\r\n        n=k;\r\n        \r\n        \r\n        char flag=0;\r\n        l=-1e10,h=1e10;\r\n        for(i=1;i<=n;++i)\r\n        {\r\n            if(i!=vs)\r\n            {\r\n               a=(q2[vs].p-q2[1].p)*q2[vs].s-(q2[i].p-q2[1].p)*q2[i].s;\r\n               b=q2[i].s-q2[vs].s;\r\n               \r\n               if(b==0) \r\n               {\r\n                  flag=1;\r\n                  break;\r\n               }\r\n               \r\n               t=a*1.0/b;\r\n               if(b>0&&t<h) h=t;\r\n               else if(b<0&&t>l) l=t;\r\n            }\r\n        }\r\n        \r\n        if(flag==0)\r\n        {\r\n           a=(int)h,b=(int)l;\r\n           if(h<0&&fabs(h-(double)a)>EPS) a--;\r\n           if(l>0&&fabs(l-(double)b)>EPS) b++;  \r\n           if(b>a) flag=1;\r\n        }\r\n        \r\n        if(flag==1) printf("NO SOLUTION\\n");\r\n        else        printf("%d\\n",abs(a)<abs(b)?a:b);  \r\n    }\r\n    return 0;\r\n}', '', 0, 1064960, 1, 2, '2010-10-16 15:38:12', '0001-01-01 00:00:00'),
(619, 14, 344, 4, '#include<iostream>\r\n#include<map>\r\n#include<string>\r\n#include<iterator>\r\n#include<utility>\r\n\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n	int n=0;\r\n	string name;\r\n	\r\n	while( cin>>n )\r\n	{\r\n		if(0 == n)\r\n			break;\r\n\r\n		int i=0,count=1;\r\n		map<string,int> nodemap;\r\n				\r\n\r\n\r\n		map<string,int>::iterator iter;\r\n		for(;i<n;++i)\r\n		{\r\n			\r\n			cin >> name;\r\n			\r\n\r\n			if( (iter=nodemap.find(name)) != nodemap.end() )\r\n				break;\r\n			else\r\n				nodemap.insert(make_pair(name,count));\r\n\r\n			++count;\r\n						\r\n		}\r\n		\r\n		if( i==n)\r\n			cout<<0<<endl;\r\n\r\n		else\r\n			cout << count - (iter->second)  <<endl;\r\n	}\r\n	return 0;\r\n}', '', 93, 1130496, 1, 2, '2010-10-16 19:50:13', '0001-01-01 00:00:00'),
(620, 14, 338, 3, '#include<stdio.h>\r\n\r\nint main()\r\n{\r\n	int n,k,num;\r\n	while( scanf("%d",&n) == 1 )\r\n	{\r\n		int intarray[1001];\r\n		\r\n		int i,mincount=0,maxcount=0;\r\n		\r\n		if(0 == n)\r\n			break;\r\n\r\n		for(i=0;i<1000;++i)\r\n			intarray[i]=0;\r\n\r\n		scanf("%d",&k);\r\n		for(i=0;i<n;++i)\r\n		{	\r\n			scanf("%d",&num);\r\n			++intarray[num];\r\n		}\r\n\r\n		for(i=0;i<=999;++i)\r\n		{\r\n			mincount += intarray[i];\r\n			if(mincount >= k+1 )\r\n			{\r\n				mincount=i;\r\n				break;\r\n			}\r\n			\r\n		}\r\n		for(i=999;i>=0;--i)\r\n		{\r\n			maxcount += intarray[i];\r\n			if(maxcount >= k+1)\r\n			{\r\n				maxcount= i;\r\n				break;\r\n			}\r\n\r\n		}\r\n\r\n		printf("%d\\n",maxcount - mincount);\r\n	}\r\n\r\n	\r\n	\r\n	\r\n	\r\n	return 0;\r\n\r\n}\r\n', '', 0, 0, 2, 1, '2010-10-16 20:06:43', '0001-01-01 00:00:00'),
(621, 14, 338, 3, '#include<stdio.h>\r\n\r\nint main()\r\n{\r\n	int n,k,num;\r\n	\r\n	while( scanf("%d",&n) == 1 )\r\n	{\r\n		int intarray[1001];\r\n		\r\n		int i,mincount=0,maxcount=0;\r\n		\r\n		if(0 == n)\r\n			break;\r\n\r\n		for(i=0;i<1000;++i)\r\n			intarray[i]=0;\r\n\r\n		scanf("%d",&k);\r\n		for(i=0;i<n;++i)\r\n		{	\r\n			scanf("%d",&num);\r\n			++intarray[num];\r\n		}\r\n\r\n		for(i=0;i<=999;++i)\r\n		{\r\n			mincount += intarray[i];\r\n			if(mincount >= k+1 )\r\n			{\r\n				mincount=i;\r\n				break;\r\n			}\r\n			\r\n		}\r\n		for(i=999;i>=0;--i)\r\n		{\r\n			maxcount += intarray[i];\r\n			if(maxcount >= k+1)\r\n			{\r\n				maxcount= i;\r\n				break;\r\n			}\r\n\r\n		}\r\n\r\n		printf("%d\\n",maxcount - mincount);\r\n	}\r\n\r\n	\r\n	\r\n	\r\n	\r\n	return 0;\r\n\r\n}\r\n', '', 0, 0, 2, 1, '2010-10-16 20:09:36', '0001-01-01 00:00:00'),
(622, 14, 338, 3, '#include<stdio.h>\r\nint intarray[1001];\r\n\r\nint main()\r\n{\r\n	int n,k,num;\r\n	\r\n	while( scanf("%d",&n) == 1 )\r\n	{\r\n		int i,mincount=0,maxcount=0;\r\n		\r\n		if(0 == n)\r\n			break;\r\n\r\n		for(i=0;i<1000;++i)\r\n			intarray[i]=0;\r\n\r\n		scanf("%d",&k);\r\n		for(i=0;i<n;++i)\r\n		{	\r\n			scanf("%d",&num);\r\n			++intarray[num];\r\n		}\r\n\r\n		for(i=0;i<=999;++i)\r\n		{\r\n			mincount += intarray[i];\r\n			if(mincount >= k+1 )\r\n			{\r\n				mincount=i;\r\n				break;\r\n			}\r\n			\r\n		}\r\n\r\n		for(i=999;i>=0;--i)\r\n		{\r\n			maxcount += intarray[i];\r\n			if(maxcount >= k+1)\r\n			{\r\n				maxcount= i;\r\n				break;\r\n			}\r\n		}\r\n\r\n		printf("%d\\n",maxcount - mincount);\r\n	}\r\n	return 0;\r\n}\r\n', '', 0, 0, 2, 1, '2010-10-16 20:11:34', '0001-01-01 00:00:00'),
(623, 14, 338, 3, '#include<stdio.h>\r\nint intarray[1001];\r\n\r\nint main()\r\n{\r\n	int n,k,num;\r\n	\r\n	while( scanf("%d",&n) == 1 )\r\n	{\r\n		int i,mincount=0,maxcount=0;\r\n		\r\n		if(0 == n)\r\n		             break;\r\n\r\n		for(i=0;i<=1000;++i)\r\n                         {\r\n			intarray[i]=0;\r\n                         }\r\n\r\n		scanf("%d",&k);\r\n		for(i=0;i<n;++i)\r\n		{	\r\n			scanf("%d",&num);\r\n			++intarray[num];\r\n		}\r\n\r\n		for(i=0;i<=999;++i)\r\n		{\r\n			mincount += intarray[i];\r\n			if(mincount >= k+1 )\r\n			{\r\n				mincount=i;\r\n				break;\r\n			}\r\n			\r\n		}\r\n\r\n		for(i=999;i>=0;--i)\r\n		{\r\n			maxcount += intarray[i];\r\n			if(maxcount >= k+1)\r\n			{\r\n				maxcount= i;\r\n				break;\r\n			}\r\n		}\r\n\r\n		printf("%d\\n",maxcount - mincount);\r\n	}\r\n	return 0;\r\n}\r\n', '', 0, 0, 2, 1, '2010-10-16 20:15:02', '0001-01-01 00:00:00'),
(624, 14, 338, 3, '#include<iostream>\r\nusing namespace std;\r\nint intarray[1001];\r\n\r\nint main()\r\n{\r\n	int n,k,num;\r\n	\r\n	while( cin>>n )\r\n	{\r\n		int i,mincount=0,maxcount=0;\r\n		\r\n		if(0 == n)\r\n			break;\r\n\r\n		for(i=0;i<1000;++i)\r\n		{\r\n			intarray[i]=0;\r\n		}\r\n\r\n		cin>>k;\r\n\r\n		for(i=0;i<n;++i)\r\n		{	\r\n			cin>>num;\r\n			++intarray[num];\r\n		}\r\n\r\n		for(i=0;i<=999;++i)\r\n		{\r\n			mincount += intarray[i];\r\n			if(mincount >= k+1 )\r\n			{\r\n				mincount=i;\r\n				break;\r\n			}\r\n			\r\n		}\r\n\r\n		for(i=999;i>=0;--i)\r\n		{\r\n			maxcount += intarray[i];\r\n			if(maxcount >= k+1)\r\n			{\r\n				maxcount= i;\r\n				break;\r\n			}\r\n		}\r\n\r\n		cout<<maxcount - mincount<<endl;\r\n	}\r\n	return 0;\r\n}\r\n', '', 0, 0, 2, 2, '2010-10-16 20:21:44', '0001-01-01 00:00:00'),
(625, 14, 338, 3, '#include<stdio.h>\r\nint intarray[1001];\r\n\r\nint main()\r\n{\r\n	int n,k,num;\r\n	\r\n	while( scanf("%d",&n) == 1 )\r\n	{\r\n		int i,mincount=0,maxcount=0;\r\n		\r\n		if(0 == n)\r\n			break;\r\n\r\n		for(i=0;i<1000;++i)\r\n		{\r\n			intarray[i]=0;\r\n		}\r\n\r\n		scanf("%d",&k);\r\n\r\n		for(i=0;i<n;++i)\r\n		{	\r\n			scanf("%d",&num);\r\n			++intarray[num];\r\n		}\r\n\r\n		for(i=0;i<=999;++i)\r\n		{\r\n			mincount += intarray[i];\r\n			if(mincount >= k+1 )\r\n			{\r\n				mincount=i;\r\n				break;\r\n			}\r\n			\r\n		}\r\n\r\n		for(i=999;i>=0;--i)\r\n		{\r\n			maxcount += intarray[i];\r\n			if(maxcount >= k+1)\r\n			{\r\n				maxcount= i;\r\n				break;\r\n			}\r\n		}\r\n\r\n		printf("%d\\n",maxcount - mincount);\r\n	}\r\n	return 0;\r\n}\r\n', '', 0, 0, 2, 1, '2010-10-16 20:24:17', '0001-01-01 00:00:00'),
(626, 14, 338, 3, '#include<stdio.h>\r\nint intarray[1001];\r\n\r\nint main()\r\n{\r\n	int n,k,num;\r\n	\r\n	while( scanf("%d",&n) == 1 )\r\n	{\r\n		int i,mincount=0,maxcount=0;\r\n		\r\n		if(0 == n)\r\n			break;\r\n\r\n		for(i=0;i<1000;++i)\r\n		{\r\n			intarray[i]=0;\r\n		}\r\n\r\n		scanf("%d",&k);\r\n\r\n		for(i=0;i<n;++i)\r\n		{	\r\n			scanf("%d",&num);\r\n			++intarray[num];\r\n		}\r\n\r\n		for(i=0;i<=999;++i)\r\n		{\r\n			mincount += intarray[i];\r\n			if(mincount >= k+1 )\r\n			{\r\n				mincount=i;\r\n				break;\r\n			}\r\n			\r\n		}\r\n\r\n		for(i=999;i>=0;--i)\r\n		{\r\n			maxcount += intarray[i];\r\n			if(maxcount >= k+1)\r\n			{\r\n				maxcount= i;\r\n				break;\r\n			}\r\n		}\r\n\r\n		printf("%d\\n",maxcount - mincount);\r\n	}\r\n	return 0;\r\n}\r\n', '', 0, 0, 2, 1, '2010-10-16 20:25:13', '0001-01-01 00:00:00'),
(627, 6, 348, 0, '#include <stdio.h>\r\n#include <string.h>\r\n\r\n#define N 45\r\n#define M 10\r\n#define W 50\r\n\r\nchar str[N];\r\nchar g[N][M][W],f[N][M][W];\r\nint  a[W],b[W],c[W];\r\nchar tmp[W],res[W];\r\nint n,k;\r\n\r\nvoid gen(char str[],int s,int t,char a[])\r\n{\r\n     int i=0;\r\n     while(t--)\r\n     {\r\n        a[i]=str[s];\r\n        ++i,++s;\r\n     }\r\n     a[i]=''\\0'';\r\n}\r\n\r\nvoid init()\r\n{\r\n    int i,j;\r\n    scanf("%s",str);\r\n    for(i=1;i<=n;++i)\r\n        for(j=i;j<=n;++j)\r\n            gen(str,i-1,j-i+1,g[i][j]);\r\n    \r\n    for(i=1;i<=n;++i)\r\n       gen(str,0,i,f[i][0]);\r\n}\r\n\r\nvoid mul(char s1[],char s2[],char s3[])\r\n{\r\n    int i,j,n1=strlen(s1),n2=strlen(s2),n3;\r\n    \r\n    memset(a,0,sizeof(a));\r\n    memset(b,0,sizeof(b));\r\n    memset(c,0,sizeof(c));\r\n    \r\n    for(i=0;i<n1;++i) a[i]=s1[n1-i-1]-''0'';\r\n    for(i=0;i<n2;++i) b[i]=s2[n2-i-1]-''0'';\r\n    \r\n    for(i=0;i<n1;++i)\r\n    {\r\n        for(j=0;j<n2;++j)\r\n        {\r\n            c[i+j]=c[i+j]+a[i]*b[j];\r\n            c[i+j+1]=c[i+j+1]+c[i+j]/10;\r\n            c[i+j]%=10;\r\n        }\r\n    }\r\n    if(c[n1+n2-1]!=0) n3=n1+n2;\r\n    else              n3=n1+n2-1; \r\n    \r\n    \r\n    int k=0;\r\n    for(i=n3-1;i>=0;--i)\r\n        s3[k++]=c[i]+''0'';\r\n    s3[k]=''\\0'';    \r\n    \r\n}\r\n\r\nchar check(char s1[],char s2[])\r\n{\r\n    int n1,n2;\r\n    if(*s2==''\\0'') return 1;\r\n    \r\n    n1=strlen(s1);\r\n    n2=strlen(s2);\r\n    if(n1<n2) return 0;\r\n    if(n1>n2) return 1;\r\n    if(n1==n2)\r\n    {\r\n       if(strcmp(s1,s2)>0) return 1;\r\n       else                return 0;\r\n    }\r\n}\r\n\r\nvoid solve()\r\n{\r\n    int i,j,kk,m,t;\r\n    for(i=2;i<=n;++i)\r\n    {\r\n        t=k;\r\n        if(i-1<k) t=i-1;\r\n        for(j=1;j<=t;++j)\r\n        {\r\n            res[0]=''\\0'';\r\n            for(kk=j;kk<=(i-1);++kk)\r\n            {\r\n                mul(f[kk][j-1],g[kk+1][i],tmp);\r\n                if(check(tmp,res)) strcpy(res,tmp);\r\n            }\r\n            strcpy(f[i][j],res);\r\n        }\r\n    }\r\n    printf("%s\\n",f[n][k]);\r\n}\r\n\r\nint main()\r\n{\r\n    //freopen("3.in","r",stdin);\r\n    //freopen("3.out","w",stdout);\r\n    while(scanf("%d %d",&n,&k)!=EOF)\r\n    {\r\n       init();\r\n       solve();\r\n    }\r\n    return 0;\r\n}\r\n\r\n', '', 15, 307200, 1, 2, '2010-10-17 00:15:32', '0001-01-01 00:00:00'),
(628, 6, 348, 0, '#include <stdio.h>\r\n#include <string.h>\r\n\r\n#define N 45\r\n#define M 10\r\n#define W 50\r\n\r\nchar str[N];\r\nchar g[N][M][W],f[N][M][W];\r\nint  a[W],b[W],c[W];\r\nchar tmp[W],res[W];\r\nint n,k;\r\n\r\nvoid gen(char str[],int s,int t,char a[])\r\n{\r\n     int i=0;\r\n     while(t--)\r\n     {\r\n        a[i]=str[s];\r\n        ++i,++s;\r\n     }\r\n     a[i]=''\\0'';\r\n}\r\n\r\nvoid init()\r\n{\r\n    int i,j;\r\n    scanf("%s",str);\r\n    for(i=1;i<=n;++i)\r\n        for(j=i;j<=n;++j)\r\n            gen(str,i-1,j-i+1,g[i][j]);\r\n    \r\n    for(i=1;i<=n;++i)\r\n       gen(str,0,i,f[i][0]);\r\n}\r\n\r\nvoid mul(char s1[],char s2[],char s3[])\r\n{\r\n    int i,j,n1=strlen(s1),n2=strlen(s2),n3;\r\n    \r\n    memset(a,0,sizeof(a));\r\n    memset(b,0,sizeof(b));\r\n    memset(c,0,sizeof(c));\r\n    \r\n    for(i=0;i<n1;++i) a[i]=s1[n1-i-1]-''0'';\r\n    for(i=0;i<n2;++i) b[i]=s2[n2-i-1]-''0'';\r\n    \r\n    for(i=0;i<n1;++i)\r\n    {\r\n        for(j=0;j<n2;++j)\r\n        {\r\n            c[i+j]=c[i+j]+a[i]*b[j];\r\n            c[i+j+1]=c[i+j+1]+c[i+j]/10;\r\n            c[i+j]%=10;\r\n        }\r\n    }\r\n    if(c[n1+n2-1]!=0) n3=n1+n2;\r\n    else              n3=n1+n2-1; \r\n    \r\n    \r\n    int k=0;\r\n    for(i=n3-1;i>=0;--i)\r\n        s3[k++]=c[i]+''0'';\r\n    s3[k]=''\\0'';    \r\n    \r\n}\r\n\r\nchar check(char s1[],char s2[])\r\n{\r\n    int n1,n2;\r\n    if(*s2==''\\0'') return 1;\r\n    \r\n    n1=strlen(s1);\r\n    n2=strlen(s2);\r\n    if(n1<n2) return 0;\r\n    if(n1>n2) return 1;\r\n    if(n1==n2)\r\n    {\r\n       if(strcmp(s1,s2)>0) return 1;\r\n       else                return 0;\r\n    }\r\n}\r\n\r\nvoid solve()\r\n{\r\n    int i,j,kk,m,t;\r\n    for(i=2;i<=n;++i)\r\n    {\r\n        t=k;\r\n        if(i-1<k) t=i-1;\r\n        for(j=1;j<=t;++j)\r\n        {\r\n            res[0]=''\\0'';\r\n            for(kk=j;kk<=(i-1);++kk)\r\n            {\r\n                mul(f[kk][j-1],g[kk+1][i],tmp);\r\n                if(check(tmp,res)) strcpy(res,tmp);\r\n            }\r\n            strcpy(f[i][j],res);\r\n        }\r\n    }\r\n    printf("%s\\n",f[n][k]);\r\n}\r\n\r\nint main()\r\n{\r\n    //freopen("3.in","r",stdin);\r\n    //freopen("3.out","w",stdout);\r\n    while(scanf("%d %d",&n,&k)!=EOF)\r\n    {\r\n       init();\r\n       solve();\r\n    }\r\n    return 0;\r\n}\r\n\r\n', '', 0, 0, 2, 2, '2010-10-17 00:16:24', '0001-01-01 00:00:00'),
(629, 33, 348, 0, '#include <stdio.h>\r\n#include <string.h>\r\n#include <iostream>\r\n#include <algorithm>\r\nusing namespace std;\r\n\r\n#define N 45\r\n#define M 10\r\n#define W 50\r\n\r\nchar str[N];\r\nchar g[N][M][W],f[N][M][W];\r\nint  a[W],b[W],c[W];\r\nchar tmp[W],res[W];\r\nint n,k;\r\n\r\nvoid gen(char str[],int s,int t,char a[])\r\n{\r\n     int i=0;\r\n     while(t--)\r\n     {\r\n        a[i]=str[s];\r\n        ++i,++s;\r\n     }\r\n     a[i]=''\\0'';\r\n}\r\n\r\nvoid init()\r\n{\r\n    int i,j;\r\n    scanf("%s",str);\r\n    for(i=1;i<=n;++i)\r\n        for(j=i;j<=n;++j)\r\n            gen(str,i-1,j-i+1,g[i][j]);\r\n    \r\n    for(i=1;i<=n;++i)\r\n       gen(str,0,i,f[i][0]);\r\n}\r\n\r\nvoid mul(char s1[],char s2[],char s3[])\r\n{\r\n    int i,j,n1=strlen(s1),n2=strlen(s2),n3;\r\n    \r\n    memset(a,0,sizeof(a));\r\n    memset(b,0,sizeof(b));\r\n    memset(c,0,sizeof(c));\r\n    \r\n    for(i=0;i<n1;++i) a[i]=s1[n1-i-1]-''0'';\r\n    for(i=0;i<n2;++i) b[i]=s2[n2-i-1]-''0'';\r\n    \r\n    for(i=0;i<n1;++i)\r\n    {\r\n        for(j=0;j<n2;++j)\r\n        {\r\n            c[i+j]=c[i+j]+a[i]*b[j];\r\n            c[i+j+1]=c[i+j+1]+c[i+j]/10;\r\n            c[i+j]%=10;\r\n        }\r\n    }\r\n    if(c[n1+n2-1]!=0) n3=n1+n2;\r\n    else              n3=n1+n2-1; \r\n    \r\n    \r\n    int k=0;\r\n    for(i=n3-1;i>=0;--i)\r\n        s3[k++]=c[i]+''0'';\r\n    s3[k]=''\\0'';    \r\n    \r\n}\r\n\r\nchar check(char s1[],char s2[])\r\n{\r\n    int n1,n2;\r\n    if(*s2==''\\0'') return 1;\r\n    \r\n    n1=strlen(s1);\r\n    n2=strlen(s2);\r\n    if(n1<n2) return 0;\r\n    if(n1>n2) return 1;\r\n    if(n1==n2)\r\n    {\r\n       if(strcmp(s1,s2)>0) return 1;\r\n       else                return 0;\r\n    }\r\n}\r\n\r\nvoid solve()\r\n{\r\n    int i,j,kk,m,t;\r\n    for(i=2;i<=n;++i)\r\n    {\r\n        t=k;\r\n        if(i-1<k) t=i-1;\r\n        for(j=1;j<=t;++j)\r\n        {\r\n            res[0]=''\\0'';\r\n            for(kk=j;kk<=(i-1);++kk)\r\n            {\r\n                mul(f[kk][j-1],g[kk+1][i],tmp);\r\n                if(check(tmp,res)) strcpy(res,tmp);\r\n            }\r\n            strcpy(f[i][j],res);\r\n        }\r\n    }\r\n    printf("%s\\n",f[n][k]);\r\n}\r\n\r\nint main()\r\n{\r\n    //freopen("3.in","r",stdin);\r\n    //freopen("3.out","w",stdout);\r\n    while(scanf("%d %d",&n,&k)!=EOF)\r\n    {\r\n       init();\r\n       solve();\r\n    }\r\n    return 0;\r\n}\r\n', '', 15, 413696, 1, 2, '2010-10-17 00:21:35', '0001-01-01 00:00:00'),
(630, 33, 348, 0, '#include <stdio.h>\r\n#include <string.h>\r\n\r\n#define N 45\r\n#define M 10\r\n#define W 50\r\n\r\nchar str[N];\r\nchar g[N][M][W],f[N][M][W];\r\nint  a[W],b[W],c[W];\r\nchar tmp[W],res[W];\r\nint n,k;\r\n\r\nvoid gen(char str[],int s,int t,char a[])\r\n{\r\n     int i=0;\r\n     while(t--)\r\n     {\r\n        a[i]=str[s];\r\n        ++i,++s;\r\n     }\r\n     a[i]=''\\0'';\r\n}\r\n\r\nvoid init()\r\n{\r\n    int i,j;\r\n    scanf("%s",str);\r\n    for(i=1;i<=n;++i)\r\n        for(j=i;j<=n;++j)\r\n            gen(str,i-1,j-i+1,g[i][j]);\r\n    \r\n    for(i=1;i<=n;++i)\r\n       gen(str,0,i,f[i][0]);\r\n}\r\n\r\nvoid mul(char s1[],char s2[],char s3[])\r\n{\r\n    int i,j,n1=strlen(s1),n2=strlen(s2),n3;\r\n    \r\n    memset(a,0,sizeof(a));\r\n    memset(b,0,sizeof(b));\r\n    memset(c,0,sizeof(c));\r\n    \r\n    for(i=0;i<n1;++i) a[i]=s1[n1-i-1]-''0'';\r\n    for(i=0;i<n2;++i) b[i]=s2[n2-i-1]-''0'';\r\n    \r\n    for(i=0;i<n1;++i)\r\n    {\r\n        for(j=0;j<n2;++j)\r\n        {\r\n            c[i+j]=c[i+j]+a[i]*b[j];\r\n            c[i+j+1]=c[i+j+1]+c[i+j]/10;\r\n            c[i+j]%=10;\r\n        }\r\n    }\r\n    if(c[n1+n2-1]!=0) n3=n1+n2;\r\n    else              n3=n1+n2-1; \r\n    \r\n    \r\n    int k=0;\r\n    for(i=n3-1;i>=0;--i)\r\n        s3[k++]=c[i]+''0'';\r\n    s3[k]=''\\0'';    \r\n    \r\n}\r\n\r\nchar check(char s1[],char s2[])\r\n{\r\n    int n1,n2;\r\n    if(*s2==''\\0'') return 1;\r\n    \r\n    n1=strlen(s1);\r\n    n2=strlen(s2);\r\n    if(n1<n2) return 0;\r\n    if(n1>n2) return 1;\r\n    if(n1==n2)\r\n    {\r\n       if(strcmp(s1,s2)>0) return 1;\r\n       else                return 0;\r\n    }\r\n}\r\n\r\nvoid solve()\r\n{\r\n    int i,j,kk,m,t;\r\n    for(i=2;i<=n;++i)\r\n    {\r\n        t=k;\r\n        if(i-1<k) t=i-1;\r\n        for(j=1;j<=t;++j)\r\n        {\r\n            res[0]=''\\0'';\r\n            for(kk=j;kk<=(i-1);++kk)\r\n            {\r\n                mul(f[kk][j-1],g[kk+1][i],tmp);\r\n                if(check(tmp,res)) strcpy(res,tmp);\r\n            }\r\n            strcpy(f[i][j],res);\r\n        }\r\n    }\r\n    printf("%s\\n",f[n][k]);\r\n}\r\n\r\nint main()\r\n{\r\n    //freopen("3.in","r",stdin);\r\n    //freopen("3.out","w",stdout);\r\n    while(scanf("%d %d",&n,&k)!=EOF)\r\n    {\r\n       init();\r\n       solve();\r\n    }\r\n    return 0;\r\n}\r\n\r\n', '', 0, 307200, 1, 1, '2010-10-17 00:22:31', '0001-01-01 00:00:00'),
(631, 33, 1, 0, '#include <stdio.h>\r\n\r\nint main()\r\n{\r\n    int a,b;\r\n    scanf("%d %d",&a, &b);\r\n    printf("%d\\n",a+b);\r\n    return 0;\r\n}', '', 0, 258048, 3, 1, '2010-10-17 00:22:56', '0001-01-01 00:00:00'),
(632, 33, 1, 0, '#include <stdio.h>\r\nint main()\r\n{\r\n    int a,b;\r\n    while(scanf("%d %d",&a,&b)!=EOF)\r\n          printf("%d\\n",a+b);\r\n    return 0;\r\n}', '', 0, 262144, 3, 1, '2010-10-17 00:24:32', '0001-01-01 00:00:00'),
(633, 6, 349, 0, '#include <stdio.h>\r\n#include <string.h>\r\n\r\n#define N 25\r\n#define M 105\r\n\r\nchar str[N][M];\r\nint  f[N][N],len[N];\r\nint  ans,n;\r\nchar used[N];\r\n\r\nint gen(int x,int y)\r\n{\r\n    char *a=str[x],*b=str[y];\r\n    char *t=str[x]+len[x]-1;\r\n    \r\n    while(t!=a)\r\n    {\r\n       if(*t==b[0])\r\n       {\r\n          if(strncmp(t,b,len[x]-(t-a))==0)\r\n             return len[y]-(len[x]-(t-a));\r\n       }\r\n       t--;\r\n    }\r\n    return 0;\r\n}\r\n\r\nvoid init()\r\n{\r\n    int i,j;\r\n    for(i=0;i<n;++i)\r\n    {\r\n        scanf("%s\\n",str+i);\r\n        len[i]=strlen(str[i]);\r\n    }\r\n    \r\n    for(i=0;i<n;++i)\r\n        for(j=0;j<n;++j)\r\n            f[i][j]=gen(i,j);\r\n}\r\n\r\nvoid dfs(int now,int tot)\r\n{\r\n    if(tot>ans) ans=tot;\r\n\r\n    used[now]++;\r\n    for(int i=0;i<n;++i)\r\n    {\r\n        if(used[i]<2&&f[now][i]>0)\r\n           dfs(i,tot+f[now][i]);\r\n    }\r\n    used[now]--;\r\n}\r\n\r\nvoid solve()\r\n{\r\n    init();\r\n    char ch=getchar();\r\n    ans=-1;\r\n    memset(used,0,sizeof(used));\r\n    for(int i=0;i<n;++i)\r\n    {\r\n        if(str[i][0]==ch)\r\n           dfs(i,len[i]);\r\n    }\r\n    printf("%d\\n",ans);\r\n}\r\n\r\nint main()\r\n{\r\n   // freopen("4.in","r",stdin);\r\n   // freopen("4.out","w",stdout);\r\n    while(scanf("%d",&n)!=EOF)\r\n       solve();\r\n    return 0;\r\n}\r\n', '', 15, 262144, 1, 2, '2010-10-17 11:44:47', '0001-01-01 00:00:00'),
(634, 6, 344, 4, '\r\n#include <stdio.h>\r\n#include <map>\r\n#include <string>\r\n#include <algorithm>\r\nusing namespace std;\r\n#define N 105\r\nmap<string,int> mp;\r\n\r\nint main()\r\n{\r\n    //freopen("1.in","r",stdin);\r\n    //freopen("1.out","w",stdout);\r\n    int n,i,t,flag,ans;\r\n    char str[N];\r\n    while(scanf("%d",&n)!=EOF)\r\n    {\r\n        mp.clear();\r\n        for(i=1;i<=n;++i)\r\n        {\r\n            scanf("%s",str);\r\n            ans=flag=0;\r\n            if(flag==0)\r\n            {\r\n               t=mp[str];\r\n               if(t==0) mp[str]=i;\r\n               else \r\n               {\r\n                  ans=i-mp[str];\r\n                  flag=1;\r\n               }\r\n            }\r\n        }\r\n        printf("%d\\n",ans);\r\n    }\r\n    return 0;\r\n}\r\n', '', 200, 1069056, 5, 2, '2010-10-17 11:58:27', '0001-01-01 00:00:00'),
(635, 6, 344, 4, '#include <stdio.h>\r\n#include <string.h>\r\n#include <algorithm>\r\nusing namespace std;\r\n#define M 105\r\n#define N 20010\r\n\r\nstruct Node\r\n{\r\n   char str[M];\r\n   int  pos;\r\n}que[N];\r\n\r\nbool cmp(const Node& a,const Node& b)\r\n{\r\n   int t=strcmp(a.str,b.str);\r\n   if(t==0) return a.pos<b.pos;\r\n   else     return t>0;\r\n}\r\nint main()\r\n{\r\n    freopen("1.in","r",stdin);\r\n    freopen("1.out","w",stdout);\r\n    int n,i,ans;\r\n    while(scanf("%d",&n)!=EOF)\r\n    {\r\n        ans=0;\r\n        for(i=0;i<n;++i)\r\n        {\r\n            scanf("%s",que[i].str);\r\n            que[i].pos=i;\r\n        }\r\n        sort(que,que+n,cmp);\r\n        \r\n        for(i=1;i<n;++i)\r\n        {\r\n            if(strcmp(que[i].str,que[i-1].str)==0)\r\n            {\r\n               ans=que[i].pos-que[i-1].pos;\r\n               break;\r\n            }\r\n        }\r\n        printf("%d\\n",ans);\r\n    }\r\n    return 0;\r\n}', '', 0, 2097152, 6, 2, '2010-10-17 12:07:46', '0001-01-01 00:00:00'),
(636, 6, 344, 4, '#include <stdio.h>\r\n#include <string.h>\r\n#include <algorithm>\r\nusing namespace std;\r\n#define M 105\r\n#define N 2010\r\n\r\nstruct Node\r\n{\r\n   char str[M];\r\n   int  pos;\r\n}que[N];\r\n\r\nbool cmp(const Node& a,const Node& b)\r\n{\r\n   int t=strcmp(a.str,b.str);\r\n   if(t==0) return a.pos<b.pos;\r\n   else     return t>0;\r\n}\r\nint main()\r\n{\r\n    freopen("1.in","r",stdin);\r\n    freopen("1.out","w",stdout);\r\n    int n,i,ans;\r\n    while(scanf("%d",&n)!=EOF)\r\n    {\r\n        ans=0;\r\n        for(i=0;i<n;++i)\r\n        {\r\n            scanf("%s",que[i].str);\r\n            que[i].pos=i;\r\n        }\r\n        sort(que,que+n,cmp);\r\n        \r\n        for(i=1;i<n;++i)\r\n        {\r\n            if(strcmp(que[i].str,que[i-1].str)==0)\r\n            {\r\n               ans=que[i].pos-que[i-1].pos;\r\n               break;\r\n            }\r\n        }\r\n        printf("%d\\n",ans);\r\n    }\r\n    return 0;\r\n}', '', 0, 483328, 7, 2, '2010-10-17 12:08:15', '0001-01-01 00:00:00'),
(637, 6, 344, 4, '#include <stdio.h>\r\n#include <string.h>\r\n#include <algorithm>\r\nusing namespace std;\r\n#define M 105\r\n#define N 5000\r\n\r\nstruct Node\r\n{\r\n   char str[M];\r\n   int  pos;\r\n}que[N];\r\n\r\nbool cmp(const Node& a,const Node& b)\r\n{\r\n   int t=strcmp(a.str,b.str);\r\n   if(t==0) return a.pos<b.pos;\r\n   else     return t>0;\r\n}\r\nint main()\r\n{\r\n    freopen("1.in","r",stdin);\r\n    freopen("1.out","w",stdout);\r\n    int n,i,ans;\r\n    while(scanf("%d",&n)!=EOF)\r\n    {\r\n        ans=0;\r\n        for(i=0;i<n;++i)\r\n        {\r\n            scanf("%s",que[i].str);\r\n            que[i].pos=i;\r\n        }\r\n        sort(que,que+n,cmp);\r\n        \r\n        for(i=1;i<n;++i)\r\n        {\r\n            if(strcmp(que[i].str,que[i-1].str)==0)\r\n            {\r\n               ans=que[i].pos-que[i-1].pos;\r\n               break;\r\n            }\r\n        }\r\n        printf("%d\\n",ans);\r\n    }\r\n    return 0;\r\n}', '', 0, 819200, 7, 2, '2010-10-17 12:08:45', '0001-01-01 00:00:00'),
(638, 6, 344, 4, '#include <stdio.h>\r\n#include <string.h>\r\n#include <algorithm>\r\nusing namespace std;\r\n#define M 105\r\n#define N 10000\r\n\r\nstruct Node\r\n{\r\n   char str[M];\r\n   int  pos;\r\n}que[N];\r\n\r\nbool cmp(const Node& a,const Node& b)\r\n{\r\n   int t=strcmp(a.str,b.str);\r\n   if(t==0) return a.pos<b.pos;\r\n   else     return t>0;\r\n}\r\nint main()\r\n{\r\n    freopen("1.in","r",stdin);\r\n    freopen("1.out","w",stdout);\r\n    int n,i,ans;\r\n    while(scanf("%d",&n)!=EOF)\r\n    {\r\n        ans=0;\r\n        for(i=0;i<n;++i)\r\n        {\r\n            scanf("%s",que[i].str);\r\n            que[i].pos=i;\r\n        }\r\n        sort(que,que+n,cmp);\r\n        \r\n        for(i=1;i<n;++i)\r\n        {\r\n            if(strcmp(que[i].str,que[i-1].str)==0)\r\n            {\r\n               ans=que[i].pos-que[i-1].pos;\r\n               break;\r\n            }\r\n        }\r\n        printf("%d\\n",ans);\r\n    }\r\n    return 0;\r\n}', '', 15, 1380352, 1, 2, '2010-10-17 12:09:06', '0001-01-01 00:00:00'),
(639, 33, 344, 0, '#include <stdio.h>\r\n#include <string.h>\r\n#include <algorithm>\r\nusing namespace std;\r\n#define M 105\r\n#define N 20010\r\n\r\nstruct Node\r\n{\r\n   char str[M];\r\n   int  pos;\r\n}que[N];\r\n\r\nbool cmp(const Node& a,const Node& b)\r\n{\r\n   int t=strcmp(a.str,b.str);\r\n   if(t==0) return a.pos<b.pos;\r\n   else     return t>0;\r\n}\r\nint main()\r\n{\r\n    //freopen("1.in","r",stdin);\r\n    //freopen("1.out","w",stdout);\r\n    int n,i,ans;\r\n    while(scanf("%d",&n)!=EOF)\r\n    {\r\n        ans=0;\r\n        for(i=0;i<n;++i)\r\n        {\r\n            scanf("%s",que[i].str);\r\n            que[i].pos=i;\r\n        }\r\n        sort(que,que+n,cmp);\r\n        \r\n        for(i=1;i<n;++i)\r\n        {\r\n            if(strcmp(que[i].str,que[i-1].str)==0)\r\n            {\r\n               ans=que[i].pos-que[i-1].pos;\r\n               break;\r\n            }\r\n        }\r\n        printf("%d\\n",ans);\r\n    }\r\n    return 0;\r\n}', '', 0, 2097152, 6, 2, '2010-10-17 12:11:00', '0001-01-01 00:00:00'),
(640, 33, 344, 0, '#include <stdio.h>\r\n#include <string.h>\r\n#include <algorithm>\r\nusing namespace std;\r\n#define M 101\r\n#define N 20001\r\n\r\nstruct Node\r\n{\r\n   char str[M];\r\n   int  pos;\r\n}que[N];\r\n\r\nbool cmp(const Node& a,const Node& b)\r\n{\r\n   int t=strcmp(a.str,b.str);\r\n   if(t==0) return a.pos<b.pos;\r\n   else     return t>0;\r\n}\r\nint main()\r\n{\r\n    //freopen("1.in","r",stdin);\r\n    //freopen("1.out","w",stdout);\r\n    int n,i,ans;\r\n    while(scanf("%d",&n)!=EOF)\r\n    {\r\n        ans=0;\r\n        for(i=0;i<n;++i)\r\n        {\r\n            scanf("%s",que[i].str);\r\n            que[i].pos=i;\r\n        }\r\n        sort(que,que+n,cmp);\r\n        \r\n        for(i=1;i<n;++i)\r\n        {\r\n            if(strcmp(que[i].str,que[i-1].str)==0)\r\n            {\r\n               ans=que[i].pos-que[i-1].pos;\r\n               break;\r\n            }\r\n        }\r\n        printf("%d\\n",ans);\r\n    }\r\n    return 0;\r\n}\r\n', '', 0, 2097152, 6, 2, '2010-10-17 12:13:40', '0001-01-01 00:00:00'),
(641, 17, 345, 4, '#include<iostream>\r\n#include<stdio.h>\r\n#include<vector>\r\n#include<string>\r\nusing namespace std;\r\nvoid show(int n,int m,vector<string>str1,vector<string>str2)\r\n{\r\n    int i; \r\n	int k;\r\n	int j;\r\n	if(n>=m)\r\n			 {\r\n		      k=n-m;\r\n			  for(i=k,j=0;i<=n;i++,j++)\r\n				 if(str1[i]==str2[j])\r\n				 {			 \r\n					 cout << str1[i] <<" "<<str1[i]<<endl;\r\n			         break;\r\n				 }\r\n			 }\r\n			\r\n		  else{\r\n				 k=m-n;\r\n			     for(i=0,j=k;j<=m;i++,j++)\r\n				     if(str1[i]==str2[j])\r\n				    {			 \r\n					  cout << str1[i] <<" "<<str1[i]<<endl;\r\n			          break;\r\n				     }\r\n			     }\r\n\r\n}\r\nint main()\r\n{\r\n    int n,m;\r\n    int i,j;\r\n    int k;\r\n	int num1,num2,num3,num4;\r\n	string snake;\r\n	vector<string>str1,str2;\r\n    while(scanf("%d",&n)!=EOF)\r\n    {   num1=num2=num3=num4=0;\r\n\r\n		for(i=0;i<n;++i){\r\n              cin >> snake;\r\n			  str1.push_back(snake);\r\n	\r\n         }\r\n	   cin>>m;\r\n       for(j=0;j<m;++j){\r\n           cin >> snake;\r\n		   str2.push_back(snake);\r\n		 }\r\n        \r\n	   for(i=0;i<n-1;i++)\r\n		 {\r\n			 if(str1[i]==str1[n-1])\r\n			 {\r\n				 num1=1;\r\n			     num2=i;\r\n				 break;\r\n			 }\r\n		 }\r\n		 for(i=0;i<m-1;i++)\r\n		 {\r\n			 if(str2[i]==str2[m-1])\r\n			 {\r\n				 num3=1;\r\n			     num4=i;\r\n				 break;\r\n			 }\r\n		 }\r\n		 if(num3==1&&num1==1&&str1[num2]==str2[num4])\r\n               show(num2,num4,str1,str2);\r\n\r\n		else if(num3==0&&num1==0&&str1[n-1]==str2[m-1])\r\n			show(n,m,str1,str2);\r\n		else\r\n			cout <<"none none"<<endl;\r\n		 str1.clear();\r\n		 str2.clear();\r\n	}\r\n	return 0;\r\n}\r\n', '', 0, 479232, 4, 2, '2010-10-17 15:11:54', '0001-01-01 00:00:00'),
(642, 14, 345, 4, '#include<iostream>\r\n#include<vector>\r\n#include<string>\r\n#include<algorithm>\r\n\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n	int num1,num2;\r\n	\r\n	while( cin >> num1  )\r\n	{\r\n		if( 0 == num1 )\r\n			break;\r\n		int i;\r\n		vector<string> vector1,vector2;\r\n		string name;\r\n		for(i=0;i<num1;++i)\r\n		{\r\n			cin>>name;\r\n			if( find(vector1.begin(),vector1.end(),name) != vector1.end() )\r\n			{\r\n				num1=i;\r\n				break;\r\n			}\r\n			vector1.push_back(name);\r\n		}\r\n		cin>>num2;\r\n		for(i=0;i<num2;++i)\r\n		{\r\n			cin>>name;\r\n			if( find(vector2.begin(),vector2.end(),name) !=vector2.end() )\r\n			{\r\n				num2=i;\r\n				break;\r\n			}\r\n			vector2.push_back(name);\r\n		}\r\n		int start;;\r\n		if( num2-num1> 0 )\r\n		{\r\n			start = num2-num1;\r\n			vector<string>::size_type i=0;\r\n			for(;i<vector1.size();i++)\r\n				if(vector2[start++] == vector1[i])\r\n					break;\r\n			if(i==vector2.size())\r\n				cout<<"none"<<'' ''<<"none" <<endl;\r\n			else\r\n				cout<<vector2[--start]<<'' ''<<vector2[start]<<endl;\r\n		}\r\n		else\r\n		{\r\n			start = num1-num2;\r\n			vector<string>::size_type i=0;\r\n			for(;i<vector2.size();i++)\r\n				if(vector1[start++] == vector2[i])\r\n					break;\r\n\r\n			if(i==vector2.size())\r\n				cout<<"none"<<'' ''<<"none"<<endl;\r\n			else\r\n				cout<<vector1[--start]<<'' ''<<vector1[start]<<endl;\r\n		}		\r\n		\r\n		\r\n	}\r\n	return 0;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n', '', 0, 483328, 4, 2, '2010-10-17 16:11:59', '0001-01-01 00:00:00'),
(643, 17, 345, 4, '#include<iostream>\r\n#include<stdio.h>\r\n#include<vector>\r\n#include<string>\r\nusing namespace std;\r\nvoid show(int n,int m,vector<string>str1,vector<string>str2)\r\n{\r\n    int i; \r\n	int k;\r\n	int j;\r\n	if(n>=m)\r\n			 {\r\n		      k=n-m;\r\n			  for(i=k,j=0;i<=n;i++,j++)\r\n				 if(str1[i]==str2[j])\r\n				 {			 \r\n					 cout << str1[i] <<" "<<str1[i]<<endl;\r\n			         break;\r\n				 }\r\n			 }\r\n			\r\n		  else{\r\n				 k=m-n;\r\n			     for(i=0,j=k;j<=m;i++,j++)\r\n				     if(str1[i]==str2[j])\r\n				    {			 \r\n					  cout << str1[i] <<" "<<str1[i]<<endl;\r\n			          break;\r\n				     }\r\n			     }\r\n\r\n}\r\nvoid show1(int n,int m,vector<string>str1,vector<string>str2)\r\n{\r\n    int i; \r\n	int k;\r\n	int j;\r\n	if(n>=m)\r\n			 {\r\n		      k=n-m;\r\n			  for(i=k,j=0;i<n;i++,j++)\r\n				 if(str1[i]==str2[j])\r\n				 {			 \r\n					 cout << str1[i] <<" "<<str1[i]<<endl;\r\n			         break;\r\n				 }\r\n			 }\r\n			\r\n		  else{\r\n				 k=m-n;\r\n			     for(i=0,j=k;j<m;i++,j++)\r\n				     if(str1[i]==str2[j])\r\n				    {			 \r\n					  cout << str1[i] <<" "<<str1[i]<<endl;\r\n			          break;\r\n				     }\r\n			     }\r\n\r\n}\r\nint main()\r\n{\r\n    int n,m;\r\n    int i,j;\r\n    int k;\r\n	int num1,num2,num3,num4;\r\n	string snake;\r\n	vector<string>str1,str2;\r\n    while(scanf("%d",&n)!=EOF)\r\n    {   \r\n		num1=num2=num3=num4=0;\r\n        for(i=0;i<n;++i){\r\n              cin >> snake;\r\n			  str1.push_back(snake);\r\n	\r\n         }\r\n	   cin>>m;\r\n       for(j=0;j<m;++j){\r\n           cin >> snake;\r\n		   str2.push_back(snake);\r\n		 }\r\n        \r\n	   for(i=0;i<n-1;i++)\r\n		 {\r\n			 if(str1[i]==str1[n-1])\r\n			 {\r\n				 num1=1;\r\n			     num2=i;\r\n				 break;\r\n			 }\r\n		 }\r\n		 for(i=0;i<m-1;i++)\r\n		 {\r\n			 if(str2[i]==str2[m-1])\r\n			 {\r\n				 num3=1;\r\n			     num4=i;\r\n				 break;\r\n			 }\r\n		 }\r\n		 if(num3==1&&num1==1&&str1[num2]==str2[num4])\r\n               show(num2,num4,str1,str2);\r\n         else if(num3==0&&num1==0)\r\n		 {\r\n			 if(str1[n-1]==str2[m-1])\r\n			  show1(n,m,str1,str2);\r\n			 else \r\n			 {\r\n				 for(i=0;i<n-1;i++)\r\n					 if(str1[i]==str2[m-1])\r\n					 {\r\n						 show(i,m-1,str1,str2);\r\n						 break;\r\n					 }\r\n				 for(i=0;i<m-1;i++)\r\n					 if(str2[i]==str1[n-1])\r\n					 {\r\n						 show(n-1,i,str1,str2);\r\n						 break;\r\n					 }\r\n			 }\r\n		 }\r\n\r\n		 else if(num3==0&&num1==1)\r\n		 {\r\n			 for(i=0;i<n-1;i++)\r\n				 if(str1[i]==str2[m-1])\r\n				 {\r\n					 show(i,m-1,str1,str2);\r\n			         break;\r\n				 }\r\n		 }\r\n		 else if(num3==1&&num1==0)\r\n		 {\r\n            for(i=0;i<m-1;i++)\r\n				if(str2[i]==str1[n-1])\r\n				{\r\n					show(n-1,i,str1,str2);\r\n					break;\r\n				}\r\n\r\n		 }\r\n		 else\r\n			cout <<"none none"<<endl;\r\n		 str1.clear();\r\n		 str2.clear();\r\n	}\r\n	return 0;\r\n}\r\n', '', 0, 483328, 4, 2, '2010-10-17 16:25:56', '0001-01-01 00:00:00'),
(644, 17, 345, 4, '#include<iostream>\r\n#include<stdio.h>\r\n#include<vector>\r\n#include<string>\r\nusing namespace std;\r\nbool flag;\r\nvoid show(int n,int m,vector<string>str1,vector<string>str2)\r\n{\r\n    int i; \r\n	int k;\r\n	int j;\r\n	if(n>=m)\r\n			 {\r\n		      k=n-m;\r\n			  for(i=k,j=0;i<=n;i++,j++)\r\n				 if(str1[i]==str2[j])\r\n				 {			 \r\n					 cout << str1[i] <<" "<<str1[i]<<endl;\r\n			         break;\r\n				 }\r\n			 }\r\n			\r\n		  else{\r\n				 k=m-n;\r\n			     for(i=0,j=k;j<=m;i++,j++)\r\n				     if(str1[i]==str2[j])\r\n				    {			 \r\n					  cout << str1[i] <<" "<<str1[i]<<endl;\r\n			          break;\r\n				     }\r\n			     }\r\n\r\n}\r\nvoid show1(int n,int m,vector<string>str1,vector<string>str2)\r\n{\r\n    int i; \r\n	int k;\r\n	int j;\r\n	if(n>=m)\r\n			 {\r\n		      k=n-m;\r\n			  for(i=k,j=0;i<n;i++,j++)\r\n				 if(str1[i]==str2[j])\r\n				 {			 \r\n					 cout << str1[i] <<" "<<str1[i]<<endl;\r\n			         break;\r\n				 }\r\n			 }\r\n			\r\n		  else{\r\n				 k=m-n;\r\n			     for(i=0,j=k;j<m;i++,j++)\r\n				     if(str1[i]==str2[j])\r\n				    {			 \r\n					  cout << str1[i] <<" "<<str1[i]<<endl;\r\n			          break;\r\n				     }\r\n			     }\r\n\r\n}\r\nint main()\r\n{\r\n    int n,m;\r\n    int i,j;\r\n    int k;\r\n	int num1,num2,num3,num4;\r\n	string snake;\r\n	vector<string>str1,str2;\r\n    while(scanf("%d",&n)!=EOF)\r\n    {   \r\n		num1=num2=num3=num4=flag=0;\r\n        for(i=0;i<n;++i){\r\n              cin >> snake;\r\n			  str1.push_back(snake);\r\n	\r\n         }\r\n	   cin>>m;\r\n       for(j=0;j<m;++j){\r\n           cin >> snake;\r\n		   str2.push_back(snake);\r\n		 }\r\n        \r\n	   for(i=0;i<n-1;i++)\r\n		 {\r\n			 if(str1[i]==str1[n-1])\r\n			 {\r\n				 num1=1;\r\n			     num2=i;\r\n				 break;\r\n			 }\r\n		 }\r\n		 for(i=0;i<m-1;i++)\r\n		 {\r\n			 if(str2[i]==str2[m-1])\r\n			 {\r\n				 num3=1;\r\n			     num4=i;\r\n				 break;\r\n			 }\r\n		 }\r\n		 if(num3==1&&num1==1&&str1[num2]==str2[num4])\r\n               show(num2,num4,str1,str2);\r\n         else if(num3==0&&num1==0)\r\n		 {\r\n			 if(str1[n-1]==str2[m-1])\r\n			   show1(n,m,str1,str2);\r\n			 else  \r\n			 {   \r\n				 for(i=0;i<n-1;i++)\r\n					 if(str1[i]==str2[m-1])\r\n					 {\r\n						 show(i,m-1,str1,str2);\r\n						 flag=1;\r\n						 break;\r\n					 }\r\n				 for(i=0;i<m-1;i++)\r\n					 if(str2[i]==str1[n-1])\r\n					 {\r\n						 show(n-1,i,str1,str2);\r\n						 flag=1;\r\n						 break;\r\n					 }\r\n				 if(!flag)\r\n					 cout <<"none none"<<endl;\r\n			  }\r\n\r\n\r\n		 }\r\n		 else if(num3==0&&num1==1)\r\n		 {\r\n			 for(i=0;i<n-1;i++)\r\n				 if(str1[i]==str2[m-1])\r\n				 {\r\n					 show(i,m-1,str1,str2);\r\n					 flag=1;\r\n			         break;\r\n				 }\r\n			 if(!flag)\r\n				 cout <<"none none"<<endl;\r\n\r\n		 }\r\n		 else if(num3==1&&num1==0)\r\n		 {\r\n            for(i=0;i<m-1;i++)\r\n				if(str2[i]==str1[n-1])\r\n				{\r\n					show(n-1,i,str1,str2);\r\n					flag=1;\r\n					break;\r\n				}\r\n			if(!flag)\r\n			  cout <<"none none"<<endl;\r\n\r\n		 }\r\n		 else\r\n			cout <<"none none"<<endl;\r\n		 str1.clear();\r\n		 str2.clear();\r\n	}\r\n	return 0;\r\n}\r\n', '', 0, 479232, 4, 2, '2010-10-17 16:41:17', '0001-01-01 00:00:00'),
(645, 6, 350, 0, '#include <stdio.h>\r\n#include <string.h>\r\n#define N 12\r\nint f[N][N][N][N],g[N][N];\r\n\r\nint getmax(int a,int b,int c,int d)\r\n{\r\n    if(a<b) a=b;\r\n    if(a<c) a=c;\r\n    if(a<d) a=d;\r\n    return a;\r\n}\r\n\r\nint main()\r\n{\r\n    //freopen("5.in","r",stdin);\r\n    //freopen("5.out","w",stdout);\r\n    int i,j,k,l,n;\r\n    while(scanf("%d",&n)!=EOF)\r\n    {\r\n       memset(g,0,sizeof(g));\r\n       memset(f,0,sizeof(f));\r\n       while(1)\r\n       {\r\n         scanf("%d %d %d",&i,&j,&k);\r\n         if(!(i||j||k)) break;\r\n         g[i][j]=k;\r\n       }\r\n       \r\n       for(i=1;i<=n;++i)\r\n       {\r\n           for(j=1;j<=n;++j)\r\n           {\r\n               for(k=1;k<=n;++k)\r\n               {\r\n                   for(l=1;l<=n;++l)\r\n                   {\r\n                       f[i][j][k][l]=getmax(f[i-1][j][k-1][l],f[i-1][j][k][l-1],\r\n                                            f[i][j-1][k-1][l],f[i][j-1][k][l-1]);\r\n                       f[i][j][k][l]+=g[i][j];\r\n                       if(!(i==k&&j==l)) f[i][j][k][l]+=g[k][l];\r\n                   }\r\n               }\r\n           }\r\n       }\r\n       printf("%d\\n",f[n][n][n][n]);\r\n    }\r\n    return 0;\r\n}', '', 0, 344064, 1, 2, '2010-10-17 21:36:31', '0001-01-01 00:00:00'),
(646, 6, 351, 0, '#include <stdio.h>\r\n#include <string.h>\r\n#define N 5005\r\n#define M 40100\r\n#define INF 10000000\r\n\r\nstruct Edge\r\n{\r\n   int v;\r\n   int c,w;\r\n   int next;\r\n}et[M];\r\nint  mp;\r\nint  head[N],pre[N];\r\nint  dis[N],Q[N*N];\r\nchar in[N];\r\nint n,k;\r\n\r\nvoid add(int u,int v,int c,int w)\r\n{\r\n     et[mp].v=v;\r\n     et[mp].c=c;\r\n     et[mp].w=w;\r\n     et[mp].next=head[u];\r\n     head[u]=mp++;\r\n}\r\n\r\nvoid add_e(int u,int v,int c,int w)\r\n{\r\n     add(u,v,c,w);\r\n     add(v,u,0,-w);\r\n}\r\n\r\nchar spfa(int n,int s,int t)\r\n{\r\n     int i,u,v,front,rear;\r\n     \r\n     for(i=0;i<n;++i)\r\n     {\r\n         dis[i]=INF;\r\n         in[i]=0;\r\n     }\r\n     front=rear=0; Q[rear]=s;\r\n     dis[s]=0;     in[s]=1;\r\n     \r\n     while(front<=rear)\r\n     {\r\n        u=Q[front];\r\n        for(i=head[u];i!=-1;i=et[i].next)\r\n        {\r\n            v=et[i].v;\r\n            if(et[i].c>0 && dis[u]+et[i].w<dis[v])\r\n            {\r\n               pre[v]=i;\r\n               dis[v]=dis[u]+et[i].w;\r\n               \r\n               if(in[v]==0)\r\n               {\r\n                  in[v]=1;\r\n                  Q[++rear]=v;\r\n               }\r\n            }\r\n        }\r\n        front++;\r\n        in[u]=0;\r\n     }\r\n     \r\n     if(dis[t]!=INF) return 1;\r\n     else            return 0;\r\n}\r\n\r\nint mc_mf(int n,int s,int t)\r\n{\r\n    int i,aug,ans;\r\n    \r\n    ans=0;\r\n    while(spfa(n,s,t))\r\n    {\r\n       aug=INF;\r\n       for(i=t;i!=s;i=et[pre[i]^1].v)\r\n       {\r\n           if(et[ pre[i] ].c<aug)\r\n              aug=et[ pre[i] ].c;\r\n       }\r\n       ans+=(dis[t]*aug);\r\n       \r\n       for(i=t;i!=s;i=et[pre[i]^1].v)\r\n       {\r\n           et[ pre[i] ].c-=aug;\r\n           et[ pre[i]^1 ].c+=aug;\r\n       }\r\n    }\r\n    return ans;\r\n}\r\n\r\nvoid solve()\r\n{\r\n    int s=0,t=2*n*n+1,u,v,tmp;\r\n    mp=0;\r\n    memset(head,-1,sizeof(head));\r\n    \r\n    add_e(s,1,k,0);\r\n    for(int i=1;i<=n;++i)\r\n    {\r\n        for(int j=1;j<=n;++j)\r\n        {\r\n            u=(i-1)*n+j;\r\n            v=u+n*n;\r\n            \r\n            scanf("%d",&tmp);\r\n            add_e(u,v,1,-tmp);\r\n            add_e(u,v,INF,0);\r\n            \r\n            if(j+1<=n) add_e(v,u+1,INF,0);\r\n            if(i+1<=n) add_e(v,u+n,INF,0);\r\n        }\r\n    }\r\n    add_e(2*n*n,t,k,0); \r\n    \r\n    printf("%d\\n",-mc_mf(t+1,s,t));\r\n}\r\n\r\nint main()\r\n{\r\n    //freopen("6.in","r",stdin);\r\n    //freopen("6.out","w",stdout);\r\n    while(scanf("%d %d",&n,&k)!=EOF)\r\n       solve();\r\n    return 0;\r\n}', '', 0, 67108864, 6, 2, '2010-10-17 22:22:05', '0001-01-01 00:00:00'),
(647, 6, 351, 0, '#include <stdio.h>\r\n#include <string.h>\r\n#define N 5005\r\n#define M 40100\r\n#define INF 10000000\r\n\r\nstruct Edge\r\n{\r\n   int v;\r\n   int c,w;\r\n   int next;\r\n}et[M];\r\nint  mp;\r\nint  head[N],pre[N];\r\nint  dis[N],Q[N*N];\r\nchar in[N];\r\nint n,k;\r\n\r\nvoid add(int u,int v,int c,int w)\r\n{\r\n     et[mp].v=v;\r\n     et[mp].c=c;\r\n     et[mp].w=w;\r\n     et[mp].next=head[u];\r\n     head[u]=mp++;\r\n}\r\n\r\nvoid add_e(int u,int v,int c,int w)\r\n{\r\n     add(u,v,c,w);\r\n     add(v,u,0,-w);\r\n}\r\n\r\nchar spfa(int n,int s,int t)\r\n{\r\n     int i,u,v,front,rear;\r\n     \r\n     for(i=0;i<n;++i)\r\n     {\r\n         dis[i]=INF;\r\n         in[i]=0;\r\n     }\r\n     front=rear=0; Q[rear]=s;\r\n     dis[s]=0;     in[s]=1;\r\n     \r\n     while(front<=rear)\r\n     {\r\n        u=Q[front];\r\n        for(i=head[u];i!=-1;i=et[i].next)\r\n        {\r\n            v=et[i].v;\r\n            if(et[i].c>0 && dis[u]+et[i].w<dis[v])\r\n            {\r\n               pre[v]=i;\r\n               dis[v]=dis[u]+et[i].w;\r\n               \r\n               if(in[v]==0)\r\n               {\r\n                  in[v]=1;\r\n                  Q[++rear]=v;\r\n               }\r\n            }\r\n        }\r\n        front++;\r\n        in[u]=0;\r\n     }\r\n     \r\n     if(dis[t]!=INF) return 1;\r\n     else            return 0;\r\n}\r\n\r\nint mc_mf(int n,int s,int t)\r\n{\r\n    int i,aug,ans;\r\n    \r\n    ans=0;\r\n    while(spfa(n,s,t))\r\n    {\r\n       aug=INF;\r\n       for(i=t;i!=s;i=et[pre[i]^1].v)\r\n       {\r\n           if(et[ pre[i] ].c<aug)\r\n              aug=et[ pre[i] ].c;\r\n       }\r\n       ans+=(dis[t]*aug);\r\n       \r\n       for(i=t;i!=s;i=et[pre[i]^1].v)\r\n       {\r\n           et[ pre[i] ].c-=aug;\r\n           et[ pre[i]^1 ].c+=aug;\r\n       }\r\n    }\r\n    return ans;\r\n}\r\n\r\nvoid solve()\r\n{\r\n    int s=0,t=2*n*n+1,u,v,tmp;\r\n    mp=0;\r\n    memset(head,-1,sizeof(head));\r\n    \r\n    add_e(s,1,k,0);\r\n    for(int i=1;i<=n;++i)\r\n    {\r\n        for(int j=1;j<=n;++j)\r\n        {\r\n            u=(i-1)*n+j;\r\n            v=u+n*n;\r\n            \r\n            scanf("%d",&tmp);\r\n            add_e(u,v,1,-tmp);\r\n            add_e(u,v,INF,0);\r\n            \r\n            if(j+1<=n) add_e(v,u+1,INF,0);\r\n            if(i+1<=n) add_e(v,u+n,INF,0);\r\n        }\r\n    }\r\n    add_e(2*n*n,t,k,0); \r\n    \r\n    printf("%d\\n",-mc_mf(t+1,s,t));\r\n}\r\n\r\nint main()\r\n{\r\n    //freopen("6.in","r",stdin);\r\n    //freopen("6.out","w",stdout);\r\n    while(scanf("%d %d",&n,&k)!=EOF)\r\n       solve();\r\n    return 0;\r\n}\r\n', '', 0, 67108864, 6, 2, '2010-10-17 22:23:14', '0001-01-01 00:00:00');
INSERT INTO `tbl_submitions` (`id`, `user_id`, `problem_id`, `exercise_id`, `source`, `result`, `used_time`, `used_memory`, `status`, `compiler_id`, `created`, `modified`) VALUES
(648, 6, 351, 0, '#include <stdio.h>\r\n#include <string.h>\r\n#define N 5005\r\n#define M 40100\r\n#define INF 10000000\r\n\r\nstruct Edge\r\n{\r\n   int v;\r\n   int c,w;\r\n   int next;\r\n}et[M];\r\nint  mp;\r\nint  head[N],pre[N];\r\nint  dis[N],Q[N];\r\nchar in[N];\r\nint n,k;\r\n\r\nvoid add(int u,int v,int c,int w)\r\n{\r\n     et[mp].v=v;\r\n     et[mp].c=c;\r\n     et[mp].w=w;\r\n     et[mp].next=head[u];\r\n     head[u]=mp++;\r\n}\r\n\r\nvoid add_e(int u,int v,int c,int w)\r\n{\r\n     add(u,v,c,w);\r\n     add(v,u,0,-w);\r\n}\r\n\r\nchar spfa(int n,int s,int t)\r\n{\r\n     int i,u,v,front,rear;\r\n     \r\n     for(i=0;i<n;++i)\r\n     {\r\n         dis[i]=INF;\r\n         in[i]=0;\r\n     }\r\n     front=rear=0; Q[rear]=s;\r\n     dis[s]=0;     in[s]=1;\r\n     \r\n     while(front<=rear)\r\n     {\r\n        u=Q[front];\r\n        for(i=head[u];i!=-1;i=et[i].next)\r\n        {\r\n            v=et[i].v;\r\n            if(et[i].c>0 && dis[u]+et[i].w<dis[v])\r\n            {\r\n               pre[v]=i;\r\n               dis[v]=dis[u]+et[i].w;\r\n               \r\n               if(in[v]==0)\r\n               {\r\n                  in[v]=1;\r\n                  Q[++rear]=v;\r\n               }\r\n            }\r\n        }\r\n        front++;\r\n        in[u]=0;\r\n     }\r\n     \r\n     if(dis[t]!=INF) return 1;\r\n     else            return 0;\r\n}\r\n\r\nint mc_mf(int n,int s,int t)\r\n{\r\n    int i,aug,ans;\r\n    \r\n    ans=0;\r\n    while(spfa(n,s,t))\r\n    {\r\n       aug=INF;\r\n       for(i=t;i!=s;i=et[pre[i]^1].v)\r\n       {\r\n           if(et[ pre[i] ].c<aug)\r\n              aug=et[ pre[i] ].c;\r\n       }\r\n       ans+=(dis[t]*aug);\r\n       \r\n       for(i=t;i!=s;i=et[pre[i]^1].v)\r\n       {\r\n           et[ pre[i] ].c-=aug;\r\n           et[ pre[i]^1 ].c+=aug;\r\n       }\r\n    }\r\n    return ans;\r\n}\r\n\r\nvoid solve()\r\n{\r\n    int s=0,t=2*n*n+1,u,v,tmp;\r\n    mp=0;\r\n    memset(head,-1,sizeof(head));\r\n    \r\n    add_e(s,1,k,0);\r\n    for(int i=1;i<=n;++i)\r\n    {\r\n        for(int j=1;j<=n;++j)\r\n        {\r\n            u=(i-1)*n+j;\r\n            v=u+n*n;\r\n            \r\n            scanf("%d",&tmp);\r\n            add_e(u,v,1,-tmp);\r\n            add_e(u,v,INF,0);\r\n            \r\n            if(j+1<=n) add_e(v,u+1,INF,0);\r\n            if(i+1<=n) add_e(v,u+n,INF,0);\r\n        }\r\n    }\r\n    add_e(2*n*n,t,k,0); \r\n    \r\n    printf("%d\\n",-mc_mf(t+1,s,t));\r\n}\r\n\r\nint main()\r\n{\r\n    //freopen("6.in","r",stdin);\r\n    //freopen("6.out","w",stdout);\r\n    while(scanf("%d %d",&n,&k)!=EOF)\r\n       solve();\r\n    return 0;\r\n}\r\n', '', 0, 987136, 7, 2, '2010-10-17 22:25:52', '0001-01-01 00:00:00'),
(649, 6, 351, 0, '#include <stdio.h>\r\n#include <string.h>\r\n#define N 5005\r\n#define M 40100\r\n#define INF 10000000\r\n\r\nstruct Edge\r\n{\r\n   int v;\r\n   int c,w;\r\n   int next;\r\n}et[M];\r\nint  mp;\r\nint  head[N],pre[N];\r\nint  dis[N],Q[100*N];\r\nchar in[N];\r\nint n,k;\r\n\r\nvoid add(int u,int v,int c,int w)\r\n{\r\n     et[mp].v=v;\r\n     et[mp].c=c;\r\n     et[mp].w=w;\r\n     et[mp].next=head[u];\r\n     head[u]=mp++;\r\n}\r\n\r\nvoid add_e(int u,int v,int c,int w)\r\n{\r\n     add(u,v,c,w);\r\n     add(v,u,0,-w);\r\n}\r\n\r\nchar spfa(int n,int s,int t)\r\n{\r\n     int i,u,v,front,rear;\r\n     \r\n     for(i=0;i<n;++i)\r\n     {\r\n         dis[i]=INF;\r\n         in[i]=0;\r\n     }\r\n     front=rear=0; Q[rear]=s;\r\n     dis[s]=0;     in[s]=1;\r\n     \r\n     while(front<=rear)\r\n     {\r\n        u=Q[front];\r\n        for(i=head[u];i!=-1;i=et[i].next)\r\n        {\r\n            v=et[i].v;\r\n            if(et[i].c>0 && dis[u]+et[i].w<dis[v])\r\n            {\r\n               pre[v]=i;\r\n               dis[v]=dis[u]+et[i].w;\r\n               \r\n               if(in[v]==0)\r\n               {\r\n                  in[v]=1;\r\n                  Q[++rear]=v;\r\n               }\r\n            }\r\n        }\r\n        front++;\r\n        in[u]=0;\r\n     }\r\n     \r\n     if(dis[t]!=INF) return 1;\r\n     else            return 0;\r\n}\r\n\r\nint mc_mf(int n,int s,int t)\r\n{\r\n    int i,aug,ans;\r\n    \r\n    ans=0;\r\n    while(spfa(n,s,t))\r\n    {\r\n       aug=INF;\r\n       for(i=t;i!=s;i=et[pre[i]^1].v)\r\n       {\r\n           if(et[ pre[i] ].c<aug)\r\n              aug=et[ pre[i] ].c;\r\n       }\r\n       ans+=(dis[t]*aug);\r\n       \r\n       for(i=t;i!=s;i=et[pre[i]^1].v)\r\n       {\r\n           et[ pre[i] ].c-=aug;\r\n           et[ pre[i]^1 ].c+=aug;\r\n       }\r\n    }\r\n    return ans;\r\n}\r\n\r\nvoid solve()\r\n{\r\n    int s=0,t=2*n*n+1,u,v,tmp;\r\n    mp=0;\r\n    memset(head,-1,sizeof(head));\r\n    \r\n    add_e(s,1,k,0);\r\n    for(int i=1;i<=n;++i)\r\n    {\r\n        for(int j=1;j<=n;++j)\r\n        {\r\n            u=(i-1)*n+j;\r\n            v=u+n*n;\r\n            \r\n            scanf("%d",&tmp);\r\n            add_e(u,v,1,-tmp);\r\n            add_e(u,v,INF,0);\r\n            \r\n            if(j+1<=n) add_e(v,u+1,INF,0);\r\n            if(i+1<=n) add_e(v,u+n,INF,0);\r\n        }\r\n    }\r\n    add_e(2*n*n,t,k,0); \r\n    \r\n    printf("%d\\n",-mc_mf(t+1,s,t));\r\n}\r\n\r\nint main()\r\n{\r\n    //freopen("6.in","r",stdin);\r\n    //freopen("6.out","w",stdout);\r\n    while(scanf("%d %d",&n,&k)!=EOF)\r\n       solve();\r\n    return 0;\r\n}', '', 31, 2973696, 1, 2, '2010-10-17 22:26:19', '0001-01-01 00:00:00'),
(650, 6, 343, 0, 'type  gtp=record x,y,d,next:longint;\r\n                 f:boolean;\r\n          end;\r\n//==================================================================\r\nvar n,m,tot,sum,ansi,top:longint;\r\n    g:array[0..250000] of gtp;\r\n    v:array[0..250000] of boolean;\r\n    count:array[0..401] of longint;\r\n    first,tmp,ans1,ans2,data,q,last:array[0..250000] of longint;\r\n//==================================================================\r\nprocedure add(x,y,d:longint); {连边}\r\nbegin\r\n inc(tot);\r\n g[tot].x:=x; g[tot].y:=y; g[tot].d:=d; g[tot].f:=false;\r\n g[tot].next:=first[x]; first[x]:=tot;\r\nend;\r\n//==================================================================\r\nprocedure dfs(x:longint); {非递归，寻找欧拉回路}\r\nvar t:longint;\r\nbegin\r\n top:=1; q[1]:=first[x]; v[x]:=true; last:=first; {初始化}\r\n \r\n while top>0 do\r\n begin\r\n  t:=q[top];\r\n  \r\n  while t<>0 do\r\n  begin\r\n   if not g[t].f then\r\n   begin\r\n    g[t].f:=true;\r\n\r\n    q[top]:=g[t].next;\r\n    data[top]:=g[t].d; last[g[t].x]:=g[t].next; {记录上一个节点的相关信息}\r\n    \r\n    inc(top); {新节点入栈}\r\n    q[top]:=last[g[t].y]; {当前弧}\r\n    v[g[t].y]:=true;\r\n    \r\n    break;\r\n   end;\r\n\r\n   t:=g[t].next;\r\n  end;\r\n  \r\n  if t=0 then {退栈了，将欧拉回路加入Tmp数组}\r\n  begin\r\n   dec(top);\r\n\r\n   if data[top]>0 then\r\n   begin\r\n    inc(sum);\r\n    tmp[sum]:=data[top];\r\n   end;\r\n  end;\r\n  \r\n end;\r\nend;\r\n//==================================================================\r\nprocedure init; {读入、构图}\r\nvar i,j,x:longint;\r\nbegin\r\n fillchar(first,sizeof(first),0);\r\n tot:=0;\r\n\r\n readln(n,m);\r\n \r\n for i:=1 to n do\r\n begin\r\n  fillchar(count,sizeof(count),0);\r\n \r\n  for j:=1 to m do\r\n  begin\r\n   read(x);\r\n   inc(count[x]);\r\n   \r\n   if count[x]>1 then add(i,n+x,(i-1)*m+j); {X向Y连边}\r\n  end;\r\n \r\n  for j:=1 to m do\r\n  if count[j]=0 then add(n+j,i,-1); {Y向X连边}\r\n end;\r\nend;\r\n//==================================================================\r\nprocedure main; {主函数}\r\nvar i,j:longint;\r\nbegin\r\n fillchar(v,sizeof(v),false);\r\n ansi:=0; tmp[0]:=n*m+1; {初始化}\r\n \r\n for i:=1 to n do {对于每个连通分量}\r\n if not v[i] then\r\n begin\r\n  sum:=0;\r\n  dfs(i);\r\n\r\n  for j:=1 to sum do {加入输出数组}\r\n  begin\r\n   inc(ansi);\r\n   ans1[ansi]:=tmp[j]; ans2[ansi]:=tmp[j-1];\r\n  end;\r\n  \r\n  if sum>0 then {加入输出数组}\r\n  begin\r\n   inc(ansi);\r\n   ans1[ansi]:=tmp[0]; ans2[ansi]:=tmp[sum];\r\n  end;\r\n end;\r\n \r\n writeln(ansi); {输出}\r\n for i:=1 to ansi do writeln(ans1[i],'' '',ans2[i]);\r\nend;\r\n//==================================================================\r\nbegin\r\n assign(input,''depot.in''); reset(input);\r\n assign(output,''depot.out''); rewrite(output);\r\n init;\r\n main;\r\n close(input); close(output);\r\nend.', '', 0, 0, 2, 3, '2010-10-18 13:17:39', '0001-01-01 00:00:00'),
(651, 6, 352, 0, '/*\r\n  Sluzbeno rjesenje zadatka Aladin.\r\n  Slozenost: O(q lg^2 n)\r\n\r\n  Autor: Goran Zuzic\r\n*/\r\n\r\n#include <algorithm>\r\n#include <functional>\r\n\r\n#include <cmath>\r\n#include <cstdio>\r\n#include <cstdlib>\r\n#include <cstring>\r\n\r\n#include <vector>\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst int MAXNODE = 2*132072;\r\ntypedef long long llint;\r\n\r\nint n, q;\r\n\r\nllint gcd( llint a, llint b ) { return b ? gcd( b, a%b ) : a; }\r\nllint calc( llint a, llint b, llint n ) {\r\n    llint x = a / b;\r\n    llint sum = x*n*(n+1) / 2; a %= b;\r\n\r\n    if( a == 0 || b == 0 ) return sum;\r\n\r\n    llint diag = n/b;\r\n    llint zadnji = a*n/b;\r\n\r\n    return sum + n*zadnji - calc( b, a, zadnji ) + diag;\r\n}\r\n\r\ninline llint solve( llint a, llint b, llint n ) { \r\n    if( n < 1 ) return 0;\r\n    llint g = gcd( a, b ); \r\n    return n*(n+1)/2*a - b*calc( a/g, b/g, n );\r\n}\r\n\r\nint _L, _R;\r\nint _A, _B;\r\n\r\nstruct node {\r\n    int a, b, poc;\r\n    int size;\r\n\r\n    llint suma;\r\n    node() { suma = 0; b = 0; }\r\n\r\n    void update( node &A, node &B ) { suma = A.suma + B.suma; }\r\n\r\n    void set_it( int aa, int bb, int pocc ) {\r\n        a = aa; b = bb; poc = pocc;\r\n        suma = solve( a, b, poc+size-1 ) - solve( a, b, poc-1 );\r\n    }\r\n\r\n    void spread( node &A, node &B ) {\r\n        if( b != 0 ) {\r\n            A.set_it( a, b, poc );\r\n            B.set_it( a, b, poc+A.size );\r\n        }\r\n        b = 0;\r\n    }\r\n\r\n} h[ MAXNODE ];\r\n\r\nvector< int > Rez;\r\n\r\nstruct tournament {\r\n    void init( int x, int l, int r ) {\r\n        h[x].size = Rez[r] - Rez[l];\r\n        if( l+1 == r ) return ;\r\n\r\n        int mid = ( l + r ) / 2;\r\n        init( 2*x, l, mid );\r\n        init( 2*x+1, mid, r );\r\n    }\r\n\r\n    llint query( int x, int l, int r ) {\r\n        if( _R <= l || r <= _L ) return 0;\r\n        if( _L <= l && r <= _R ) return h[x].suma;\r\n\r\n        h[x].spread( h[2*x], h[2*x+1] );\r\n\r\n        int mid = ( l + r ) / 2;\r\n        return query( 2*x, l, mid )\r\n            +  query( 2*x+1, mid, r );\r\n    }\r\n\r\n    void update( int x, int l, int r ) {\r\n        if( _R <= l || r <= _L ) return ;\r\n        if( _L <= l && r <= _R ) { \r\n            h[x].set_it( _A, _B, Rez[l]-Rez[_L]+1 );\r\n            return ;\r\n        }\r\n\r\n        h[x].spread( h[2*x], h[2*x+1] );\r\n\r\n        int mid = ( l + r ) / 2;\r\n        update( 2*x, l, mid );\r\n        update( 2*x+1, mid, r );\r\n        h[x].update( h[2*x], h[2*x+1] );\r\n    }\r\n} T;\r\n\r\nconst int MAXQ = 100100;\r\n\r\nstruct query {\r\n    int type;\r\n    int l, r;\r\n    int a, b;\r\n    \r\n    query() {}\r\n    query( int _type, int _l, int _r, int _a, int _b ) : type( _type ), l( _l ), r( _r ), a( _a ), b( _b ) {}\r\n} Q[ MAXQ ];\r\n\r\nint main( void )\r\n{\r\n    scanf( "%d %d", &n, &q );\r\n    Rez.reserve( 2*q + 100 );\r\n\r\n    Rez.push_back( 0 );\r\n    Rez.push_back( n );\r\n\r\n    for( int counter = 0; counter < q; ++counter ) {\r\n        int type, l, r; scanf( "%d %d %d", &type, &l, &r ); _L = --l; _R = --r;\r\n        Rez.push_back( l );\r\n        Rez.push_back( r+1 );\r\n\r\n        if( type == 1 ) {\r\n            scanf( "%d %d", &_A, &_B ); _A %= _B;\r\n            Q[counter] = query( type, l, r, _A, _B );\r\n        }\r\n        else {\r\n            Q[counter] = query( type, l, r, 0, 0 );\r\n        }\r\n    }\r\n\r\n    sort( Rez.begin(), Rez.end() );\r\n    T.init( 1, 0, ( int )Rez.size()-1 );\r\n\r\n    for( int counter = 0; counter < q; ++counter ) {\r\n        _L = lower_bound( Rez.begin(), Rez.end(), Q[counter].l ) - Rez.begin();\r\n        _R = upper_bound( Rez.begin(), Rez.end(), Q[counter].r ) - Rez.begin();\r\n\r\n        _A = Q[counter].a;\r\n        _B = Q[counter].b;\r\n\r\n        if( Q[counter].type == 1 ) {\r\n            T.update( 1, 0, ( int )Rez.size() - 1 );\r\n        }\r\n        else {\r\n            printf( "%lld\\n", T.query( 1, 0, ( int )Rez.size() - 1 ) );\r\n        }\r\n    }\r\n\r\n    return (0-0);\r\n}\r\n', '', 0, 8654848, 4, 2, '2010-10-18 21:35:38', '0001-01-01 00:00:00'),
(652, 6, 353, 0, '#include <stdio.h>\r\n\r\nint main()\r\n{\r\n    int a,b,n;\r\n    char flag;\r\n    while(scanf("%d",&a)!=EOF)\r\n    {\r\n        flag=0,n=7;\r\n        while(n--)\r\n        {\r\n           scanf("%d",&b);\r\n           if(flag==0)\r\n           {\r\n              if(a<b) flag=1;\r\n              if(b<a) flag=2;\r\n           }\r\n           else if(flag==1&&b<a) flag=3;\r\n           else if(flag==2&&a<b) flag=3;\r\n           a=b;\r\n        }\r\n        \r\n        if(flag==1)      printf("ascending\\n");\r\n        else if(flag==2) printf("descending\\n");\r\n        else if(flag==3) printf("mixed\\n");\r\n    }  \r\n    return 0;\r\n}\r\n     ', '', 0, 258048, 1, 2, '2010-10-19 13:10:54', '0001-01-01 00:00:00'),
(653, 6, 354, 0, '#include <stdio.h>\r\nint main()\r\n{\r\n    int n,i,j;\r\n    long long sum;\r\n    while(scanf("%d",&n)!=EOF)\r\n    {\r\n        sum=0;\r\n        for(i=0;i<=n;++i)\r\n        {\r\n            for(j=i;j<=n;++j)\r\n                sum+=(i+j);\r\n        }\r\n        printf("%I64d\\n",sum);\r\n    }\r\n    return 0;\r\n}\r\n', '', 0, 262144, 1, 2, '2010-10-19 19:52:46', '0001-01-01 00:00:00'),
(654, 6, 355, 0, '#include <stdio.h>\r\n#include <string.h>\r\n#define N 105\r\ntypedef long long LL;\r\nchar str[ N ];\r\nchar choice[ N ] ;\r\nchar br[]={ 0, 5, 1, 20 };\r\n\r\nint check( char ch ) { return( ch == ''A'' || ch == ''E'' || ch == ''I'' || ch == ''O'' || ch == ''U'' ); }\r\n\r\nchar pan( void ) \r\n{\r\n	for( int i = 0; str[ i+1 ] != 0  &&  str[ i+2 ] != 0; ++i ) \r\n    {\r\n		char f1 = ( check( str[ i+0 ] ) || choice[ i+0 ] == 1 );\r\n		char f2 = ( check( str[ i+1 ] ) || choice[ i+1 ] == 1 );\r\n		char f3 = ( check( str[ i+2 ] ) || choice[ i+2 ] == 1 );\r\n		if( f1 == f2 && f2 == f3 ) return 0;\r\n	}\r\n	return 1;\r\n}\r\n\r\nLL dfs( int pos, char f ) \r\n{\r\n	if( str[ pos ] == 0 ) return (LL)( f && pan() );\r\n	\r\n	if( str[ pos ] >= ''A'' && str[ pos ] <= ''Z'' )\r\n		return( dfs( pos + 1, f | ( str[ pos ] == ''L'' ) ) );\r\n	\r\n	LL res = 0ll;\r\n	for( int i = 1; i <= 3; ++i ) \r\n    {\r\n		choice[ pos ] = i;\r\n		res += br[ i ] * dfs( pos + 1, f | ( i == 2 ) );\r\n	}\r\n	\r\n	return res;\r\n}\r\n\r\nint main( ) \r\n{\r\n	while(scanf( "%s", str )!=EOF)\r\n	{\r\n       memset(choice,0,sizeof(choice));\r\n       printf( "%lld\\n", dfs( 0 , 0 ) );\r\n    }\r\n	return  0;\r\n}', '', 93, 262144, 1, 2, '2010-10-19 20:33:26', '0001-01-01 00:00:00'),
(655, 6, 356, 0, '#include <stdio.h>\r\n#include <string.h>\r\n#define MAXT 101\r\n\r\nint a[MAXT], b[MAXT];\r\nint ca[MAXT], cb[MAXT];\r\n\r\nint main(){\r\n	int n;\r\n	\r\n    while(scanf("%d", &n)!=EOF)\r\n    {\r\n       memset(a,0,sizeof(a));\r\n       memset(b,0,sizeof(b));\r\n       for (int i = 0; i < n; i++)\r\n       {\r\n           int x, y;\r\n           scanf("%d %d", &x, &y);\r\n           a[x]++;\r\n           b[y]++;\r\n           \r\n           for (int j = 0; j < MAXT; j++)\r\n           {\r\n              ca[j] = a[j];\r\n              cb[j] = b[j];\r\n           }\r\n           \r\n           int sol = 0;\r\n           int ap = MAXT - 1;\r\n           int bp = 1;\r\n           \r\n           while ( ap > 0 && bp < MAXT )\r\n           {\r\n              while ( ap > 0 && !ca[ap] ) ap--;\r\n              while ( bp < MAXT && !cb[bp] ) bp++;\r\n              \r\n              if ( ap == 0 || bp == MAXT ) break;\r\n              if ( ap + bp > sol ) sol = ap + bp;\r\n              \r\n              if ( ca[ap] > cb[bp] )\r\n              {\r\n                 ca[ap] -= cb[bp];\r\n                 cb[bp] = 0;\r\n              }\r\n              else \r\n              {\r\n                  cb[bp] -= ca[ap];\r\n                  ca[ap] = 0;\r\n              }\r\n           }\r\n           printf("%d\\n", sol);\r\n       }\r\n	}\r\n	return 0;\r\n}\r\n', '', 889, 262144, 1, 2, '2010-10-19 22:08:28', '0001-01-01 00:00:00'),
(656, 14, 345, 4, '#include<iostream>\r\n#include<map>\r\n#include<string>\r\n#include<utility>\r\n\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n	int n=0,m=0;\r\n	string name;\r\n	while( cin >> n )\r\n	{\r\n		map<string,int> nodemap;\r\n		for(int i=0;i<n;++i)\r\n		{\r\n			cin >> name;\r\n			if( nodemap.find(name) != nodemap.end() )\r\n				continue;\r\n			nodemap.insert(make_pair(name,i));\r\n		}\r\n\r\n		cin >> m;\r\n		string sharename="none";\r\n		int j=0;\r\n		for(;j<m;++j)\r\n		{\r\n			cin >> name;\r\n			if( nodemap.find(name) != nodemap.end() )\r\n			{	\r\n				sharename = name;\r\n				break;\r\n			}\r\n			nodemap.insert(make_pair(name,j));\r\n		}\r\n		for(j = j+1;j<m;++j)\r\n		{\r\n			cin>>name;\r\n			if( nodemap.find( name) == nodemap.end() )\r\n				sharename="none";\r\n		}\r\n\r\n		cout<<sharename << " "<<  sharename<< endl;\r\n\r\n\r\n	}\r\n	return 0;\r\n}\r\n\r\n\r\n', '', 0, 483328, 4, 2, '2010-10-20 08:17:48', '0001-01-01 00:00:00'),
(657, 14, 345, 4, '#include<iostream>\r\n#include<map>\r\n#include<string>\r\n#include<utility>\r\n\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n	int n=0,m=0;\r\n	string name;\r\n	while( cin >> n )\r\n	{\r\n		map<string,int> nodemap;\r\n		for(int i=0;i<n;++i)\r\n		{\r\n			cin >> name;\r\n			if( nodemap.find(name) != nodemap.end() )\r\n				continue;\r\n			nodemap.insert(make_pair(name,i));\r\n		}\r\n\r\n		cin >> m;\r\n		string sharename="none";\r\n		int j=0;\r\n		for(;j<m;++j)\r\n		{\r\n			cin >> name;\r\n			if( nodemap.find(name) != nodemap.end() )\r\n			{	\r\n				sharename = name;\r\n				break;\r\n			}\r\n			nodemap.insert(make_pair(name,j));\r\n		}\r\n		for(j = j+1;j<m;++j)\r\n		{\r\n			cin>>name;\r\n		}\r\n\r\n		cout<<sharename << " "<<  sharename<< endl;\r\n\r\n\r\n	}\r\n	return 0;\r\n}', '', 0, 483328, 4, 2, '2010-10-20 08:27:58', '0001-01-01 00:00:00'),
(658, 17, 345, 4, '#include<iostream>\r\n#include<stdio.h>\r\n#include<vector>\r\n#include<string>\r\nusing namespace std;\r\nbool flag;\r\n\r\nvoid show(int n,int m,vector<string>str1,vector<string>str2)//计算两条链表长度的差\r\n                                                            //如果第一个链表比第二个长，第一个链表先向前移动f步\r\n{\r\n    int i; \r\n	int k;\r\n	int j;\r\n	if(n>=m)\r\n     {\r\n	 k=n-m;\r\n	 for(i=k,j=0;i<=n;i++,j++)\r\n	     if(str1[i]==str2[j])\r\n	    {			 \r\n	       cout << str1[i] <<" "<<str1[i]<<endl;\r\n	       break;\r\n	    }\r\n     }\r\n			\r\n	else\r\n     {\r\n\r\n	 k=m-n;\r\n	 for(i=0,j=k;j<=m;i++,j++)\r\n	     if(str1[i]==str2[j])\r\n	 {			 \r\n	     cout << str1[i] <<" "<<str1[i]<<endl;\r\n	     break;\r\n	  }\r\n      }\r\n\r\n}\r\nvoid show1(int n,int m,vector<string>str1,vector<string>str2)//计算两条链表长度的差\r\n                                                            //如果第一个链表比第二个长，第一个链表先向前移动f步\r\n{\r\n    int i; \r\n    int k;\r\n    int j;\r\n    if(n>=m)\r\n   {\r\n	k=n-m;\r\n	for(i=k,j=0;i<n;i++,j++)\r\n		if(str1[i]==str2[j])\r\n		{			 \r\n			cout << str1[i] <<" "<<str1[i]<<endl;\r\n			 break;\r\n		}\r\n   }\r\n   else\r\n  {\r\n	k=m-n;\r\n	for(i=0,j=k;j<m;i++,j++)\r\n		if(str1[i]==str2[j])\r\n		{			 \r\n		    cout << str1[i] <<" "<<str1[i]<<endl;\r\n		    break;\r\n		 }\r\n  }\r\n\r\n}\r\n\r\n\r\nint main()\r\n{\r\n    int n,m;\r\n    int i,j;\r\n    int k;\r\n    int num1,num2,num3,num4;\r\n    string snake;\r\n    vector<string>str1,str2;\r\n    while(scanf("%d",&n)!=EOF)\r\n    {   \r\n	num1=num2=num3=num4=flag=0;\r\n        for(i=0;i<n;++i){\r\n              cin >> snake;\r\n	      str1.push_back(snake);//输入数据\r\n	\r\n         }\r\n       cin>>m;\r\n       for(j=0;j<m;++j){\r\n           cin >> snake;\r\n	   str2.push_back(snake);\r\n	}                         //输入数据\r\n        \r\n	   for(i=0;i<n-1;i++)\r\n	  {\r\n		if(str1[i]==str1[n-1])\r\n		{\r\n			 num1=1;//判断有环，记录环的首个节点\r\n			 num2=i;\r\n			 break;\r\n			 }\r\n		 }\r\n		 for(i=0;i<m-1;i++)\r\n		 {\r\n			 if(str2[i]==str2[m-1])\r\n			 {\r\n			     num3=1;//判断有环，记录环的首个节点\r\n			     num4=i;\r\n			     break;\r\n			 }\r\n		 }\r\n	//判断环存在的情况	 \r\n        if(num3==1&&num1==1&&str1[num2]==str2[num4]) //都存在环\r\n               show(num2,num4,str1,str2);\r\n        \r\n         else if(num3==0&&num1==0)  //都没有环的情况\r\n	   {\r\n			\r\n             if(str1[n-1]==str2[m-1])\r\n			    show1(n,m,str1,str2);\r\n			 else                //尾节点不相同的情况\r\n			 {   \r\n				 for(i=0;i<n-1;i++)\r\n					 if(str1[i]==str2[m-1])\r\n					 {\r\n						 show(i,m-1,str1,str2);\r\n						 flag=1;\r\n						 break;\r\n					 }\r\n				 \r\n                  for(i=0;i<m-1;i++)\r\n					 if(str2[i]==str1[n-1])\r\n					 {\r\n						 show(n-1,i,str1,str2);\r\n						 flag=1;\r\n						 break;\r\n					 }\r\n				 if(!flag)\r\n					 cout <<"none"<<" "<<"none"<<endl;\r\n			  }\r\n\r\n\r\n		 }\r\n		\r\n        else\r\n		cout <<"none"<<" "<<"none"<<endl;\r\n		 \r\n         str1.clear();\r\n		 str2.clear();//清空\r\n	}\r\n	return 0;\r\n}\r\n', '', 0, 479232, 4, 2, '2010-10-20 08:42:39', '0001-01-01 00:00:00'),
(659, 14, 338, 3, '#include<stdio.h>\r\nint intarray[1001];\r\n\r\nint main()\r\n{\r\n	int n,k,num;\r\n	\r\n	while( scanf("%d",&n) == 1 )\r\n	{\r\n		int i,mincount=0,maxcount=0;\r\n		\r\n		if(0 == n)\r\n			break;\r\n\r\n		for(i=0;i<1000;++i)\r\n		{\r\n			intarray[i]=0;\r\n		}\r\n\r\n		scanf("%d",&k);\r\n\r\n		for(i=0;i<n;++i)\r\n		{	\r\n			scanf("%d",&num);\r\n			++intarray[num];\r\n		}\r\n\r\n		for(i=0;i<=999;++i)\r\n		{\r\n			mincount += intarray[i];\r\n			if(mincount >= k+1 )\r\n			{\r\n				mincount=i;\r\n				break;\r\n			}\r\n			\r\n		}\r\n\r\n		for(i=999;i>=0;--i)\r\n		{\r\n			maxcount += intarray[i];\r\n			if(maxcount >= k+1)\r\n			{\r\n				maxcount= i;\r\n				break;\r\n			}\r\n		}\r\n\r\n		printf("%d\\n",maxcount - mincount);\r\n	}\r\n	return 0;\r\n}\r\n', '', 390, 266240, 1, 1, '2010-10-20 08:48:04', '0001-01-01 00:00:00'),
(660, 17, 345, 4, '#include<iostream>\r\n#include<stdio.h>\r\n#include<vector>\r\n#include<string>\r\nusing namespace std;\r\nbool flag;\r\n\r\nvoid show(int n,int m,vector<string>str1,vector<string>str2)//计算两条链表长度的差\r\n                                                            //如果第一个链表比第二个长，第一个链表先向前移动f步\r\n{\r\n    int i; \r\n	int k;\r\n	int j;\r\n	if(n>=m)\r\n     {\r\n	 k=n-m;\r\n	 for(i=k,j=0;i<=n;i++,j++)\r\n	     if(str1[i]==str2[j])\r\n	    {			 \r\n	       cout << str1[i] <<" "<<str1[i]<<endl;\r\n	       break;\r\n	    }\r\n     }\r\n			\r\n	else\r\n     {\r\n\r\n	 k=m-n;\r\n	 for(i=0,j=k;j<=m;i++,j++)\r\n	     if(str1[i]==str2[j])\r\n	 {			 \r\n	     cout << str1[i] <<" "<<str1[i]<<endl;\r\n	     break;\r\n	  }\r\n      }\r\n\r\n}\r\nvoid show1(int n,int m,vector<string>str1,vector<string>str2)//计算两条链表长度的差\r\n                                                            //如果第一个链表比第二个长，第一个链表先向前移动f步\r\n{\r\n    int i; \r\n    int k;\r\n    int j;\r\n    if(n>=m)\r\n   {\r\n	k=n-m;\r\n	for(i=k,j=0;i<n;i++,j++)\r\n		if(str1[i]==str2[j])\r\n		{			 \r\n			cout << str1[i] <<" "<<str1[i]<<endl;\r\n			 break;\r\n		}\r\n   }\r\n   else\r\n  {\r\n	k=m-n;\r\n	for(i=0,j=k;j<m;i++,j++)\r\n		if(str1[i]==str2[j])\r\n		{			 \r\n		    cout << str1[i] <<" "<<str1[i]<<endl;\r\n		    break;\r\n		 }\r\n  }\r\n\r\n}\r\n\r\n\r\nint main()\r\n{\r\n    int n,m;\r\n    int i,j;\r\n    int k;\r\n    int num1,num2,num3,num4;\r\n    string snake;\r\n    vector<string>str1,str2;\r\n    while(scanf("%d",&n)!=EOF)\r\n    {   \r\n	num1=num2=num3=num4=flag=0;\r\n        for(i=0;i<n;++i){\r\n              cin >> snake;\r\n	      str1.push_back(snake);//输入数据\r\n	\r\n         }\r\n       cin>>m;\r\n       for(j=0;j<m;++j){\r\n           cin >> snake;\r\n	   str2.push_back(snake);\r\n	}                         //输入数据\r\n        \r\n	   for(i=0;i<n-1;i++)\r\n	  {\r\n		if(str1[i]==str1[n-1])\r\n		{\r\n			 num1=1;//判断有环，记录环的首个节点\r\n			 num2=i;\r\n			 break;\r\n			 }\r\n		 }\r\n		 for(i=0;i<m-1;i++)\r\n		 {\r\n			 if(str2[i]==str2[m-1])\r\n			 {\r\n			     num3=1;//判断有环，记录环的首个节点\r\n			     num4=i;\r\n			     break;\r\n			 }\r\n		 }\r\n	//判断环存在的情况	 \r\n        if(num3==1&&num1==1&&str1[num2]==str2[num4]) //都存在环\r\n               show(num2,num4,str1,str2);\r\n        \r\n         else if(num3==0&&num1==0)  //都没有环的情况\r\n	    {\r\n			\r\n             if(str1[n-1]==str2[m-1])\r\n			    show1(n,m,str1,str2);\r\n              else\r\n		      cout <<"none"<<" "<<"none"<<endl;\r\n\r\n\r\n		 }\r\n		\r\n        else\r\n		cout <<"none"<<" "<<"none"<<endl;\r\n		 \r\n         str1.clear();\r\n		 str2.clear();//清空\r\n	}\r\n	return 0;\r\n}\r\n', '', 0, 483328, 4, 2, '2010-10-20 08:50:44', '0001-01-01 00:00:00'),
(661, 6, 356, 0, '#include <stdio.h>\r\n#define N 100010\r\nint a[N],b[N];\r\n\r\nint main()\r\n{\r\n    int i,j,k,n,x,y,res,tmp;\r\n    while(scanf("%d",&n)!=EOF)\r\n    {\r\n        for(i=0;i<n;++i)\r\n        {\r\n            scanf("%d %d",&x,&y);\r\n            if(i==0) \r\n            {\r\n               a[i]=x;\r\n               b[i]=y;\r\n            }\r\n            else\r\n            {\r\n               for(j=0;j<i;++j)\r\n               {\r\n                   if(a[j]<=x)\r\n                   {\r\n                      for(k=i-1;k>=j;--k)\r\n                          a[k+1]=a[k];\r\n                      break;\r\n                   }\r\n               }  \r\n               a[j]=x;\r\n               \r\n               for(j=0;j<i;++j)\r\n               {\r\n                   if(b[j]<=y)\r\n                   {\r\n                      for(k=i-1;k>=j;--k)\r\n                          b[k+1]=b[k];\r\n                      break;\r\n                   }\r\n               }     \r\n               b[j]=y;\r\n            }\r\n                \r\n            res=0;\r\n            for(j=0;j<=i;++j)\r\n            {\r\n                tmp=a[j]+b[i-j];\r\n                if(tmp>res) res=tmp;\r\n            }\r\n            printf("%d\\n",res);\r\n        }\r\n    }\r\n    return 0;\r\n} \r\n', '', 1000, 1060864, 5, 2, '2010-10-20 09:15:25', '0001-01-01 00:00:00'),
(662, 6, 356, 0, '#include <stdio.h>\r\n#include <algorithm>\r\nusing namespace std;\r\n#define N 100010\r\nint a[N],b[N];\r\n\r\nint main()\r\n{\r\n    int i,j,k,n,x,y,res,tmp;\r\n    while(scanf("%d",&n)!=EOF)\r\n    {\r\n        for(i=0;i<n;++i)\r\n        {\r\n            scanf("%d %d",&x,&y);\r\n            a[i]=x,b[i]=y;\r\n            sort(a,a+i+1);\r\n            sort(b,b+i+1);\r\n            \r\n            res=0;\r\n            for(j=0;j<=i;++j)\r\n            {\r\n                tmp=a[j]+b[i-j];\r\n                if(tmp>res) res=tmp;\r\n            }\r\n            printf("%d\\n",res);\r\n        }\r\n    }\r\n    return 0;\r\n} ', '', 1000, 1056768, 5, 2, '2010-10-20 09:21:47', '0001-01-01 00:00:00'),
(663, 14, 339, 3, '#include<stdio.h>\r\n\r\nint num[1000001];\r\nint shownum[1000];\r\n\r\n\r\nint compare(const void *p1,const void *p2)\r\n{\r\n	\r\n		return (*(int *)p2) - (*(int *)p1);\r\n}\r\n\r\nint main()\r\n{\r\n	int n=0,r=0;\r\n	while( scanf("%d",&n) ==1)\r\n	{\r\n		int i;\r\n\r\n		if( 0==n)\r\n			break;\r\n\r\n		scanf("%d",&r);\r\n		for(i=0;i<r;++i)\r\n		{\r\n			scanf("%d",&shownum[i]);\r\n		}\r\n\r\n		for(i=0;i<n;++i)\r\n		{\r\n			scanf("%d",&num[i]);\r\n		}\r\n\r\n		qsort(num,n,sizeof(int),compare);\r\n\r\n		for(i=0;i<r;++i)\r\n		{\r\n			printf("%d\\n",num[ shownum[i] ]);\r\n		}\r\n	}\r\n	return 0;\r\n}\r\n\r\n\r\n\r\n', '', 202, 4272128, 1, 1, '2010-10-20 09:32:15', '0001-01-01 00:00:00'),
(664, 6, 356, 0, '#include <stdio.h>\r\n#define N 100010\r\nint a[N],b[N];\r\nint ca[N],cb[N],ta[N],tb[N];\r\n\r\nint main()\r\n{\r\n    int i,j,k,n,x,y,res,tmp;\r\n    while(scanf("%d",&n)!=EOF)\r\n    {\r\n        for(i=0;i<n;++i) ca[i]=0,cb[i]=0;\r\n        for(i=0;i<n;++i)\r\n        {\r\n            scanf("%d %d",&x,&y);\r\n            if(i==0) \r\n            {\r\n               a[i]=x;b[i]=y;\r\n               ca[i]++,cb[i]++;\r\n            }\r\n            else\r\n            {\r\n               for(j=0;j<i;++j)\r\n               {\r\n                   if(a[j]<x)\r\n                   {\r\n                      for(k=i-1;k>=j;--k)\r\n                      {\r\n                          a[k+1]=a[k];\r\n                          ca[k+1]=ca[k];\r\n                      }\r\n                      break;\r\n                   }\r\n               }  \r\n               a[j]=x;\r\n               ca[j]++;\r\n               \r\n               for(j=0;j<i;++j)\r\n               {\r\n                   if(b[j]<=y)\r\n                   {\r\n                      for(k=i-1;k>=j;--k)\r\n                      {\r\n                          b[k+1]=b[k];\r\n                          cb[k+1]=cb[k];\r\n                      }\r\n                      break;\r\n                   }\r\n               }     \r\n               b[j]=y;\r\n               cb[j]++;\r\n            }\r\n            \r\n            for(j=0;j<=i;++j)\r\n                ta[j]=ca[j],tb[j]=cb[j];\r\n            \r\n            j=0,k=i;    \r\n            res=0;\r\n            while(1)\r\n            {\r\n                if(ta[j]==0) j++;\r\n                if(tb[k]==0) k--;\r\n                if(j>i||k<0) break;\r\n                tmp=a[j]+b[k];\r\n                if(tmp>res) res=tmp;\r\n                if(ta[i]>tb[k]) ta[i]-=tb[k],tb[k]=0;\r\n                else            tb[k]-=ta[j],ta[j]=0;\r\n            }\r\n            printf("%d\\n",res);\r\n        }\r\n    }\r\n    return 0;\r\n} ', '', 1000, 2666496, 5, 2, '2010-10-20 09:32:50', '0001-01-01 00:00:00'),
(665, 6, 356, 0, '#include <stdio.h>\r\n#define N 100010\r\nint a[N],b[N];\r\nint ca[N],cb[N],ta[N],tb[N];\r\n\r\nint main()\r\n{\r\n    //freopen("mali.in","r",stdin);\r\n    //freopen("3.out","w",stdout);\r\n    int i,j,k,n,x,y,res,tmp,flag;\r\n    while(scanf("%d",&n)!=EOF)\r\n    {\r\n        for(i=1;i<=n;++i) ca[i]=0,cb[i]=0;\r\n        a[0]=0,b[0]=0;\r\n        for(i=1;i<=n;++i)\r\n        {\r\n            scanf("%d %d",&x,&y);\r\n            if(i==1) \r\n            {\r\n               a[i]=x;b[i]=y;\r\n               ca[i]++,cb[i]++;\r\n               a[0]++,b[0]++;\r\n            }\r\n            else\r\n            {\r\n               flag=0;\r\n               for(j=1;j<=a[0];++j)\r\n               {\r\n                   if(a[j]<x)\r\n                   {\r\n                      for(k=a[0];k>=j;--k)\r\n                      {\r\n                          a[k+1]=a[k];\r\n                          ca[k+1]=ca[k];\r\n                      }\r\n                      break;\r\n                   }\r\n                   else if(a[j]==x)\r\n                   {\r\n                      ca[j]++;\r\n                      flag=1;\r\n                      break;\r\n                   }\r\n               }  \r\n               if(flag==0)\r\n               {\r\n                  a[j]=x;\r\n                  ca[j]=1;\r\n                  a[0]++;\r\n               }\r\n               \r\n               flag=0;\r\n               for(j=1;j<=b[0];++j)\r\n               {\r\n                   if(b[j]<y)\r\n                   {\r\n                      for(k=b[0];k>=j;--k)\r\n                      {\r\n                          b[k+1]=b[k];\r\n                          cb[k+1]=cb[k];\r\n                      }\r\n                      break;\r\n                   }\r\n                   else if(b[j]==y)\r\n                   {\r\n                      cb[j]++;\r\n                      flag=1;\r\n                      break;\r\n                   }\r\n               }  \r\n               if(flag==0)\r\n               {\r\n                  b[j]=y;\r\n                  cb[j]=1;\r\n                  b[0]++;\r\n               }\r\n            }\r\n            \r\n            for(j=1;j<=a[0];++j)\r\n                ta[j]=ca[j];\r\n            for(j=1;j<=b[0];++j)\r\n                tb[j]=cb[j];\r\n                \r\n            /*for(j=1;j<=a[0];++j)\r\n                printf("%d ",a[j]);\r\n            printf("\\n");\r\n            for(j=1;j<=b[0];++j)\r\n                printf("%d ",b[j]);\r\n            printf("\\n");\r\n            \r\n            for(j=1;j<=a[0];++j)\r\n                printf("%d ",ta[j]);\r\n            printf("\\n");\r\n            for(j=1;j<=b[0];++j)\r\n                printf("%d ",tb[j]);\r\n            printf("\\n");*/\r\n            \r\n            j=1,k=b[0];    \r\n            res=0;\r\n            while(1)\r\n            {\r\n                if(ta[j]==0) j++;\r\n                if(tb[k]==0) k--;\r\n                if(j>a[0]||k<1) break;\r\n                tmp=a[j]+b[k];\r\n                if(tmp>res) res=tmp;\r\n                if(ta[j]>tb[k]) ta[j]-=tb[k],tb[k]=0;\r\n                else            tb[k]-=ta[j],ta[j]=0;\r\n            }\r\n            printf("%d\\n",res);\r\n        }\r\n    }\r\n    return 0;\r\n} ', '', 826, 2666496, 1, 2, '2010-10-20 09:57:00', '0001-01-01 00:00:00'),
(666, 29, 1, 0, '#include<stdio.h>\r\nint main()\r\n{\r\nint a,b;\r\nwhile(scanf("%d%d",&a,&b)==2)\r\n{\r\nprintf("%d\\n",a+b);\r\n}\r\nreturn 0;\r\n}', '', 0, 258048, 3, 1, '2010-10-20 21:09:47', '0001-01-01 00:00:00'),
(667, 29, 1, 0, '#include <stdio.h>\r\nint main()\r\n{\r\nint a,b;\r\nwhile(scanf("%d%d",&a,&b)==2)\r\n{\r\nprintf("%d\\n",a+b);\r\n}\r\nreturn 0;\r\n}', '', 0, 258048, 3, 1, '2010-10-20 21:11:02', '0001-01-01 00:00:00'),
(668, 6, 361, 0, '#include <stdio.h>\r\n#include <string.h>\r\n#define N 205\r\n#define M 105\r\ntypedef long long LL;\r\nchar dir[8][2]={{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}};\r\n\r\nint n,m;\r\nint len;\r\nchar g[N][N];\r\nchar str[M];\r\nLL dp[M][N][N];\r\n\r\nchar check(int x,int y)\r\n{\r\n    if(x<0||x>=n||y<0||y>=m) return 0;\r\n    else                     return 1;\r\n}\r\n\r\nint main(void)\r\n {\r\n    int p,i,j,k,nx,ny;\r\n    LL sum;\r\n    while(scanf("%d %d %d",&n,&m,&len)!=EOF)\r\n    {\r\n        for(i=0;i<n;++i)\r\n           scanf("%s",g+i);\r\n        scanf("%s",str);\r\n        \r\n        memset(dp,0,sizeof(dp));\r\n        for(p=0;p<len;++p)\r\n        {\r\n           for(i=0;i<n;++i)\r\n           {\r\n               for(j=0;j<m;++j)\r\n               {\r\n                   if(g[i][j]!=str[p])\r\n                   {\r\n                      dp[p][i][j]=0;\r\n                      continue;\r\n                   }\r\n                   \r\n                   if(p==0)\r\n                   {\r\n                      dp[p][i][j]=1;\r\n                      continue;\r\n                   }\r\n                   \r\n                   sum=0;\r\n                   for(k=0;k<8;++k)\r\n                   {\r\n                       nx=i+dir[k][0];\r\n                       ny=j+dir[k][1];\r\n                       if(check(nx,ny))\r\n                          sum+=dp[p-1][nx][ny];\r\n                   }\r\n                   dp[p][i][j]=sum;\r\n               }\r\n           }\r\n        }\r\n        \r\n        sum=0;\r\n        for(i=0;i<n;++i)\r\n        {\r\n            for(j=0;j<m;++j)\r\n                sum+=dp[len-1][i][j];\r\n        }\r\n        printf("%I64d\\n",sum);\r\n    }\r\n    return 0;\r\n}\r\n', '', 280, 35672064, 1, 1, '2010-10-23 09:48:50', '0001-01-01 00:00:00'),
(669, 7, 356, 0, '#include<iostream>\r\n#include<set>\r\n\r\nusing namespace std;\r\n\r\nset<int> sa, sb;\r\nset<int>::iterator ia, ib;\r\nint n;\r\n\r\nint main()\r\n{\r\n	int a, b, i;\r\n	while(scanf("%d", &n)==1)\r\n	{\r\n		sa.clear();\r\n		sb.clear();\r\n		for(i = 0; i < n; i++)\r\n		{\r\n			scanf("%d %d", &a, &b);\r\n			sa.insert(a);\r\n			sb.insert(b);\r\n			ia = sa.begin();\r\n			ib = sb.end();\r\n			int t1 = *ia + *(--ib);\r\n			ia = sa.end();\r\n			ib = sb.begin();\r\n			int t2 = *(--ia) + *ib;\r\n//			printf("%d %d\\n", t1, t2);\r\n			printf("%d\\n", max(t1, t2));\r\n		}\r\n	}\r\n	return 0;\r\n}', 'Main.cpp: In function ''int main()'':\r\nMain.cpp:13:22: error: ''scanf'' was not declared in this scope\r\nMain.cpp:29:30: error: ''printf'' was not declared in this scope\r\n', 0, 0, 2, 2, '2010-10-23 12:20:10', '0001-01-01 00:00:00'),
(670, 7, 356, 0, '#include<iostream>\r\n#include<set>\r\n#include<cstdio>\r\n\r\nusing namespace std;\r\n\r\nset<int> sa, sb;\r\nset<int>::iterator ia, ib;\r\nint n;\r\n\r\nint main()\r\n{\r\n	int a, b, i;\r\n	while(scanf("%d", &n)==1)\r\n	{\r\n		sa.clear();\r\n		sb.clear();\r\n		for(i = 0; i < n; i++)\r\n		{\r\n			scanf("%d %d", &a, &b);\r\n			sa.insert(a);\r\n			sb.insert(b);\r\n			ia = sa.begin();\r\n			ib = sb.end();\r\n			int t1 = *ia + *(--ib);\r\n			ia = sa.end();\r\n			ib = sb.begin();\r\n			int t2 = *(--ia) + *ib;\r\n//			printf("%d %d\\n", t1, t2);\r\n			printf("%d\\n", max(t1, t2));\r\n		}\r\n	}\r\n	return 0;\r\n}', '', 374, 483328, 4, 2, '2010-10-23 12:20:53', '0001-01-01 00:00:00'),
(671, 6, 364, 0, '#include <stdio.h>\r\n#include <string.h>\r\n#include <algorithm>\r\nusing namespace std;\r\n#define N 100010\r\nstruct Node\r\n{\r\n    int x,y;\r\n}que[N];\r\nint dp[N];\r\n\r\nbool cmp(const Node &a,const Node &b)\r\n{\r\n     return a.x<b.x;\r\n}\r\n\r\nint main()\r\n{\r\n    int a,b,i,j,n,res,ans;\r\n    while(scanf("%d",&n)!=EOF)\r\n    {\r\n       memset(dp,0,sizeof(dp));\r\n       for(i=0;i<n;++i)\r\n       {\r\n           scanf("%d %d",&a,&b);\r\n           que[i].x=a,que[i].y=b;\r\n       }\r\n       \r\n       sort(que,que+n,cmp);\r\n       dp[0]=1,ans=1;\r\n       for(i=1;i<n;++i)\r\n       {\r\n           res=1;\r\n           for(j=0;j<i;++j)\r\n           {\r\n               if(que[j].y<que[i].y&&dp[j]+1>res)\r\n                  res=dp[j]+1;\r\n           }\r\n           dp[i]=res;\r\n           if(ans<res) ans=res;\r\n       }\r\n       printf("%d\\n",n+1-ans);\r\n    }\r\n    return 0;\r\n}', '', 1000, 1462272, 5, 2, '2010-10-23 14:51:47', '0001-01-01 00:00:00'),
(672, 6, 364, 0, '#include <iostream>\r\n#include <set>\r\n#include <vector>\r\nusing namespace std;\r\n\r\n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\r\n\r\nint main() {\r\n	//ifstream cin("pcb.in");\r\n	//ofstream cout("pcb.out");\r\n	int a, b, N;\r\n	cin >> N;\r\n\r\n	vector< pair<int, int> > V;\r\n	rep(i, N) {\r\n		cin >> a >> b;\r\n		V.push_back( make_pair(a, b) );\r\n	}\r\n	sort( V.begin(), V.end() );\r\n\r\n	set<int, greater<int> > S;\r\n	rep(i, N) {\r\n		int x = V[i].second;\r\n		typeof(S.begin()) it = S.upper_bound(x);\r\n		if ( it != S.end() ) S.erase( it );\r\n		S.insert(x);\r\n	}\r\n	cout << S.size() << endl;\r\n\r\n	return 0;\r\n};', 'Main.cpp: In function ''int main()'':\r\nMain.cpp:19:27: error: ''sort'' was not declared in this scope\r\nMain.cpp:24:19: error: ''typeof'' was not declared in this scope\r\nMain.cpp:24:21: error: expected '';'' before ''it''\r\nMain.cpp:25:8: error: ''it'' was not declared in this scope\r\n', 0, 0, 2, 2, '2010-10-23 14:59:36', '0001-01-01 00:00:00'),
(673, 6, 364, 0, '#include <iostream>\r\n#include <set>\r\n#include <vector>\r\n#includ  <algorithm>\r\nusing namespace std;\r\n\r\n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\r\n\r\nint main() {\r\n	//ifstream cin("pcb.in");\r\n	//ofstream cout("pcb.out");\r\n	int a, b, N;\r\n	cin >> N;\r\n\r\n	vector< pair<int, int> > V;\r\n	rep(i, N) {\r\n		cin >> a >> b;\r\n		V.push_back( make_pair(a, b) );\r\n	}\r\n	sort( V.begin(), V.end() );\r\n\r\n	set<int, greater<int> > S;\r\n	rep(i, N) {\r\n		int x = V[i].second;\r\n		typeof(S.begin()) it = S.upper_bound(x);\r\n		if ( it != S.end() ) S.erase( it );\r\n		S.insert(x);\r\n	}\r\n	cout << S.size() << endl;\r\n\r\n	return 0;\r\n};\r\n', 'Main.cpp:4:2: error: invalid preprocessing directive #includ\r\nMain.cpp: In function ''int main()'':\r\nMain.cpp:20:27: error: ''sort'' was not declared in this scope\r\nMain.cpp:25:19: error: ''typeof'' was not declared in this scope\r\nMain.cpp:25:21: error: expected '';'' before ''it''\r\nMain.cpp:26:8: error: ''it'' was not declared in this scope\r\n', 0, 0, 2, 2, '2010-10-23 15:00:19', '0001-01-01 00:00:00'),
(674, 6, 364, 0, '#include <iostream>\r\n#include <set>\r\n#include <vector>\r\n#include <algorithm>\r\nusing namespace std;\r\n\r\n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\r\n\r\nint main() {\r\n	//ifstream cin("pcb.in");\r\n	//ofstream cout("pcb.out");\r\n	int a, b, N;\r\n	cin >> N;\r\n\r\n	vector< pair<int, int> > V;\r\n	rep(i, N) {\r\n		cin >> a >> b;\r\n		V.push_back( make_pair(a, b) );\r\n	}\r\n	sort( V.begin(), V.end() );\r\n\r\n	set<int, greater<int> > S;\r\n	set<int, greater<int> >::iterator it;\r\n	rep(i, N) {\r\n		int x = V[i].second;\r\n		it = S.upper_bound(x);\r\n		if ( it != S.end() ) S.erase( it );\r\n		S.insert(x);\r\n	}\r\n	cout << S.size() << endl;\r\n\r\n	return 0;\r\n};', '', 0, 372736, 4, 2, '2010-10-23 15:02:32', '0001-01-01 00:00:00'),
(675, 6, 364, 0, '#include <iostream>\r\n#include <set>\r\n#include <vector>\r\n#include <algorithm>\r\nusing namespace std;\r\n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\r\n\r\nint main() \r\n{\r\n	//ifstream cin("pcb.in");\r\n	//ofstream cout("2.out");\r\n	int a, b, N;\r\n	while(cin >> N)\r\n	{\r\n       vector< pair<int, int> > V;\r\n       rep(i, N) \r\n       {\r\n           cin >> a >> b;\r\n           V.push_back( make_pair(a, b) );\r\n       }\r\n       sort( V.begin(), V.end() );\r\n       set<int, greater<int> > S;\r\n       set<int, greater<int> >::iterator it;\r\n       rep(i, N) \r\n       {\r\n           int x = V[i].second;\r\n           it = S.upper_bound(x);\r\n           if ( it != S.end() ) S.erase( it );\r\n           S.insert(x);\r\n       }\r\n       cout << S.size() << endl;\r\n    }\r\n    return 0;\r\n}', '', 1000, 4739072, 5, 2, '2010-10-23 15:05:54', '0001-01-01 00:00:00'),
(676, 6, 364, 0, '#include <stdio.h>\r\n#include <set>\r\n#include <vector>\r\n#include <algorithm>\r\nusing namespace std;\r\n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\r\n\r\nint main() \r\n{\r\n	//ifstream cin("pcb.in");\r\n	//ofstream cout("2.out");\r\n	int a, b, N;\r\n	while(scanf("%d",&N)!=EOF)\r\n	{\r\n       vector< pair<int, int> > V;\r\n       rep(i, N) \r\n       {\r\n           scanf("%d %d",&a,&b);\r\n           V.push_back( make_pair(a, b) );\r\n       }\r\n       sort( V.begin(), V.end() );\r\n       set<int, greater<int> > S;\r\n       set<int, greater<int> >::iterator it;\r\n       rep(i, N) \r\n       {\r\n           int x = V[i].second;\r\n           it = S.upper_bound(x);\r\n           if ( it != S.end() ) S.erase( it );\r\n           S.insert(x);\r\n       }\r\n       printf("%d\\n",(int)S.size());\r\n    }\r\n    return 0;\r\n}', '', 530, 4665344, 1, 2, '2010-10-23 15:07:29', '0001-01-01 00:00:00'),
(677, 6, 364, 0, '#include <stdio.h>\r\n#include <string.h>\r\n#include <algorithm>\r\nusing namespace std;\r\n#define N 100010\r\nstruct Node\r\n{\r\n    int x,y;\r\n}que[N];\r\nint dp[N];\r\n\r\nbool cmp(const Node &a,const Node &b)\r\n{\r\n     if(a.x!=b.x) return a.x<b.x;\r\n     else         return a.y<b.y;\r\n}\r\n\r\nint main()\r\n{\r\n    //freopen("pcb.in","r",stdin);\r\n    //freopen("1.out","w",stdout);\r\n    int a,b,i,j,n,res,ans;\r\n    while(scanf("%d",&n)!=EOF)\r\n    {\r\n       memset(dp,0,sizeof(dp));\r\n       for(i=0;i<n;++i)\r\n       {\r\n           scanf("%d %d",&a,&b);\r\n           que[i].x=a,que[i].y=b;\r\n       }\r\n       \r\n       sort(que,que+n,cmp);\r\n       dp[0]=1,ans=1;\r\n       for(i=1;i<n;++i)\r\n       {\r\n           res=1;\r\n           for(j=0;j<i;++j)\r\n           {\r\n               if(que[j].y>que[i].y&&dp[j]+1>res)\r\n                  res=dp[j]+1;\r\n           }\r\n           dp[i]=res;\r\n           if(ans<res) ans=res;\r\n       }\r\n       printf("%d\\n",n+1-ans);\r\n    }\r\n    return 0;\r\n}', '', 1000, 1462272, 5, 2, '2010-10-23 15:12:47', '0001-01-01 00:00:00'),
(678, 6, 364, 0, '#include <stdio.h>\r\n#include <string.h>\r\n#include <algorithm>\r\nusing namespace std;\r\n#define N 100010\r\nstruct Node\r\n{\r\n    int x,y;\r\n}que[N];\r\nint a[N];\r\n\r\nbool cmp(const Node &a,const Node &b)\r\n{\r\n     return a.x<b.x;\r\n}\r\n\r\nint main()\r\n{\r\n   // freopen("pcb.in","r",stdin);\r\n    //freopen("1.out","w",stdout);\r\n    int x,y,i,j,n,high,low,mid,len,tmp;\r\n    while(scanf("%d",&n)!=EOF)\r\n    {\r\n       for(i=0;i<n;++i)\r\n       {\r\n           scanf("%d %d",&x,&y);\r\n           que[i].x=x,que[i].y=y;\r\n       }\r\n       \r\n       sort(que,que+n,cmp);\r\n       len=0;\r\n       a[++len]=que[0].y;\r\n       for(i=1;i<n;++i)\r\n       {\r\n           tmp=que[i].y;\r\n           if(tmp<a[len]) a[++len]=tmp;\r\n           else\r\n           {\r\n              low=1,high=len;\r\n              while(low<=high)\r\n              {\r\n                 mid=(low+high)>>1;\r\n                 if(a[mid]<tmp) high=mid-1;\r\n                 else           low=mid+1;\r\n              }\r\n              a[low]=tmp;\r\n           }\r\n       }\r\n       printf("%d\\n",len);\r\n    }\r\n    return 0;\r\n}', '', 218, 1462272, 1, 2, '2010-10-23 15:36:19', '0001-01-01 00:00:00'),
(679, 6, 365, 0, '#include <stdio.h>\r\n#include <string.h>\r\n#include <stdlib.h>\r\n#include <math.h>\r\n#define N   550\r\n#define M   200000\r\n#define MAXVISION 100\r\n#define INF 1<<30\r\n\r\nstruct Edge\r\n{\r\n   int v;\r\n   int c,f;\r\n   int next;\r\n}et[M];\r\nint mp;\r\nint head[N],pre[N],cur[N];\r\nint d[N],cnt[N];\r\n\r\nstruct Node\r\n{\r\n   int x,y;\r\n}que[300];\r\nint n,s,t,l,w;\r\n\r\nvoid add(int u,int v,int c)\r\n{\r\n    et[mp].v=v;\r\n    et[mp].c=c;\r\n    et[mp].f=0;\r\n    et[mp].next=head[u];\r\n    head[u]=mp++;\r\n}\r\n\r\nvoid add_e(int u,int v,int c)\r\n{\r\n    add(u,v,c);\r\n    add(v,u,0);\r\n}\r\n\r\nint isap(int n,int s,int t)\r\n{\r\n    int u,v,now,flow,low,tmp;\r\n    \r\n    memset(d,0,sizeof(d));\r\n    memset(cnt,0,sizeof(cnt));\r\n    for(u=0;u<n;++u) cur[u]=head[u];\r\n    \r\n    u=s;\r\n    flow=0;\r\n    cnt[0]=n;\r\n    low=INF;\r\n    while(d[s]<n)\r\n    {\r\n       for(now=cur[u];now!=-1;now=et[now].next)\r\n       {\r\n           if(et[now].c>et[now].f&&d[u]==d[v=et[now].v]+1)\r\n              break;\r\n       }\r\n       \r\n       cur[u]=now;\r\n       if(now>=0)\r\n       {\r\n          pre[v]=now;\r\n          tmp=et[now].c-et[now].f;\r\n          low=tmp<low?tmp:low;\r\n          \r\n          u=v;\r\n          if(u==t)\r\n          {\r\n             for(;u!=s;u=et[pre[u]^1].v)\r\n             {\r\n                 et[pre[u]].f+=low;\r\n                 et[pre[u]^1].f-=low;\r\n             }\r\n             flow+=low;\r\n             low=INF;\r\n          }\r\n       }\r\n       else\r\n       {\r\n          if(--cnt[d[u]]==0) break;\r\n          \r\n          d[u]=n;\r\n          cur[u]=head[u];\r\n          for(now=head[u];now!=-1;now=et[now].next)\r\n          {\r\n              if(et[now].c>et[now].f&&d[u]>d[et[now].v]+1)\r\n                 d[u]=d[et[now].v]+1;\r\n          }\r\n          cnt[d[u]]++;\r\n          \r\n          if(u!=s) u=et[pre[u]^1].v;\r\n       }\r\n    }\r\n    return flow;\r\n}\r\n\r\nint check(int x1, int y1, int x2, int y2)\r\n{\r\n    if ((abs(x1 - x2) > 2 * MAXVISION) || (abs(y1 - y2) > 2 * MAXVISION))\r\n        return 0;\r\n    return ((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) <= 4 * MAXVISION * MAXVISION);\r\n}\r\n\r\nvoid solve()\r\n{\r\n    int i,j;\r\n    for(i=1;i<=n;++i)\r\n        scanf("%d %d",&que[i].x,&que[i].y);\r\n\r\n    \r\n    s=mp=0,t=2*n+1;\r\n    memset(head,-1,sizeof(head));\r\n    for(i=1;i<=n;++i)\r\n    {\r\n        add_e(i,i+n,1);\r\n        if(que[i].y<=MAXVISION)   add_e(s,i,INF);\r\n        for(j=i+1;j<=n;++j)\r\n        {\r\n            if(check(que[i].x,que[i].y,que[j].x,que[j].y))\r\n            {\r\n               add_e(i+n,j,INF);\r\n               add_e(j+n,i,INF);\r\n            }\r\n        }\r\n        if(w-que[i].y<=MAXVISION) add_e(n+i,t,INF);\r\n    }\r\n    printf("%d\\n",isap(t+1,s,t));\r\n}\r\n\r\nint main()\r\n{\r\n    //freopen("all.in","r",stdin);\r\n    //freopen("all.out","w",stdout);\r\n    while(scanf("%d %d %d",&l,&w,&n)!=EOF)\r\n       solve();\r\n    return 0;\r\n}', '', 46, 3481600, 1, 2, '2010-10-23 17:45:25', '0001-01-01 00:00:00');
INSERT INTO `tbl_submitions` (`id`, `user_id`, `problem_id`, `exercise_id`, `source`, `result`, `used_time`, `used_memory`, `status`, `compiler_id`, `created`, `modified`) VALUES
(680, 33, 365, 0, 'var e:array[1..502,1..502]of word;\r\n    level:array[1..502]of word;\r\n    mark:array[0..502]of word;\r\n    n,i,j,v,t,s,k:word;\r\n    x,y:array[1..250]of word;\r\n    reach:boolean;\r\nprocedure main(v:word);\r\nvar i,t,h:word;\r\nbegin\r\n    h:=n-1;t:=s;\r\n    if v=n-1 then\r\n    begin\r\n        reach:=true;\r\n        inc(k,s);\r\n        exit;\r\n    end;\r\n    for i:=1 to n do\r\n    if e[v,i]>0 then\r\n    begin\r\n        if level[i]+1=level[v] then\r\n        begin\r\n            if e[v,i]<s then s:=e[v,i];\r\n            main(i);\r\n            if level[n]>=n then exit;\r\n            if reach=true then break;\r\n            s:=t;\r\n        end;\r\n        if level[i]<h then h:=level[i];\r\n    end;\r\n    if reach=false then\r\n    begin\r\n        dec(mark[level[v]]);\r\n        if mark[level[v]]=0 then level[n]:=n;\r\n        level[v]:=h+1;\r\n        inc(mark[level[v]]);\r\n    end\r\n    else\r\n    begin\r\n        dec(e[v,i],s);\r\n        inc(e[i,v],s);\r\n    end;\r\nend;\r\nbegin\r\n    readln(v,t,n);\r\n    for i:=1 to n do readln(x[i],y[i]);\r\n    for i:=1 to n do\r\n        for j:=1 to n do\r\n        if(i<>j)and(sqr(x[i]-x[j])+sqr(y[i]-y[j])<=40000)then\r\n        begin\r\n            e[i+n,j]:=maxint;e[j,j+n]:=1;\r\n            e[j+n,i]:=maxint;e[i,i+n]:=1;\r\n        end;\r\n    for i:=1 to n do\r\n    begin\r\n        if y[i]+100>=t then e[i+n,n*2+1]:=1;\r\n        if y[i]<=100 then e[n*2+2,i]:=1;\r\n    end;\r\n    n:=n*2+2;\r\n    mark[0]:=n;\r\n    while level[n]<n do\r\n    begin\r\n        s:=maxint;\r\n        reach:=false;\r\n        main(n);\r\n    end;\r\n    writeln(k);\r\nend.', '', 0, 1306624, 4, 3, '2010-10-23 17:46:51', '0001-01-01 00:00:00'),
(681, 33, 365, 0, '#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\n#define MAXN 250\r\n#define MAXV (MAXN * 2 + 3)\r\n#define MAXVISION 100\r\n#define INFINITY 1000000\r\n#define UNDEFINED -1\r\n\r\n    typedef struct flow_network {\r\n        int n, source, sink;\r\n        int cap[MAXV][MAXV];\r\n    } flow_network;\r\n\r\nvoid form_flow_network(flow_network *g, int n, int w, int *x, int *y);\r\nvoid find_max_flow(flow_network *g, int f[MAXV][MAXV]);\r\n\r\nint main(void)\r\n{\r\n    int l, w, n, i;\r\n    int x[MAXN], y[MAXN];\r\n    flow_network g;\r\n    int flow[MAXV][MAXV], flow_value;\r\n\r\n\r\n    scanf("%d%d%d", &l, &w, &n);    \r\n    for (i = 0; i < n; i++)\r\n        scanf("%d%d", &x[i], &y[i]);\r\n    \r\n    form_flow_network(&g, n, w, x, y);\r\n    find_max_flow(&g, flow);\r\n    \r\n    flow_value = 0;\r\n    for (i = 0; i < g.n; i++)\r\n        flow_value += flow[g.source][i];\r\n\r\n    printf("%d\\n", flow_value);\r\n    \r\n    return 0;\r\n}\r\n\r\nint are_close_enough(int x1, int y1, int x2, int y2)\r\n{\r\n    if ((abs(x1 - x2) > 2 * MAXVISION) || (abs(y1 - y2) > 2 * MAXVISION))\r\n        return 0;\r\n    return ((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) <= 4 * MAXVISION * MAXVISION);\r\n}\r\n\r\nvoid form_flow_network(flow_network *g, int n, int w, int *x, int *y)\r\n{\r\n    int i, j;\r\n    int s, t;\r\n\r\n    g->n = 2 * n + 2;\r\n    g->source = s = 2 * n;\r\n    g->sink = t = 2 * n + 1;\r\n\r\n    // default capacities\r\n    for (i = 0; i < n; i++)\r\n        for (j = 0; j < n; j++)\r\n            g->cap[i][j] = 0;\r\n\r\n    for (i = 0; i < n; i++) {\r\n        g->cap[i][n + i] = 1;                   // i-in to i-out\r\n        if (w - y[i] <= MAXVISION)\r\n            g->cap[n + i][t] = INFINITY;        // i-out to sink\r\n        if (y[i] - 0 <= MAXVISION)\r\n            g->cap[s][i] = INFINITY;            // source to i-in\r\n        for (j = i + 1; j < n; j++)\r\n            if (are_close_enough(x[i], y[i], x[j], y[j])) {\r\n                g->cap[n + i][j] = INFINITY;    // i-out to j-in\r\n                g->cap[n + j][i] = INFINITY;    // j-out to i-in\r\n            }\r\n    }\r\n}\r\n\r\nvoid bfs(flow_network *g, int *parent)\r\n{\r\n    int queue[MAXV], b, e;\r\n    int visited[MAXV];\r\n    int v, u;\r\n\r\n    for (v = 0; v < g->n; v++) {\r\n        visited[v] = 0;\r\n        parent[v]  = UNDEFINED;\r\n    }\r\n    \r\n    b = e = 0;\r\n    queue[e++] = g->source;\r\n    visited[g->source] = 1;\r\n\r\n    while (b < e) {\r\n        v = queue[b++];\r\n        for (u = 0; u < g->n; u++)\r\n            if (g->cap[v][u] > 0 && !visited[u]) {\r\n                visited[u] = 1;\r\n                parent[u]  = v;\r\n                queue[e++] = u;\r\n            }\r\n    }\r\n}\r\n\r\nvoid augment_flow_along_path(flow_network *g, int f[MAXV][MAXV], int *parent)\r\n{\r\n    int u, v;\r\n\r\n    for (v = g->sink, u = parent[v]; u != UNDEFINED; v = u, u = parent[u]) {\r\n        f[u][v]++;\r\n        f[v][u]--;\r\n        g->cap[u][v]--;\r\n        g->cap[v][u]++;\r\n        // the flow and capacities are increased/decreased by one, which would\r\n        // be innefficient in general case, but in this task every path augments\r\n        // flow by one.\r\n    }\r\n}\r\n\r\nvoid find_max_flow(flow_network *g, int f[MAXV][MAXV])\r\n{\r\n    int parent[MAXV], i, j;\r\n\r\n    for (i = 0; i < g->n; i++)\r\n        for (j = 0; j < g->n; j++)\r\n            f[i][j] = 0;\r\n\r\n    // Ford-Fulkerson method: find an augmenting path and augment flow along that path.\r\n    // (the flow is maximum if and only if no augmenting path exists.)    \r\n    bfs(g, parent);\r\n    while (parent[g->sink] != UNDEFINED) {  // augmenting path found\r\n        augment_flow_along_path(g, f, parent);\r\n        bfs(g, parent);\r\n    }\r\n}\r\n', '', 0, 2252800, 4, 2, '2010-10-23 17:49:20', '0001-01-01 00:00:00'),
(682, 33, 365, 0, '/* Solution for task "Escape"\r\n * Linas Petrauskas\r\n */\r\n\r\n#include <stdio.h>\r\n#include <string.h>\r\n#include <stdlib.h>\r\n\r\n#define MAXN 250\r\n#define MAXV (MAXN * 2 + 3)\r\n#define MAXVISION 100\r\n#define INFINITY 1000000\r\n#define UNDEFINED -1\r\n\r\ntypedef struct flow_network \r\n{\r\n        int n, source, sink;\r\n        int cap[MAXV][MAXV];\r\n} flow_network;\r\n\r\nvoid form_flow_network(flow_network *g, int n, int w, int *x, int *y);\r\nvoid find_max_flow(flow_network *g, int f[MAXV][MAXV]);\r\n\r\nint main(void)\r\n{\r\n    //freopen("all.in", "r", stdin);\r\n    //freopen("all.out", "w", stdout);\r\n    int l, w, n, i;\r\n    int x[MAXN], y[MAXN];\r\n    flow_network g;\r\n    int flow[MAXV][MAXV], flow_value;\r\n\r\n\r\n\r\n    while(scanf("%d%d%d", &l, &w, &n)!=EOF)\r\n    {    \r\n       for (i = 0; i < n; i++)\r\n          scanf("%d%d", &x[i], &y[i]);\r\n       \r\n       memset(flow,0,sizeof(flow));\r\n       form_flow_network(&g, n, w, x, y);\r\n       find_max_flow(&g, flow);\r\n       \r\n       flow_value = 0;\r\n       for (i = 0; i < g.n; i++)\r\n           flow_value += flow[g.source][i];\r\n       printf("%d\\n", flow_value);\r\n    }\r\n    return 0;\r\n}\r\n\r\nint are_close_enough(int x1, int y1, int x2, int y2)\r\n{\r\n    if ((abs(x1 - x2) > 2 * MAXVISION) || (abs(y1 - y2) > 2 * MAXVISION))\r\n        return 0;\r\n    return ((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) <= 4 * MAXVISION * MAXVISION);\r\n}\r\n\r\nvoid form_flow_network(flow_network *g, int n, int w, int *x, int *y)\r\n{\r\n    int i, j;\r\n    int s, t;\r\n\r\n    g->n = 2 * n + 2;\r\n    g->source = s = 2 * n;\r\n    g->sink = t = 2 * n + 1;\r\n\r\n    // default capacities\r\n    for (i = 0; i < n; i++)\r\n        for (j = 0; j < n; j++)\r\n            g->cap[i][j] = 0;\r\n\r\n    for (i = 0; i < n; i++) \r\n    {\r\n        g->cap[i][n + i] = 1;                   // i-in to i-out\r\n        if (w - y[i] <= MAXVISION)\r\n            g->cap[n + i][t] = INFINITY;        // i-out to sink\r\n        if (y[i] - 0 <= MAXVISION)\r\n            g->cap[s][i] = INFINITY;            // source to i-in\r\n        for (j = i + 1; j < n; j++)\r\n            if (are_close_enough(x[i], y[i], x[j], y[j])) \r\n            {\r\n                g->cap[n + i][j] = INFINITY;    // i-out to j-in\r\n                g->cap[n + j][i] = INFINITY;    // j-out to i-in\r\n            }\r\n    }\r\n}\r\n\r\nvoid bfs(flow_network *g, int *parent)\r\n{\r\n    int queue[MAXV], b, e;\r\n    int visited[MAXV];\r\n    int v, u;\r\n\r\n    for (v = 0; v < g->n; v++) {\r\n        visited[v] = 0;\r\n        parent[v]  = UNDEFINED;\r\n    }\r\n    \r\n    b = e = 0;\r\n    queue[e++] = g->source;\r\n    visited[g->source] = 1;\r\n\r\n    while (b < e) {\r\n        v = queue[b++];\r\n        for (u = 0; u < g->n; u++)\r\n            if (g->cap[v][u] > 0 && !visited[u]) {\r\n                visited[u] = 1;\r\n                parent[u]  = v;\r\n                queue[e++] = u;\r\n            }\r\n    }\r\n}\r\n\r\nvoid augment_flow_along_path(flow_network *g, int f[MAXV][MAXV], int *parent)\r\n{\r\n    int u, v;\r\n\r\n    for (v = g->sink, u = parent[v]; u != UNDEFINED; v = u, u = parent[u]) {\r\n        f[u][v]++;\r\n        f[v][u]--;\r\n        g->cap[u][v]--;\r\n        g->cap[v][u]++;\r\n        // the flow and capacities are increased/decreased by one, which would\r\n        // be innefficient in general case, but in this task every path augments\r\n        // flow by one.\r\n    }\r\n}\r\n\r\nvoid find_max_flow(flow_network *g, int f[MAXV][MAXV])\r\n{\r\n    int parent[MAXV], i, j;\r\n\r\n    for (i = 0; i < g->n; i++)\r\n        for (j = 0; j < g->n; j++)\r\n            f[i][j] = 0;\r\n\r\n    // Ford-Fulkerson method: find an augmenting path and augment flow along that path.\r\n    // (the flow is maximum if and only if no augmenting path exists.)    \r\n    bfs(g, parent);\r\n    while (parent[g->sink] != UNDEFINED) {  // augmenting path found\r\n        augment_flow_along_path(g, f, parent);\r\n        bfs(g, parent);\r\n    }\r\n}\r\n', '', 2000, 2256896, 5, 2, '2010-10-23 17:53:41', '0001-01-01 00:00:00'),
(683, 33, 365, 0, '// thomas fersch\r\n#include <fstream>\r\n#include <stdio.h>\r\n#include <list>\r\nusing namespace std;\r\n\r\nconst int INF = 1000000;\r\nconst int MAX_N = 1000;\r\n\r\n\r\n\r\nstruct Edge {\r\n	int from, to, capacity, flow;\r\n	Edge(int f, int t, int c) {from = f; to = t; capacity = c; flow = 0; }\r\n};\r\n\r\ntypedef list<Edge>::iterator EI;\r\n\r\nstruct Node {\r\n	list<EI> edges;\r\n	EI lastEdge;\r\n};\r\n\r\nint L, W, N;\r\n\r\nNode nodes[2 * MAX_N + 2];\r\nlist<Edge> edges;\r\n\r\nint xsoldier[MAX_N + 1];\r\nint ysoldier[MAX_N + 1];\r\n\r\nvoid add_edge(int from, int to, int capacity) {\r\n	edges.push_front(Edge(from, to, capacity));\r\n	nodes[from].edges.push_back(edges.begin());\r\n	nodes[to].edges.push_back(edges.begin());\r\n}\r\n\r\nvoid input() {\r\n	\r\n	for (int i = 1; i <= N; i++) scanf("%d %d" ,&xsoldier[i] , &ysoldier[i]);\r\n	//in.close();\r\n}\r\n\r\nvoid init_graph() {\r\n	for (int i = 1; i <= N; i++) {\r\n		add_edge(i, i + N, 1);\r\n		if (W - ysoldier[i] <= 100) add_edge(0, i, INF);\r\n		if (ysoldier[i] <= 100) add_edge(i + N, 2 * N + 1, INF);\r\n		for (int j = i + 1; j <= N; j++) {\r\n			long long dx = xsoldier[i] - xsoldier[j];\r\n			long long dy = ysoldier[i] - ysoldier[j];\r\n			if (dx * dx + dy * dy <= 40000) {\r\n				add_edge(i + N, j, INF);\r\n				add_edge(j + N, i, INF);\r\n			}\r\n		}\r\n	}\r\n}\r\n\r\nbool bfs() {\r\n	for (int i = 0; i <= 2 * N + 1; i++) nodes[i].lastEdge = edges.end();\r\n	list<int> queue;\r\n	queue.push_back(0);\r\n	while (!queue.empty()) {\r\n		int akt = queue.front();\r\n		queue.pop_front();\r\n		if (akt == 2 * N + 1) return true;\r\n		for (list<EI>::iterator i = nodes[akt].edges.begin(); i != nodes[akt].edges.end(); i++) {\r\n			int to = (*i)->to;\r\n			if (to == akt) to = (*i)->from;\r\n			if (nodes[to].lastEdge != edges.end() || to == 0) continue;\r\n			if ((to == (*i)->to && (*i)->flow < (*i)->capacity) || (to == (*i)->from && (*i)->flow > 0)) {\r\n				nodes[to].lastEdge = *i;\r\n				queue.push_back(to);\r\n			}\r\n		}\r\n	}\r\n	return false;\r\n}\r\n\r\nvoid adjust_flows() {\r\n	int akt = 2 * N + 1;\r\n	while (nodes[akt].lastEdge != edges.end()) {\r\n		EI e = nodes[akt].lastEdge;\r\n		if (akt == e->to) {\r\n			e->flow++;\r\n			akt = e->from;\r\n		} else {\r\n			e->flow--;\r\n			akt = e->to;\r\n		}\r\n	}\r\n}\r\n\r\nvoid output() {\r\n	int nsoldiers = 0;\r\n	for (list<EI>::iterator i = nodes[0].edges.begin(); i != nodes[0].edges.end(); i++) {\r\n		nsoldiers += (*i)->flow;\r\n	}\r\n	printf("%d\\n",nsoldiers);\r\n	//out << nsoldiers << endl;\r\n	//out.close();\r\n}\r\n\r\nint main() \r\n{\r\n    //freopen("all.in","r",stdin);\r\n    //freopen("1.out","w",stdout);\r\n	while(scanf("%d %d %d",&L,&W,&N)!=EOF)\r\n	{\r\n     input();\r\n     init_graph();\r\n	while (bfs()) adjust_flows();\r\n	output();\r\n    }\r\n	return 0;\r\n}', '', 2000, 5701632, 5, 2, '2010-10-23 17:54:57', '0001-01-01 00:00:00'),
(684, 33, 365, 0, '#include <stdio.h>\r\n#include <string.h>\r\n#include <stdlib.h>\r\n\r\n#define MAXN 250\r\n#define MAXV (MAXN * 2 + 3)\r\n#define MAXVISION 100\r\n#define INFINITY 1000000\r\n#define UNDEFINED -1\r\n\r\ntypedef struct flow_network \r\n{\r\n        int n, source, sink;\r\n        int cap[MAXV][MAXV];\r\n} flow_network;\r\n\r\nvoid form_flow_network(flow_network *g, int n, int w, int *x, int *y);\r\nvoid find_max_flow(flow_network *g, int f[MAXV][MAXV]);\r\n\r\nint main(void)\r\n{\r\n    //freopen("escape.in", "r", stdin);\r\n    //freopen("11.out", "w", stdout);\r\n    int l, w, n, i;\r\n    int x[MAXN], y[MAXN];\r\n    flow_network g;\r\n    int flow[MAXV][MAXV], flow_value;\r\n\r\n\r\n\r\n    while(scanf("%d%d%d", &l, &w, &n)!=EOF)\r\n    {    \r\n       for (i = 0; i < n; i++)\r\n          scanf("%d%d", &x[i], &y[i]);\r\n       \r\n       memset(flow,0,sizeof(flow));\r\n       form_flow_network(&g, n, w, x, y);\r\n       find_max_flow(&g, flow);\r\n       \r\n       flow_value = 0;\r\n       for (i = 0; i < g.n; i++)\r\n           flow_value += flow[g.source][i];\r\n       printf("%d\\n", flow_value);\r\n    }\r\n    return 0;\r\n}\r\n\r\nint are_close_enough(int x1, int y1, int x2, int y2)\r\n{\r\n    if ((abs(x1 - x2) > 2 * MAXVISION) || (abs(y1 - y2) > 2 * MAXVISION))\r\n        return 0;\r\n    return ((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) <= 4 * MAXVISION * MAXVISION);\r\n}\r\n\r\nvoid form_flow_network(flow_network *g, int n, int w, int *x, int *y)\r\n{\r\n    int i, j;\r\n    int s, t;\r\n\r\n    g->n = 2 * n + 2;\r\n    g->source = s = 2 * n;\r\n    g->sink = t = 2 * n + 1;\r\n\r\n    // default capacities\r\n    for (i = 0; i < 2*n+4; i++)\r\n        for (j = 0; j < 2*n+4; j++)\r\n            g->cap[i][j] = 0;\r\n\r\n    for (i = 0; i < n; i++) \r\n    {\r\n        g->cap[i][n + i] = 1;                   // i-in to i-out\r\n        if (w - y[i] <= MAXVISION)\r\n            g->cap[n + i][t] = INFINITY;        // i-out to sink\r\n        if (y[i] - 0 <= MAXVISION)\r\n            g->cap[s][i] = INFINITY;            // source to i-in\r\n        for (j = i + 1; j < n; j++)\r\n            if (are_close_enough(x[i], y[i], x[j], y[j])) \r\n            {\r\n                g->cap[n + i][j] = INFINITY;    // i-out to j-in\r\n                g->cap[n + j][i] = INFINITY;    // j-out to i-in\r\n            }\r\n    }\r\n}\r\n\r\nvoid bfs(flow_network *g, int *parent)\r\n{\r\n    int queue[MAXV], b, e;\r\n    int visited[MAXV];\r\n    int v, u;\r\n\r\n    for (v = 0; v < g->n; v++) {\r\n        visited[v] = 0;\r\n        parent[v]  = UNDEFINED;\r\n    }\r\n    \r\n    b = e = 0;\r\n    queue[e++] = g->source;\r\n    visited[g->source] = 1;\r\n\r\n    while (b < e) {\r\n        v = queue[b++];\r\n        for (u = 0; u < g->n; u++)\r\n            if (g->cap[v][u] > 0 && !visited[u]) {\r\n                visited[u] = 1;\r\n                parent[u]  = v;\r\n                queue[e++] = u;\r\n            }\r\n    }\r\n}\r\n\r\nvoid augment_flow_along_path(flow_network *g, int f[MAXV][MAXV], int *parent)\r\n{\r\n    int u, v;\r\n\r\n    for (v = g->sink, u = parent[v]; u != UNDEFINED; v = u, u = parent[u]) {\r\n        f[u][v]++;\r\n        f[v][u]--;\r\n        g->cap[u][v]--;\r\n        g->cap[v][u]++;\r\n        // the flow and capacities are increased/decreased by one, which would\r\n        // be innefficient in general case, but in this task every path augments\r\n        // flow by one.\r\n    }\r\n}\r\n\r\nvoid find_max_flow(flow_network *g, int f[MAXV][MAXV])\r\n{\r\n    int parent[MAXV], i, j;\r\n\r\n    for (i = 0; i < g->n; i++)\r\n        for (j = 0; j < g->n; j++)\r\n            f[i][j] = 0;\r\n\r\n    // Ford-Fulkerson method: find an augmenting path and augment flow along that path.\r\n    // (the flow is maximum if and only if no augmenting path exists.)    \r\n    bfs(g, parent);\r\n    while (parent[g->sink] != UNDEFINED) {  // augmenting path found\r\n        augment_flow_along_path(g, f, parent);\r\n        bfs(g, parent);\r\n    }\r\n}\r\n', '', 405, 2256896, 1, 2, '2010-10-23 18:38:45', '0001-01-01 00:00:00'),
(685, 6, 367, 0, '#include <stdio.h>\r\n#define N 1000010\r\nint a[N],qs[N],qb[N];\r\nint n,m,c;\r\n\r\nvoid solve()\r\n{\r\n    int i,hs,rs,hb,rb;\r\n    for(i=1;i<=n;++i) \r\n        scanf("%d",a+i); \r\n    \r\n    bool ok;\r\n    hs=1,rs=1,qs[rs]=1;\r\n    hb=1,rb=1,qb[rb]=1;\r\n    \r\n    for(i=2;i<m;++i)\r\n    {\r\n        qs[++rs]=i;\r\n        while(rs>hs)\r\n        {\r\n           if(a[qs[rs]]<=a[qs[rs-1]])\r\n           {\r\n              qs[rs-1]=qs[rs];\r\n              rs--;\r\n           }\r\n           else break;\r\n        }\r\n        \r\n        qb[++rb]=i;\r\n        while(rb>hb)\r\n        {\r\n           if(a[qb[rb]]>=a[qb[rb-1]])\r\n           {\r\n              qb[rb-1]=qb[rb];\r\n              rb--;\r\n           }\r\n           else break;\r\n        }\r\n    }\r\n    \r\n    for(i=m;i<=n;++i)\r\n    {\r\n        qs[++rs]=i;\r\n        while(rs>hs)\r\n        {\r\n           if(a[qs[rs]]<=a[qs[rs-1]])\r\n           {\r\n              qs[rs-1]=qs[rs];\r\n              rs--;\r\n           }\r\n           else break;\r\n        }\r\n        \r\n        qb[++rb]=i;\r\n        while(rb>hb)\r\n        {\r\n           if(a[qb[rb]]>=a[qb[rb-1]])\r\n           {\r\n              qb[rb-1]=qb[rb];\r\n              rb--;\r\n           }\r\n           else break;\r\n        }\r\n        \r\n        if(i-qs[hs]+1>m) hs++;\r\n        if(i-qb[hb]+1>m) hb++;\r\n        if(a[qb[hb]]-a[qs[hs]]<=c) \r\n        {\r\n           printf("%d\\n",i-m+1);\r\n           ok=true;\r\n        }\r\n    }\r\n    if(!ok) printf("NONE\\n");      \r\n}\r\n\r\nint main()\r\n{\r\n    while(scanf("%d %d %d",&n,&m,&c)!=EOF)\r\n       solve();\r\n    return 0;\r\n}', '', 1325, 12283904, 5, 2, '2010-10-24 00:13:20', '0001-01-01 00:00:00'),
(686, 6, 367, 0, '// Felix Arends\r\n#define _CRT_SECURE_NO_DEPRECATE\r\n\r\n#include <cstdio>\r\n#include <list>\r\n#include <cassert>\r\n#include <ctime>\r\n\r\nusing namespace std;\r\n\r\ntypedef list<int> LI;\r\n\r\nstruct MinMaxQueue \r\n{\r\n    LI   q, qmax, qmin;\r\n\r\n    void push(int v) \r\n    {\r\n        q.push_back(v);\r\n        \r\n        // every v gets added to or removed from the qmin and qmax lists\r\n        // at most once, hence get amortised O(1) runtime.\r\n        while(!qmax.empty() && qmax.back() < v) qmax.pop_back();\r\n        qmax.push_back(v);\r\n        while(!qmin.empty() && qmin.back() > v) qmin.pop_back();\r\n        qmin.push_back(v);\r\n    }\r\n\r\n    int peek() { return q.front(); }\r\n\r\n    int pop() \r\n    {\r\n        int v = q.front();\r\n        q.pop_front();\r\n        if (v == qmax.front()) qmax.pop_front();\r\n        if (v == qmin.front()) qmin.pop_front();\r\n        return v;\r\n    }\r\n\r\n    int getMax() { return qmax.front(); }\r\n    int getMin() { return qmin.front(); }\r\n    size_t size() { return q.size(); }\r\n    \r\n    void clear()\r\n    {\r\n        q.clear();\r\n        qmax.clear();\r\n        qmin.clear();\r\n    }\r\n};\r\nMinMaxQueue q;\r\n\r\n\r\nint main() \r\n{\r\n    int N, M, C;\r\n    while(scanf("%d %d %d", &N, &M, &C)!=EOF)\r\n    {\r\n        int v;\r\n        bool  found = false;\r\n        q.clear();\r\n        for(int n = 0; n < N; n++)\r\n        {\r\n            scanf("%d", &v);\r\n            q.push(v);\r\n            if(n >= M) q.pop();\r\n            if(n >= M-1 && q.getMax() - q.getMin() <= C) \r\n            {\r\n               found = true;\r\n               printf("%d\\n", n - M + 2);\r\n            }\r\n        }\r\n        if (!found) printf("NONE\\n");\r\n    }\r\n    return 0;\r\n}\r\n', '', 1000, 1028096, 5, 2, '2010-10-24 00:14:47', '0001-01-01 00:00:00'),
(687, 6, 367, 0, '#include <stdio.h>\r\n#define N 1000010\r\nint a[N],qs[N],qb[N];\r\nint n,m,c;\r\n\r\nvoid solve()\r\n{\r\n    int i,hs,rs,hb,rb;\r\n    for(i=1;i<=n;++i) \r\n        scanf("%d",a+i); \r\n    \r\n    bool ok;\r\n    hs=1,rs=1,qs[rs]=1;\r\n    hb=1,rb=1,qb[rb]=1;\r\n    \r\n    for(i=2;i<m;++i)\r\n    {\r\n        qs[++rs]=i;\r\n        while(rs>hs)\r\n        {\r\n           if(a[qs[rs]]<=a[qs[rs-1]])\r\n           {\r\n              qs[rs-1]=qs[rs];\r\n              rs--;\r\n           }\r\n           else break;\r\n        }\r\n        \r\n        qb[++rb]=i;\r\n        while(rb>hb)\r\n        {\r\n           if(a[qb[rb]]>=a[qb[rb-1]])\r\n           {\r\n              qb[rb-1]=qb[rb];\r\n              rb--;\r\n           }\r\n           else break;\r\n        }\r\n    }\r\n    \r\n    for(i=m;i<=n;++i)\r\n    {\r\n        qs[++rs]=i;\r\n        while(rs>hs)\r\n        {\r\n           if(a[qs[rs]]<=a[qs[rs-1]])\r\n           {\r\n              qs[rs-1]=qs[rs];\r\n              rs--;\r\n           }\r\n           else break;\r\n        }\r\n        \r\n        qb[++rb]=i;\r\n        while(rb>hb)\r\n        {\r\n           if(a[qb[rb]]>=a[qb[rb-1]])\r\n           {\r\n              qb[rb-1]=qb[rb];\r\n              rb--;\r\n           }\r\n           else break;\r\n        }\r\n        \r\n        if(i-qs[hs]+1>m) hs++;\r\n        if(i-qb[hb]+1>m) hb++;\r\n        if(a[qb[hb]]-a[qs[hs]]<=c) \r\n        {\r\n           printf("%d\\n",i-m+1);\r\n           ok=true;\r\n        }\r\n    }\r\n    if(!ok) printf("NONE\\n");      \r\n}\r\n\r\nint main()\r\n{\r\n    while(scanf("%d %d %d",&n,&m,&c)!=EOF)\r\n       solve();\r\n    return 0;\r\n}', '', 1980, 12283904, 1, 2, '2010-10-24 00:16:33', '0001-01-01 00:00:00'),
(688, 6, 367, 0, '// Felix Arends\r\n#define _CRT_SECURE_NO_DEPRECATE\r\n\r\n#include <cstdio>\r\n#include <list>\r\n#include <cassert>\r\n#include <ctime>\r\n\r\nusing namespace std;\r\n\r\ntypedef list<int> LI;\r\n\r\nstruct MinMaxQueue \r\n{\r\n    LI   q, qmax, qmin;\r\n\r\n    void push(int v) \r\n    {\r\n        q.push_back(v);\r\n        \r\n        // every v gets added to or removed from the qmin and qmax lists\r\n        // at most once, hence get amortised O(1) runtime.\r\n        while(!qmax.empty() && qmax.back() < v) qmax.pop_back();\r\n        qmax.push_back(v);\r\n        while(!qmin.empty() && qmin.back() > v) qmin.pop_back();\r\n        qmin.push_back(v);\r\n    }\r\n\r\n    int peek() { return q.front(); }\r\n\r\n    int pop() \r\n    {\r\n        int v = q.front();\r\n        q.pop_front();\r\n        if (v == qmax.front()) qmax.pop_front();\r\n        if (v == qmin.front()) qmin.pop_front();\r\n        return v;\r\n    }\r\n\r\n    int getMax() { return qmax.front(); }\r\n    int getMin() { return qmin.front(); }\r\n    size_t size() { return q.size(); }\r\n    \r\n    void clear()\r\n    {\r\n        q.clear();\r\n        qmax.clear();\r\n        qmin.clear();\r\n    }\r\n};\r\nMinMaxQueue q;\r\n\r\n\r\nint main() \r\n{\r\n    int N, M, C;\r\n    while(scanf("%d %d %d", &N, &M, &C)!=EOF)\r\n    {\r\n        int v;\r\n        bool  found = false;\r\n        q.clear();\r\n        for(int n = 0; n < N; n++)\r\n        {\r\n            scanf("%d", &v);\r\n            q.push(v);\r\n            if(n >= M) q.pop();\r\n            if(n >= M-1 && q.getMax() - q.getMin() <= C) \r\n            {\r\n               found = true;\r\n               printf("%d\\n", n - M + 2);\r\n            }\r\n        }\r\n        if (!found) printf("NONE\\n");\r\n    }\r\n    return 0;\r\n}\r\n', '', 2000, 1028096, 5, 2, '2010-10-24 00:19:32', '0001-01-01 00:00:00'),
(689, 6, 367, 0, '// Felix Arends\r\n#define _CRT_SECURE_NO_DEPRECATE\r\n\r\n#include <cstdio>\r\n#include <list>\r\n#include <cassert>\r\n#include <ctime>\r\n\r\nusing namespace std;\r\n\r\ntypedef list<int> LI;\r\n\r\nstruct MinMaxQueue \r\n{\r\n    LI   q, qmax, qmin;\r\n\r\n    void push(int v) \r\n    {\r\n        q.push_back(v);\r\n        \r\n        // every v gets added to or removed from the qmin and qmax lists\r\n        // at most once, hence get amortised O(1) runtime.\r\n        while(!qmax.empty() && qmax.back() < v) qmax.pop_back();\r\n        qmax.push_back(v);\r\n        while(!qmin.empty() && qmin.back() > v) qmin.pop_back();\r\n        qmin.push_back(v);\r\n    }\r\n\r\n    int peek() { return q.front(); }\r\n\r\n    int pop() \r\n    {\r\n        int v = q.front();\r\n        q.pop_front();\r\n        if (v == qmax.front()) qmax.pop_front();\r\n        if (v == qmin.front()) qmin.pop_front();\r\n        return v;\r\n    }\r\n\r\n    int getMax() { return qmax.front(); }\r\n    int getMin() { return qmin.front(); }\r\n    size_t size() { return q.size(); }\r\n    \r\n    void clear()\r\n    {\r\n        q.clear();\r\n        qmax.clear();\r\n        qmin.clear();\r\n    }\r\n};\r\nMinMaxQueue q;\r\n\r\n\r\nint main() \r\n{\r\n    int N, M, C;\r\n    while(scanf("%d %d %d", &N, &M, &C)!=EOF)\r\n    {\r\n        int v;\r\n        bool  found = false;\r\n        q.clear();\r\n        for(int n = 0; n < N; n++)\r\n        {\r\n            scanf("%d", &v);\r\n            q.push(v);\r\n            if(n >= M) q.pop();\r\n            if(n >= M-1 && q.getMax() - q.getMin() <= C) \r\n            {\r\n               found = true;\r\n               printf("%d\\n", n - M + 2);\r\n            }\r\n        }\r\n        if (!found) printf("NONE\\n");\r\n    }\r\n    return 0;\r\n}\r\n', '', 5037, 1032192, 5, 2, '2010-10-24 00:20:24', '0001-01-01 00:00:00'),
(690, 6, 367, 0, '#include <stdio.h>\r\n#include <algorithm>\r\nusing namespace std;\r\n#define N 1000010\r\nint a[N];\r\nint np[N],ns[N];\r\nint xp[N],xs[N];\r\n\r\nint main()\r\n{\r\n    int i,j,k,n,m,c;\r\n    while(scanf("%d %d %d",&n,&m,&c)!=EOF)\r\n    {\r\n       for(i=1;i<=n;++i)\r\n       {\r\n           scanf("%d",a+i);\r\n           if(i%m==1) np[i]=xp[i]=a[i];\r\n           else\r\n           {\r\n              np[i]=min(np[i-1],a[i]);\r\n              xp[i]=max(xp[i-1],a[i]);\r\n           }\r\n       }\r\n       \r\n       for(i=n-(n%m);i>=1;--i)\r\n       {\r\n           if(i%m==0)\r\n           {\r\n              ns[i]=a[i];\r\n              xs[i]=a[i];\r\n           }\r\n           else\r\n           {\r\n              ns[i]=min(ns[i+1],a[i]);\r\n              xs[i]=max(xs[i+1],a[i]);\r\n           }\r\n       }\r\n       \r\n       k=0;\r\n       for(i=m;i<=n;++i)\r\n       {\r\n           j=i-m+1;\r\n           if(max(xp[i],xs[j])-min(np[i],ns[j])<=c)\r\n           {\r\n              printf("%d\\n",j);\r\n              k++;\r\n           }\r\n       }\r\n       if(k==0) printf("NONE\\n");\r\n    }\r\n    return 0;\r\n}', '', 2041, 20295680, 1, 2, '2010-10-24 10:41:58', '0001-01-01 00:00:00'),
(691, 6, 367, 0, '#include <cstdio>\r\n#include <list>\r\n#include <cassert>\r\n#include <ctime>\r\n\r\nusing namespace std;\r\n\r\ntypedef list<int> LI;\r\n\r\nstruct MinMaxQueue \r\n{\r\n    LI   q, qmax, qmin;\r\n\r\n    void push(int v) \r\n    {\r\n        q.push_back(v);\r\n        \r\n        // every v gets added to or removed from the qmin and qmax lists\r\n        // at most once, hence get amortised O(1) runtime.\r\n        while(!qmax.empty() && qmax.back() < v) qmax.pop_back();\r\n        qmax.push_back(v);\r\n        while(!qmin.empty() && qmin.back() > v) qmin.pop_back();\r\n        qmin.push_back(v);\r\n    }\r\n\r\n    int peek() { return q.front(); }\r\n\r\n    int pop() \r\n    {\r\n        int v = q.front();\r\n        q.pop_front();\r\n        if (v == qmax.front()) qmax.pop_front();\r\n        if (v == qmin.front()) qmin.pop_front();\r\n        return v;\r\n    }\r\n\r\n    int getMax() { return qmax.front(); }\r\n    int getMin() { return qmin.front(); }\r\n    size_t size() { return q.size(); }\r\n    \r\n    void clear()\r\n    {\r\n        q.clear();\r\n        qmax.clear();\r\n        qmin.clear();\r\n    }\r\n};\r\nMinMaxQueue q;\r\n\r\n\r\nint main() \r\n{\r\n    int N, M, C;\r\n    while(scanf("%d %d %d", &N, &M, &C)!=EOF)\r\n    {\r\n        int v;\r\n        bool  found = false;\r\n        q.clear();\r\n        for(int n = 0; n < N; n++)\r\n        {\r\n            scanf("%d", &v);\r\n            q.push(v);\r\n            if(n >= M) q.pop();\r\n            if(n >= M-1 && q.getMax() - q.getMin() <= C) \r\n            {\r\n               found = true;\r\n               printf("%d\\n", n - M + 2);\r\n            }\r\n        }\r\n        if (!found) printf("NONE\\n");\r\n    }\r\n    return 0;\r\n}', '', 6348, 1032192, 1, 2, '2010-10-24 10:43:42', '0001-01-01 00:00:00'),
(692, 6, 93, 0, '#include <stdio.h>\r\n#include <algorithm>\r\nusing namespace std;\r\nstruct Node\r\n{\r\n   int a,b;\r\n}que[210];\r\n\r\nbool cmp(const Node& p,const Node& q)\r\n{\r\n   return p.a<q.a;\r\n}\r\n\r\nint main()\r\n{\r\n    int i,n,m;\r\n    while(scanf("%d %d",&n,&m)!=EOF)\r\n    {\r\n       n+=m;\r\n       for(i=0;i<n;++i)\r\n           scanf("%d %d",&que[i].a,&que[i].b);\r\n       sort(que,que+n,cmp);\r\n       for(i=0;i<n;++i)\r\n           printf("%d %d\\n",que[i].a,que[i].b);\r\n    }\r\n    return 0;\r\n}\r\n', '', 0, 262144, 1, 2, '2010-10-24 16:48:21', '0001-01-01 00:00:00'),
(693, 6, 345, 0, '#include <stdio.h>\r\n#include <string.h>\r\n#include <algorithm>\r\nusing namespace std;\r\n#define N 10010\r\nstruct Node\r\n{\r\n   char str[105];\r\n}qa[N],qb[N],ta[N],tb[N];\r\n\r\nbool cmp(const Node& a,const Node& b)\r\n{\r\n    return strcmp(a.str,b.str)<0;\r\n}\r\n\r\nint find(char s[],Node q[],int n)\r\n{\r\n    int mid,low=0,high=n-1,t;\r\n    while(low<=high)\r\n    {\r\n        mid=(low+high)>>1;\r\n        int t=strcmp(q[mid].str,s);\r\n        if(t==0) return mid;\r\n        else if(t<0) low=mid+1;\r\n        else         high=mid-1; \r\n    }\r\n    return -1;\r\n}\r\n\r\nint main()\r\n{\r\n    int i,n,m,t;\r\n    while(scanf("%d",&n)!=EOF)\r\n    {\r\n        for(i=0;i<n;++i)\r\n        {\r\n            scanf("%s",&qa[i].str);\r\n            strcpy(ta[i].str,qa[i].str);\r\n        }\r\n        \r\n        scanf("%d",&m);\r\n        for(i=0;i<m;++i)\r\n        {\r\n            scanf("%s",&qb[i].str);\r\n            strcpy(tb[i].str,qb[i].str);\r\n        }\r\n        \r\n        sort(ta,ta+n,cmp);\r\n        sort(tb,tb+m,cmp);\r\n        \r\n        for(i=0;i<n;++i)\r\n        {\r\n            t=find(qa[i].str,tb,m);\r\n            if(t!=-1) break;\r\n        }\r\n        if(t==-1) printf("none ");\r\n        else      printf("%s ",tb[t].str);\r\n        \r\n        for(i=0;i<m;++i)\r\n        {\r\n            t=find(qb[i].str,ta,n);\r\n            if(t!=-1) break;\r\n        }\r\n        if(t==-1) printf("none\\n");\r\n        else      printf("%s\\n",ta[t].str);\r\n    }\r\n    return 0;\r\n}', '', 0, 2097152, 6, 2, '2010-10-24 20:12:38', '0001-01-01 00:00:00'),
(694, 6, 345, 0, '#include <stdio.h>\r\n#include <string.h>\r\n#include <algorithm>\r\nusing namespace std;\r\n#define N 10010\r\nstruct Node\r\n{\r\n   char str[105];\r\n}qa[N],qb[N],ta[N],tb[N];\r\n\r\nbool cmp(const Node& a,const Node& b)\r\n{\r\n    return strcmp(a.str,b.str)<0;\r\n}\r\n\r\nint find(char s[],Node q[],int n)\r\n{\r\n    int mid,low=0,high=n-1,t;\r\n    while(low<=high)\r\n    {\r\n        mid=(low+high)>>1;\r\n        int t=strcmp(q[mid].str,s);\r\n        if(t==0) return mid;\r\n        else if(t<0) low=mid+1;\r\n        else         high=mid-1; \r\n    }\r\n    return -1;\r\n}\r\n\r\nint main()\r\n{\r\n    int i,n,m,t;\r\n    while(scanf("%d",&n)!=EOF)\r\n    {\r\n        for(i=0;i<n;++i)\r\n        {\r\n            scanf("%s",&qa[i].str);\r\n            strcpy(ta[i].str,qa[i].str);\r\n        }\r\n        \r\n        scanf("%d",&m);\r\n        for(i=0;i<m;++i)\r\n        {\r\n            scanf("%s",&qb[i].str);\r\n            strcpy(tb[i].str,qb[i].str);\r\n        }\r\n        \r\n        sort(ta,ta+n,cmp);\r\n        sort(tb,tb+m,cmp);\r\n        \r\n        for(i=0;i<n;++i)\r\n        {\r\n            t=find(qa[i].str,tb,m);\r\n            if(t!=-1) break;\r\n        }\r\n        if(t==-1) printf("none ");\r\n        else      printf("%s ",tb[t].str);\r\n        \r\n        for(i=0;i<m;++i)\r\n        {\r\n            t=find(qb[i].str,ta,n);\r\n            if(t!=-1) break;\r\n        }\r\n        if(t==-1) printf("none\\n");\r\n        else      printf("%s\\n",ta[t].str);\r\n    }\r\n    return 0;\r\n}', '', 15, 4472832, 1, 2, '2010-10-24 20:15:35', '0001-01-01 00:00:00'),
(695, 6, 336, 2, '#include <stdio.h>\r\n#include <algorithm>\r\nusing namespace std;\r\nconst int N = 50050;\r\nstruct Node\r\n{\r\n    int a,cnt;\r\n}que[N];\r\nint n;\r\n\r\nint get(int x)\r\n{\r\n    int cnt=0;\r\n    while(x)\r\n    {\r\n        x&=(x-1);\r\n        cnt++;\r\n    }\r\n    return cnt;\r\n}\r\n\r\nvoid init()\r\n{\r\n    for(int i=0;i<n;++i)\r\n    {\r\n        scanf("%d",&que[i].a);\r\n        que[i].cnt=get(que[i].a);\r\n    }\r\n}\r\n\r\nbool cmp(const Node& p,const Node& q)\r\n{\r\n    return p.cnt<q.cnt;\r\n}\r\n\r\nvoid solve()\r\n{\r\n    init();\r\n    if(n>0)\r\n    {\r\n       int i;\r\n       sort(que,que+n,cmp);\r\n       for(i=0;i<(n-1);++i)\r\n           printf("%d ",que[i].a);\r\n       printf("%d\\n",que[i].a);\r\n    }\r\n    else printf("\\n");\r\n}\r\n\r\nint main()\r\n{\r\n	while(scanf("%d",&n)!=EOF)\r\n	   solve();\r\n	return 0;\r\n}', '', 15, 659456, 4, 2, '2010-10-25 11:08:39', '0001-01-01 00:00:00'),
(696, 6, 336, 2, '#include <stdio.h>\r\n#include <algorithm>\r\nusing namespace std;\r\nconst int N = 50050;\r\nstruct Node\r\n{\r\n    int a,cnt;\r\n}que[N];\r\nint n;\r\n\r\nint get(int x)\r\n{\r\n    int cnt=0;\r\n    while(x)\r\n    {\r\n        x&=(x-1);\r\n        cnt++;\r\n    }\r\n    return cnt;\r\n}\r\n\r\nvoid init()\r\n{\r\n    for(int i=0;i<n;++i)\r\n    {\r\n        scanf("%d",&que[i].a);\r\n        que[i].cnt=get(que[i].a);\r\n    }\r\n}\r\n\r\nbool cmp(const Node& p,const Node& q)\r\n{\r\n    if(p.cnt!=q.cnt) return p.cnt<q.cnt;\r\n    else             return p.a<q.a;\r\n}\r\n\r\nvoid solve()\r\n{\r\n    if(n>0)\r\n    {\r\n       int i;\r\n       init();\r\n       sort(que,que+n,cmp);\r\n       for(i=0;i<(n-1);++i)\r\n           printf("%d ",que[i].a);\r\n       printf("%d\\n",que[i].a);\r\n    }\r\n    else printf("\\n");\r\n}\r\n\r\nint main()\r\n{\r\n	while(scanf("%d",&n)!=EOF)\r\n	   solve();\r\n	return 0;\r\n}', '', 92, 659456, 1, 2, '2010-10-25 12:24:16', '0001-01-01 00:00:00'),
(697, 6, 338, 3, '#include <stdio.h>\r\n#include <string.h>\r\n#define N 1010\r\nint v[N];\r\n\r\nint main()\r\n{\r\n    int n,k,i,max_v,min_v,cnt,t1,t2;\r\n    while(scanf("%d %d",&n,&k)!=EOF)\r\n    {\r\n       memset(v,0,sizeof(v));\r\n       k++,max_v=-1,min_v=N;\r\n       for(i=0;i<n;++i)\r\n       {\r\n           scanf("%d",&t1);\r\n           v[ t1 ]++;\r\n           if(t1>max_v) max_v=t1;\r\n           if(t1<min_v) min_v=t1;\r\n       }\r\n       \r\n       cnt=0;\r\n       for(i=min_v;i<=max_v;++i)\r\n       {\r\n           cnt+=v[i];\r\n           if(cnt>=k) \r\n           {\r\n              t1=i;\r\n              break;\r\n           }\r\n       }\r\n\r\n       cnt=0;\r\n       for(i=max_v;i>=min_v;--i)\r\n       {\r\n           cnt+=v[i];\r\n           if(cnt>=k) \r\n           {\r\n              t2=i;\r\n              break;\r\n           }\r\n       }\r\n       printf("%d\\n",t2-t1);\r\n    }\r\n    return 0;\r\n}', '', 374, 266240, 1, 2, '2010-10-25 12:53:37', '0001-01-01 00:00:00'),
(698, 6, 339, 3, '#include <stdio.h>\r\n#define N 100010\r\n#define M 1010\r\nint a[N],q[M];\r\n\r\nint par(int low, int high)\r\n{\r\n    int key = a[low];\r\n    while(low < high)\r\n    {\r\n        while(low < high && key >= a[low])\r\n            high--;\r\n        if (low < high) \r\n            a[low] = a[high];\r\n        while(low < high && key <= a[low])\r\n            low++;\r\n        if (low < high)\r\n            a[low] = a[high];\r\n    }\r\n    a[low] = key;    \r\n    return low;\r\n}\r\n\r\nint get(int low, int high, int k)\r\n{\r\n    //Find the partition according to quick-sort algorithm.\r\n    int n = par(low,high);\r\n    \r\n    if (n + 1 == k)     return a[n];\r\n    else if (n + 1 < k) return get(n + 1, high, k);\r\n    else                return get(low, n - 1, k);\r\n}\r\n\r\nint main()\r\n{\r\n    int n,k,i;\r\n    while(scanf("%d %d",&n,&k)!=EOF)\r\n    {\r\n        for(i=0;i<k;++i) scanf("%d",q+i);\r\n        for(i=0;i<n;++i) scanf("%d",a+i);\r\n        \r\n        for(i=0;i<k;++i) printf("%d\\n",get(0,n-1,n-q[i]));\r\n    }\r\n    return 0;\r\n}', '', 600, 761856, 5, 2, '2010-10-25 13:48:40', '0001-01-01 00:00:00'),
(699, 6, 339, 0, '#include <stdio.h>\r\n#include <algorithm>\r\n#define N 100010\r\n#define M 1010\r\nusing namespace std;\r\nint a[N],q[M];\r\n\r\nbool cmp(int u,int v)\r\n{\r\n      return u>v;\r\n}\r\n\r\nint main()\r\n{\r\n    int i,n,m;\r\n    while(scanf("%d %d",&n,&m)!=EOF)\r\n    {\r\n        for(i=0;i<m;++i) scanf("%d",q+i);\r\n        for(i=0;i<n;++i) scanf("%d",a+i);\r\n        \r\n        for(i=0;i<m;++i)\r\n        {\r\n            nth_element(a,a+q[i],a+n,cmp);\r\n            printf("%d\\n",a[ q[i] ]);\r\n        }\r\n    }\r\n    return 0;\r\n}', '', 600, 663552, 5, 2, '2010-10-25 19:21:08', '0001-01-01 00:00:00'),
(700, 6, 339, 0, '#include <stdio.h>\r\n#include <algorithm>\r\n#define N 100010\r\n#define M 1010\r\nusing namespace std;\r\nint a[N],q[M];\r\n\r\nbool cmp(int u,int v)\r\n{\r\n      return u>v;\r\n}\r\n\r\nint main()\r\n{\r\n    int i,n,m;\r\n    while(scanf("%d %d",&n,&m)!=EOF)\r\n    {\r\n        for(i=0;i<m;++i) scanf("%d",q+i);\r\n        for(i=0;i<n;++i) scanf("%d",a+i);\r\n        \r\n        sort(a,a+n,cmp);\r\n        for(i=0;i<m;++i)\r\n            printf("%d\\n",a[ q[i] ]);\r\n    }\r\n    return 0;\r\n}', '', 202, 663552, 1, 2, '2010-10-25 19:24:56', '0001-01-01 00:00:00'),
(701, 6, 339, 0, '#include <stdio.h>\r\n#include <algorithm>\r\n#define N 205\r\n#define M 1010\r\nusing namespace std;\r\n\r\nstruct Heap\r\n{\r\n    int size;\r\n    int a[N];\r\n    Heap() { size=0; }\r\n    void clear() { size=0; }   \r\n    void insert(int x)\r\n    {\r\n         int p=++size,f=p>>1;\r\n         while(f>0)\r\n         {\r\n             if(x>a[f]) break; \r\n             a[p]=a[f],p=f,f>>=1;\r\n         }\r\n         a[p]=x;\r\n    }\r\n    \r\n    void down(int pos)\r\n    {\r\n         int p,c,x;\r\n         p=1,x=a[pos],c=p<<1;\r\n         \r\n         while(c<=size)\r\n         {\r\n             if(c<size&&a[c+1]<a[c]) c++;\r\n             if(x<a[c]) break; \r\n             a[p]=a[c],p=c,c<<=1;\r\n         }\r\n         a[p]=x;\r\n    }\r\n    \r\n    \r\n    int pop()\r\n    {\r\n        int tmp=a[1];\r\n        a[1]=a[size--];\r\n        down(1);\r\n        return tmp;\r\n    }\r\n}h;\r\nstruct Node\r\n{\r\n   int k,v;\r\n}que[M];\r\nint res[M];\r\n\r\nbool cmp(const Node& a,const Node& b)\r\n{\r\n    return a.k>b.k;\r\n}\r\n\r\nint main()\r\n{\r\n    int i,n,m,max_v,t,r,j,l;\r\n    while(scanf("%d %d",&n,&m)!=EOF)\r\n    {\r\n       h.clear();\r\n       max_v=-1;\r\n       for(i=0;i<m;++i) \r\n       {\r\n           scanf("%d",&que[i].k);\r\n           que[i].v=i,que[i].k++;\r\n           if(que[i].k>max_v) max_v=que[i].k;\r\n       }\r\n       sort(que,que+m,cmp);\r\n       \r\n       for(i=1;i<=n;++i)\r\n       {\r\n           scanf("%d",&t);\r\n           if(i<=max_v) h.insert(t);\r\n           if(i>max_v)\r\n           {\r\n              r=h.pop();\r\n              h.insert(t);\r\n           }\r\n       }\r\n\r\n       i=0;\r\n       while(i<m)\r\n       {\r\n           t=que[i].k;\r\n           j=i+1;\r\n           while(t==que[j].k) j++;\r\n         \r\n           while(t>h.size) r=h.pop();\r\n           r=h.pop();\r\n           \r\n           if(j>i+1)\r\n           {\r\n              for(l=i;l<j;++l) \r\n                  res[ que[l].v ]=r;\r\n           }\r\n           else if(j==i+1) \r\n              res[ que[i].v ]=r;\r\n           \r\n           i=j;\r\n       }\r\n       \r\n       for(i=0;i<m;++i)\r\n           printf("%d\\n",res[i]);\r\n    }\r\n    return 0;\r\n}\r\n', '', 78, 270336, 4, 2, '2010-10-26 07:10:36', '0001-01-01 00:00:00'),
(702, 6, 339, 0, '#include <stdio.h>\r\n#include <algorithm>\r\n#define N 205\r\n#define M 1010\r\nusing namespace std;\r\n\r\nstruct Heap\r\n{\r\n    int size;\r\n    int a[N];\r\n    Heap() { size=0; }\r\n    void clear() { size=0; }   \r\n    int top() { return a[1]; }\r\n    void insert(int x)\r\n    {\r\n         int p=++size,f=p>>1;\r\n         while(f>0)\r\n         {\r\n             if(x>a[f]) break; \r\n             a[p]=a[f],p=f,f>>=1;\r\n         }\r\n         a[p]=x;\r\n    }\r\n    \r\n    void down(int pos)\r\n    {\r\n         int p,c,x;\r\n         p=1,x=a[pos],c=p<<1;\r\n         \r\n         while(c<=size)\r\n         {\r\n             if(c<size&&a[c+1]<a[c]) c++;\r\n             if(x<a[c]) break; \r\n             a[p]=a[c],p=c,c<<=1;\r\n         }\r\n         a[p]=x;\r\n    }\r\n    \r\n    \r\n    int pop()\r\n    {\r\n        int tmp=a[1];\r\n        a[1]=a[size--];\r\n        down(1);\r\n        return tmp;\r\n    }\r\n}h;\r\nint q[M],ind[N],res[N];\r\n\r\nbool cmp(int a,int b)\r\n{\r\n    return a>b;\r\n}\r\n\r\nint main()\r\n{\r\n    int i,n,m,max_v,t,r,j,len;\r\n    while(scanf("%d %d",&n,&m)!=EOF)\r\n    {\r\n       h.clear();\r\n       max_v=-1;\r\n       for(i=0;i<m;++i) \r\n       {\r\n           scanf("%d",q+i);\r\n           q[i]++;\r\n           ind[i]=q[i];\r\n           if(q[i]>max_v) max_v=q[i];\r\n       }\r\n       \r\n       sort(ind,ind+m,cmp);\r\n       len=0;\r\n       ind[len++]=ind[0];\r\n       for(i=1;i<m;++i)\r\n       {\r\n           if(ind[i]!=ind[i-1])\r\n              ind[len++]=ind[i];\r\n       }\r\n       \r\n       for(i=1;i<=n;++i)\r\n       {\r\n           scanf("%d",&t);\r\n           if(i<=max_v) h.insert(t);\r\n           if(i>max_v&&t>h.top())\r\n           {\r\n              r=h.pop();\r\n              h.insert(t);\r\n           }\r\n       }\r\n\r\n       for(i=0;i<len;++i)\r\n       {\r\n           t=ind[i];\r\n           while(t<h.size) r=h.pop();\r\n           res[ ind[i] ]=h.pop();\r\n       }\r\n       \r\n       for(i=0;i<m;++i)\r\n           printf("%d\\n",res[ q[i] ]);\r\n    }\r\n    return 0;\r\n}', '', 140, 266240, 1, 2, '2010-10-26 20:48:05', '0001-01-01 00:00:00'),
(703, 34, 367, 0, '#include <iostream>\r\n#include <algorithm>\r\n\r\n#define M 1000000\r\n\r\ntypedef struct{\r\n	int l,r;\r\n	int mid(){ return (l+r)>>1;}\r\n}Tree;\r\nTree tt[M*4];\r\n\r\nint len;\r\nint sorted[M];\r\nint toLeft[20][M];\r\nint val[20][M];\r\n\r\nvoid build(int left, int right, int deep, int nod){\r\n	int mid = (left+right)>>1;\r\n	tt[nod].l=left;\r\n	tt[nod].r=right;\r\n	if(left==right) return ;\r\n	int lsame = mid - left + 1;//lsame表示和val_mid相等且分到左边的\r\n	for(int i = left ; i <= right ; i ++) {\r\n		if(val[deep][i] < sorted[mid]) {\r\n			lsame --;//先假设左边的数(mid - l + 1)个都等于val_mid,然后把实际上小于val_mid的减去\r\n			//其实就是分在左边的并和val_mid相等的数的个数\r\n		}\r\n	}\r\n	int lpos=left;\r\n	int rpos=mid+1;\r\n	int same=0;\r\n	for(int i=left;i<=right;++i){\r\n		if(i==left){\r\n			toLeft[deep][i]=0;\r\n		}\r\n		else {\r\n			toLeft[deep][i]=toLeft[deep][i-1];\r\n		}\r\n		if(val[deep][i]<sorted[mid]){\r\n			toLeft[deep][i]++;\r\n			val[deep+1][lpos++]=val[deep][i];\r\n		}\r\n		else if(val[deep][i]>sorted[mid]){\r\n			val[deep+1][rpos++]=val[deep][i];\r\n		}\r\n		else{//相等的情况\r\n			if(same<lsame){\r\n				same++;\r\n				toLeft[deep][i]++;\r\n				val[deep+1][lpos++]=val[deep][i];\r\n			}\r\n			else{\r\n				val[deep+1][rpos++]=val[deep][i];\r\n			}\r\n		}\r\n	}\r\n	build(left,mid,deep+1,nod*2);\r\n	build(mid+1,right,deep+1,nod*2+1);\r\n}\r\n\r\nint cmp(const void *a ,const void *b){\r\n	return *(int *)a - *(int *)b;\r\n}\r\n\r\nint query(int l, int r, int k, int d, int nod){\r\n	if(l==r)\r\n		return val[d][l];\r\n	int s;//s表示[ l , r ]有多少个分到左边\r\n	int ss;//ss表示 [tt[nod].left , l-1 ]有多少个分到左边\r\n	if(l==tt[nod].l){\r\n		s=toLeft[d][r];\r\n		ss=0;\r\n	}\r\n	else {\r\n		s=toLeft[d][r] - toLeft[d][l-1];\r\n		ss=toLeft[d][l-1];\r\n	}\r\n	if(s>=k){//左区间\r\n		int newl = tt[nod].l + ss;\r\n		int newr = tt[nod].l + ss + s - 1;\r\n		query(newl, newr, k, d+1,nod*2);\r\n	}\r\n	else{\r\n		int mid=tt[nod].mid();\r\n		int bb = l - tt[nod].l - ss;//bb表示 [tt[nod].left , l-1 ]有多少个分到右边\r\n		int b = r - l + 1 - s;//b表示 [l , r]有多少个分到右边  [第二排序条件是按历史时间排序]\r\n		int newl = mid + bb + 1;\r\n		int newr = mid + bb + b;\r\n		return query(newl,newr,k-s,d+1,nod*2+1);\r\n	}\r\n}\r\n\r\nint main(){\r\n	int n,m,c;//总长、片长、起伏\r\n	scanf("%d%d%d",&n,&m,&c);\r\n	for(int i=1;i<=n;++i){\r\n		scanf("%d",sorted+i);\r\n		val[0][i]=sorted[i];\r\n	}\r\n	qsort(sorted+1,n,sizeof(int),cmp);\r\n	build(1,n,0,1);\r\n\r\n	for(int i=1;i<=n-m+1;++i){\r\n		if(query(i,i+m-1,m,0,1)-query(i,i+m-1,1,0,1) <= c)\r\n			printf("%d\\n",i);\r\n	}\r\n		/*\r\n	int a,b,e,d;\r\n	while(scanf("%d%d%d",&a,&b,&e)){\r\n		d=query(a,b,e,0,1);\r\n		printf("%d\\n ",d);\r\n	}*/\r\n	return 0;\r\n}', 'Main.cpp: In function ''int main()'':\r\nMain.cpp:95:25: error: ''scanf'' was not declared in this scope\r\nMain.cpp:105:19: error: ''printf'' was not declared in this scope\r\n', 0, 0, 2, 2, '2010-10-26 22:42:50', '0001-01-01 00:00:00'),
(704, 34, 367, 0, '#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\n#define M 1000000\r\n\r\ntypedef struct{\r\n	int l,r;\r\n	int mid(){ return (l+r)>>1;}\r\n}Tree;\r\nTree tt[M*4];\r\n\r\nint len;\r\nint sorted[M];\r\nint toLeft[20][M];\r\nint val[20][M];\r\n\r\nvoid build(int left, int right, int deep, int nod){\r\n	int mid = (left+right)>>1;\r\n	tt[nod].l=left;\r\n	tt[nod].r=right;\r\n	if(left==right) return ;\r\n	int lsame = mid - left + 1;//lsame表示和val_mid相等且分到左边的\r\n	for(int i = left ; i <= right ; i ++) {\r\n		if(val[deep][i] < sorted[mid]) {\r\n			lsame --;//先假设左边的数(mid - l + 1)个都等于val_mid,然后把实际上小于val_mid的减去\r\n			//其实就是分在左边的并和val_mid相等的数的个数\r\n		}\r\n	}\r\n	int lpos=left;\r\n	int rpos=mid+1;\r\n	int same=0;\r\n	for(int i=left;i<=right;++i){\r\n		if(i==left){\r\n			toLeft[deep][i]=0;\r\n		}\r\n		else {\r\n			toLeft[deep][i]=toLeft[deep][i-1];\r\n		}\r\n		if(val[deep][i]<sorted[mid]){\r\n			toLeft[deep][i]++;\r\n			val[deep+1][lpos++]=val[deep][i];\r\n		}\r\n		else if(val[deep][i]>sorted[mid]){\r\n			val[deep+1][rpos++]=val[deep][i];\r\n		}\r\n		else{//相等的情况\r\n			if(same<lsame){\r\n				same++;\r\n				toLeft[deep][i]++;\r\n				val[deep+1][lpos++]=val[deep][i];\r\n			}\r\n			else{\r\n				val[deep+1][rpos++]=val[deep][i];\r\n			}\r\n		}\r\n	}\r\n	build(left,mid,deep+1,nod*2);\r\n	build(mid+1,right,deep+1,nod*2+1);\r\n}\r\n\r\nint cmp(const void *a ,const void *b){\r\n	return *(int *)a - *(int *)b;\r\n}\r\n\r\nint query(int l, int r, int k, int d, int nod){\r\n	if(l==r)\r\n		return val[d][l];\r\n	int s;//s表示[ l , r ]有多少个分到左边\r\n	int ss;//ss表示 [tt[nod].left , l-1 ]有多少个分到左边\r\n	if(l==tt[nod].l){\r\n		s=toLeft[d][r];\r\n		ss=0;\r\n	}\r\n	else {\r\n		s=toLeft[d][r] - toLeft[d][l-1];\r\n		ss=toLeft[d][l-1];\r\n	}\r\n	if(s>=k){//左区间\r\n		int newl = tt[nod].l + ss;\r\n		int newr = tt[nod].l + ss + s - 1;\r\n		query(newl, newr, k, d+1,nod*2);\r\n	}\r\n	else{\r\n		int mid=tt[nod].mid();\r\n		int bb = l - tt[nod].l - ss;//bb表示 [tt[nod].left , l-1 ]有多少个分到右边\r\n		int b = r - l + 1 - s;//b表示 [l , r]有多少个分到右边  [第二排序条件是按历史时间排序]\r\n		int newl = mid + bb + 1;\r\n		int newr = mid + bb + b;\r\n		return query(newl,newr,k-s,d+1,nod*2+1);\r\n	}\r\n}\r\n\r\nint main(){\r\n	int n,m,c;//总长、片长、起伏\r\n	scanf("%d%d%d",&n,&m,&c);\r\n	for(int i=1;i<=n;++i){\r\n		scanf("%d",sorted+i);\r\n		val[0][i]=sorted[i];\r\n	}\r\n	qsort(sorted+1,n,sizeof(int),cmp);\r\n	build(1,n,0,1);\r\n\r\n	for(int i=1;i<=n-m+1;++i){\r\n		if(query(i,i+m-1,m,0,1)-query(i,i+m-1,1,0,1) <= c)\r\n			printf("%d\\n",i);\r\n	}\r\n		/*\r\n	int a,b,e,d;\r\n	while(scanf("%d%d%d",&a,&b,&e)){\r\n		d=query(a,b,e,0,1);\r\n		printf("%d\\n ",d);\r\n	}*/\r\n	return 0;\r\n}', 'Main.c:8:11: error: expected '':'', '','', '';'', ''}'' or ''__attribute__'' before ''{'' token\r\nMain.c: In function ''build'':\r\nMain.c:23:2: error: ''for'' loop initial declarations are only allowed in C99 mode\r\nMain.c:23:2: note: use option -std=c99 or -std=gnu99 to compile your code\r\nMain.c:32:10: error: redefinition of ''i''\r\nMain.c:23:10: note: previous definition of ''i'' was here\r\nMain.c:32:2: error: ''for'' loop initial declarations are only allowed in C99 mode\r\nMain.c: In function ''query'':\r\nMain.c:84:18: err', 0, 0, 2, 1, '2010-10-26 22:45:21', '0001-01-01 00:00:00');
INSERT INTO `tbl_submitions` (`id`, `user_id`, `problem_id`, `exercise_id`, `source`, `result`, `used_time`, `used_memory`, `status`, `compiler_id`, `created`, `modified`) VALUES
(705, 34, 367, 0, '#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\n#define M 1000000\r\n\r\ntypedef struct{\r\n	int l,r;\r\n	int mid(){ return (l+r)>>1;}\r\n}Tree;\r\nTree tt[M*4];\r\n\r\nint len;\r\nint sorted[M];\r\nint toLeft[20][M];\r\nint val[20][M];\r\n\r\nvoid build(int left, int right, int deep, int nod){\r\n	int mid = (left+right)>>1;\r\n	tt[nod].l=left;\r\n	tt[nod].r=right;\r\n	if(left==right) return ;\r\n	int lsame = mid - left + 1;//lsame表示和val_mid相等且分到左边的\r\n	for(int i = left ; i <= right ; i ++) {\r\n		if(val[deep][i] < sorted[mid]) {\r\n			lsame --;//先假设左边的数(mid - l + 1)个都等于val_mid,然后把实际上小于val_mid的减去\r\n			//其实就是分在左边的并和val_mid相等的数的个数\r\n		}\r\n	}\r\n	int lpos=left;\r\n	int rpos=mid+1;\r\n	int same=0;\r\n	for(int i=left;i<=right;++i){\r\n		if(i==left){\r\n			toLeft[deep][i]=0;\r\n		}\r\n		else {\r\n			toLeft[deep][i]=toLeft[deep][i-1];\r\n		}\r\n		if(val[deep][i]<sorted[mid]){\r\n			toLeft[deep][i]++;\r\n			val[deep+1][lpos++]=val[deep][i];\r\n		}\r\n		else if(val[deep][i]>sorted[mid]){\r\n			val[deep+1][rpos++]=val[deep][i];\r\n		}\r\n		else{//相等的情况\r\n			if(same<lsame){\r\n				same++;\r\n				toLeft[deep][i]++;\r\n				val[deep+1][lpos++]=val[deep][i];\r\n			}\r\n			else{\r\n				val[deep+1][rpos++]=val[deep][i];\r\n			}\r\n		}\r\n	}\r\n	build(left,mid,deep+1,nod*2);\r\n	build(mid+1,right,deep+1,nod*2+1);\r\n}\r\n\r\nint cmp(const void *a ,const void *b){\r\n	return *(int *)a - *(int *)b;\r\n}\r\n\r\nint query(int l, int r, int k, int d, int nod){\r\n	if(l==r)\r\n		return val[d][l];\r\n	int s;//s表示[ l , r ]有多少个分到左边\r\n	int ss;//ss表示 [tt[nod].left , l-1 ]有多少个分到左边\r\n	if(l==tt[nod].l){\r\n		s=toLeft[d][r];\r\n		ss=0;\r\n	}\r\n	else {\r\n		s=toLeft[d][r] - toLeft[d][l-1];\r\n		ss=toLeft[d][l-1];\r\n	}\r\n	if(s>=k){//左区间\r\n		int newl = tt[nod].l + ss;\r\n		int newr = tt[nod].l + ss + s - 1;\r\n		query(newl, newr, k, d+1,nod*2);\r\n	}\r\n	else{\r\n		int mid=tt[nod].mid();\r\n		int bb = l - tt[nod].l - ss;//bb表示 [tt[nod].left , l-1 ]有多少个分到右边\r\n		int b = r - l + 1 - s;//b表示 [l , r]有多少个分到右边  [第二排序条件是按历史时间排序]\r\n		int newl = mid + bb + 1;\r\n		int newr = mid + bb + b;\r\n		return query(newl,newr,k-s,d+1,nod*2+1);\r\n	}\r\n}\r\n\r\nint main(){\r\n	int n,m,c;//总长、片长、起伏\r\n	scanf("%d%d%d",&n,&m,&c);\r\n	for(int i=1;i<=n;++i){\r\n		scanf("%d",sorted+i);\r\n		val[0][i]=sorted[i];\r\n	}\r\n	qsort(sorted+1,n,sizeof(int),cmp);\r\n	build(1,n,0,1);\r\n\r\n	for(int i=1;i<=n-m+1;++i){\r\n		if(query(i,i+m-1,m,0,1)-query(i,i+m-1,1,0,1) <= c)\r\n			printf("%d\\n",i);\r\n	}\r\n		/*\r\n	int a,b,e,d;\r\n	while(scanf("%d%d%d",&a,&b,&e)){\r\n		d=query(a,b,e,0,1);\r\n		printf("%d\\n ",d);\r\n	}*/\r\n	return 0;\r\n}', 'Main.c:8:11: error: expected '':'', '','', '';'', ''}'' or ''__attribute__'' before ''{'' token\r\nMain.c: In function ''build'':\r\nMain.c:23:2: error: ''for'' loop initial declarations are only allowed in C99 mode\r\nMain.c:23:2: note: use option -std=c99 or -std=gnu99 to compile your code\r\nMain.c:32:10: error: redefinition of ''i''\r\nMain.c:23:10: note: previous definition of ''i'' was here\r\nMain.c:32:2: error: ''for'' loop initial declarations are only allowed in C99 mode\r\nMain.c: In function ''query'':\r\nMain.c:84:18: err', 0, 0, 2, 1, '2010-10-26 22:46:51', '0001-01-01 00:00:00'),
(706, 34, 367, 0, '#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\n#define M 1000000\r\n\r\ntypedef struct{\r\n	int l,r;\r\n	int mid(){ return (l+r)>>1;}\r\n}Tree;\r\nTree tt[M*4];\r\n\r\nint len;\r\nint sorted[M];\r\nint toLeft[20][M];\r\nint val[20][M];\r\n\r\nvoid build(int left, int right, int deep, int nod){\r\n	int mid = (left+right)>>1;\r\n	tt[nod].l=left;\r\n	tt[nod].r=right;\r\n	if(left==right) return ;\r\n	int lsame = mid - left + 1;//lsame表示和val_mid相等且分到左边的\r\n	for(int i = left ; i <= right ; i ++) {\r\n		if(val[deep][i] < sorted[mid]) {\r\n			lsame --;//先假设左边的数(mid - l + 1)个都等于val_mid,然后把实际上小于val_mid的减去\r\n			//其实就是分在左边的并和val_mid相等的数的个数\r\n		}\r\n	}\r\n	int lpos=left;\r\n	int rpos=mid+1;\r\n	int same=0;\r\n	for(int i=left;i<=right;++i){\r\n		if(i==left){\r\n			toLeft[deep][i]=0;\r\n		}\r\n		else {\r\n			toLeft[deep][i]=toLeft[deep][i-1];\r\n		}\r\n		if(val[deep][i]<sorted[mid]){\r\n			toLeft[deep][i]++;\r\n			val[deep+1][lpos++]=val[deep][i];\r\n		}\r\n		else if(val[deep][i]>sorted[mid]){\r\n			val[deep+1][rpos++]=val[deep][i];\r\n		}\r\n		else{//相等的情况\r\n			if(same<lsame){\r\n				same++;\r\n				toLeft[deep][i]++;\r\n				val[deep+1][lpos++]=val[deep][i];\r\n			}\r\n			else{\r\n				val[deep+1][rpos++]=val[deep][i];\r\n			}\r\n		}\r\n	}\r\n	build(left,mid,deep+1,nod*2);\r\n	build(mid+1,right,deep+1,nod*2+1);\r\n}\r\n\r\nint cmp(const void *a ,const void *b){\r\n	return *(int *)a - *(int *)b;\r\n}\r\n\r\nint query(int l, int r, int k, int d, int nod){\r\n	if(l==r)\r\n		return val[d][l];\r\n	int s;//s表示[ l , r ]有多少个分到左边\r\n	int ss;//ss表示 [tt[nod].left , l-1 ]有多少个分到左边\r\n	if(l==tt[nod].l){\r\n		s=toLeft[d][r];\r\n		ss=0;\r\n	}\r\n	else {\r\n		s=toLeft[d][r] - toLeft[d][l-1];\r\n		ss=toLeft[d][l-1];\r\n	}\r\n	if(s>=k){//左区间\r\n		int newl = tt[nod].l + ss;\r\n		int newr = tt[nod].l + ss + s - 1;\r\n		query(newl, newr, k, d+1,nod*2);\r\n	}\r\n	else{\r\n		int mid=tt[nod].mid();\r\n		int bb = l - tt[nod].l - ss;//bb表示 [tt[nod].left , l-1 ]有多少个分到右边\r\n		int b = r - l + 1 - s;//b表示 [l , r]有多少个分到右边  [第二排序条件是按历史时间排序]\r\n		int newl = mid + bb + 1;\r\n		int newr = mid + bb + b;\r\n		return query(newl,newr,k-s,d+1,nod*2+1);\r\n	}\r\n}\r\n\r\nint main(){\r\n	int n,m,c;//总长、片长、起伏\r\n	scanf("%d%d%d",&n,&m,&c);\r\n	for(int i=1;i<=n;++i){\r\n		scanf("%d",sorted+i);\r\n		val[0][i]=sorted[i];\r\n	}\r\n	qsort(sorted+1,n,sizeof(int),cmp);\r\n	build(1,n,0,1);\r\n\r\n	for(int i=1;i<=n-m+1;++i){\r\n		if(query(i,i+m-1,m,0,1)-query(i,i+m-1,1,0,1) <= c)\r\n			printf("%d\\n",i);\r\n	}\r\n		/*\r\n	int a,b,e,d;\r\n	while(scanf("%d%d%d",&a,&b,&e)){\r\n		d=query(a,b,e,0,1);\r\n		printf("%d\\n ",d);\r\n	}*/\r\n	return 0;\r\n}', 'Main.c:8:11: error: expected '':'', '','', '';'', ''}'' or ''__attribute__'' before ''{'' token\r\nMain.c: In function ''build'':\r\nMain.c:23:2: error: ''for'' loop initial declarations are only allowed in C99 mode\r\nMain.c:23:2: note: use option -std=c99 or -std=gnu99 to compile your code\r\nMain.c:32:10: error: redefinition of ''i''\r\nMain.c:23:10: note: previous definition of ''i'' was here\r\nMain.c:32:2: error: ''for'' loop initial declarations are only allowed in C99 mode\r\nMain.c: In function ''query'':\r\nMain.c:84:18: err', 0, 0, 2, 1, '2010-10-26 22:52:06', '0001-01-01 00:00:00'),
(707, 34, 367, 0, '#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\n#define M 1000000\r\n\r\ntypedef struct{\r\n	int l,r;\r\n	int mid(){ return (l+r)>>1;}\r\n}Tree;\r\nTree tt[M*4];\r\n\r\nint len;\r\nint sorted[M];\r\nint toLeft[20][M];\r\nint val[20][M];\r\n\r\nvoid build(int left, int right, int deep, int nod){\r\n	int mid = (left+right)>>1;\r\n	tt[nod].l=left;\r\n	tt[nod].r=right;\r\n	if(left==right) return ;\r\n	int lsame = mid - left + 1;//lsame表示和val_mid相等且分到左边的\r\n	int i=1;\r\n	for(i = left ; i <= right ; i ++) {\r\n		if(val[deep][i] < sorted[mid]) {\r\n			lsame --;//先假设左边的数(mid - l + 1)个都等于val_mid,然后把实际上小于val_mid的减去\r\n			//其实就是分在左边的并和val_mid相等的数的个数\r\n		}\r\n	}\r\n	int lpos=left;\r\n	int rpos=mid+1;\r\n	int same=0;\r\n	for(i=left;i<=right;++i){\r\n		if(i==left){\r\n			toLeft[deep][i]=0;\r\n		}\r\n		else {\r\n			toLeft[deep][i]=toLeft[deep][i-1];\r\n		}\r\n		if(val[deep][i]<sorted[mid]){\r\n			toLeft[deep][i]++;\r\n			val[deep+1][lpos++]=val[deep][i];\r\n		}\r\n		else if(val[deep][i]>sorted[mid]){\r\n			val[deep+1][rpos++]=val[deep][i];\r\n		}\r\n		else{//相等的情况\r\n			if(same<lsame){\r\n				same++;\r\n				toLeft[deep][i]++;\r\n				val[deep+1][lpos++]=val[deep][i];\r\n			}\r\n			else{\r\n				val[deep+1][rpos++]=val[deep][i];\r\n			}\r\n		}\r\n	}\r\n	build(left,mid,deep+1,nod*2);\r\n	build(mid+1,right,deep+1,nod*2+1);\r\n}\r\n\r\nint cmp(const void *a ,const void *b){\r\n	return *(int *)a - *(int *)b;\r\n}\r\n\r\nint query(int l, int r, int k, int d, int nod){\r\n	if(l==r)\r\n		return val[d][l];\r\n	int s;//s表示[ l , r ]有多少个分到左边\r\n	int ss;//ss表示 [tt[nod].left , l-1 ]有多少个分到左边\r\n	if(l==tt[nod].l){\r\n		s=toLeft[d][r];\r\n		ss=0;\r\n	}\r\n	else {\r\n		s=toLeft[d][r] - toLeft[d][l-1];\r\n		ss=toLeft[d][l-1];\r\n	}\r\n	if(s>=k){//左区间\r\n		int newl = tt[nod].l + ss;\r\n		int newr = tt[nod].l + ss + s - 1;\r\n		query(newl, newr, k, d+1,nod*2);\r\n	}\r\n	else{\r\n		int mid=tt[nod].mid();\r\n		int bb = l - tt[nod].l - ss;//bb表示 [tt[nod].left , l-1 ]有多少个分到右边\r\n		int b = r - l + 1 - s;//b表示 [l , r]有多少个分到右边  [第二排序条件是按历史时间排序]\r\n		int newl = mid + bb + 1;\r\n		int newr = mid + bb + b;\r\n		return query(newl,newr,k-s,d+1,nod*2+1);\r\n	}\r\n}\r\n\r\nint main(){\r\n	int n,m,c;//总长、片长、起伏\r\n	scanf("%d%d%d",&n,&m,&c);\r\n	int i=1;\r\n	for(i=1;i<=n;++i){\r\n		scanf("%d",sorted+i);\r\n		val[0][i]=sorted[i];\r\n	}\r\n	qsort(sorted+1,n,sizeof(int),cmp);\r\n	build(1,n,0,1);\r\n\r\n	for(i=1;i<=n-m+1;++i){\r\n		if(query(i,i+m-1,m,0,1)-query(i,i+m-1,1,0,1) <= c)\r\n			printf("%d\\n",i);\r\n	}\r\n		/*\r\n	int a,b,e,d;\r\n	while(scanf("%d%d%d",&a,&b,&e)){\r\n		d=query(a,b,e,0,1);\r\n		printf("%d\\n ",d);\r\n	}*/\r\n	return 0;\r\n}', '', 0, 33554432, 6, 2, '2010-10-26 22:59:51', '0001-01-01 00:00:00'),
(708, 17, 345, 4, '#include<iostream>\r\n#include<vector>\r\n#include<algorithm>\r\n#include<stdio.h>\r\nusing namespace std;\r\nbool flag;\r\nint main()\r\n{\r\n    vector<string>l1,l2;\r\n    string snake;\r\n    int n,m;\r\n    while(scanf("%d",&n)!=EOF)\r\n    {   \r\n       for(int i=0;i<n;i++)\r\n        {\r\n               cin>>snake;\r\n               l1.push_back(snake);\r\n        }\r\n        cin>>m;\r\n        for(int i=0;i<m;i++)\r\n        {\r\n                cin>>snake;\r\n                l2.push_back(snake);\r\n        }\r\n        vector<string>::iterator result;\r\n        for(int i=0;i<m;i++)\r\n        {\r\n              result = find(l1.begin( ),l1.end( ),l2[i]); //查找3\r\n              if (result == l1.end( )) \r\n                 {flag=0;}\r\n              else //找到\r\n              {flag=1;\r\n  \r\n               break;\r\n             }\r\n         }\r\n         if(flag)\r\n          cout<<*result<<" "<<*result<<endl;\r\n          else\r\n          cout<<"none"<<" "<<"none"<<endl;\r\n         l1.clear();\r\n         l2.clear();\r\n      }\r\n        return 0;\r\n}\r\n', '', 0, 479232, 4, 2, '2010-10-27 14:24:09', '0001-01-01 00:00:00'),
(709, 17, 345, 4, ' \r\n\r\n#include<iostream>\r\n#include<vector>\r\n#include<algorithm>\r\n#include<stdio.h>\r\nusing namespace std;\r\nbool flag;\r\nint main()\r\n{\r\n    vector<string>l1,l2;\r\n    string snake;\r\n    int n,m;\r\n    int len1,len2;\r\n    while(scanf("%d",&n)!=EOF)\r\n    {   \r\n       for(int i=0;i<n;i++)\r\n        {\r\n               cin>>snake;\r\n               l1.push_back(snake);\r\n        }\r\n        cin>>m;\r\n        for(int i=0;i<m;i++)\r\n        {\r\n                cin>>snake;\r\n                l2.push_back(snake);\r\n        }\r\n        vector<string>::iterator result;\r\n        len1=l1.size();\r\n        len2=l2.size();\r\n        \r\n        if(len1<=len2){\r\n        for(int i=0;i<m;i++)\r\n        {\r\n              result = find(l1.begin( ),l1.end( ),l2[i]); //����3\r\n              if (result == l1.end( )) {\r\n                  flag=0;\r\n              }\r\n              else //�ҵ�\r\n              {\r\n                flag=1;\r\n                break;\r\n             }\r\n         }\r\n         }\r\n         else{\r\n         for(int i=0;i<n;i++)\r\n        {\r\n              result = find(l2.begin( ),l2.end( ),l1[i]); //����3\r\n              if (result == l2.end( )) {\r\n                  flag=0;\r\n              }\r\n              else //�ҵ�\r\n              {\r\n                flag=1;\r\n                break;\r\n             }\r\n         }\r\n         }\r\n         \r\n        if(flag)\r\n          cout<<*result<<" "<<*result<<endl;\r\n         else\r\n          cout<<"none"<<" "<<"none"<<endl;\r\n         l1.clear();\r\n         l2.clear();\r\n      }\r\n       return 0;\r\n}\r\n', '', 0, 483328, 4, 2, '2010-10-27 15:44:52', '0001-01-01 00:00:00'),
(710, 24, 336, 2, '#include <iostream>\r\n#include <vector>\r\n#include <algorithm>\r\n\r\nusing namespace std;\r\n\r\nint getBitCount_method(int n)\r\n{\r\n	int count = 0;\r\n	while ( n != 0 )\r\n	{\r\n		n = n & (n - 1);\r\n		++count;\r\n	}\r\n\r\n	return count;\r\n}\r\n\r\nvector<int> getSortVec(vector<int> a, int count[], int n)\r\n{\r\n	vector<int> rstVec;\r\n	vector<int> vecArray[33];\r\n	for (int i = 0; i < n; ++i)\r\n	{\r\n		vecArray[count[i]].push_back(a[i]);\r\n	}\r\n\r\n	for (int i = 0; i < 32; ++i)\r\n	{\r\n		for (int j = 0; j < vecArray[i].size(); ++j)\r\n		{\r\n			rstVec.push_back(vecArray[i][j]);\r\n		}\r\n	}\r\n\r\n	return rstVec;\r\n}\r\n\r\nint main()\r\n{\r\n	int n;\r\n	int i=0;\r\n	int x;\r\n	vector<int> number;\r\n	int count[50000] = {0};\r\n	while(scanf("%d",&n) != EOF)\r\n	{\r\n		i=0;\r\n		while(i<n)\r\n		{\r\n			cin>>x;\r\n			number.push_back(x);\r\n			i++;\r\n		}\r\n		sort(number.begin(),number.end());\r\n\r\n		for (int i = 0; i < n; ++i)\r\n			count[i] = getBitCount_method(number[i]);\r\n\r\n		vector<int> rstVec = getSortVec(number, count, n);\r\n\r\n		for (int i = 0; i < rstVec.size(); i++)\r\n			cout << rstVec[i] << " ";\r\n		cout << endl;\r\n\r\n		number.clear();\r\n		memset(count,0,50000*sizeof(int));\r\n	}\r\n	return 0;\r\n\r\n}', 'Main.c:1:20: fatal error: iostream: No such file or directory\r\ncompilation terminated.\r\n', 0, 0, 2, 1, '2010-10-27 16:49:58', '0001-01-01 00:00:00'),
(711, 24, 336, 2, '#include <iostream>\r\n#include <vector>\r\n#include <algorithm>\r\n\r\nusing namespace std;\r\n\r\nint getBitCount_method(int n)\r\n{\r\n	int count = 0;\r\n	int i;\r\n	char string[33];\r\n	itoa(n,string,2);\r\n	for(i=0;i<33;i++)\r\n	{\r\n		if(string[i]==''1'')\r\n			count++;\r\n	}\r\n\r\n	return count;\r\n}\r\n\r\nvector<int> getSortVec(vector<int> a, int count[], int n)\r\n{\r\n	vector<int> rstVec;\r\n	vector<int> vecArray[33];\r\n	for (int i = 0; i < n; ++i)\r\n	{\r\n		vecArray[count[i]].push_back(a[i]);\r\n	}\r\n\r\n	for (int i = 0; i <= 32; ++i)\r\n	{\r\n		for (int j = 0; j < vecArray[i].size(); ++j)\r\n		{\r\n			rstVec.push_back(vecArray[i][j]);\r\n		}\r\n	}\r\n\r\n	return rstVec;\r\n}\r\n\r\nint main()\r\n{\r\n	int n;\r\n	int i=0;\r\n	int x;\r\n	vector<int> number;\r\n	int count[50000] = {0};\r\n	while(scanf("%d",&n) != EOF)\r\n	{\r\n		i=0;\r\n		while(i<n)\r\n		{\r\n			cin>>x;\r\n			number.push_back(x);\r\n			i++;\r\n		}\r\n		sort(number.begin(),number.end());\r\n\r\n		for (int i = 0; i < n; ++i)\r\n			count[i] = getBitCount_method(number[i]);\r\n\r\n		vector<int> rstVec = getSortVec(number, count, n);\r\n\r\n		for (int i = 0; i < rstVec.size(); i++)\r\n			cout << rstVec[i] << " ";\r\n		cout << endl;\r\n\r\n		number.clear();\r\n		memset(count,0,50000*sizeof(int));\r\n	}\r\n	return 0;\r\n\r\n}', 'Main.c:1:20: fatal error: iostream: No such file or directory\r\ncompilation terminated.\r\n', 0, 0, 2, 1, '2010-10-27 17:51:38', '0001-01-01 00:00:00'),
(712, 24, 336, 2, '#include <iostream>\r\n#include <vector>\r\n#include <algorithm>\r\n\r\nusing namespace std;\r\n\r\nint getBitCount_method(int n)\r\n{\r\n	int count = 0;\r\n	int i;\r\n	char string[33];\r\n	itoa(n,string,2);\r\n	for(i=0;i<33;i++)\r\n	{\r\n		if(string[i]==''1'')\r\n			count++;\r\n	}\r\n\r\n	return count;\r\n}\r\n\r\nvector<int> getSortVec(vector<int> a, int count[], int n)\r\n{\r\n	vector<int> rstVec;\r\n	vector<int> vecArray[33];\r\n	for (int i = 0; i < n; ++i)\r\n	{\r\n		vecArray[count[i]].push_back(a[i]);\r\n	}\r\n\r\n	for (int i = 0; i <= 32; ++i)\r\n	{\r\n		for (int j = 0; j < vecArray[i].size(); ++j)\r\n		{\r\n			rstVec.push_back(vecArray[i][j]);\r\n		}\r\n	}\r\n\r\n	return rstVec;\r\n}\r\n\r\nint main()\r\n{\r\n	int n;\r\n	int i=0;\r\n	int x;\r\n	vector<int> number;\r\n	int count[50000] = {0};\r\n	while(scanf("%d",&n) != EOF)\r\n	{\r\n		i=0;\r\n		while(i<n)\r\n		{\r\n			cin>>x;\r\n			number.push_back(x);\r\n			i++;\r\n		}\r\n		sort(number.begin(),number.end());\r\n\r\n		for (int i = 0; i < n; ++i)\r\n			count[i] = getBitCount_method(number[i]);\r\n\r\n		vector<int> rstVec = getSortVec(number, count, n);\r\n\r\n		for (int i = 0; i < rstVec.size(); i++)\r\n			cout << rstVec[i] << " ";\r\n		cout << endl;\r\n\r\n		number.clear();\r\n		memset(count,0,50000*sizeof(int));\r\n	}\r\n	return 0;\r\n\r\n}', 'Main.cpp: In function ''int main()'':\r\nMain.cpp:49:21: error: ''scanf'' was not declared in this scope\r\nMain.cpp:49:26: error: ''EOF'' was not declared in this scope\r\nMain.cpp:70:35: error: ''memset'' was not declared in this scope\r\n', 0, 0, 2, 2, '2010-10-27 17:52:47', '0001-01-01 00:00:00'),
(713, 1, 374, 0, '#include <stdio.h>\r\n#include <iostream>\r\n#include <fstream>\r\n#include <time.h>\r\n#include <algorithm>\r\n#include <vector>\r\n#include <map>\r\n#include <string>\r\n#include <functional>\r\nusing namespace std;\r\nint gen_main();\r\nint cal_main();\r\nint main(int argc, char* argv[])\r\n{\r\n	//gen_main();\r\n	//freopen("c:/ti.txt","r",stdin);\r\n	//freopen("c:/to.txt","w",stdout);\r\n\r\n	int cas,n;\r\n	int i,j,k,t,max,s,e,x;\r\n    while(scanf("%d",&cas)==1)\r\n    {\r\n        for(i=0;i<cas;i++)\r\n        {\r\n            if(i)cout<<("\\n");\r\n			cout<<"Case "<<i+1<<":"<<std::endl;\r\n            scanf("%d",&n);\r\n            max=-(2<<31); \r\n			s=1;\r\n            for(j=k=1,t=0,e=1;j<=n;j++)\r\n            {\r\n                scanf("%d",&x);\r\n				if(j==1)max=x;\r\n                t+=x;\r\n                if(t>max)  {max=t;s=k;e=j;}\r\n                if(t<0)      {k=j+1;t=0;}\r\n            }\r\n			cout<<max<<'' ''<<s<<'' ''<<e<<std::endl;\r\n        }\r\n    }\r\n    return 0;\r\n}\r\n\r\nint gen_main()\r\n{\r\n	srand( (unsigned)time( NULL ) );//srand()函数产生一个以当前时间开始的随机种子.应该放在for等循环语句前面 不然要很长时间等待\r\n	ofstream ci("c:/ti.txt");\r\n\r\n	ci<<"57"<<endl;\r\n	ci<<"7 -1 -2 -3 -4 -5 -6 -5"<<std::endl;\r\n	ci<<"7 1 2 3 4 5 6 7"<<std::endl;\r\n	ci<<"1 -1"<<std::endl;\r\n	ci<<"1 1"<<std::endl;\r\n	ci<<"1 0"<<std::endl;\r\n	ci<<"7 -8 -2 -3 -4 -5 -6 -1"<<std::endl;\r\n	ci<<"7 -8 -2 -3 0 -5 -6 -1"<<std::endl;\r\n	ci<<"7 -8 -2 -3 1 -5 -6 -1"<<std::endl;\r\n	ci<<"3 -1 1 0"<<std::endl;\r\n	ci<<"3 1 0 -1"<<std::endl;\r\n	ci<<"3 1 -1 0"<<std::endl;\r\n	ci<<"3 1 1 1"<<std::endl;\r\n	int icase=12;\r\n	while(icase++<18)\r\n	{\r\n		ci<<10000;\r\n		for(int i=0;i<10000;++i)\r\n		{\r\n			int ir=rand();\r\n			if(ir&4)ir=-ir;\r\n\r\n			ci<<" "<<ir;\r\n		}\r\n		ci<<endl;\r\n	}\r\n	while(icase++<58)\r\n	{\r\n		ci<<20;\r\n		for(int i=0;i<20;++i)\r\n		{\r\n			int ir=rand();\r\n			if(ir&4)ir=-ir;\r\n\r\n			ci<<" "<<ir;\r\n		}\r\n		ci<<endl;\r\n	}\r\n	return 0;\r\n\r\n}\r\n', '', 15, 364544, 1, 2, '2010-10-27 18:21:16', '0001-01-01 00:00:00'),
(714, 24, 336, 2, '#include <iostream>\r\n#include <vector>\r\n#include <algorithm>\r\n#include <memory>\r\n\r\nusing namespace std;\r\n\r\nint getBitCount_method(int n)\r\n{\r\n	int count = 0;\r\n	int i;\r\n	char string[33];\r\n	itoa(n,string,2);\r\n	for(i=0;i<33;i++)\r\n	{\r\n		if(string[i]==''1'')\r\n			count++;\r\n	}\r\n\r\n	return count;\r\n}\r\n\r\nvector<int> getSortVec(vector<int> a, int count[], int n)\r\n{\r\n	vector<int> rstVec;\r\n	vector<int> vecArray[33];\r\n	for (int i = 0; i < n; ++i)\r\n	{\r\n		vecArray[count[i]].push_back(a[i]);\r\n	}\r\n\r\n	for (int i = 0; i <= 32; ++i)\r\n	{\r\n		for (int j = 0; j < vecArray[i].size(); ++j)\r\n		{\r\n			rstVec.push_back(vecArray[i][j]);\r\n		}\r\n	}\r\n\r\n	return rstVec;\r\n}\r\n\r\nint main()\r\n{\r\n	int n;\r\n	int i=0;\r\n	int x;\r\n	vector<int> number;\r\n	int count[50000] = {0};\r\n	while(cin>>n)\r\n	{\r\n		i=0;\r\n		while(i<n)\r\n		{\r\n			cin>>x;\r\n			number.push_back(x);\r\n			i++;\r\n		}\r\n		sort(number.begin(),number.end());\r\n\r\n		for (int i = 0; i < n; ++i)\r\n			count[i] = getBitCount_method(number[i]);\r\n\r\n		vector<int> rstVec = getSortVec(number, count, n);\r\n\r\n		for (int i = 0; i < rstVec.size(); i++)\r\n			cout << rstVec[i] << " ";\r\n		cout << endl;\r\n\r\n		number.clear();\r\n		memset(count,0,50000*sizeof(int));\r\n	}\r\n	return 0;\r\n}', 'Main.cpp: In function ''int main()'':\r\nMain.cpp:71:35: error: ''memset'' was not declared in this scope\r\n', 0, 0, 2, 2, '2010-10-27 18:57:16', '0001-01-01 00:00:00'),
(715, 24, 336, 2, '#include <iostream>\r\n#include <vector>\r\n#include <algorithm>\r\n#include <memory>\r\n\r\nusing namespace std;\r\n\r\nint getBitCount_method(int n)\r\n{\r\n	int count = 0;\r\n	int i;\r\n	char string[33];\r\n	itoa(n,string,2);\r\n	for(i=0;i<33;i++)\r\n	{\r\n		if(string[i]==''1'')\r\n			count++;\r\n	}\r\n\r\n	return count;\r\n}\r\n\r\nvector<int> getSortVec(vector<int> a, int count[], int n)\r\n{\r\n	vector<int> rstVec;\r\n	vector<int> vecArray[33];\r\n	for (int i = 0; i < n; ++i)\r\n	{\r\n		vecArray[count[i]].push_back(a[i]);\r\n	}\r\n\r\n	for (int i = 0; i <= 32; ++i)\r\n	{\r\n		for (int j = 0; j < vecArray[i].size(); ++j)\r\n		{\r\n			rstVec.push_back(vecArray[i][j]);\r\n		}\r\n	}\r\n\r\n	return rstVec;\r\n}\r\n\r\nint main()\r\n{\r\n	int n;\r\n	int i=0;\r\n	int x;\r\n	vector<int> number;\r\n	int count[50000] = {0};\r\n	while(cin>>n)\r\n	{\r\n		i=0;\r\n		while(i<n)\r\n		{\r\n			cin>>x;\r\n			number.push_back(x);\r\n			i++;\r\n		}\r\n		sort(number.begin(),number.end());\r\n\r\n		for (int i = 0; i < n; ++i)\r\n			count[i] = getBitCount_method(number[i]);\r\n\r\n		vector<int> rstVec = getSortVec(number, count, n);\r\n\r\n		for (int i = 0; i < rstVec.size(); i++)\r\n			cout << rstVec[i] << " ";\r\n		cout << endl;\r\n\r\n		number.clear();\r\n		for(int i = 0;i<50000;i++)\r\n		{\r\n			count[i]=0;\r\n		}\r\n	}\r\n	return 0;\r\n}', '', 46, 1277952, 4, 2, '2010-10-27 18:58:39', '0001-01-01 00:00:00'),
(716, 1, 375, 0, '#include <stdio.h>\r\n#include <iostream>\r\n#include <fstream>\r\n#include <time.h>\r\n#include <algorithm>\r\n#include <vector>\r\n#include <map>\r\n#include <string>\r\n#include <functional>\r\nusing namespace std;\r\nint gen_main();\r\nint calc_main();\r\n\r\n#include<iostream>\r\n#define maxn 10004\r\nusing namespace std;\r\nint a[maxn+1],b[maxn+1];\r\n\r\nint main(int argc, char* argv[])\r\n{\r\n	//gen_main();\r\n	//freopen("c:/ti.txt","r",stdin);\r\n	//freopen("c:/to.txt","w",stdout);\r\n\r\n	calc_main();\r\n\r\n    return 0;\r\n}\r\nint calc_main()\r\n{\r\n    int n,i,k,max;\r\n    while(scanf("%d",&n)==1)\r\n    {\r\n        for(i=0;i<n;i++)\r\n            scanf("%d",&a[i]);\r\n        max=1,b[0]=0,b[1]=a[0];\r\n        for(i=1;i<n;i++)//求最大不降子序列\r\n        {\r\n            if(a[i]>=b[max])\r\n                b[++max]=a[i];\r\n            else\r\n            {\r\n                k=max-1;\r\n                while(a[i]<b[k])\r\n                    k--;\r\n                b[k+1]=a[i];\r\n            }\r\n        }\r\n        cout<<max<<endl;\r\n    }\r\n    return 0;\r\n}\r\nint gen_main()\r\n{\r\n	srand( (unsigned)time( NULL ) );//srand()函数产生一个以当前时间开始的随机种子.应该放在for等循环语句前面 不然要很长时间等待\r\n	ofstream ci("c:/ti.txt");\r\n\r\n	int iTotalcase=1000;\r\n	//ci<<iTotalcase<<std::endl;\r\n	int icase=0;\r\n	while(icase++<50)\r\n	{\r\n		ci<<10000;\r\n		for(int i=0;i<10000;++i)\r\n		{\r\n			int ir=rand();\r\n\r\n			ci<<" "<<ir;\r\n		}\r\n		ci<<endl;\r\n	}\r\n	while(icase++<=iTotalcase)\r\n	{\r\n		ci<<20;\r\n		for(int i=0;i<20;++i)\r\n		{\r\n			int ir=rand();\r\n			ci<<" "<<ir;\r\n		}\r\n		ci<<endl;\r\n	}\r\n	return 0;\r\n\r\n}\r\n', '', 187, 450560, 1, 2, '2010-10-27 19:09:27', '0001-01-01 00:00:00'),
(717, 24, 336, 2, '#include <iostream>\r\n#include <map>\r\n#include <set>\r\n#include <cstring>\r\n\r\nusing namespace std;\r\n\r\nmap<int,set<int> > map_num;\r\nmap<int,set<int> >::iterator map_num_iter,tmpmapiter;\r\nset<int>::iterator set_iter,tmpsetiter;\r\nint nums[500001];\r\nint GetBitCount(int num)\r\n{\r\n    char buffer[65];\r\n    itoa (num,buffer,2);\r\n    int count=0;\r\n    for (int i=0;i<strlen(buffer);i++)\r\n    {\r\n        if (buffer[i]==''1'')\r\n        {\r\n            count++;\r\n        }\r\n    }\r\n\r\n\r\n\r\n    return count;\r\n}\r\n\r\nint main()\r\n{\r\n    int n;\r\n    \r\n    int tmpbcount;\r\n    while (cin>>n)\r\n    {\r\n    	\r\n        for (int i=0;i<n;i++)\r\n        {\r\n            cin>>nums[i];\r\n            tmpbcount=GetBitCount(nums[i]);\r\n            map_num[tmpbcount].insert(nums[i]);\r\n        }\r\n        for (map_num_iter=map_num.begin();\r\n                map_num_iter!=map_num.end();\r\n                map_num_iter++)\r\n        {\r\n            tmpmapiter=map_num_iter;\r\n            set<int> tmpset = map_num_iter->second;\r\n            for (set_iter=tmpset.begin();\r\n                    set_iter!=tmpset.end();\r\n                    set_iter++)\r\n            {\r\n                tmpsetiter=set_iter;\r\n                cout<<*set_iter;\r\n				tmpsetiter++;\r\n				tmpmapiter++;\r\n                if (tmpmapiter==map_num.end() &&\r\n                        tmpsetiter==tmpset.end())\r\n                {\r\n                    cout<<endl;\r\n                }\r\n                else\r\n                {\r\n                    cout<<" ";\r\n                }\r\n				tmpmapiter--;\r\n            }\r\n        }\r\n        map_num.clear();\r\n    }\r\n    return 0;\r\n}\r\n', 'Main.cpp: In function ''int GetBitCount(int)'':\r\nMain.cpp:15:23: error: ''itoa'' was not declared in this scope\r\n', 0, 0, 2, 2, '2010-10-27 19:47:08', '0001-01-01 00:00:00'),
(718, 24, 336, 2, '#include <iostream>\r\n#include <map>\r\n#include <set>\r\n#include <cstring>\r\n#include <cstdlib>\r\n\r\nusing namespace std;\r\n\r\nmap<int,set<int> > map_num;\r\nmap<int,set<int> >::iterator map_num_iter,tmpmapiter;\r\nset<int>::iterator set_iter,tmpsetiter;\r\nint nums[500001];\r\nint GetBitCount(int num)\r\n{\r\n    char buffer[65];\r\n    itoa (num,buffer,2);\r\n    int count=0;\r\n    for (int i=0;i<strlen(buffer);i++)\r\n    {\r\n        if (buffer[i]==''1'')\r\n        {\r\n            count++;\r\n        }\r\n    }\r\n\r\n\r\n\r\n    return count;\r\n}\r\n\r\nint main()\r\n{\r\n    int n;\r\n    \r\n    int tmpbcount;\r\n    while (cin>>n)\r\n    {\r\n    	\r\n        for (int i=0;i<n;i++)\r\n        {\r\n            cin>>nums[i];\r\n            tmpbcount=GetBitCount(nums[i]);\r\n            map_num[tmpbcount].insert(nums[i]);\r\n        }\r\n        for (map_num_iter=map_num.begin();\r\n                map_num_iter!=map_num.end();\r\n                map_num_iter++)\r\n        {\r\n            tmpmapiter=map_num_iter;\r\n            set<int> tmpset = map_num_iter->second;\r\n            for (set_iter=tmpset.begin();\r\n                    set_iter!=tmpset.end();\r\n                    set_iter++)\r\n            {\r\n                tmpsetiter=set_iter;\r\n                cout<<*set_iter;\r\n				tmpsetiter++;\r\n				tmpmapiter++;\r\n                if (tmpmapiter==map_num.end() &&\r\n                        tmpsetiter==tmpset.end())\r\n                {\r\n                    cout<<endl;\r\n                }\r\n                else\r\n                {\r\n                    cout<<" ";\r\n                }\r\n				tmpmapiter--;\r\n            }\r\n        }\r\n        map_num.clear();\r\n    }\r\n    return 0;\r\n}\r\n', '', 62, 3145728, 4, 2, '2010-10-27 19:48:01', '0001-01-01 00:00:00'),
(719, 24, 336, 2, '#include <iostream>\r\n#include <map>\r\n#include <set>\r\n#include <cstring>\r\n#include <cstdlib>\r\nusing namespace std;\r\n\r\nmap<int,set<int> > map_num;\r\nmap<int,set<int> >::iterator map_num_iter,tmpmapiter;\r\nset<int>::iterator set_iter,tmpsetiter;\r\nint nums[500001];\r\nint GetBitCount(int num)\r\n{\r\nint count = 0;\r\nwhile ( n != 0 )\r\n{\r\n   n = n & (n - 1);\r\n   ++count;\r\n}\r\n    return count;\r\n}\r\n\r\nint main()\r\n{\r\n    int n;\r\n    \r\n    int tmpbcount;\r\n    while (cin>>n)\r\n    {\r\n    	\r\n        for (int i=0;i<n;i++)\r\n        {\r\n            cin>>nums[i];\r\n            tmpbcount=GetBitCount(nums[i]);\r\n            map_num[tmpbcount].insert(nums[i]);\r\n        }\r\n        for (map_num_iter=map_num.begin();\r\n                map_num_iter!=map_num.end();\r\n                map_num_iter++)\r\n        {\r\n            tmpmapiter=map_num_iter;\r\n            set<int> tmpset = map_num_iter->second;\r\n            for (set_iter=tmpset.begin();\r\n                    set_iter!=tmpset.end();\r\n                    set_iter++)\r\n            {\r\n                tmpsetiter=set_iter;\r\n                cout<<*set_iter;\r\n				tmpsetiter++;\r\n				tmpmapiter++;\r\n                if (tmpmapiter==map_num.end() &&\r\n                        tmpsetiter==tmpset.end())\r\n                {\r\n                    cout<<endl;\r\n                }\r\n                else\r\n                {\r\n                    cout<<" ";\r\n                }\r\n				tmpmapiter--;\r\n            }\r\n        }\r\n        map_num.clear();\r\n    }\r\n    return 0;\r\n}\r\n', 'Main.cpp: In function ''int GetBitCount(int)'':\r\nMain.cpp:15:9: error: ''n'' was not declared in this scope\r\n', 0, 0, 2, 2, '2010-10-27 19:55:48', '0001-01-01 00:00:00'),
(720, 24, 336, 2, '#include <iostream>\r\n#include <map>\r\n#include <set>\r\n#include <cstring>\r\n#include <cstdlib>\r\nusing namespace std;\r\n\r\nmap<int,set<int> > map_num;\r\nmap<int,set<int> >::iterator map_num_iter,tmpmapiter;\r\nset<int>::iterator set_iter,tmpsetiter;\r\nint nums[500001];\r\nint GetBitCount(int n)\r\n{\r\nint count = 0;\r\nwhile ( n != 0 )\r\n{\r\n   n = n & (n - 1);\r\n   ++count;\r\n}\r\n    return count;\r\n}\r\n\r\nint main()\r\n{\r\n    int n;\r\n    \r\n    int tmpbcount;\r\n    while (cin>>n)\r\n    {\r\n    	\r\n        for (int i=0;i<n;i++)\r\n        {\r\n            cin>>nums[i];\r\n            tmpbcount=GetBitCount(nums[i]);\r\n            map_num[tmpbcount].insert(nums[i]);\r\n        }\r\n        for (map_num_iter=map_num.begin();\r\n                map_num_iter!=map_num.end();\r\n                map_num_iter++)\r\n        {\r\n            tmpmapiter=map_num_iter;\r\n            set<int> tmpset = map_num_iter->second;\r\n            for (set_iter=tmpset.begin();\r\n                    set_iter!=tmpset.end();\r\n                    set_iter++)\r\n            {\r\n                tmpsetiter=set_iter;\r\n                cout<<*set_iter;\r\n				tmpsetiter++;\r\n				tmpmapiter++;\r\n                if (tmpmapiter==map_num.end() &&\r\n                        tmpsetiter==tmpset.end())\r\n                {\r\n                    cout<<endl;\r\n                }\r\n                else\r\n                {\r\n                    cout<<" ";\r\n                }\r\n				tmpmapiter--;\r\n            }\r\n        }\r\n        map_num.clear();\r\n    }\r\n    return 0;\r\n}\r\n', '', 46, 3141632, 4, 2, '2010-10-27 19:56:15', '0001-01-01 00:00:00'),
(721, 27, 345, 4, '#include <stdio.h>\r\n#include <map>\r\n#include <string>\r\n#include <iostream>\r\n\r\nusing namespace std;\r\nint main(int argc, char* argv[])\r\n{\r\n	int n1,n2,i;\r\n	string name;\r\n    while(scanf("%d",&n1)==1){\r\n		int j=0;\r\n		string same_name="none";\r\n    	map<string,int> m;\r\n    	for(i=1;i<=n1;++i){\r\n			cin>>name;\r\n    		if(m.find(name)!=m.end()){\r\n				i--;\r\n				break;\r\n			}else{   m.insert(pair<string,int>(name,i));  }\r\n		}\r\n		scanf("%d",&n2);\r\n		for(i=1;i<=n2;++i){\r\n			cin>>name;\r\n			if(j==0 && m.find(name)!=m.end()){\r\n				same_name=name;\r\n			    j=1;\r\n			}\r\n		}\r\n		cout<<same_name<<" "<<same_name<<endl;\r\n	}\r\n    return 0;\r\n}', '', 0, 483328, 4, 2, '2010-10-27 20:07:38', '0001-01-01 00:00:00'),
(722, 1, 376, 0, '#include <stdio.h>\r\n#include <iostream>\r\n#include <fstream>\r\n#include <time.h>\r\n#include <algorithm>\r\n#include <vector>\r\n#include <map>\r\n#include <string>\r\n#include <functional>\r\nusing namespace std;\r\nint gen_main();\r\nint calc_main();\r\n\r\n\r\nint main(int argc, char* argv[])\r\n{\r\n	//gen_main();\r\n	//freopen("c:/ti.txt","r",stdin);\r\n	//freopen("c:/to.txt","w",stdout);\r\n\r\n	calc_main();\r\n\r\n    return 0;\r\n}\r\n\r\n__int64 max_multiply(int *a, int n)\r\n{\r\n    int positives = 0;\r\n    int negitives = 0;\r\n    int zeros = 0;\r\n    int minp;\r\n    int maxn, minn;\r\n    int i;\r\n    int not_use;\r\n    __int64 sum = 1;\r\n    int del = 0;\r\n    minp = 1<<30;\r\n    maxn = -minp;\r\n    minn = 0;\r\n\r\n    //统计0的个数\r\n    //负数的个数，负数的最小值，最大值\r\n    //正数的个数，正数的最小值，最大值\r\n    for (i=0; i<n; i++)\r\n    {\r\n        if (a[i] > 0)\r\n        {\r\n            positives++;\r\n            if (a[i] < minp)\r\n                minp = a[i];\r\n        }\r\n        else if (a[i] < 0)\r\n        {\r\n            negitives++;\r\n            if (a[i] > maxn)\r\n                maxn = a[i];\r\n            if (a[i] < minn)\r\n                minn = a[i];\r\n        }\r\n        else if (a[i] == 0)\r\n        {\r\n            zeros++;\r\n        }\r\n    }\r\n\r\n    //如果有0的存在\r\n    if (zeros != 0)\r\n    {\r\n\r\n        //并且0的个数不止1个，返回0\r\n        if (zeros > 1)\r\n            return 0;\r\n        //只有一个0\r\n        else\r\n        {\r\n            //负数为奇数个，直接返回0\r\n            if (negitives&0x1)\r\n                return 0;\r\n            else//除去0\r\n                not_use = 0;\r\n        }\r\n    }\r\n    //没有0\r\n    else\r\n    {\r\n        //负数的个数是奇数，除去负数的最大值\r\n        if (negitives&0x1)\r\n            not_use = maxn;\r\n        //负数的个数是偶数，如果有正数，去除一个正数最小值，否则，去除一个负数最小值\r\n        else\r\n        {\r\n            if (positives > 0)\r\n                not_use = minp;\r\n            else\r\n                not_use = minn;\r\n        }\r\n    }\r\n    for (i=0; i<n; i++)\r\n    {\r\n        if ( (a[i] == not_use) && (!del) )\r\n        {\r\n            del = 1;\r\n            continue;\r\n        }\r\n        sum *= a[i];\r\n    }\r\n    return sum;\r\n}\r\nint a[50001] = {-1, -5, -3, 1, 3, 0, 0, 2, 4, 2};\r\n\r\nint calc_main()\r\n{\r\n	int n;\r\n	while(scanf("%d",&n)==1)\r\n	{\r\n		for(int i=0;i<n;++i)\r\n		{\r\n			scanf("%d",&a[i]);\r\n		}\r\n		std::cout<<max_multiply(a,n)<<std::endl;\r\n	}\r\n    return 0;\r\n}\r\nint gen_main()\r\n{\r\n	srand( (unsigned)time( NULL ) );//srand()函数产生一个以当前时间开始的随机种子.应该放在for等循环语句前面 不然要很长时间等待\r\n	ofstream ci("c:/ti.txt");\r\n\r\n	ci<<("12 0 0 1 2 3 4 5 6 -1 -1 -12 12\\n");\r\n	ci<<("6 0 1 2 3 4 5\\n");\r\n	ci<<("6 0 -1 -2 -3 -4 -5\\n");\r\n	ci<<("6 0 1 -2 -3 -4 -5\\n");\r\n	ci<<("6 0 1 22 -3 -4 -5\\n");\r\n	ci<<("6 0 1 -2 3 4 -5\\n");\r\n	ci<<("6 0 1 -2 3 4 5\\n");\r\n	ci<<("6 1 1 -2 3 4 5\\n");\r\n	ci<<("6 1 1 2 3 4 5\\n");\r\n	ci<<("6 -8 -1 -2 -3 -4 -5\\n");\r\n	ci<<("10 1 2 3 4 -8 -1 -2 -3 -4 -5\\n");\r\n	ci<<("7 1  -8 -1 -2 -3 -4 -5\\n");\r\n	ci<<("7 1  8 -1 -2 -3 -4 -5\\n");\r\n	ci<<("7 -6 -8 -1 -2 -3 -4 -5\\n");\r\n	ci<<"8 10 11 -8 -1 -2 -3 -4 -5\\n";\r\n\r\n	int icase=6;\r\n	while(icase--)\r\n	{\r\n		int inum=50000,inum64=62;\r\n		ci<<inum;\r\n		while(inum--)\r\n		{\r\n			if(inum64-->0)\r\n			{\r\n				if(rand()&4)ci<<(" 2");\r\n				else ci<<(" -2");\r\n			}\r\n			else\r\n				ci<<((rand()&8)?" 1":" -1");\r\n		}\r\n		ci<<std::endl;\r\n\r\n	}\r\n	icase=20;\r\n	while(icase--)\r\n	{\r\n		int inum=200,inum64=62;\r\n		ci<<inum+1;\r\n		ci<<" 0";\r\n		while(inum--)\r\n		{\r\n			if(inum64-->0)\r\n			{\r\n				if(rand()&4)ci<<(" 2");\r\n				else ci<<(" -2");\r\n			}\r\n			else\r\n				ci<<((rand()&8)?" 1":" -1");\r\n		}\r\n		ci<<std::endl;\r\n\r\n	}\r\n	icase=20;\r\n	while(icase--)\r\n	{\r\n		int inum=200,inum64=62;\r\n		ci<<inum;\r\n		while(inum--)\r\n		{\r\n			if(inum64-->0)\r\n			{\r\n				if(icase&1)ci<<(" 2");\r\n				else ci<<(" -2");\r\n			}\r\n			else\r\n				ci<<((icase&1)?" 1":" -1");\r\n		}\r\n		ci<<std::endl;\r\n\r\n	}\r\n	icase=20;\r\n	while(icase--)\r\n	{\r\n		int inum=199,inum64=62;\r\n		ci<<inum;\r\n		while(inum--)\r\n		{\r\n			if(inum64-->0)\r\n			{\r\n				if(icase&1)ci<<(" 2");\r\n				else ci<<(" -2");\r\n			}\r\n			else\r\n				ci<<((icase&1)?" 1":" -1");\r\n		}\r\n		ci<<std::endl;\r\n\r\n	}\r\n	icase=20;\r\n	while(icase--)\r\n	{\r\n		int inum=201,inum64=62;\r\n		ci<<inum+1;\r\n		ci<<" 0";\r\n		while(inum--)\r\n		{\r\n			if(inum64-->0)\r\n			{\r\n				if(rand()&4)ci<<(" 2");\r\n				else ci<<(" -2");\r\n			}\r\n			else\r\n				ci<<((rand()&8)?" 1":" -1");\r\n		}\r\n		ci<<std::endl;\r\n\r\n	}\r\n	icase=20;\r\n	while(icase--)\r\n	{\r\n		int inum=200,inum64=62;\r\n		ci<<inum+2;\r\n		ci<<" 0 0";\r\n		while(inum--)\r\n		{\r\n			if(inum64-->0)\r\n			{\r\n				if(rand()&4)ci<<(" 2");\r\n				else ci<<(" -2");\r\n			}\r\n			else\r\n				ci<<((rand()&8)?" 1":" -1");\r\n		}\r\n		ci<<std::endl;\r\n\r\n	}\r\n	return 0;\r\n\r\n}\r\n', '', 78, 569344, 1, 2, '2010-10-27 20:16:17', '0001-01-01 00:00:00'),
(723, 24, 336, 2, '#include <iostream>\r\n#include <map>\r\n#include <set>\r\n#include <cstring>\r\n#include <cstdlib>\r\nusing namespace std;\r\n\r\nmap<int,set<int> > map_num;\r\nmap<int,set<int> >::iterator map_num_iter,tmpmapiter;\r\nset<int>::iterator set_iter,tmpsetiter;\r\nint nums[500001];\r\nint GetBitCount(int n)\r\n{\r\nint count = 0;\r\nwhile ( n != 0 )\r\n{\r\n   n = n & (n - 1);\r\n   ++count;\r\n}\r\n    return count;\r\n}\r\n\r\nint main()\r\n{\r\n    int n;\r\n    \r\n    int tmpbcount;\r\n    while (cin>>n)\r\n    {\r\n    	\r\n        for (int i=0;i<n;i++)\r\n        {\r\n            cin>>nums[i];\r\n            tmpbcount=GetBitCount(nums[i]);\r\n            map_num[tmpbcount].insert(nums[i]);\r\n        }\r\n        for (map_num_iter=map_num.begin();\r\n                map_num_iter!=map_num.end();\r\n                map_num_iter++)\r\n        {\r\n            tmpmapiter=map_num_iter;\r\n            set<int> tmpset = map_num_iter->second;\r\n            for (set_iter=tmpset.begin();\r\n                    set_iter!=tmpset.end();\r\n                    set_iter++)\r\n            {\r\n                tmpsetiter=set_iter;\r\n                cout<<*set_iter<<" ";\r\n				tmpsetiter++;\r\n				tmpmapiter++;\r\n        \r\n                   \r\n                \r\n              \r\n                    \r\n             \r\n				tmpmapiter--;\r\n            }\r\n        }\r\n       cout<<endl;\r\n        map_num.clear();\r\n    }\r\n    return 0;\r\n}\r\n', '', 62, 3145728, 4, 2, '2010-10-27 20:21:00', '0001-01-01 00:00:00'),
(724, 24, 336, 2, '#include <iostream>\r\n#include <vector>\r\nusing namespace std;\r\n\r\n/* 统计一个整数的二进制序列中"1"的个数 */\r\nint getBitCount_method1(int n)\r\n{\r\nint count = 0;\r\nfor (int i = 1; i <= 32; ++i)\r\n{\r\n   if ( n & 0x00000001) //取n的二进制序列的最低位\r\n   {\r\n    ++count;\r\n   }\r\n   n = n >> 1;\r\n}\r\n\r\nreturn count;\r\n}\r\n\r\n/* 统计一个整数的二进制序列中"1"的个数 */\r\nint getBitCount_method2(int n)\r\n{\r\nint count = 0;\r\nwhile ( n != 0 )\r\n{\r\n   n = n & (n - 1);\r\n   ++count;\r\n}\r\n\r\nreturn count;\r\n}\r\n\r\n/* 基本的快速排序 */\r\nvoid quickSort(int a[], int startIndex, int endIndex)\r\n{\r\nif ( endIndex <= startIndex )\r\n{\r\n   return;\r\n}\r\nif ( endIndex - startIndex == 1 )\r\n{\r\n   if ( a[startIndex] > a[endIndex] )\r\n   {\r\n    int tmp = a[startIndex];\r\n    a[startIndex] = a[endIndex];\r\n    a[endIndex] = tmp;\r\n   }\r\n   return;\r\n}\r\n\r\nint centerIndex = startIndex;\r\nint i = startIndex;\r\nint j = endIndex;\r\nwhile ( i <= j )\r\n{\r\n   while ( (i <= endIndex) && (a[i] <= a[centerIndex]) )\r\n   {\r\n    ++i;\r\n   }\r\n   while ( a[j] > a[centerIndex] )\r\n   {\r\n    --j;\r\n   }\r\n   if ( i <= j )\r\n   {\r\n    int tmp = a[i];\r\n    a[i] = a[j];\r\n    a[j] = tmp;\r\n   }\r\n}\r\nint tmp = a[j];\r\na[j] = a[centerIndex];\r\na[centerIndex] = tmp;\r\ncenterIndex = j;\r\nquickSort(a, startIndex, centerIndex -1);\r\nquickSort(a, centerIndex+1, endIndex);\r\n}\r\n\r\n/* 一种基数排序,这是33个vector，因为一个整数"1"的个数顶多为0~32 */\r\nvector<int> getSortVec(int a[], int count[], int n)\r\n{\r\nvector<int> rstVec;\r\nvector<int> vecArray[33]; //利用vector作为"链式桶",表示0~32个"1"的桶\r\nfor (int i = 0; i < n; ++i)\r\n{\r\n   vecArray[count[i]].push_back(a[i]); //装进各个桶中，散开\r\n}\r\n\r\n//收集各个桶\r\nfor (int i = 0; i < 32; ++i)\r\n{\r\n   for (int j = 0; j < vecArray[i].size(); ++j)\r\n   {\r\n    rstVec.push_back(vecArray[i][j]);\r\n   }\r\n}\r\n\r\nreturn rstVec;\r\n}\r\n\r\n/* 一种特殊的快速排序 */\r\n/* 代码暂时省略，后来补上 */\r\n\r\nint main()\r\n{\r\nint a[10] = {0,-1,-2,7,6,5,4,3,2,1};\r\nquickSort(a, 0, 9); //首先进行快速排序(相当于基数排序的 辅助字段排序\r\nint count[10] = {0};\r\n\r\n//计算排好序的数组中每个数字二进制中"1"的个数\r\nfor (int i = 0; i < 10; ++i)\r\n{\r\n   count[i] = getBitCount_method2(a[i]);\r\n}\r\n\r\nvector<int> rstVec = getSortVec(a, count, 10);\r\n\r\nfor (int i = 0; i < rstVec.size(); ++i)\r\n{\r\n   cout << rstVec[i] << " ";\r\n}\r\ncout << endl;\r\n\r\nreturn 0;\r\n}', '', 0, 372736, 4, 2, '2010-10-27 20:33:13', '0001-01-01 00:00:00'),
(725, 27, 345, 4, '#include <stdio.h>\r\n#include <map>\r\n#include <string>\r\n#include <iostream>\r\n\r\nusing namespace std;\r\nint main()\r\n{\r\n	int n1,n2,i;\r\n	string name;\r\n    while(scanf("%d",&n1)==1){\r\n		int j=0;\r\n		string same_name="none";\r\n    	map<string,int> m;\r\n    	for(i=1;i<=n1;++i){\r\n			cin>>name;\r\n    		if(m.find(name)!=m.end()){\r\n				for(++i;i<=n1;++i) cin>>name;\r\n			}else{   m.insert(pair<string,int>(name,i));  }\r\n		}\r\n		scanf("%d",&n2);\r\n		for(i=1;i<=n2;++i){\r\n			cin>>name;\r\n			if( m.find(name)!=m.end()){\r\n				same_name=name;\r\n			    for(++i;i<=n2;++i) cin>>name;\r\n			}\r\n		}\r\n		cout<<same_name<<" "<<same_name<<endl;\r\n	}\r\n    return 0;\r\n} ', '', 0, 483328, 4, 2, '2010-10-27 20:47:20', '0001-01-01 00:00:00'),
(726, 17, 345, 4, '#include<iostream>\r\n#include<vector>\r\n#include<algorithm>\r\n#include<stdio.h>\r\n#include<string.h>\r\nusing namespace std;\r\nbool flag;\r\nbool cmp(const string a,const string b)\r\n{\r\n    return a<b;\r\n}\r\nint main()\r\n{   \r\n    vector<string>l1,l2;\r\n    string snake;\r\n    int n,m;\r\n    while(scanf("%d",&n)!=EOF)\r\n    {   \r\n       for(int i=0;i<n;i++)\r\n        {\r\n               cin>>snake;\r\n               l1.push_back(snake);\r\n        }\r\n        cin>>m;\r\n        for(int i=0;i<m;i++)\r\n        {\r\n                cin>>snake;\r\n                l2.push_back(snake);\r\n        }\r\n        sort(l1.begin(),l1.end(),cmp);\r\n        vector<string>::iterator result;\r\n        for(int i=0;i<m;i++)\r\n        {\r\n              result = find(l1.begin( ),l1.end( ),l2[i]); //查找3\r\n              if (result == l1.end( )) \r\n                 {flag=0;}\r\n              else //找到\r\n              {flag=1;\r\n  \r\n               break;\r\n             }\r\n         }\r\n         if(flag)\r\n          cout<<*result<<" "<<*result<<endl;\r\n          else\r\n          cout<<"none"<<" "<<"none"<<endl;\r\n         l1.clear();\r\n         l2.clear();\r\n      }\r\n        return 0;\r\n}\r\n', '', 0, 487424, 4, 2, '2010-10-28 08:00:14', '0001-01-01 00:00:00'),
(727, 6, 374, 5, '#include <stdio.h>\r\n\r\nint main()\r\n{\r\n	int T,cnt=0,rs,rt,ts,tt,res,tmp,v,i,n;\r\n	scanf("%d",&T);\r\n	while(T--)\r\n	{\r\n	   scanf("%d",&n);\r\n	   for(i=1;i<=n;++i)\r\n	   {\r\n		   scanf("%d",&v);\r\n		   if(i==1)\r\n		   {\r\n			  tmp=res=v;\r\n			  rs=rt=ts=tt=i;\r\n		   }\r\n		   else\r\n		   {\r\n		     if(tmp<0) \r\n			 {\r\n				tmp=v;\r\n				ts=tt=i;\r\n			 }\r\n			 else tmp+=v,tt++;\r\n\r\n			 if(tmp>res)\r\n			 {\r\n				res=tmp;\r\n				rs=ts;\r\n				rt=tt;\r\n			 }\r\n		   }\r\n	   }\r\n	   if(cnt!=0) printf("\\n"); \r\n	   printf("Case %d:\\n",++cnt);\r\n	   printf("%d %d %d\\n",res,rs,rt);\r\n	}\r\n	return 0;\r\n}', '', 15, 258048, 1, 2, '2010-10-28 08:08:43', '0001-01-01 00:00:00'),
(728, 6, 374, 5, '#include <stdio.h>\r\n\r\nint main()\r\n{\r\n    int T,n,rs,rt,v,res,tmp,i,ts,tt,cnt=0;\r\n    scanf("%d",&T);\r\n    while(T--)\r\n    {\r\n       scanf("%d",&n);\r\n       for(i=1;i<=n;++i)\r\n       {\r\n           scanf("%d",&v);\r\n           if(i==1) \r\n           {\r\n              res=tmp=v;\r\n              rs=rt=ts=tt=i;\r\n           }\r\n           else\r\n           {\r\n              if(tmp<0) \r\n              {\r\n                 tmp=v;\r\n                 ts=tt=i;\r\n              }\r\n              else \r\n              {\r\n                 tmp+=v;\r\n                 tt++;\r\n              }\r\n              \r\n              if(tmp>res)\r\n              {\r\n                 res=tmp;\r\n                 rs=ts;\r\n                 rt=tt;\r\n              }\r\n           }\r\n       }\r\n       if(cnt!=0) printf("\\n");\r\n       printf("Case %d:\\n",++cnt);\r\n       printf("%d %d %d\\n",res,rs,rt);\r\n    }\r\n    return 0;\r\n}\r\n', '', 15, 262144, 1, 2, '2010-10-28 08:12:05', '0001-01-01 00:00:00'),
(729, 31, 335, 2, '#include <stdio.h>\r\n\r\nint f(int a,int b)\r\n{\r\n	int m = a^b;\r\n	int count = 0;\r\n	while(m != 0)\r\n	{\r\n		m &= (m-1);\r\n		count ++;\r\n	}\r\n	return count;\r\n}\r\nint main()\r\n{\r\n	int a,b,c[100],n;\r\n	while(scanf("%d%d",&a,&b)==2)\r\n	{\r\n		n = f(a,b);\r\n		printf("%d\\n",n);\r\n	}\r\n	return 0;\r\n}', '', 78, 262144, 1, 1, '2010-10-28 08:12:27', '0001-01-01 00:00:00'),
(730, 10, 336, 2, '#include <stdio.h>\r\n#include <iostream>\r\n#include <vector>\r\n#include <algorithm>\r\n#include <iterator>\r\n#define POW(c) (1<<(c))\r\n#define MASK(c) (((unsigned long)-1) / (POW(POW(c)) + 1))\r\n#define ROUND(n, c) (((n) & MASK(c)) + ((n) >> POW(c) & MASK(c)))\r\nusing namespace std;\r\nint bit_count(unsigned int n)\r\n{\r\nn = ROUND(n, 0);\r\nn = ROUND(n, 1);\r\nn = ROUND(n, 2);\r\nn = ROUND(n, 3);\r\nn = ROUND(n, 4);\r\nreturn n;\r\n}\r\nbool compare(int a,int b)\r\n{\r\n   if(bit_count(a)==bit_count(b))\r\n    return a<b;\r\n   else \r\n    return bit_count(a)<bit_count(b);\r\n}\r\nint main()\r\n{\r\n int num,size,i=0;\r\n vector<int> temp;\r\n while(EOF != scanf("%d",&size))\r\n {\r\n  i = 0;\r\n  temp.clear();\r\n   while(i != size)\r\n   {\r\n  scanf("%d",&num);\r\n  temp.push_back(num);\r\n  i++;\r\n   }\r\n  sort(temp.begin(),temp.end(),compare);\r\n  for(vector<int>::iterator iter = temp.begin();\r\n      iter != temp.end();iter++)\r\n   printf("%d ",*iter);\r\n   printf("\\n");\r\n }\r\n return 0;\r\n}\r\n', '', 31, 618496, 3, 2, '2010-10-28 08:12:33', '0001-01-01 00:00:00'),
(731, 27, 345, 4, '#include <stdio.h>\r\n#include <map>\r\n#include <string>\r\n#include <iostream>\r\n\r\nusing namespace std;\r\nint main()\r\n{\r\n	int n1,n2,i;\r\n	string name;\r\n    while(scanf("%d",&n1)==1){\r\n		string same_name="none";\r\n    	map<string,int> m;\r\n    	for(i=1;i<=n1;++i){\r\n			cin>>name;\r\n    		if(m.find(name)!=m.end()){\r\n				for(++i;i<=n1;++i) cin>>name;\r\n			}else{   m.insert(pair<string,int>(name,i));  }\r\n		}\r\n		scanf("%d",&n2);\r\n		for(i=1;i<=n2;++i){\r\n			cin>>name;\r\n			if( m.find(name)!=m.end()){\r\n				same_name=name;\r\n			    for(++i;i<=n2;++i) cin>>name;\r\n			}\r\n		}\r\n		cout<<same_name<<" "<<same_name<<endl;\r\n	}\r\n    return 0;\r\n} \r\n', '', 0, 483328, 4, 2, '2010-10-28 08:13:44', '0001-01-01 00:00:00'),
(732, 6, 374, 5, '#include<stdio.h>\r\nint i,cas,j,k,t,max,s,e,n,x;\r\nint main()\r\n{\r\n   scanf("%d",&cas);\r\n   for(i=0;i<cas;i++)\r\n   {\r\n         scanf("%d",&n);\r\n         max=-99999999;\r\n         for(j=k=1,t=0;j<=n;j++)\r\n         {\r\n               scanf("%d",&x);\r\n               t+=x;\r\n               if(t>max) \r\n               {\r\n                   max=t; \r\n                   s=k;\r\n                   e=j;\r\n                }\r\n                if(t<0)\r\n                {\r\n                   k=j+1;\r\n                   t=0;\r\n                }\r\n         }          \r\n         printf("Case %d:\\n",i+1);\r\n         printf("%d %d %d\\n",max,s,e);\r\n         if(i!=cas-1) printf("\\n");\r\n   }\r\n   return 0;\r\n}', '', 15, 262144, 1, 2, '2010-10-28 08:14:53', '0001-01-01 00:00:00');
INSERT INTO `tbl_submitions` (`id`, `user_id`, `problem_id`, `exercise_id`, `source`, `result`, `used_time`, `used_memory`, `status`, `compiler_id`, `created`, `modified`) VALUES
(733, 10, 336, 2, '#include <stdio.h>\r\n#include <iostream>\r\n#include <vector>\r\n#include <algorithm>\r\n#include <iterator>\r\n#define POW(c) (1<<(c))\r\n#define MASK(c) (((unsigned long)-1) / (POW(POW(c)) + 1))\r\n#define ROUND(n, c) (((n) & MASK(c)) + ((n) >> POW(c) & MASK(c)))\r\nusing namespace std;\r\nint bit_count(unsigned int n)\r\n{\r\nn = ROUND(n, 0);\r\nn = ROUND(n, 1);\r\nn = ROUND(n, 2);\r\nn = ROUND(n, 3);\r\nn = ROUND(n, 4);\r\nreturn n;\r\n}\r\nbool compare(int a,int b)\r\n{\r\n   if(bit_count(a)==bit_count(b))\r\n    return a<b;\r\n   else \r\n    return bit_count(a)<bit_count(b);\r\n}\r\nint main()\r\n{\r\n int num,size,i=0;\r\n vector<int> temp;\r\n while(EOF != scanf("%d",&size))\r\n {\r\n  i = 0;\r\n  temp.clear();\r\n   while(i != size)\r\n   {\r\n  scanf("%d",&num);\r\n  temp.push_back(num);\r\n  i++;\r\n   }\r\n  sort(temp.begin(),temp.end(),compare);\r\n  for(vector<int>::iterator iter = temp.begin();\r\n      iter != temp.end();iter++)\r\n   printf("%d ",*iter);\r\n }\r\n return 0;\r\n}\r\n', '', 31, 622592, 3, 2, '2010-10-28 08:15:43', '0001-01-01 00:00:00'),
(734, 6, 374, 5, '#include <stdio.h>\r\n\r\nint main()\r\n{\r\n    int T,n,rs,rt,v,res,tmp,i,ts,tt,cnt=0;\r\n    scanf("%d",&T);\r\n    while(T--)\r\n    {\r\n       scanf("%d",&n);\r\n       for(i=1;i<=n;++i)\r\n       {\r\n           scanf("%d",&v);\r\n           if(i==1) \r\n           {\r\n              res=tmp=v;\r\n              rs=rt=ts=tt=i;\r\n           }\r\n           else\r\n           {\r\n              if(tmp<0) \r\n              {\r\n                 tmp=v;\r\n                 ts=tt=i;\r\n              }\r\n              else \r\n              {\r\n                 tmp+=v;\r\n                 tt++;\r\n              }\r\n              \r\n              if(tmp>res)\r\n              {\r\n                 res=tmp;\r\n                 rs=ts;\r\n                 rt=tt;\r\n              }\r\n           }\r\n       }\r\n       printf("Case %d:\\n",++cnt);\r\n       printf("%d %d %d\\n\\n",res,rs,rt);\r\n    }\r\n    return 0;\r\n}\r\n', '', 15, 258048, 3, 2, '2010-10-28 08:18:28', '0001-01-01 00:00:00'),
(735, 6, 375, 5, '#include <stdio.h>\r\n#define N 500000\r\nint a[N];\r\n\r\nint main()\r\n{\r\n	int n,len,v,low,high,mid,i;\r\n	while(scanf("%d",&n)!=EOF)\r\n	{\r\n	    scanf("%d",&v);\r\n		len=0;\r\n		a[++len]=v;\r\n		for(i=1;i<n;++i)\r\n		{\r\n		    scanf("%d",&v);\r\n			if(v>a[len]) a[++len]=v;\r\n			else\r\n			{\r\n			   low=1,high=len;\r\n			   while(low<=high)\r\n			   {\r\n				  mid=(low+high)>>1;\r\n				  if(a[mid]<v) low=mid+1;\r\n				  else         high=mid-1;\r\n			   }\r\n			}\r\n			a[low]=v;\r\n		}\r\n		printf("%d\\n",len);\r\n	}\r\n	return 0;\r\n}	\r\n', '', 171, 2265088, 4, 2, '2010-10-28 08:27:16', '0001-01-01 00:00:00'),
(736, 10, 336, 2, '#include <stdio.h>\r\n#include <iostream>\r\n#include <vector>\r\n#include <algorithm>\r\n#include <iterator>\r\n#define POW(c) (1<<(c))\r\n#define MASK(c) (((unsigned long)-1) / (POW(POW(c)) + 1))\r\n#define ROUND(n, c) (((n) & MASK(c)) + ((n) >> POW(c) & MASK(c)))\r\nusing namespace std;\r\nint bit_count(unsigned int n)\r\n{\r\nn = ROUND(n, 0);\r\nn = ROUND(n, 1);\r\nn = ROUND(n, 2);\r\nn = ROUND(n, 3);\r\nn = ROUND(n, 4);\r\nreturn n;\r\n}\r\nbool compare(int a,int b)\r\n{\r\n   if(bit_count(a)==bit_count(b))\r\n    return a<b;\r\n   else \r\n    return bit_count(a)<bit_count(b);\r\n}\r\nint main()\r\n{\r\n int num,size,i;\r\n vector<int> temp;\r\n while(EOF != scanf("%d",&size))\r\n {\r\n	if(size == 0)\r\n	  continue;\r\n  i = 0;\r\n  temp.clear();\r\n\r\n   while(i != size)\r\n   {\r\n  scanf("%d",&num);\r\n  temp.push_back(num);\r\n  i++;\r\n   }\r\n\r\n  sort(temp.begin(),temp.end(),compare);\r\n\r\n  for(vector<int>::iterator iter = temp.begin();\r\n      iter != temp.end();iter++)\r\n   printf("%d ",*iter);\r\n   printf("\\b");\r\n   printf("\\n");\r\n }\r\n return 0;\r\n}\r\n', '', 31, 622592, 4, 2, '2010-10-28 08:29:06', '0001-01-01 00:00:00'),
(737, 6, 375, 5, '#include <stdio.h>\r\n#include <string.h>\r\n#include <algorithm>\r\nusing namespace std;\r\n#define N 50010\r\nint b[N];\r\n\r\nint main()\r\n{\r\n    int i,n,high,low,mid,len,tmp;\r\n    while(scanf("%d",&n)!=EOF)\r\n    {\r\n       scanf("%d",&tmp);\r\n           \r\n       len=0;\r\n       b[++len]=tmp;\r\n       for(i=1;i<n;++i)\r\n       {\r\n           scanf("%d",&tmp);\r\n           //printf("%d %d\\n",tmp,b[1]);\r\n           if(tmp>b[len]) b[++len]=tmp;\r\n           else\r\n           {\r\n              low=1,high=len;\r\n              while(low<=high)\r\n              {\r\n                 mid=(low+high)>>1;\r\n                 if(b[mid]<tmp) low=mid+1;\r\n                 else           high=mid-1;\r\n              }\r\n              b[low]=tmp;\r\n           }\r\n       }\r\n       printf("%d\\n",len);\r\n    }\r\n    return 0;\r\n}', '', 171, 454656, 4, 2, '2010-10-28 08:29:36', '0001-01-01 00:00:00'),
(738, 10, 336, 2, '#include <stdio.h>\r\n#include <iostream>\r\n#include <vector>\r\n#include <algorithm>\r\n#include <iterator>\r\n#define POW(c) (1<<(c))\r\n#define MASK(c) (((unsigned long)-1) / (POW(POW(c)) + 1))\r\n#define ROUND(n, c) (((n) & MASK(c)) + ((n) >> POW(c) & MASK(c)))\r\nusing namespace std;\r\nint bit_count(unsigned int n)\r\n{\r\nn = ROUND(n, 0);\r\nn = ROUND(n, 1);\r\nn = ROUND(n, 2);\r\nn = ROUND(n, 3);\r\nn = ROUND(n, 4);\r\nreturn n;\r\n}\r\nbool compare(int a,int b)\r\n{\r\n   if(bit_count(a)==bit_count(b))\r\n    return a<b;\r\n   else \r\n    return bit_count(a)<bit_count(b);\r\n}\r\nint main()\r\n{\r\n int num,size,i;\r\n vector<int> temp;\r\n while(EOF != scanf("%d",&size))\r\n {\r\n  i = 0;\r\n  temp.clear();\r\n\r\n   while(i != size)\r\n   {\r\n  scanf("%d",&num);\r\n  temp.push_back(num);\r\n  i++;\r\n   }\r\n\r\n  sort(temp.begin(),temp.end(),compare);\r\n\r\n  for(vector<int>::iterator iter = temp.begin();\r\n      iter != temp.end();iter++)\r\n   printf("%d ",*iter);\r\n   printf("\\b");\r\n   printf("\\n");\r\n }\r\n return 0;\r\n}\r\n', '', 31, 618496, 4, 2, '2010-10-28 08:31:01', '0001-01-01 00:00:00'),
(739, 6, 375, 5, '#include <stdio.h>\r\n#define N 50010\r\nint a[N],dp[N];\r\n\r\nint main()\r\n{\r\n    int i,j,n,res;\r\n    while(scanf("%d",&n)!=EOF)\r\n    {\r\n          for(i=0;i<n;++i) scanf("%d",a+i);\r\n          \r\n          res=dp[0]=1;\r\n          for(i=1;i<n;++i)\r\n          {\r\n              dp[i]=1;\r\n              for(j=0;j<i;++j)\r\n              {\r\n                 if(a[j]<=a[i]&&dp[j]+1>dp[i]) dp[i]=dp[j]+1;\r\n              }\r\n              if(dp[i]>res) res=dp[i];\r\n          }\r\n          printf("%d\\n",res);\r\n    }\r\n    return 0;\r\n}', '', 500, 655360, 5, 2, '2010-10-28 08:33:11', '0001-01-01 00:00:00'),
(740, 10, 336, 2, '#include<stdio.h>\r\nint main()\r\n{\r\n   int i,size,k,temp,shuzu[1000],count;\r\n   int kmin,kmax;\r\n   for(i = 0; i != 1000 ;i++)\r\n    shuzu[i] = 0;\r\n   scanf("%d",&size);\r\n   scanf("%d",&k);\r\n   for(i = 0 ; i != size ; i++)\r\n   {\r\n    scanf("%d",&temp);\r\n    shuzu[temp] +=1;\r\n   }\r\n   count = 0;\r\n   i = 0;\r\n   while(count<k+1)\r\n   {\r\n    ++i;\r\n    count += shuzu[i];\r\n   }    \r\n   kmin = i;\r\n   count = 0;\r\n   i = 1000;\r\n   while(count<k+1)\r\n   {\r\n    --i;\r\n    count += shuzu[i];\r\n   }    \r\n   kmax = i;\r\n   printf("\\n%d",kmax - kmin);\r\n   return 0;\r\n}', '', 0, 262144, 7, 1, '2010-10-28 08:33:58', '0001-01-01 00:00:00'),
(741, 6, 375, 5, '#include <stdio.h>\r\n#include <string.h>\r\n#include <algorithm>\r\nusing namespace std;\r\n#define N 50010\r\nint b[N];\r\n\r\nint main()\r\n{\r\n    int i,n,high,low,mid,len,tmp;\r\n    while(scanf("%d",&n)!=EOF)\r\n    {\r\n       scanf("%d",&tmp);\r\n           \r\n       len=0;\r\n       b[++len]=tmp;\r\n       for(i=1;i<n;++i)\r\n       {\r\n           scanf("%d",&tmp);\r\n           //printf("%d %d\\n",tmp,b[1]);\r\n           if(tmp>=b[len]) b[++len]=tmp;\r\n           else\r\n           {\r\n              low=1,high=len;\r\n              while(low<=high)\r\n              {\r\n                 mid=(low+high)>>1;\r\n                 if(b[mid]<tmp) low=mid+1;\r\n                 else           high=mid-1;\r\n              }\r\n              b[low]=tmp;\r\n           }\r\n       }\r\n       printf("%d\\n",len);\r\n    }\r\n    return 0;\r\n}', '', 156, 458752, 4, 2, '2010-10-28 08:34:13', '0001-01-01 00:00:00'),
(742, 27, 345, 4, '#include <stdio.h>\r\n#include <map>\r\n#include <string>\r\n#include <iostream>\r\n\r\nusing namespace std;\r\nint main()\r\n{\r\n	int n1,n2,i;\r\n	string name;\r\n    while(scanf("%d",&n1)==1){\r\n		string same_name="none";\r\n    	map<string,int> m;\r\n\r\n    	for(i=1;i<=n1;++i){\r\n			cin>>name;\r\n    		if(m.find(name)!=m.end()){\r\n				for(++i;i<=n1;++i) cin>>name;\r\n			}else{   m.insert(pair<string,int>(name,i));  }\r\n		}\r\n\r\n		scanf("%d",&n2);\r\n		for(i=1;i<=n2;++i){\r\n			cin>>name;\r\n			if( m.find(name)!=m.end()){\r\n				if(m.find(same_name)!=m.end()){\r\n			    	if(m[same_name]>m[name])\r\n						same_name=name;\r\n				}else same_name=name;\r\n			}\r\n		}\r\n\r\n		cout<<same_name<<" "<<same_name<<endl;\r\n	}\r\n    return 0;\r\n} \r\n', '', 0, 479232, 4, 2, '2010-10-28 08:44:03', '0001-01-01 00:00:00'),
(743, 30, 375, 5, '#include <stdio.h>\r\n#include <iostream>\r\n#include <vector>\r\n\r\nusing namespace std;\r\n\r\nvector< int > X(vector< int > h,int* m)\r\n{\r\n	(*m)++;\r\n	vector < int > h_1;\r\n	int max_h=h[0];\r\n	for(int i=1;i<h.size();i++)\r\n	{\r\n		if(h[i]>max_h)\r\n			h_1.push_back(h[i]);\r\n		else\r\n			max_h=h[i];\r\n	}\r\n	return h_1;\r\n}\r\n\r\nint main()\r\n{\r\n	int n;\r\n	vector< int > H;\r\n	while(scanf("%d",&n)==1)\r\n	{\r\n		int height;\r\n		vector< int > H;\r\n		for(int i=0;i<n;i++)\r\n		{\r\n			scanf("%d",&height);\r\n			H.push_back(height);\r\n		}\r\n		int m;\r\n		int* sum=&m;\r\n		(*sum)=0;\r\n		while(!H.empty())\r\n			H=X(H,sum);\r\n		printf("%d\\n",*sum);\r\n	}\r\n	return 0;\r\n}\r\n', '', 500, 1433600, 5, 2, '2010-10-28 08:47:09', '0001-01-01 00:00:00'),
(744, 6, 375, 5, '#include <stdio.h> \r\n#define M 100000 \r\nint x[M],y[M]; \r\nint main() \r\n{ \r\n    int n,i,j,c; \r\n    y[0]=0; \r\n    while(scanf("%d",&n)!=EOF) \r\n    { \r\n                              c=1; \r\n                              for(i=0;i<n;i++) \r\n                              { \r\n                                               scanf("%d",&x[i]); \r\n                                               for(j=0;j<c;j++) \r\n                                                     if(x[i]<y[j]) { y[j]=x[i];break;} \r\n                                               if(j==c) {y[c]=x[i];c++;} \r\n                              }                                         \r\n                              printf("%d\\n",c-1);                        \r\n    } \r\n    return 0; \r\n}', '', 249, 1060864, 1, 2, '2010-10-28 08:48:18', '0001-01-01 00:00:00'),
(745, 10, 336, 2, '#include <stdio.h>\r\n#include <iostream>\r\n#include <vector>\r\n#include <algorithm>\r\n#include <iterator>\r\n#define POW(c) (1<<(c))\r\n#define MASK(c) (((unsigned long)-1) / (POW(POW(c)) + 1))\r\n#define ROUND(n, c) (((n) & MASK(c)) + ((n) >> POW(c) & MASK(c)))\r\nusing namespace std;\r\nint bit_count(unsigned int n)\r\n{\r\nn = ROUND(n, 0);\r\nn = ROUND(n, 1);\r\nn = ROUND(n, 2);\r\nn = ROUND(n, 3);\r\nn = ROUND(n, 4);\r\nreturn n;\r\n}\r\nbool compare(int a,int b)\r\n{\r\n   if(bit_count(a)==bit_count(b))\r\n    return a<b;\r\n   else \r\n    return bit_count(a)<bit_count(b);\r\n}\r\nint main()\r\n{\r\n int num,size,i;\r\n vector<int> temp;\r\n while(EOF != scanf("%d",&size))\r\n {\r\n  i = 0;\r\n  temp.clear();\r\n\r\n   while(i != size)\r\n   {\r\n  scanf("%d",&num);\r\n  temp.push_back(num);\r\n  i++;\r\n   }\r\n  sort(temp.begin(),temp.end(),compare);\r\n\r\n  vector<int>::iterator iter = temp.begin();\r\n  for(i=0;i != size;i++)\r\n  {\r\n	  if(i+1 == size)\r\n		printf("%d",*iter);\r\n	  else printf("%d ",*iter);\r\n	  ++iter;\r\n  }\r\n   printf("\\n");\r\n }\r\n return 0;\r\n}', '', 155, 884736, 1, 2, '2010-10-28 08:50:02', '0001-01-01 00:00:00'),
(746, 6, 376, 5, '#include <stdio.h>\r\n#define N 50010\r\nint s[N],t[N],a[N];\r\n\r\nint main()\r\n{\r\n	int n,i;\r\n	__int64 res,tmp;\r\n	while(scanf("%d",&n)!=EOF)\r\n	{\r\n	   s[0]=t[n+1]=1;\r\n	   for(i=1;i<=n;++i)\r\n	   {\r\n		   scanf("%d",a+i);\r\n		   s[i]=s[i-1]*a[i];\r\n	   }\r\n\r\n	   for(i=n;i>=1;--i)\r\n	   {\r\n		   t[i]=t[i+1]*a[i];\r\n		   tmp=s[i-1]*t[i+1];\r\n		   if(i==n||tmp>res) res=tmp;\r\n	   }\r\n	   printf("%I64d\\n",res);\r\n	}\r\n	return 0;\r\n}', '', 78, 860160, 4, 2, '2010-10-28 08:56:00', '0001-01-01 00:00:00'),
(747, 6, 376, 5, '#include <stdio.h>\r\n#define N 50010\r\nint s[N],t[N],a[N];\r\n\r\nint main()\r\n{\r\n	int n,i;\r\n	long long res,tmp;\r\n	while(scanf("%d",&n)!=EOF)\r\n	{\r\n	   s[0]=t[n+1]=1;\r\n	   for(i=1;i<=n;++i)\r\n	   {\r\n		   scanf("%d",a+i);\r\n		   s[i]=s[i-1]*a[i];\r\n	   }\r\n\r\n	   for(i=n;i>=1;--i)\r\n	   {\r\n		   t[i]=t[i+1]*a[i];\r\n		   tmp=s[i-1]*t[i+1];\r\n		   if(i==n||tmp>res) res=tmp;\r\n	   }\r\n	   printf("%I64d\\n",res);\r\n	}\r\n	return 0;\r\n}', '', 78, 860160, 4, 2, '2010-10-28 09:00:00', '0001-01-01 00:00:00'),
(748, 6, 376, 5, '#include <stdio.h>\r\n#define N 50010\r\nint s[N],t[N],a[N];\r\n\r\nint main()\r\n{\r\n	int n,i;\r\n	long long res,tmp;\r\n	while(scanf("%d",&n)!=EOF)\r\n	{\r\n	   s[0]=t[n+1]=1;\r\n	   for(i=1;i<=n;++i)\r\n	   {\r\n		   scanf("%d",a+i);\r\n		   s[i]=s[i-1]*a[i];\r\n	   }\r\n\r\n	   for(i=n;i>=1;--i)\r\n	   {\r\n		   t[i]=t[i+1]*a[i];\r\n		   tmp=s[i-1]*t[i+1];\r\n		   if(i==n||tmp>res) res=tmp;\r\n	   }\r\n	   printf("lld\\n",res);\r\n	}\r\n	return 0;\r\n}', '', 78, 860160, 4, 2, '2010-10-28 09:03:09', '0001-01-01 00:00:00'),
(749, 27, 345, 4, '#include <stdio.h>\r\n#include <map>\r\n#include <string>\r\n#include <iostream>\r\n\r\nusing namespace std;\r\nint main()\r\n{\r\n	int n1,n2,i;\r\n	string name;\r\n    while(scanf("%d",&n1)==1){\r\n		string same_name1="none";\r\n		string same_name2="none";\r\n		string last_name="none";\r\n    	map<string,int> m;\r\n\r\n    	for(i=1;i<=n1;++i){\r\n			cin>>name;\r\n    		if(m.find(name)!=m.end()){\r\n				for(++i;i<=n1;++i) cin>>name;\r\n				last_name=name;\r\n			}else{   m.insert(pair<string,int>(name,i));  }\r\n		}\r\n\r\n		scanf("%d",&n2);\r\n		for(i=1;i<=n2;++i){\r\n			cin>>name;\r\n			if( m.find(name)!=m.end()){\r\n			  same_name1=name;\r\n			  for(++i;i<=n1;++i) cin>>name;\r\n			  if(m[last_name]<m[same_name1])  same_name2=last_name;\r\n			  else same_name2=same_name1;\r\n			}\r\n		}\r\n		if(same_name2=="none") same_name2=same_name1;\r\n\r\n		cout<<same_name1<<" "<<same_name2<<endl;\r\n	}\r\n    return 0;\r\n} \r\n', '', 0, 368640, 4, 2, '2010-10-28 09:04:13', '0001-01-01 00:00:00'),
(750, 14, 374, 5, '#include <stdio.h>\r\nint num[20001];\r\n\r\nint main()\r\n{\r\n	int testcase=1,n=0,number;\r\n	while( scanf("%d",&n) ==1 )\r\n	{\r\n		int k=0,i=0,max=0,remax=0;\r\n		int rebegin=0,begin=0,end=0;\r\n\r\n		if( 0==n)\r\n			break;\r\n	\r\n		for(k=0;k<n;++k)\r\n		{\r\n			scanf("%d",&number);\r\n			for(i=0; i<number;++i)\r\n				scanf("%d",&num[i]);\r\n\r\n			remax=max=num[0];\r\n			for(i=1; i<number;++i)\r\n			{\r\n				   if (max >=0) {\r\n						max += num[i];\r\n				   } else {\r\n						max = num[i]; \r\n						rebegin = i; \r\n				   }\r\n        \r\n				if ( remax < max) { \r\n					remax = max;\r\n					begin=rebegin;\r\n					end=i;\r\n				}\r\n\r\n			}\r\n\r\n			printf("Case %d:\\n%d %d %d\\n",testcase++,remax,begin+1,end+1);\r\n\r\n		}\r\n	}\r\n	return 0;\r\n}\r\n', '', 15, 339968, 4, 1, '2010-10-28 09:06:46', '0001-01-01 00:00:00'),
(751, 10, 338, 3, '#include<stdio.h>\r\n\r\nint main()\r\n{\r\n   int i,size,k,temp,shuzu[1000],count;\r\n   int kmin,kmax;\r\n\r\n   while(EOF != scanf("%d%d",&size,&k))\r\n   {\r\n	   for(i = 0; i != 1000 ;i++)\r\n       shuzu[i] = 0;\r\n     for(i = 0 ; i != size ; i++)\r\n	 {\r\n     scanf("%d",&temp);\r\n     shuzu[temp] +=1;\r\n	 }\r\n   count = 0;\r\n   i = 0;\r\n    while(count<k+1)\r\n    {\r\n     ++i;\r\n     count += shuzu[i];\r\n    }    \r\n   kmin = i;\r\n\r\n   count = 0;\r\n   i = 1000;\r\n    while(count<k+1)\r\n    {\r\n     --i;\r\n     count += shuzu[i];\r\n    }    \r\n   kmax = i;\r\n   printf("%d\\n",kmax - kmin);\r\n   }\r\n   return 0;\r\n}\r\n', '', 374, 258048, 4, 1, '2010-10-28 09:08:18', '0001-01-01 00:00:00'),
(752, 27, 345, 4, '#include <stdio.h>\r\n#include <map>\r\n#include <string>\r\n#include <iostream>\r\n\r\nusing namespace std;\r\nint main()\r\n{\r\n	int n1,n2,i;\r\n	string name;\r\n    while(scanf("%d",&n1)==1){\r\n		string same_name1="none";\r\n		string same_name2="none";\r\n		string last_name="none";\r\n    	map<string,int> m;\r\n\r\n    	for(i=1;i<=n1;++i){\r\n			cin>>name;\r\n    		if(m.find(name)!=m.end()){\r\n				for(++i;i<=n1;++i) cin>>name;\r\n				last_name=name;\r\n			}else{   m.insert(pair<string,int>(name,i));  }\r\n		}\r\n\r\n		scanf("%d",&n2);\r\n		for(i=1;i<=n2;++i){\r\n			cin>>name;\r\n			if( m.find(name)!=m.end()){\r\n			  same_name1=name;\r\n			  for(++i;i<=n2;++i) cin>>name;\r\n			  if(m[last_name]<m[same_name1])  same_name2=last_name;\r\n			  else same_name2=same_name1;\r\n			}\r\n		}\r\n		if(same_name2=="none") same_name2=same_name1;\r\n\r\n		cout<<same_name1<<" "<<same_name2<<endl;\r\n	}\r\n    return 0;\r\n} \r\n', '', 0, 479232, 4, 2, '2010-10-28 09:10:01', '0001-01-01 00:00:00'),
(753, 14, 374, 5, '#include <stdio.h>\r\nint num[20001];\r\n\r\nint main()\r\n{\r\n	int n=0,number;\r\n	while( scanf("%d",&n) ==1 )\r\n	{\r\n		int k=0,i=0,max=0,remax=0, testcase=1;\r\n		int rebegin=0,begin=0,end=0;\r\n\r\n		if( 0==n)\r\n			break;\r\n	\r\n		for(k=0;k<n;++k)\r\n		{\r\n			scanf("%d",&number);\r\n			for(i=0; i<number;++i)\r\n				scanf("%d",&num[i]);\r\n\r\n			remax=max=num[0];\r\n			for(i=1; i<number;++i)\r\n			{\r\n				   if (max >=0) {\r\n						max += num[i];\r\n				   } else {\r\n						max = num[i]; \r\n						rebegin = i; \r\n				   }\r\n        \r\n				if ( remax < max) { \r\n					remax = max;\r\n					begin=rebegin;\r\n					end=i;\r\n				}\r\n\r\n			}\r\n\r\n			printf("Case %d:\\n%d %d %d\\n",testcase++,remax,begin+1,end+1);\r\n\r\n		}\r\n	}\r\n	return 0;\r\n}\r\n', '', 15, 339968, 4, 1, '2010-10-28 09:13:23', '0001-01-01 00:00:00'),
(754, 27, 345, 4, '#include <stdio.h>\r\n#include <map>\r\n#include <string>\r\n#include <iostream>\r\n\r\nusing namespace std;\r\nint main()\r\n{\r\n	int n1,n2,i;\r\n	string name;\r\n    while(scanf("%d",&n1)==1){\r\n		string same_name1="none";\r\n		string same_name2="none";\r\n		string last_name="none";\r\n    	map<string,int> m;\r\n\r\n    	for(i=1;i<=n1;++i){\r\n			cin>>name;\r\n    		if(m.find(name)!=m.end()){\r\n				for(++i;i<=n1;++i) cin>>name;\r\n				last_name=name;\r\n			}else{   m.insert(pair<string,int>(name,i));  }\r\n		}\r\n\r\n		scanf("%d",&n2);\r\n		for(i=1;i<=n2;++i){\r\n			cin>>name;\r\n			if( m.find(name)!=m.end()){\r\n			  same_name2=same_name1=name;\r\n			  for(++i;i<=n2;++i){\r\n				cin>>name;\r\n				if(m[name]<m[same_name1])  same_name1=name;\r\n			  }\r\n			}\r\n		}\r\n		if(same_name2=="none") same_name2=same_name1;\r\n\r\n		cout<<same_name1<<" "<<same_name2<<endl;\r\n	}\r\n    return 0;\r\n} \r\n', '', 46, 548864, 1, 2, '2010-10-28 09:13:54', '0001-01-01 00:00:00'),
(755, 10, 338, 3, '#include<stdio.h>\r\n\r\nint main()\r\n{\r\n   int i,size,k,temp,shuzu[1000],count;\r\n   int kmin,kmax;\r\n\r\n   while(EOF != scanf("%d%d",&size,&k))\r\n   {\r\n	   if(size == 0)\r\n		   continue;\r\n	   for(i = 0; i != 1000 ;i++)\r\n       shuzu[i] = 0;\r\n     for(i = 0 ; i != size ; i++)\r\n	 {\r\n     scanf("%d",&temp);\r\n     shuzu[temp] +=1;\r\n	 }\r\n   count = 0;\r\n   i = 0;\r\n    while(count<k+1)\r\n    {\r\n     ++i;\r\n     count += shuzu[i];\r\n    }    \r\n   kmin = i;\r\n\r\n   count = 0;\r\n   i = 1000;\r\n    while(count<k+1)\r\n    {\r\n     --i;\r\n     count += shuzu[i];\r\n    }    \r\n   kmax = i;\r\n   printf("%d\\n",kmax - kmin);\r\n   }\r\n   return 0;\r\n}\r\n', '', 374, 258048, 4, 1, '2010-10-28 09:13:59', '0001-01-01 00:00:00'),
(756, 10, 339, 3, '#include<stdio.h>\r\n#include<vector>\r\n#include<algorithm>\r\n\r\nusing namespace std;\r\n\r\nbool compare(int num1,int num2)\r\n{\r\n return num1>num2;\r\n}\r\n\r\nint iterator_index(vector<int>& shuzu,int i)\r\n{\r\n vector<int>::iterator iter = shuzu.begin();\r\n while(i != 0)\r\n {\r\n  ++iter;\r\n  --i;\r\n }\r\n return *iter;\r\n}\r\nint main()\r\n{\r\n int size,k,i,temp;\r\n vector<int> shuzu,choice;\r\n while(scanf("%d%d",&size,&k))\r\n {\r\n	 choice.clear();\r\n     shuzu.clear();\r\n for(i=0;i != k;i++)\r\n {\r\n  scanf("%d",&temp);\r\n  choice.push_back(temp);\r\n }\r\n for(i=0;i != size; i++)\r\n {\r\n  scanf("%d",&temp);\r\n  shuzu.push_back(temp);\r\n }\r\n sort(shuzu.begin(),shuzu.end(),compare);\r\n\r\n for(vector<int>::iterator iter = choice.begin();\r\n  iter != choice.end();iter++)\r\n  printf("%d\\n",iterator_index(shuzu,*iter));\r\n }\r\n return 0;\r\n}\r\n', '', 600, 1343488, 5, 2, '2010-10-28 09:23:49', '0001-01-01 00:00:00'),
(757, 27, 345, 4, '#include <stdio.h>\r\n#include <map>\r\n#include <string>\r\n#include <iostream>\r\n\r\nusing namespace std;\r\nint main()\r\n{\r\n	int n1,n2,i;\r\n	string name;\r\n    while(scanf("%d",&n1)==1){\r\n		string same_name1="none";\r\n		string same_name2="none";\r\n    	map<string,int> m;\r\n\r\n    	for(i=1;i<=n1;++i){\r\n			cin>>name;\r\n    		if(m.find(name)!=m.end()){\r\n				for(++i;i<=n1;++i) cin>>name;\r\n			}else{   m.insert(pair<string,int>(name,i));  }\r\n		}\r\n\r\n		scanf("%d",&n2);\r\n		for(i=1;i<=n2;++i){\r\n			cin>>name;\r\n			if( m.find(name)!=m.end()){\r\n			  same_name2=same_name1=name;\r\n			  for(++i;i<=n2;++i){\r\n				cin>>name;\r\n				if(m[name]<m[same_name1])  same_name1=name;\r\n			  }\r\n			}\r\n		}\r\n\r\n		cout<<same_name1<<" "<<same_name2<<endl;\r\n	}\r\n    return 0;\r\n} \r\n', '', 31, 544768, 1, 2, '2010-10-28 09:24:58', '0001-01-01 00:00:00'),
(758, 14, 374, 5, '#include <stdio.h>\r\nint num[20001];\r\n\r\nint main()\r\n{\r\n	int n=0,number;\r\n	while( scanf("%d",&n) ==1 )\r\n	{\r\n		int k=0;\r\n\r\n		if( 0==n)\r\n			break;\r\n	\r\n		for(k=0;k<n;++k)\r\n		{\r\n			int i=0,max=0,remax=0, rebegin=0,begin=0,end=0;\r\n		\r\n			scanf("%d",&number);\r\n			for(i=0; i<number;++i)\r\n				scanf("%d",&num[i]);\r\n\r\n			remax=max=num[0];\r\n			for(i=1; i<number;++i)\r\n			{\r\n				   if (max >=0) {\r\n						max += num[i];\r\n				   } else {\r\n						max = num[i]; \r\n						rebegin = i; \r\n				   }\r\n        \r\n				if ( remax < max) { \r\n					remax = max;\r\n					begin=rebegin;\r\n					end=i;\r\n				}\r\n\r\n			}\r\n\r\n			printf("Case %d:\\n%d %d %d\\n",k+1,remax,begin+1,end+1);\r\n\r\n		}\r\n	}\r\n	return 0;\r\n}\r\n', '', 15, 335872, 3, 1, '2010-10-28 09:25:56', '0001-01-01 00:00:00'),
(759, 30, 375, 5, '#include <stdio.h>\r\n#include <iostream>\r\n#include <vector>\r\n\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n	int n;\r\n	while(scanf("%d",&n)==1)\r\n	{\r\n		int height,i,j;\r\n		vector< int > H,h;\r\n		for(i=0;i<n;i++)\r\n		{\r\n			scanf("%d",&height);\r\n			H.push_back(height);\r\n		}\r\n		if(H.empty())\r\n			continue;\r\n		else\r\n			h.push_back(H[0]);\r\n		for(i=1;i<n;i++)\r\n		{\r\n			int f=-1,p=32767;\r\n			for(j=0;j<h.size();j++)\r\n			{\r\n				if(h[j]-H[i]>0&&h[j]-H[i]<p)\r\n				{\r\n					f=j;\r\n					p=h[j]-H[i];\r\n				}\r\n			}\r\n			if(f==-1)\r\n				h.push_back(H[i]);\r\n			else\r\n				h[f]=H[i];\r\n		}\r\n		printf("%d\\n",h.size());\r\n	}\r\n	return 0;\r\n}', '', 500, 618496, 5, 2, '2010-10-28 09:26:31', '0001-01-01 00:00:00'),
(760, 17, 374, 5, '#include<stdio.h>\r\n#define MAX 10000\r\nint MaxSum(int *A,int n)\r\n{\r\n    int nStart,nAll,i;\r\n    int j;\r\n    int num1,num2,num;\r\n	int f[MAX];\r\n	num=num1=num2=0;\r\n    j=0;\r\n    nStart = 0;\r\n    nAll = A[0];\r\n    for(i=0;i<n;i++)\r\n    { \r\n \r\n      if(nStart<0){ \r\n           nStart = A[i];\r\n      }\r\n      else{ \r\n		     nStart+=A[i];\r\n    \r\n	   }\r\n      if(nAll<nStart){\r\n         nAll=nStart;\r\n \r\n        }\r\n}\r\n\r\n    return nAll;\r\n}  \r\nint main()\r\n{   \r\n    int A[MAX];\r\n    int n,i,j;\r\n    while(scanf("%d",&n)!=EOF)\r\n    {\r\n        for(i=0;i<n;i++)\r\n          scanf("%d",&A[i]);\r\n        j=MaxSum(A,n);\r\n        printf("%d\\n",j);\r\n    }\r\n    return 0;\r\n}       \r\n    \r\n', '', 15, 299008, 4, 1, '2010-10-28 09:27:04', '0001-01-01 00:00:00'),
(761, 10, 339, 3, '#include<stdio.h>\r\n#include<vector>\r\n#include<algorithm>\r\n\r\nusing namespace std;\r\n\r\nbool compare(int num1,int num2)\r\n{\r\n return num1>num2;\r\n}\r\n\r\nint iterator_index(vector<int>& shuzu,int i)\r\n{\r\n vector<int>::iterator iter = shuzu.begin();\r\n while(i != 0)\r\n {\r\n  ++iter;\r\n  --i;\r\n }\r\n return *iter;\r\n}\r\nint main()\r\n{\r\n int size,k,i,temp;\r\n vector<int> shuzu,choice;\r\n while(scanf("%d%d",&size,&k))\r\n {\r\n	 choice.clear();\r\n     shuzu.clear();\r\n for(i=0;i != k;i++)\r\n {\r\n  scanf("%d",&temp);\r\n  choice.push_back(temp);\r\n }\r\n for(i=0;i != size; i++)\r\n {\r\n  scanf("%d",&temp);\r\n  shuzu.push_back(temp);\r\n }\r\n sort(shuzu.begin(),shuzu.end(),compare);\r\n\r\n for(vector<int>::iterator iter = choice.begin();\r\n  iter != choice.end();iter++)\r\n  printf("%d\\n",iterator_index(shuzu,*iter));\r\n }\r\n return 0;\r\n}\r\n', '', 600, 1343488, 5, 2, '2010-10-28 09:35:41', '0001-01-01 00:00:00'),
(762, 17, 374, 5, '#include<stdio.h>\r\n#define MAX 10000\r\nint MaxSum( int a[], int n )\r\n{\r\n    int this_sum, max_sum, best_i, best_j, i, j;\r\n    max_sum = 0; best_i = best_j = -1;\r\n    for( i=0; i<n; i++ )\r\n    {\r\n        this_sum = 0;\r\n        for( j=i; j<n; j++ )\r\n        {\r\n            this_sum += a[j];\r\n            if( this_sum > max_sum )\r\n            {\r\n                max_sum = this_sum;\r\n                best_i = i;\r\n                best_j = j;\r\n            }\r\n        }\r\n    }\r\n    printf("%d %d %d\\n",max_sum,best_i+1,best_j+1);\r\n    return max_sum ;\r\n}\r\nint main()\r\n{   \r\n    int A[MAX];\r\n    int n,i,j,m;\r\n    int num;\r\n    num=1;\r\n    scanf("%d",&m);\r\n    while(m--)\r\n    {\r\n        scanf("%d",&n);\r\n        for(i=0;i<n;i++)\r\n          scanf("%d",&A[i]);\r\n        printf("Case %d:\\n",num);\r\n        MaxSum(A,n);\r\n    }\r\n    return 0;\r\n}       \r\n    \r\n', '', 80, 258048, 5, 1, '2010-10-28 09:37:10', '0001-01-01 00:00:00'),
(763, 20, 336, 2, '\r\n#include<stdio.h>\r\n#include "stdafx.h"\r\n\r\nint count(unsigned int n)\r\n{\r\n	int num;\r\n	for(num = 0; n; n >>= 1)\r\n	{\r\n		num += n & 1;\r\n	}\r\n	return num;\r\n}\r\n\r\nint main()\r\n{\r\n	int m,n,i,j;\r\n	int a[100],b[100];\r\n\r\n	scanf("%d",&n);\r\n\r\n	for(i=0;i<n;i++)\r\n	{\r\n		scanf("%d",&a[i]);\r\n	}\r\n	\r\n	for(j=0;j<n;j++)\r\n	{\r\n		b[j]=count(a[j]);\r\n	}\r\n	\r\n	for(i=0;i<n-1;i++)\r\n	{\r\n		for(j=i+1;j<n;j++)\r\n		{  \r\n			if(b[i]>b[j])\r\n            {\r\n				m=a[i];a[i]=a[j];a[j]=m;\r\n			}\r\n\r\n		}\r\n	}\r\n\r\n	for(i=0;i<n;i++)\r\n	{\r\n		printf("%d",a[i]);\r\n	}\r\n	return 0;		\r\n			\r\n}', 'Main.c:3:20: fatal error: stdafx.h: No such file or directory\r\ncompilation terminated.\r\n', 0, 0, 2, 1, '2010-10-28 09:37:34', '0001-01-01 00:00:00'),
(764, 20, 336, 2, '\r\n#include<stdio.h>\r\n#include "stdafx.h"\r\n\r\nint count(unsigned int n)\r\n{\r\n	int num;\r\n	for(num = 0; n; n >>= 1)\r\n	{\r\n		num += n & 1;\r\n	}\r\n	return num;\r\n}\r\n\r\nint main()\r\n{\r\n	int m,n,i,j;\r\n	int a[100],b[100];\r\n\r\n	scanf("%d",&n);\r\n\r\n	for(i=0;i<n;i++)\r\n	{\r\n		scanf("%d",&a[i]);\r\n	}\r\n	\r\n	for(j=0;j<n;j++)\r\n	{\r\n		b[j]=count(a[j]);\r\n	}\r\n	\r\n	for(i=0;i<n-1;i++)\r\n	{\r\n		for(j=i+1;j<n;j++)\r\n		{  \r\n			if(b[i]>b[j])\r\n            {\r\n				m=a[i];a[i]=a[j];a[j]=m;\r\n			}\r\n\r\n		}\r\n	}\r\n\r\n	for(i=0;i<n;i++)\r\n	{\r\n		printf("%d",a[i]);\r\n	}\r\n	return 0;		\r\n			\r\n}', 'Main.c:3:20: fatal error: stdafx.h: No such file or directory\r\ncompilation terminated.\r\n', 0, 0, 2, 1, '2010-10-28 09:38:42', '0001-01-01 00:00:00'),
(765, 14, 374, 5, '#include <stdio.h>\r\nint num[20001];\r\n\r\nint main()\r\n{\r\n	int n=0,number;\r\n	while( scanf("%d",&n) ==1 )\r\n	{\r\n		int k=0;\r\n\r\n		if( 0==n)\r\n			break;\r\n	\r\n		for(k=0;k<n;++k)\r\n		{\r\n			int i=0,max=0,remax=0, rebegin=0,begin=0,end=0;\r\n		\r\n			scanf("%d",&number);\r\n			for(i=0; i<number;++i)\r\n				scanf("%d",&num[i]);\r\n\r\n			remax=max=num[0];\r\n			for(i=1; i<number;++i)\r\n			{\r\n				   if (max >=0) {\r\n						max += num[i];\r\n				   } else {\r\n						max = num[i]; \r\n						rebegin = i; \r\n				   }\r\n        \r\n				if ( remax < max) { \r\n					remax = max;\r\n					begin=rebegin;\r\n					end=i;\r\n				}\r\n\r\n			}\r\n\r\n			printf("Case %d:\\n%d %d %d\\n\\n",k+1,remax,begin+1,end+1);\r\n\r\n		}\r\n	}\r\n	return 0;\r\n}\r\n', '', 15, 335872, 3, 1, '2010-10-28 09:38:55', '0001-01-01 00:00:00'),
(766, 20, 336, 2, '#include<stdio.h>\r\nint count(unsigned int n)\r\n{\r\n	int num;\r\n	for(num = 0; n; n >>= 1)\r\n	{\r\n		num += n & 1;\r\n	}\r\n	return num;\r\n}\r\nint main()\r\n{\r\n	int m,n,i,j;\r\n	int a[100],b[100];\r\n	scanf("%d",&n);\r\n	for(i=0;i<n;i++)\r\n	{\r\n		scanf("%d",&a[i]);\r\n	}\r\n	for(j=0;j<n;j++)\r\n	{\r\n		b[j]=count(a[j]);\r\n	}\r\n	for(i=0;i<n-1;i++)\r\n	{\r\n		for(j=i+1;j<n;j++)\r\n		{  \r\n			if(b[i]>b[j])\r\n            {\r\n				m=a[i];a[i]=a[j];a[j]=m;\r\n			}\r\n		}\r\n	}\r\n	for(i=0;i<n;i++)\r\n	{\r\n		printf("%d",a[i]);\r\n	}\r\n	return 0;			\r\n}', '', 0, 258048, 7, 1, '2010-10-28 09:41:09', '0001-01-01 00:00:00'),
(767, 10, 338, 3, '#include<stdio.h>\r\nint main()\r\n{\r\n   int i,size,k,temp,shuzu[1000],count;\r\n   int kmin,kmax;\r\n   while(scanf("%d%d",&size,&k))\r\n   {\r\n   for(i = 0; i != 1000 ;i++)\r\n    shuzu[i] = 0;\r\n   for(i = 0 ; i != size ; i++)\r\n   {\r\n    scanf("%d",&temp);\r\n    shuzu[temp] +=1;\r\n   }\r\n   count = 0;\r\n   i = 0;\r\n   while(count<k+1)\r\n   {\r\n    ++i;\r\n    count += shuzu[i];\r\n   }    \r\n   kmin = i;\r\n   count = 0;\r\n   i = 1000;\r\n   while(count<k+1)\r\n   {\r\n    --i;\r\n    count += shuzu[i];\r\n   }    \r\n   kmax = i;\r\n   printf("%d\\n",kmax - kmin);\r\n   }\r\n   return 0;\r\n}\r\n', '', 400, 258048, 5, 1, '2010-10-28 09:43:58', '0001-01-01 00:00:00'),
(768, 6, 376, 5, '#include <stdio.h>\r\n#define N 50010\r\n__int64 s[N],t[N];\r\nint a[N];\r\n\r\nint main()\r\n{\r\n    //freopen("1.txt","r",stdin);\r\n	//freopen("2.txt","w",stdout);\r\n	int n,i;\r\n	__int64 res,tmp;\r\n	while(scanf("%d",&n)!=EOF)\r\n	{\r\n	   s[0]=t[n+1]=1;\r\n	   for(i=1;i<=n;++i)\r\n	   {\r\n		   scanf("%d",a+i);\r\n		   s[i]=s[i-1]*a[i];\r\n	   }\r\n\r\n	   for(i=n;i>=1;--i)\r\n	   {\r\n		   t[i]=t[i+1]*a[i];\r\n		   tmp=s[i-1]*t[i+1];\r\n		   if(i==n||tmp>res) res=tmp;\r\n	   }\r\n	   printf("%I64d\\n",res);\r\n	}\r\n	return 0;\r\n}', '', 78, 1257472, 1, 2, '2010-10-28 09:45:10', '0001-01-01 00:00:00'),
(769, 21, 374, 5, '#include<stdio.h>\r\nvoid maxsub(int data[],int n){\r\n	int i,max1=0,max2=0,temp=0,l=0,left=0,right=0;\r\n	for(i=0;i<=n;i++){\r\n\r\n		temp=data[i]+max1;\r\n\r\n		if(temp>=0){\r\n			max1=temp;\r\n		}\r\n		else{\r\n			l=i+1;\r\n			max1=0;\r\n		}\r\n		if(max1>max2){\r\n			left=l;\r\n			right=i;\r\n			max2=max1;\r\n		}\r\n	}\r\n	printf("%d %d %d\\n",max2,left+1,right+1);\r\n	\r\n}\r\n\r\nvoid main(){\r\n	int line,n1;  \r\n	int data[20000];\r\n	scanf("%d",&line);\r\n	  for(int i=0;i<line;i++){\r\n		data[20000]=0;\r\n		  scanf("%d",&n1);\r\n			for(int j=0;j<n1;j++){\r\n				scanf("%d",&data[j]);\r\n			}\r\n		printf("Case %d:\\n",i+1);\r\n		maxsub(data,n1);\r\n\r\n	  }\r\n}', 'Main.c: In function ''main'':\r\nMain.c:29:4: error: ''for'' loop initial declarations are only allowed in C99 mode\r\nMain.c:29:4: note: use option -std=c99 or -std=gnu99 to compile your code\r\nMain.c:32:4: error: ''for'' loop initial declarations are only allowed in C99 mode\r\n', 0, 0, 2, 1, '2010-10-28 09:45:56', '0001-01-01 00:00:00'),
(770, 14, 375, 5, '#include <stdio.h>\r\nint num[20001];\r\n\r\nint main()\r\n{\r\n	int n=0,number;\r\n	while( scanf("%d",&n) ==1 )\r\n	{\r\n		int k=0;\r\n\r\n		if( 0==n)\r\n			break;\r\n	\r\n		for(k=0;k<n;++k)\r\n		{\r\n			int i=0,max=0,remax=0, rebegin=0,begin=0,end=0;\r\n		\r\n			scanf("%d",&number);\r\n			for(i=0; i<number;++i)\r\n				scanf("%d",&num[i]);\r\n\r\n			remax=max=num[0];\r\n			for(i=1; i<number;++i)\r\n			{\r\n				   if (max >=0) {\r\n						max += num[i];\r\n				   } else {\r\n						max = num[i]; \r\n						rebegin = i; \r\n				   }\r\n        \r\n				if ( remax < max) { \r\n					remax = max;\r\n					begin=rebegin;\r\n					end=i;\r\n				}\r\n\r\n			}\r\n			if( 0==i)\r\n				printf("Case %d:\\n%d %d %d\\n",k+1,remax,begin+1,end+1);\r\n		\r\n			printf("\\n");\r\n			printf("Case %d:\\n%d %d %d\\n",k+1,remax,begin+1,end+1);\r\n		}\r\n	}\r\n	return 0;\r\n}\r\n', '', 15, 339968, 7, 1, '2010-10-28 09:46:16', '0001-01-01 00:00:00'),
(771, 20, 336, 2, '#include<stdio.h>\r\nint count(unsigned int n)\r\n{\r\n	int num;\r\n	for(num = 0; n; n >>= 1)\r\n	{\r\n		num += n & 1;\r\n	}\r\n	return num;\r\n}\r\nint main()\r\n{\r\n	int m,n,i,j;\r\n	int a[100],b[100];\r\n\r\n	scanf("%d",&n);\r\n\r\n	for(i=0;i<n;i++)\r\n	{\r\n		scanf("%d",&a[i]);\r\n	}\r\n	\r\n	for(j=0;j<n;j++)\r\n	{\r\n		b[j]=count(a[j]);\r\n	}\r\n	\r\n	for(i=0;i<n-1;i++)\r\n	{\r\n			if(b[i]>b[i+1])\r\n            {\r\n				m=a[i];a[i]=a[i+1];a[i+1]=m;\r\n			}\r\n	}\r\n\r\n	for(i=0;i<n;i++)\r\n	{\r\n		printf("%d",a[i]);\r\n	}\r\n	return 0;			\r\n}', '', 0, 258048, 7, 1, '2010-10-28 09:46:31', '0001-01-01 00:00:00'),
(772, 22, 374, 5, '#include<stdio.h>\r\n#define M 20000\r\nint start,end;\r\nint array[M];\r\n\r\nint MaxSubSequenceSum(const int A[], int N)\r\n{\r\n	int ThisSum, MaxSum, j,Tstart;\r\n	ThisSum = MaxSum = 0;Tstart=start=end=1;\r\n	for(j = 0; j < N; j ++)\r\n	{\r\n		ThisSum += A[j];\r\n		if(ThisSum > MaxSum){\r\n			MaxSum = ThisSum;\r\n			start=Tstart;\r\n			end=j+1;\r\n		}\r\n		else {\r\n			if(ThisSum < 0){\r\n				ThisSum = 0;\r\n				Tstart=j+2;\r\n			}\r\n		}\r\n	}\r\n	return MaxSum;\r\n}\r\nint main()\r\n{\r\n	int n,i,m,j=1;\r\n	while(scanf("%d",&n)==1)\r\n	{\r\n		while(j<=n)\r\n		{\r\n			scanf("%d",&m);\r\n			for(i=0;i<m;i++){\r\n				scanf("%d",&array[i]);\r\n			}\r\n			printf("Case %d:\\n%d ",j,MaxSubSequenceSum(array,m));\r\n			printf("%d %d\\n",start,end);\r\n			if(j!=n)printf("\\n");\r\n			++j;\r\n		}\r\n	}\r\n	return 0;\r\n}', '', 15, 335872, 4, 2, '2010-10-28 09:46:54', '0001-01-01 00:00:00'),
(773, 14, 375, 5, '#include <stdio.h>\r\nint num[20001];\r\n\r\nint main()\r\n{\r\n	int n=0,number;\r\n	while( scanf("%d",&n) ==1 )\r\n	{\r\n		int k=0;\r\n\r\n		if( 0==n)\r\n			break;\r\n	\r\n		for(k=0;k<n;++k)\r\n		{\r\n			int i=0,max=0,remax=0, rebegin=0,begin=0,end=0;\r\n		\r\n			scanf("%d",&number);\r\n			for(i=0; i<number;++i)\r\n				scanf("%d",&num[i]);\r\n\r\n			remax=max=num[0];\r\n			for(i=1; i<number;++i)\r\n			{\r\n				   if (max >=0) {\r\n						max += num[i];\r\n				   } else {\r\n						max = num[i]; \r\n						rebegin = i; \r\n				   }\r\n        \r\n				if ( remax < max) { \r\n					remax = max;\r\n					begin=rebegin;\r\n					end=i;\r\n				}\r\n\r\n			}\r\n			if( 0==k)\r\n				printf("Case %d:\\n%d %d %d\\n",k+1,remax,begin+1,end+1);\r\n		\r\n			printf("\\n");\r\n			printf("Case %d:\\n%d %d %d\\n",k+1,remax,begin+1,end+1);\r\n		}\r\n	}\r\n	return 0;\r\n}\r\n', '', 15, 339968, 7, 1, '2010-10-28 09:47:06', '0001-01-01 00:00:00'),
(774, 17, 374, 5, '#include<stdio.h>\r\n#define MAX 10000\r\nvoid MaxSum(int *A,int n)\r\n{\r\n    int nStart,nAll,i;\r\n    int j;\r\nint num1,num2;\r\nnum1=num2=0;\r\n    j=0;\r\n    nStart = 0;\r\n    nAll = A[0];\r\n    for(i=0;i<n;i++)\r\n    { \r\n	\r\n      if(nStart<0) {nStart = A[i];num2=i;}\r\n      else {\r\n          nStart+=A[i];\r\n      }\r\n      if(nAll<nStart){\r\n        nAll=nStart;\r\n        num1=i;\r\n        \r\n        }\r\n\r\n      }\r\n    printf("%d %d %d\\n",nAll,num2+1,num1+1);\r\n    return ;\r\n}  \r\nint main()\r\n{   \r\n    int A[MAX];\r\n    int n,i,j,m;\r\n    int num;\r\n    num=1;\r\n    scanf("%d",&m);\r\n    while(m--)\r\n    {\r\n        scanf("%d",&n);\r\n        for(i=0;i<n;i++)\r\n          scanf("%d",&A[i]);\r\n        printf("Case %d:\\n",num);\r\n        MaxSum(A,n);\r\n    }\r\n    return 0;\r\n}   \r\n    \r\n', '', 15, 266240, 4, 1, '2010-10-28 09:47:11', '0001-01-01 00:00:00'),
(775, 21, 374, 5, '#include<stdio.h>\r\nvoid maxsub(int data[],int n){\r\n	int i,max1=0,max2=0,temp=0,l=0,left=0,right=0;\r\n	for(i=0;i<=n;i++){\r\n\r\n		temp=data[i]+max1;\r\n\r\n		if(temp>=0){\r\n			max1=temp;\r\n		}\r\n		else{\r\n			l=i+1;\r\n			max1=0;\r\n		}\r\n		if(max1>max2){\r\n			left=l;\r\n			right=i;\r\n			max2=max1;\r\n		}\r\n	}\r\n	printf("%d %d %d\\n",max2,left+1,right+1);\r\n	\r\n}\r\n\r\nvoid main(){\r\n	int line,n1,i,j;  \r\n	int data[20000];\r\n	scanf("%d",&line);\r\n	  for(i=0;i<line;i++){\r\n		data[20000]=0;\r\n		  scanf("%d",&n1);\r\n			for(j=0;j<n1;j++){\r\n				scanf("%d",&data[j]);\r\n			}\r\n		printf("Case %d:\\n",i+1);\r\n		maxsub(data,n1);\r\n\r\n	  }\r\n}', '', 15, 303104, 4, 1, '2010-10-28 09:49:16', '0001-01-01 00:00:00'),
(776, 30, 375, 5, '#include <stdio.h>\r\n#include <iostream>\r\n#include <vector>\r\n\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n	int n;\r\n	while(scanf("%d",&n)==1)\r\n	{\r\n		int height,i,j;\r\n		vector< int > H,h;\r\n		for(i=0;i<n;i++)\r\n		{\r\n			scanf("%d",&height);\r\n			H.push_back(height);\r\n		}\r\n		if(H.empty())\r\n			continue;\r\n		else\r\n			h.push_back(H[0]);\r\n		for(i=1;i<n;i++)\r\n		{\r\n			int J=h.size();\r\n			for(j=0;j<J;j++)\r\n			{\r\n				if(h[j]-H[i]>0)\r\n				{\r\n					h[j]=H[i];\r\n					j=h.size();\r\n				}\r\n				else if(j==J-1)\r\n					h.push_back(H[i]);\r\n			}\r\n		}\r\n		printf("%d\\n",h.size());\r\n	}\r\n	return 0;\r\n}', '', 500, 618496, 5, 2, '2010-10-28 09:49:52', '0001-01-01 00:00:00'),
(777, 14, 374, 5, '#include <stdio.h>\r\nint num[20001];\r\n\r\nint main()\r\n{\r\n	int n=0,number;\r\n	while( scanf("%d",&n) ==1 )\r\n	{\r\n		int k=0;\r\n\r\n		if( 0==n)\r\n			break;\r\n	\r\n		for(k=0;k<n;++k)\r\n		{\r\n			int i=0,max=0,remax=0, rebegin=0,begin=0,end=0;\r\n		\r\n			scanf("%d",&number);\r\n			for(i=0; i<number;++i)\r\n				scanf("%d",&num[i]);\r\n\r\n			remax=max=num[0];\r\n			for(i=1; i<number;++i)\r\n			{\r\n				   if (max >=0) {\r\n						max += num[i];\r\n				   } else {\r\n						max = num[i]; \r\n						rebegin = i; \r\n				   }\r\n        \r\n				if ( remax < max) { \r\n					remax = max;\r\n					begin=rebegin;\r\n					end=i;\r\n				}\r\n\r\n			}\r\n			if(0 != k)\r\n				printf("\\n");\r\n			printf("Case %d:\\n%d %d %d\\n",k+1,remax,begin+1,end+1);\r\n		\r\n		\r\n		}\r\n	}\r\n	return 0;\r\n}\r\n', '', 15, 335872, 1, 1, '2010-10-28 09:52:29', '0001-01-01 00:00:00'),
(778, 13, 374, 5, '#include <iostream>\r\n#include <string>\r\n#include <vector>\r\n#include <stdio.h>\r\nusing namespace std;\r\n\r\nvoid MaxSubseq_DP(int nums[], int count, int &resStart, int &resEnd, int &resMax)\r\n{\r\n    int start, max;\r\n    int i;\r\n    \r\n    start = resStart = resEnd = 0; //初始化当前子序列和最大子序列为nums[0]\r\n    max = resMax = nums[0];\r\n\r\n    for (i = 1; i < count; ++i) \r\n	{\r\n        if (max > 0) \r\n		{\r\n            max += nums[i];\r\n        } \r\n		else \r\n		{\r\n            max = nums[i]; //抛弃当前子序列\r\n            start = i; //开始新的子序列搜索\r\n        }\r\n        \r\n        if (resMax < max) \r\n		{ //更新最大子序列\r\n            resMax = max;\r\n            resStart = start+1;\r\n            resEnd = i+1;\r\n        }\r\n    }//for\r\n\r\n    return;\r\n} \r\n\r\nint main()\r\n{\r\n	int count,resStart,resEnd,resMax,cases;\r\n	vector<int> result;\r\n	vector<vector<int> >results;\r\n\r\n	scanf("%d",&cases);\r\n	for(int i=0;i<cases;+i)\r\n	{\r\n		scanf("%d",&count);\r\n		int nums[20000];\r\n		for(int n=0;n<count;n++)\r\n			scanf("%d",&nums[n]);\r\n\r\n		MaxSubseq_DP(nums,count,resStart,resEnd,resMax);\r\n		result.clear();\r\n		result.push_back(resMax);\r\n		result.push_back(resStart);\r\n		result.push_back(resEnd);\r\n		results.push_back(result);\r\n	}\r\n\r\n	for(i=0;i<cases;++i)\r\n	{\r\n		cout<<"Case "<<i+1<<":/n";\r\n		for(int n=0;n<3;++n)\r\n			cout<<results[i][n]<<" ";\r\n		cout<<endl;\r\n	}\r\n\r\n\r\n	return 0;\r\n}\r\n\r\n', 'Main.c:1:20: fatal error: iostream: No such file or directory\r\ncompilation terminated.\r\n', 0, 0, 2, 1, '2010-10-28 09:52:36', '0001-01-01 00:00:00'),
(779, 10, 338, 3, '#include<stdio.h>\r\nint main()\r\n{\r\n   int i,size,k,temp,shuzu[1000],count;\r\n   int kmin,kmax;\r\n   while(scanf("%d%d",&size,&k))\r\n   {\r\n   for(i = 0; i != 1000 ;i++)\r\n    shuzu[i] = 0;\r\n   for(i = 0 ; i != size ; i++)\r\n   {\r\n    scanf("%d",&temp);\r\n    shuzu[temp] +=1;\r\n   }\r\n   count = 0;\r\n   i = 0;\r\n   while(count<k+1)\r\n   {\r\n    ++i;\r\n    count += shuzu[i];\r\n   }    \r\n   kmin = i;\r\n   count = 0;\r\n   i = 1000;\r\n   while(count<k+1)\r\n   {\r\n    --i;\r\n    count += shuzu[i];\r\n   }    \r\n   kmax = i;\r\n   printf("%d\\n",kmax - kmin);\r\n   }\r\n   return 0;\r\n}\r\n', '', 400, 258048, 5, 1, '2010-10-28 09:53:22', '0001-01-01 00:00:00'),
(780, 10, 338, 3, '#include<stdio.h>\r\nint main()\r\n{\r\n   int i,size,k,temp,shuzu[1000],count;\r\n   int kmin,kmax;\r\n   while(EOF != scanf("%d%d",&size,&k))\r\n   {\r\n   for(i = 0; i != 1000 ;i++)\r\n    shuzu[i] = 0;\r\n   for(i = 0 ; i != size ; i++)\r\n   {\r\n    scanf("%d",&temp);\r\n    shuzu[temp] +=1;\r\n   }\r\n   count = 0;\r\n   i = 0;\r\n   while(count<k+1)\r\n   {\r\n    ++i;\r\n    count += shuzu[i];\r\n   }    \r\n   kmin = i;\r\n   count = 0;\r\n   i = 1000;\r\n   while(count<k+1)\r\n   {\r\n    --i;\r\n    count += shuzu[i];\r\n   }    \r\n   kmax = i;\r\n   printf("%d\\n",kmax - kmin);\r\n   }\r\n   return 0;\r\n}\r\n', '', 374, 262144, 4, 1, '2010-10-28 09:55:16', '0001-01-01 00:00:00'),
(781, 17, 374, 5, '#include<stdio.h>\r\n#include<stdlib.h>\r\n#define MAX 10000\r\nvoid MaxSum(int *A,int n)\r\n{\r\n    int nStart,nAll,i;\r\n    int j;\r\nint num1,num2,num;\r\nnum1=num2=num=0;\r\n    j=0;\r\n    nStart = 0;\r\n    nAll = A[0];\r\n    for(i=0;i<n;i++)\r\n    if(A[i]<0) num++;\r\n    if(num<n-1){\r\n    for(i=0;i<n;i++)\r\n    { \r\n      if(nStart<0) {nStart = A[i];num2=i;}\r\n      else {\r\n          nStart+=A[i];\r\n      }\r\n      if(nAll<nStart){\r\n        nAll=nStart;\r\n        num1=i;\r\n      }\r\n\r\n      }\r\n      \r\n    printf("%d %d %d\\n",nAll,num2+1,num1+1);\r\n   }\r\n   else{\r\n            for(i=0;i<n;i++)\r\n    { \r\n      if(nStart<0) {nStart = A[i];num2=i;}\r\n      else {\r\n          nStart+=A[i];\r\n      }\r\n      if(nAll<nStart){\r\n        nAll=nStart;\r\n        num1=i;\r\n      }\r\n\r\n      }\r\n      \r\n    printf("%d %d %d\\n",nAll,num1+1,num1+1);\r\n   }\r\n   \r\n    return ;\r\n}  \r\nint main()\r\n{   \r\n    int A[MAX];\r\n    int n,i,j,m;\r\n    int num;\r\n    num=1;\r\n    scanf("%d",&m);\r\n    while(m--)\r\n    {\r\n        scanf("%d",&n);\r\n        for(i=0;i<n;i++)\r\n          scanf("%d",&A[i]);\r\n        printf("Case %d:\\n",num);\r\n        MaxSum(A,n);\r\n        num++;\r\n    }\r\n    system("pause");\r\n    return 0;\r\n}   \r\n    \r\n', '', 15, 262144, 4, 1, '2010-10-28 09:56:05', '0001-01-01 00:00:00'),
(782, 20, 336, 2, '#include<stdio.h>\r\nint count(unsigned int n)\r\n{\r\n	int num;\r\n	for(num = 0; n; n >>= 1)\r\n	{\r\n		num += n & 1;\r\n	}\r\n	return num;\r\n}\r\nint main()\r\n{\r\n	int m,n,i;\r\n	int a[100];\r\n\r\n	scanf("%d",&n);\r\n\r\n	for(i=0;i<n;i++)\r\n	{\r\n		scanf("%d",&a[i]);\r\n	}\r\n	\r\n	for(i=0;i<n-1;i++)\r\n	{\r\n		if(count(a[i])>count(a[i+1]))\r\n        {\r\n			m=a[i];a[i]=a[i+1];a[i+1]=m;\r\n		}\r\n	}\r\n\r\n	for(i=0;i<n;i++)\r\n	{\r\n		printf("%d",a[i]);\r\n	}\r\n	return 0;			\r\n}', '', 0, 262144, 7, 1, '2010-10-28 09:57:27', '0001-01-01 00:00:00'),
(783, 21, 374, 5, '#include<stdio.h>\r\nvoid maxsub(int data[],int n){\r\n	int i,max1=0,max2=0,temp=0,l=0,left=0,right=0;\r\n	for(i=0;i<=n;i++){\r\n\r\n		temp=data[i]+max1;\r\n\r\n		if(temp>=0){\r\n			max1=temp;\r\n		}\r\n		else{\r\n			l=i+1;\r\n			max1=0;\r\n		}\r\n		if(max1>max2){\r\n			left=l;\r\n			right=i;\r\n			max2=max1;\r\n		}\r\n	}\r\n	if (left == 0 && right == 0 && max2 == 0 && data[0] != 0){\r\n		max2=data[0];\r\n		for(i=0;i<n;i++){\r\n			if(data[i]>max2){\r\n				max2=data[i];\r\n				left=i;\r\n				right=i;\r\n			}\r\n		}\r\n	}\r\n\r\n	printf("%d %d %d\\n",max2,left+1,right+1);\r\n	\r\n}\r\n\r\nvoid main(){\r\n	int line,n1,i,j;  \r\n	int data[20000];\r\n	scanf("%d",&line);\r\n	  for(i=0;i<line;i++){\r\n		data[20000]=0;\r\n		  scanf("%d",&n1);\r\n			for(j=0;j<n1;j++){\r\n				scanf("%d",&data[j]);\r\n			}\r\n		printf("Case %d:\\n",i+1);\r\n		maxsub(data,n1);\r\n\r\n	  }\r\n}', '', 15, 307200, 4, 1, '2010-10-28 10:05:14', '0001-01-01 00:00:00'),
(784, 22, 374, 5, '#include<stdio.h>\r\n#define M 20000\r\nint start,end;\r\nint array[M];\r\n\r\nint MaxSubSequenceSum(const int A[], int N)\r\n{\r\n	int ThisSum, MaxSum, j,Tstart,Max=A[0],x=0,y;\r\n	ThisSum = MaxSum = 0;Tstart=start=end=1;\r\n	for(j = 0; j < N; j ++)\r\n	{\r\n		if(A[j]<=0)\r\n		{\r\n			++x;\r\n			if(A[j]>Max){\r\n				Max=A[j];\r\n				y=j+1;\r\n			}\r\n		}\r\n		ThisSum += A[j];\r\n		if(ThisSum > MaxSum){\r\n			MaxSum = ThisSum;\r\n			start=Tstart;\r\n			end=j+1;\r\n		}\r\n		else {\r\n			if(ThisSum < 0){\r\n				ThisSum = 0;\r\n				Tstart=j+2;\r\n			}\r\n		}\r\n	}\r\n	if(x==N){\r\n		start=end=y;\r\n		return Max;\r\n	}\r\n	return MaxSum;\r\n}\r\nint main()\r\n{\r\n	int n,i,m,j=1;\r\n	while(scanf("%d",&n)==1)\r\n	{\r\n		while(j<=n)\r\n		{\r\n			scanf("%d",&m);\r\n			for(i=0;i<m;i++){\r\n				scanf("%d",&array[i]);\r\n			}\r\n			printf("Case %d:\\n%d ",j,MaxSubSequenceSum(array,m));\r\n			printf("%d %d\\n",start,end);\r\n			if(j!=n)printf("\\n");\r\n			++j;\r\n		}\r\n	}\r\n	return 0;\r\n}', '', 15, 335872, 4, 2, '2010-10-28 10:10:17', '0001-01-01 00:00:00'),
(785, 21, 374, 5, '#include<stdio.h>\r\nvoid maxsub(int data[],int n){\r\n	int i,max1=0,max2=0,temp=0,l=0,left=0,right=0;\r\n	for(i=0;i<=n;i++){\r\n\r\n		temp=data[i]+max1;\r\n\r\n		if(temp>=0){\r\n			max1=temp;\r\n		}\r\n		else{\r\n			l=i+1;\r\n			max1=0;\r\n		}\r\n		if(max1>max2){\r\n			left=l;\r\n			right=i;\r\n			max2=max1;\r\n		}\r\n	}\r\n	if (left == 0 && right == 0 && max2 == 0 && data[0] != 0){\r\n		max2=data[0];\r\n		for(i=0;i<n;i++){\r\n			if(data[i]>max2){\r\n				max2=data[i];\r\n				left=i;\r\n				right=i;\r\n			}\r\n		}\r\n	}\r\n\r\n	printf("%d %d %d\\n\\n",max2,left+1,right+1);\r\n	\r\n}\r\n\r\nvoid main(){\r\n	int line,n1,i,j;  \r\n	int data[20000];\r\n	scanf("%d",&line);\r\n	  for(i=0;i<line;i++){\r\n		data[20000]=0;\r\n		  scanf("%d",&n1);\r\n			for(j=0;j<n1;j++){\r\n				scanf("%d",&data[j]);\r\n			}\r\n		printf("Case %d:\\n",i+1);\r\n		maxsub(data,n1);\r\n\r\n	  }\r\n}', '', 15, 299008, 4, 1, '2010-10-28 10:14:12', '0001-01-01 00:00:00'),
(786, 21, 374, 5, '#include<stdio.h>\r\nvoid maxsub(int data[],int n,int m){\r\n	int i,max1=0,max2=0,temp=0,l=0,left=0,right=0;\r\n	for(i=0;i<n;i++){\r\n\r\n		temp=data[i]+max1;\r\n\r\n		if(temp>=0){\r\n			max1=temp;\r\n		}\r\n		else{\r\n			l=i+1;\r\n			max1=0;\r\n		}\r\n		if(max1>max2){\r\n			left=l;\r\n			right=i;\r\n			max2=max1;\r\n		}\r\n	}\r\n	if (left == 1 && right == 1 && max2 == 0 && data[0] != 0){\r\n		max2=data[0];\r\n		for(i=0;i<n;i++){\r\n			if(data[i]>max2){\r\n				max2=data[i];\r\n				left=i;\r\n				right=i;\r\n			}\r\n		}\r\n	}\r\n	if(m)printf("%d %d %d\\n\\n",max2,left+1,right+1);\r\n	else printf("%d %d %d\\n",max2,left+1,right+1);\r\n}\r\n\r\nvoid main(){\r\n	int line,n1,i,j;  \r\n	int data[20000];\r\n	scanf("%d",&line);\r\n	  for(i=0;i<line;i++){\r\n		\r\n		  scanf("%d",&n1);\r\n			for(j=0;j<n1;j++){\r\n				scanf("%d",&data[j]);\r\n			}\r\n		printf("Case %d:\\n",i+1);\r\n		if(i<line-1)maxsub(data,n1,1);\r\n		else maxsub(data,n1,0);\r\n\r\n	  }\r\n}', '', 15, 299008, 4, 1, '2010-10-28 10:43:38', '0001-01-01 00:00:00'),
(787, 23, 374, 5, '#include"stdio.h"\r\n\r\nint val[20010];\r\nvoid maxlist(int*,int,int);\r\nint main(){\r\n	int line,n=0;\r\n	int i=0,j=1;\r\n\r\n	scanf("%d",&line);\r\n	while(j<=line){	\r\n		scanf("%d",&n);\r\n 	    for(i=0;i<n;++i) scanf("%d",&val[i]);\r\n		maxlist(val,n,j);\r\n	}\r\n	return 0;\r\n}\r\nvoid maxlist(int* val,int n,int line){\r\n	int temp,max,firstnum=1,lastnum=1;\r\n	max=temp=val[0];\r\n	for(int i=1;i<n;++i){\r\n		temp+=val[i];\r\n		if(temp>max){\r\n			max=temp;\r\n			lastnum=i+1;\r\n		}else if(temp<=0){\r\n			temp=0;\r\n			if(val[i+1]>0) firstnum=i+2;\r\n		}\r\n	}\r\n		printf("case %d\\n",line);\r\n		printf("%d %d %d",max,firstnum,lastnum);\r\n}', 'Main.c: In function ''maxlist'':\r\nMain.c:20:2: error: ''for'' loop initial declarations are only allowed in C99 mode\r\nMain.c:20:2: note: use option -std=c99 or -std=gnu99 to compile your code\r\n', 0, 0, 2, 1, '2010-10-28 11:40:10', '0001-01-01 00:00:00'),
(788, 23, 374, 5, '#include"stdio.h"\r\n\r\nint val[20010];\r\nvoid maxlist(int*,int,int);\r\nint main(){\r\n	int line,n=0;\r\n	int i=0,j=1;\r\n\r\n	scanf("%d",&line);\r\n	while(j<=line){	\r\n		scanf("%d",&n);\r\n 	    for(i=0;i<n;++i) scanf("%d",&val[i]);\r\n		maxlist(val,n,j);\r\n	}\r\n	return 0;\r\n}\r\nvoid maxlist(int* val,int n,int line){\r\n	int temp,max,firstnum=1,lastnum=1;\r\n	max=temp=val[0];\r\n	for(int i=1;i<n;++i){\r\n		temp+=val[i];\r\n		if(temp>max){\r\n			max=temp;\r\n			lastnum=i+1;\r\n		}else if(temp<=0){\r\n			temp=0;\r\n			if(val[i+1]>0) firstnum=i+2;\r\n		}\r\n	}\r\n		printf("case %d\\n",line);\r\n		printf("%d %d %d",max,firstnum,lastnum);\r\n}', '', 80, 339968, 5, 2, '2010-10-28 11:45:11', '0001-01-01 00:00:00');
INSERT INTO `tbl_submitions` (`id`, `user_id`, `problem_id`, `exercise_id`, `source`, `result`, `used_time`, `used_memory`, `status`, `compiler_id`, `created`, `modified`) VALUES
(789, 23, 374, 5, '#include"stdio.h"\r\n\r\nint val[20010];\r\nvoid maxlist(int*,int,int);\r\nint main(){\r\n	int line,n=0;\r\n	int i=0,j=1;\r\n    int temp,max,firstnum=1,lastnum=1;\r\n	max=temp=val[0];\r\n	scanf("%d",&line);\r\n	while(j<=line){	\r\n		scanf("%d",&n);\r\n 	    for(i=0;i<n;++i) scanf("%d",&val[i]);\r\n		max=temp=val[0];\r\n		for(i=1;i<n;++i){\r\n		temp+=val[i];\r\n		if(temp>max){\r\n			max=temp;\r\n			lastnum=i+1;\r\n		}else if(temp<=0){\r\n			temp=0;\r\n			if(val[i+1]>0) firstnum=i+2;\r\n		}\r\n	}\r\n		printf("case %d\\n",line);\r\n		printf("%d %d %d",max,firstnum,lastnum);\r\n	}\r\n	return 0;\r\n}', '', 80, 335872, 5, 2, '2010-10-28 11:49:00', '0001-01-01 00:00:00'),
(790, 23, 374, 5, '#include"stdio.h"\r\n\r\nint val[20010];\r\nvoid maxlist(int*,int,int);\r\nint main(){\r\n	int line,n=0,i=0,j=0;\r\n    int temp,max,firstnum=1,lastnum=1;\r\n	\r\n	while(scanf("%d",&line)==1){	\r\n		scanf("%d",&n);\r\n		for(i=0;i<n;++i) scanf("%d",&val[i]);\r\n		\r\n		max=temp=val[0];\r\n		for(i=1;i<n;++i){\r\n			temp+=val[i];\r\n			if(temp>max){\r\n				max=temp;\r\n				lastnum=i+1;\r\n			}else if(temp<=0){\r\n				temp=0;\r\n				if(val[i+1]>0) firstnum=i+2;\r\n			}\r\n		}\r\n		printf("case %d\\n",line);\r\n		printf("%d %d %d",max,firstnum,lastnum);\r\n		if(++j==line) break;\r\n	}\r\n	return 0;\r\n}', '', 0, 339968, 4, 2, '2010-10-28 11:55:22', '0001-01-01 00:00:00'),
(791, 23, 374, 5, '#include"stdio.h"\r\n\r\nint val[20010];\r\nvoid maxlist(int*,int,int);\r\nint main(){\r\n	int line,n=0,i=0,j=0;\r\n    int temp,max,firstnum=1,lastnum=1;\r\n\r\n	scanf("%d",&line);\r\n	while(1){	\r\n		scanf("%d",&n);\r\n		for(i=0;i<n;++i) scanf("%d",&val[i]);\r\n		\r\n		max=temp=val[0];\r\n		for(i=1;i<n;++i){\r\n			temp+=val[i];\r\n			if(temp>max){\r\n				max=temp;\r\n				lastnum=i+1;\r\n			}else if(temp<=0){\r\n				temp=0;\r\n				if(val[i+1]>0) firstnum=i+2;\r\n			}\r\n		}\r\n		printf("case %d\\n",line);\r\n		printf("%d %d %d",max,firstnum,lastnum);\r\n		if(++j==line) break;\r\n	}\r\n	return 0;\r\n}', '', 31, 339968, 4, 1, '2010-10-28 12:00:05', '0001-01-01 00:00:00'),
(792, 17, 374, 5, '#include<stdio.h>\r\n#include<stdlib.h>\r\n#define MAX 10000\r\nvoid MaxSum(int *A,int n)\r\n{\r\n    int nStart,nAll,i;\r\n    int j;\r\n    int num1,num2,num;\r\n    num1=num=num2=0;\r\n    j=0;\r\n    nStart = 0;\r\n    nAll = A[0];\r\n    for(i=0;i<n;i++)\r\n    {\r\n      if(A[i]<0)num++;\r\n    }\r\n    for(i=0;i<n;i++)\r\n    { \r\n      if(nStart<0) {nStart = A[i];num2=i;}\r\n      else {\r\n          nStart+=A[i];\r\n      }\r\n      if(nAll<nStart){\r\n        nAll=nStart;\r\n        num1=i;\r\n      }\r\n\r\n      }\r\n    if(num<n-1) printf("%d %d %d\\n",nAll,num2+1,num1+1);\r\n    else\r\n    printf("%d %d %d",nAll,num1+1,num1+1);\r\n    return ;\r\n}  \r\nint main()\r\n{   \r\n    int A[MAX];\r\n    int n,i,j,m;\r\n    int num;\r\n    num=1;\r\n    scanf("%d",&m);\r\n    while(m--)\r\n    {\r\n        scanf("%d",&n);\r\n        for(i=0;i<n;i++)\r\n          scanf("%d",&A[i]);\r\n        printf("Case %d:\\n",num);\r\n        MaxSum(A,n);\r\n                if(m!=0)printf("\\n\\n");\r\n        else printf("\\n");\r\n        num++;\r\n    }\r\n    system("pause");\r\n    return 0;\r\n}   \r\n    \r\n', '', 15, 262144, 4, 1, '2010-10-28 12:42:25', '0001-01-01 00:00:00'),
(793, 17, 374, 5, '#include<stdio.h>\r\n#include<stdlib.h>\r\n#define MAX 10000\r\nvoid MaxSum(int *a,int n)\r\n{       int i;\r\n		int sum=0,maxnum=-1001,first =0, last = 0, temp = 1;\r\n		for (i=0;i<n;i++)\r\n		{\r\n			sum += a[i];\r\n			if (sum > maxnum)\r\n			{\r\n				maxnum = sum;first = temp;last = i+1;\r\n			}\r\n			if (sum < 0)\r\n			{\r\n				sum = 0;temp = i+2;\r\n			}\r\n		}\r\n\r\n	printf("%d %d %d\\n",maxnum,first,last);\r\n    return ;\r\n}  \r\nint main()\r\n{   \r\n    int A[MAX];\r\n    int n,i,j,m;\r\n    int num;\r\n    num=1;\r\n    scanf("%d",&m);\r\n    while(m--)\r\n    {\r\n        scanf("%d",&n);\r\n        for(i=0;i<n;i++)\r\n          scanf("%d",&A[i]);\r\n        printf("Case %d:\\n",num);\r\n        MaxSum(A,n);\r\n        if(m!=0)printf("\\n");\r\n        num++;\r\n    }\r\n    system("pause");\r\n    return 0;\r\n}   \r\n    \r\n', '', 15, 266240, 4, 1, '2010-10-28 13:01:02', '0001-01-01 00:00:00'),
(794, 17, 374, 5, '#include<stdio.h>\r\nint main()\r\n{\r\n	int j,i,k,n,m,t;\r\n	int a[100002];\r\n	scanf("%d",&t);\r\n	for (j=1;j<=t;j++)\r\n	{\r\n		scanf("%d",&n);\r\n		for (i=0;i<n;i++)\r\n		{\r\n			scanf("%d",&a[i]);\r\n		}\r\n		int sum=0,maxnum=-1001,first =0, last = 0, temp = 1;\r\n		for (i=0;i<n;i++)\r\n		{\r\n			sum += a[i];\r\n			if (sum > maxnum)\r\n			{\r\n				maxnum = sum;first = temp;last = i+1;\r\n			}\r\n			if (sum < 0)\r\n			{\r\n				sum = 0;temp = i+2;\r\n			}\r\n		}\r\n\r\n		printf("Case %d:\\n%d %d %d\\n",j,maxnum,first,last);\r\n		if (j!=t)\r\n		{\r\n			printf("\\n");\r\n		}\r\n	}\r\n	return 0;\r\n}\r\n', '', 15, 622592, 1, 1, '2010-10-28 13:03:01', '0001-01-01 00:00:00'),
(795, 17, 375, 5, '#include<stdio.h>\r\n#define M 30010\r\nint main()\r\n{\r\n    int i,j,n;\r\n    int num[M];\r\n    int f[M];\r\n    int max;\r\n    while(scanf("%d",&n)!=EOF)\r\n    { \r\n      max=0;\r\n      for(i=0;i<n;i++)\r\n        scanf("%d",&num[i]);\r\n      for(i=0;i<n;i++)\r\n      {\r\n         f[i]=1;\r\n         for(j=0;j<i;j++)\r\n         {\r\n           if(num[i]>num[j])\r\n           {\r\n              f[i]=f[j]+1;\r\n           }\r\n         }\r\n       }\r\n       for(i=0;i<n;i++)\r\n        if(max<f[i]) max=f[i];\r\n       printf("%d\\n",max);\r\n      }\r\n      return 0;\r\n\r\n}\r\n             \r\n           \r\n', '', 500, 462848, 5, 1, '2010-10-28 13:35:46', '0001-01-01 00:00:00'),
(796, 17, 345, 4, '#include<iostream>\r\n#include<vector>\r\n#include<algorithm>\r\n#include<stdio.h>\r\n#include<string.h>\r\nusing namespace std;\r\nbool flag;\r\nbool cmp(const string a,const string b)\r\n{\r\n    return a<b;\r\n}\r\nint main()\r\n{   \r\n    vector<string>l1,l2,r1,r2;\r\n    string snake;\r\n    int n,m;\r\n    while(scanf("%d",&n)!=EOF)\r\n    {   \r\n       for(int i=0;i<n;i++)\r\n        {\r\n               cin>>snake;\r\n               l1.push_back(snake);\r\n               r1.push_back(snake);\r\n        }\r\n        cin>>m;\r\n        for(int i=0;i<m;i++)\r\n        {\r\n                cin>>snake;\r\n                l2.push_back(snake);\r\n                r2.push_back(snake);\r\n        }\r\n        sort(r1.begin(),r1.end(),cmp);\r\n        sort(r2.begin(),r2.end(),cmp);\r\n        vector<string>::iterator result;\r\n        \r\n             for(int i=0;i<n;i++)\r\n        {\r\n              result = find(r2.begin( ),r2.end( ),l1[i]); //查找3\r\n              if (result == r2.end( )) \r\n                 {flag=0;}\r\n              else //找到\r\n              {flag=1;\r\n  \r\n               break;\r\n             }\r\n         }\r\n         if(flag)\r\n          cout<<*result<<" ";\r\n          else\r\n          cout<<"none"<<" ";\r\n\r\n        for(int i=0;i<m;i++)\r\n        {\r\n              result = find(r1.begin( ),r1.end( ),l2[i]); //查找3\r\n              if (result == r1.end( )) \r\n                 {flag=0;}\r\n              else //找到\r\n              {\r\n                   flag=1;\r\n                   break;\r\n             }\r\n         }\r\n         if(flag)\r\n          cout<<*result<<endl;\r\n          else\r\n          cout<<"none"<<endl;\r\n    \r\n         l1.clear();\r\n         l2.clear();\r\n         r1.clear();\r\n         r2.clear();\r\n      }\r\n        return 0;\r\n}\r\n', '', 109, 573440, 1, 2, '2010-10-28 15:13:03', '0001-01-01 00:00:00'),
(797, 17, 376, 5, '#include<stdio.h>\r\n#include<stdlib.h>\r\nint *num;\r\nint *left;\r\nint *right;\r\nvoid get_left(int n)\r\n{\r\n    int i;\r\n    left[0]=1;\r\n    for(i=1;i<n;i++)\r\n      left[i]=left[i-1]*num[i];\r\n}\r\nvoid get_right(int n)\r\n{\r\n    int i;\r\n    right[n-1]=1;\r\n    for(i=n-2;i>=0;i--)\r\n        right[i]=right[i+1]*num[i+1];\r\n}\r\n   \r\nint get_max(int len,int &max)\r\n{   \r\n    int i;\r\n    max=left[0]*right[0];\r\n    int pos=0;\r\n    for(i=1;i<len;++i)\r\n    {\r\n      if(left[i]*right[i]>max)\r\n      {\r\n           max=left[i]*right[i];\r\n           pos=i;\r\n      }\r\n    }\r\n    return pos;\r\n}\r\nint main()\r\n{\r\n    int n;\r\n    int i;\r\n    int max;\r\n    while(scanf("%d",&n)!=EOF)\r\n    {  max=0;\r\n       for(i=0;i<n;i++)\r\n         scanf("%d",num+i);\r\n       get_left(n);\r\n       get_right(n);\r\n       printf("%d\\n",get_max(n,max));\r\n       printf("%d\\n",max);\r\n       }\r\n       return 0;\r\n    }\r\n', 'Main.c:21:25: error: expected '';'', '','' or '')'' before ''&'' token\r\n', 0, 0, 2, 1, '2010-10-28 15:23:12', '0001-01-01 00:00:00'),
(798, 17, 375, 5, '#include<stdio.h>\r\n#define M 30010\r\nint main()\r\n{\r\n    int i,j,n;\r\n    int num[M];\r\n    int f[M];\r\n    int max;\r\n    while(scanf("%d",&n)!=EOF)\r\n    { \r\n      max=0;\r\n      for(i=0;i<n;i++)\r\n        scanf("%d",&num[i]);\r\n      for(i=0;i<n;i++)\r\n      {\r\n         f[i]=1;\r\n         for(j=0;j<i;j++)\r\n         {\r\n           if(num[i]>num[j]&&f[j]+1>f[i])\r\n           {\r\n              f[i]=f[j]+1;\r\n           }\r\n         }\r\n       }\r\n       for(i=0;i<n;i++)\r\n        if(max<f[i]) max=f[i];\r\n       printf("%d\\n",max);\r\n      }\r\n      return 0;\r\n\r\n}\r\n             \r\n           \r\n', '', 500, 462848, 5, 1, '2010-10-28 15:25:01', '0001-01-01 00:00:00'),
(799, 36, 335, 2, '#include<iostream>\r\n#include<algorithm>\r\n\r\nusing namespace std;\r\n\r\n\r\nint bit_count(unsigned int a,unsigned int b)\r\n{\r\n	int count=0;\r\n	a=a^b;\r\n	while(a)\r\n	{\r\n		a &=(a-1);\r\n			count++;\r\n	}\r\n	return count;\r\n}\r\n\r\nint main()\r\n{\r\n	unsigned int a,b;\r\n	int wei;\r\n	cout<<"输入整数a和整数b"<<endl;\r\n	cin>>a>>b;\r\n	wei=bit_count(a,b);\r\n	cout<<wei<<endl;\r\n	system("pause");\r\n	return 0;\r\n}', 'Main.c:1:19: fatal error: iostream: No such file or directory\r\ncompilation terminated.\r\n', 0, 0, 2, 1, '2010-10-28 15:40:50', '0001-01-01 00:00:00'),
(800, 36, 335, 2, '#include<iostream>\r\n#include<algorithm>\r\n\r\nusing namespace std;\r\n\r\n\r\nint bit_count(unsigned int a,unsigned int b)\r\n{\r\n	int count=0;\r\n	a=a^b;\r\n	while(a)\r\n	{\r\n		a &=(a-1);\r\n			count++;\r\n	}\r\n	return count;\r\n}\r\n\r\nint main()\r\n{\r\n	unsigned int a,b;\r\n	int wei;\r\n	while(cin>>a>>b)\r\n	{\r\n	wei=bit_count(a,b);\r\n	cout<<wei<<endl;\r\n	}\r\n	//system("pause");\r\n	return 0;\r\n}', 'Main.c:1:19: fatal error: iostream: No such file or directory\r\ncompilation terminated.\r\n', 0, 0, 2, 1, '2010-10-28 15:47:04', '0001-01-01 00:00:00'),
(801, 36, 335, 2, '#include<iostream>\r\n#include<algorithm>\r\n#include<vector>\r\n\r\nusing namespace std;\r\n\r\n\r\nint bit_count(unsigned int a,unsigned int b)\r\n{\r\n	int count=0;\r\n	a=a^b;\r\n	while(a)\r\n	{\r\n		a &=(a-1);\r\n			count++;\r\n	}\r\n	return count;\r\n}\r\n\r\nint main()\r\n{\r\n	vector<int>::iterator  i;\r\n	vector<int> out;\r\n	unsigned int a,b;\r\n	int wei;\r\n	while(cin>>a>>b)\r\n	{\r\n	wei=bit_count(a,b);\r\n	out.push_back (wei);\r\n	}\r\n	for(i=out.begin ();i!=out.end ();i++)\r\n	cout<<*i<<endl;\r\n	//system("pause");\r\n	return 0;\r\n}', 'Main.c:1:19: fatal error: iostream: No such file or directory\r\ncompilation terminated.\r\n', 0, 0, 2, 1, '2010-10-28 15:51:32', '0001-01-01 00:00:00'),
(802, 35, 335, 2, '#include <stdio.h>\r\nint main()\r\n{\r\n    int a[20][2];\r\n	int i=0,times=0;\r\n	while(scanf("%d ,%d ",&a[i][0],&a[i][1])!=EOF);  \r\n		i++;\r\n	for(int j=0;a[j][0]!=NULL;j++)\r\n	{\r\n		int c=a[j][0]^a[j][1];\r\n		while(c!=0)\r\n		{\r\n			c=c&(c-1);\r\n			times++;\r\n		}\r\n		printf("%d\\n",times);\r\n	}\r\n	return 0;\r\n}\r\n', 'Main.c: In function ''main'':\r\nMain.c:8:2: error: ''for'' loop initial declarations are only allowed in C99 mode\r\nMain.c:8:2: note: use option -std=c99 or -std=gnu99 to compile your code\r\nMain.c:8:21: warning: comparison between pointer and integer\r\n', 0, 0, 2, 1, '2010-10-28 16:00:47', '0001-01-01 00:00:00'),
(803, 35, 335, 2, '#include <stdio.h>\r\n#define MAX 50\r\nint main()\r\n{\r\n    int a[MAX];\r\n	int i=0,times;\r\n	while(scanf("%d",&a[i])!=EOF)  \r\n		i++;\r\n	for(int j=0;j<i;j+=2)\r\n	{\r\n		\r\n		int c=a[j]^a[j+1];\r\n		times=0;\r\n		while(c!=0)\r\n		{\r\n			c=c&(c-1);\r\n			times++;\r\n		}\r\n		printf("%d\\n",times);\r\n	}\r\n	return 0;\r\n}', 'Main.c: In function ''main'':\r\nMain.c:9:2: error: ''for'' loop initial declarations are only allowed in C99 mode\r\nMain.c:9:2: note: use option -std=c99 or -std=gnu99 to compile your code\r\n', 0, 0, 2, 1, '2010-10-28 16:09:01', '0001-01-01 00:00:00'),
(804, 35, 335, 2, '#include <stdio.h>\r\n#define MAX 50\r\nint main()\r\n{\r\n    int a[MAX];\r\n	int i=0,times;\r\n	while(scanf("%d",&a[i])!=EOF)  \r\n		i++;\r\n	for(int j=0;j<i;j+=2)\r\n	{\r\n		\r\n		int c=a[j]^a[j+1];\r\n		times=0;\r\n		while(c!=0)\r\n		{\r\n			c=c&(c-1);\r\n			times++;\r\n		}\r\n		printf("%d\\n",times);\r\n	}\r\n	return 0;\r\n}\r\n', '', 0, 262144, 7, 2, '2010-10-28 16:14:41', '0001-01-01 00:00:00'),
(805, 36, 335, 2, '#include<iostream>\r\n#include<algorithm>\r\n#include<vector>\r\n\r\nusing namespace std;\r\n\r\n\r\nint bit_count(unsigned int a,unsigned int b)\r\n{\r\n	int count=0;\r\n	a=a^b;\r\n	while(a)\r\n	{\r\n		a &=(a-1);\r\n			count++;\r\n	}\r\n	return count;\r\n}\r\n\r\nint main()\r\n{\r\n	vector<int>::iterator  i;\r\n	vector<int> out;\r\n	unsigned int a,b;\r\n	int wei;\r\n	while(cin>>a>>b)\r\n	{\r\n	wei=bit_count(a,b);\r\n	out.push_back (wei);\r\n	}\r\n	for(i=out.begin ();i!=out.end ();i++)\r\n	cout<<*i<<endl;\r\n	//system("pause");\r\n	return 0;\r\n}', '', 100, 1417216, 5, 2, '2010-10-29 08:02:32', '0001-01-01 00:00:00'),
(806, 36, 335, 2, '#include<iostream>\r\n#include<algorithm>\r\n#include<vector>\r\n\r\nusing namespace std;\r\n\r\n\r\nint bit_count(unsigned int a,unsigned int b)\r\n{\r\n	int count=0;\r\n	a=a^b;\r\n	while(a)\r\n	{\r\n		a &=(a-1);\r\n			count++;\r\n	}\r\n	return count;\r\n}\r\n\r\nint main()\r\n{\r\n	vector<int>::iterator  i;\r\n	vector<int> out;\r\n	unsigned int a,b;\r\n	int wei;\r\n	while(cin>>a>>b)\r\n	{\r\n	wei=bit_count(a,b);\r\n	cout<<wei<<endl;\r\n	//out.push_back (wei);\r\n	}\r\n	for(i=out.begin ();i!=out.end ();i++)\r\n	cout<<*i<<endl;\r\n	return 0;\r\n}', '', 100, 368640, 5, 2, '2010-10-29 08:07:19', '0001-01-01 00:00:00'),
(807, 35, 335, 2, '#include <stdio.h>\r\n\r\nint main()\r\n{\r\n    int a,b,times;\r\n while(scanf("%d %d",&a,&b)!=EOF)  \r\n {\r\n     int c=a^b;\r\n     times=0;\r\n     while(c!=0)\r\n     {\r\n        c=c&(c-1);\r\n        times++;\r\n     }\r\n     printf("%d\\n",times);\r\n	 }   \r\n     return 0;\r\n}', '', 78, 262144, 1, 2, '2010-10-29 08:07:55', '0001-01-01 00:00:00'),
(808, 36, 335, 2, '#include<iostream>\r\n#include<algorithm>\r\n#include<vector>\r\n\r\nusing namespace std;\r\n\r\n\r\nint bit_count(unsigned int a,unsigned int b)\r\n{\r\n	int count=0;\r\n	a=a^b;\r\n	while(a)\r\n	{\r\n		a &=(a-1);\r\n			count++;\r\n	}\r\n	return count;\r\n}\r\n\r\nint main()\r\n{\r\n	vector<int>::iterator  i;\r\n	vector<int> out;\r\n	unsigned int a,b;\r\n	int wei;\r\n	while(cin>>a>>b)\r\n	{\r\n	wei=bit_count(a,b);\r\n	cout<<wei<<endl;\r\n	//out.push_back (wei);\r\n	}\r\n	//for(i=out.begin ();i!=out.end ();i++)\r\n	//cout<<*i<<endl;\r\n	return 0;\r\n}', '', 100, 368640, 5, 2, '2010-10-29 08:08:21', '0001-01-01 00:00:00'),
(809, 36, 335, 2, '#include<iostream>\r\n#include<algorithm>\r\n#include<list>\r\n\r\nusing namespace std;\r\n\r\n\r\nint bit_count(unsigned int a,unsigned int b)\r\n{\r\n	int count=0;\r\n	a=a^b;\r\n	while(a)\r\n	{\r\n		a &=(a-1);\r\n			count++;\r\n	}\r\n	return count;\r\n}\r\n\r\nint main()\r\n{\r\n	//vector<int>::iterator  i;\r\n	list<int> out;\r\n	unsigned int a,b;\r\n	int wei;\r\n	while(cin>>a>>b)\r\n	{\r\n	wei=bit_count(a,b);\r\n	cout<<wei<<endl;\r\n	//out.push_back (wei);\r\n	}\r\n	//for(i=out.begin ();i!=out.end ();i++)\r\n	//cout<<*i<<endl;\r\n	return 0;\r\n}', '', 100, 368640, 5, 2, '2010-10-29 08:10:09', '0001-01-01 00:00:00'),
(810, 36, 335, 2, '#include<iostream>\r\n#include<algorithm>\r\n//#include<list>\r\n\r\nusing std::cin; using std::endl;\r\nusing std::count ;\r\n\r\n\r\nint bit_count(unsigned int a,unsigned int b)\r\n{\r\n	int count=0;\r\n	a=a^b;\r\n	while(a)\r\n	{\r\n		a &=(a-1);\r\n			count++;\r\n	}\r\n	return count;\r\n}\r\n\r\nint main()\r\n{\r\n	//vector<int>::iterator  i;\r\n	//list<int> out;\r\n	unsigned int a,b;\r\n	int wei;\r\n	while(cin>>a>>b)\r\n	{\r\n	wei=bit_count(a,b);\r\n	cout<<wei<<endl;\r\n	//out.push_back (wei);\r\n	}\r\n	//for(i=out.begin ();i!=out.end ();i++)\r\n	//cout<<*i<<endl;\r\n	return 0;\r\n}', 'Main.cpp: In function ''int main()'':\r\nMain.cpp:30:2: error: ''cout'' was not declared in this scope\r\n', 0, 0, 2, 2, '2010-10-29 08:12:47', '0001-01-01 00:00:00'),
(811, 36, 335, 2, '#include<iostream>\r\n#include<algorithm>\r\n//#include<list>\r\n\r\nusing std::cin; using std::endl;\r\nusing std::cout ;\r\n\r\n\r\nint bit_count(unsigned int a,unsigned int b)\r\n{\r\n	int count=0;\r\n	a=a^b;\r\n	while(a)\r\n	{\r\n		a &=(a-1);\r\n			count++;\r\n	}\r\n	return count;\r\n}\r\n\r\nint main()\r\n{\r\n	//vector<int>::iterator  i;\r\n	//list<int> out;\r\n	unsigned int a,b;\r\n	int wei;\r\n	while(cin>>a>>b)\r\n	{\r\n	wei=bit_count(a,b);\r\n	cout<<wei<<endl;\r\n	//out.push_back (wei);\r\n	}\r\n	//for(i=out.begin ();i!=out.end ();i++)\r\n	//cout<<*i<<endl;\r\n	return 0;\r\n}', '', 100, 364544, 5, 2, '2010-10-29 08:13:24', '0001-01-01 00:00:00'),
(812, 36, 335, 2, '#include<iostream>\r\n#include<algorithm>\r\n//#include<list>\r\n\r\nusing std::cin; using std::endl;\r\nusing std::cout ;\r\n\r\n\r\nint main()\r\n{\r\n	unsigned int a,b;\r\n	int count;\r\n	while(cin>>a>>b)\r\n	{\r\n		count=0;\r\n		a=a^b;\r\n		while(a)\r\n		{\r\n			a &=(a-1);\r\n			count++;\r\n		}\r\n		cout<<count<<endl;\r\n	}\r\n	return 0;\r\n}', '', 100, 368640, 5, 2, '2010-10-29 08:19:54', '0001-01-01 00:00:00'),
(813, 36, 335, 2, '#include<iostream>\r\n#include<algorithm>\r\n\r\nusing std::cin; using std::endl;\r\nusing std::cout ;\r\n\r\n\r\nint main()\r\n{\r\n	unsigned int a,b;\r\n	int count;\r\n	while(cin>>a>>b)\r\n	{\r\n		count=0;\r\n		a=a^b;\r\n		while(a)\r\n		{\r\n			a &=(a-1);\r\n			count++;\r\n		}\r\n		cout<<count<<endl;\r\n	}\r\n	return 0;\r\n}', '', 100, 368640, 5, 2, '2010-10-29 08:23:42', '0001-01-01 00:00:00'),
(814, 36, 335, 2, '#include<stdio.h>\r\n\r\nint main()\r\n{\r\n	int a,b;\r\n	int count;\r\n	while(scanf("%d%d",&a,&b))\r\n	{\r\n		count=0;\r\n		a=a^b;\r\n		while(a)\r\n		{\r\n			a &=(a-1);\r\n			count++;\r\n		}\r\n		printf("%d\\n",count);\r\n	}\r\n	return 0;\r\n}', '', 100, 258048, 5, 1, '2010-10-29 08:34:58', '0001-01-01 00:00:00'),
(815, 36, 335, 2, '#include<stdio.h>\r\n\r\nint main()\r\n{\r\n	int a,b;\r\n	int count;\r\n	while(scanf("%d %d",&a,&b)!=EOF)\r\n	{\r\n		count=0;\r\n		a=a^b;\r\n		while(a)\r\n		{\r\n			a &=(a-1);\r\n			count++;\r\n		}\r\n		printf("%d\\n",count);\r\n	}\r\n	return 0;\r\n}', '', 62, 262144, 1, 2, '2010-10-29 08:36:29', '0001-01-01 00:00:00'),
(816, 35, 336, 2, '#include<stdio.h>\r\nvoid change(int &a,int &b)\r\n{\r\n	int temp=a;\r\n	a=b;b=temp;\r\n}\r\nint main()\r\n{\r\n	int n;\r\n	while(scanf("%d",&n)!=EOF&&n>=0&&n<=50000)\r\n	{\r\n		int A[50000][2];\r\n		for(int i=0;i<n;i++)\r\n		{\r\n			scanf("%d ",&A[i][0]);\r\n			A[i][1]=A[i][0];\r\n			int times=0;\r\n			for(int count=0;A[i][1];A[i][1]&=A[i][1]-1)\r\n				times++;\r\n			A[i][1]=times;\r\n		}\r\n		for(int j=n-1;j>0;j--)\r\n		{\r\n			for(int i=0;i<j;i++)\r\n			{\r\n				if(A[i][1]>A[i+1][1])\r\n				{\r\n					change(A[i][1],A[i+1][1]);\r\n					change(A[i][0],A[i+1][0]);\r\n				}\r\n				if(A[i][1]==A[i+1][1]&&A[i][0]>A[i+1][0])\r\n				{\r\n					change(A[i][1],A[i+1][1]);\r\n					change(A[i][0],A[i+1][0]);\r\n				}\r\n			}\r\n		}\r\n		for(int m=0;m<n;m++)\r\n			printf("%d ",A[m][0]);\r\n	}\r\n	return 0;\r\n}', '', 200, 618496, 5, 2, '2010-10-29 08:51:56', '0001-01-01 00:00:00'),
(817, 35, 336, 2, '#include<stdio.h>\r\nvoid change(int &a,int &b)\r\n{\r\n	int temp=a;a=b;b=temp;\r\n}\r\nint main()\r\n{\r\n	int n=1;\r\n	while(scanf("%d ",&n)!=EOF&&n>=0&&n<=50000)\r\n	{\r\n		int A[50000][2];\r\n		for(int i=0;i<n;i++)\r\n		{\r\n			scanf("%d",&A[i][0]);\r\n			A[i][1]=A[i][0];\r\n			int times=0;\r\n			for(;A[i][1];A[i][1]&=A[i][1]-1)\r\n				times++;\r\n			A[i][1]=times;\r\n		}\r\n		for(int j=n-1;j>0;j--)\r\n		{\r\n			for(int i=0;i<j;i++)\r\n			{\r\n				if(A[i][1]>A[i+1][1])\r\n				{\r\n					change(A[i][1],A[i+1][1]);\r\n					change(A[i][0],A[i+1][0]);\r\n				}\r\n				if(A[i][1]==A[i+1][1]&&A[i][0]>A[i+1][0])\r\n				{\r\n					change(A[i][1],A[i+1][1]);\r\n					change(A[i][0],A[i+1][0]);\r\n				}\r\n			}\r\n		}\r\n		for(int m=0;m<n;m++)\r\n			printf("%d ",A[m][0]);\r\n	}\r\n	return 0;\r\n}', '', 200, 618496, 5, 2, '2010-10-29 09:10:30', '0001-01-01 00:00:00'),
(818, 35, 336, 2, '#include<stdio.h>\r\nvoid change(int &a,int &b)\r\n{\r\n	int temp=a;a=b;b=temp;\r\n}\r\nint main()\r\n{\r\n	int n=1;\r\n	while(scanf("%d ",&n)!=EOF&&n>=0&&n<=50000)\r\n	{\r\n		int A[50000][2];\r\n		for(int i=0;i<n;i++)\r\n		{\r\n			scanf("%d",&A[i][0]);\r\n			A[i][1]=A[i][0];\r\n			int times=0;\r\n			for(;A[i][1];A[i][1]&=A[i][1]-1)\r\n				times++;\r\n			A[i][1]=times;\r\n		}\r\n		for(int j=n-1;j>0;j--)\r\n		{\r\n			for(int i=0;i<j;i++)\r\n			{\r\n				if(A[i][1]>A[i+1][1])\r\n				{\r\n					change(A[i][1],A[i+1][1]);\r\n					change(A[i][0],A[i+1][0]);\r\n				}\r\n				if(A[i][1]==A[i+1][1]&&A[i][0]>A[i+1][0])\r\n				{\r\n					change(A[i][1],A[i+1][1]);\r\n					change(A[i][0],A[i+1][0]);\r\n				}\r\n			}\r\n		}\r\n		for(int m=0;m<n;m++)\r\n			printf("%d ",A[m][0]);\r\n		printf("\\n");\r\n	}\r\n	return 0;\r\n}', '', 200, 622592, 5, 2, '2010-10-29 09:12:14', '0001-01-01 00:00:00'),
(819, 35, 336, 2, '#include<stdio.h>\r\nint main()\r\n{\r\n	int n=1;\r\n	while(scanf("%d ",&n)!=EOF&&n>=0&&n<=50000)\r\n	{\r\n		int A[50000][2];\r\n		for(int i=0;i<n;i++)\r\n		{\r\n			scanf("%d",&A[i][0]);\r\n			A[i][1]=A[i][0];\r\n			int times=0;\r\n			for(;A[i][1];A[i][1]&=A[i][1]-1)\r\n				times++;\r\n			A[i][1]=times;\r\n		}\r\n		for(int j=n-1;j>0;j--)\r\n		{\r\n			for(int i=0;i<j;i++)\r\n			{\r\n				if(A[i][1]>A[i+1][1])\r\n				{\r\n					int temp=A[i][1];A[i][1]=A[i+1][1];A[i+1][1]=temp;\r\n					temp=A[i][0];A[i][0]=A[i+1][0];A[i+1][0]=temp;\r\n				}\r\n				if(A[i][1]==A[i+1][1]&&A[i][0]>A[i+1][0])\r\n				{\r\n					int temp=A[i][1];A[i][1]=A[i+1][1];A[i+1][1]=temp;\r\n					temp=A[i][0];A[i][0]=A[i+1][0];A[i+1][0]=temp;\r\n				}\r\n			}\r\n		}\r\n		for(int m=0;m<n;m++)\r\n			printf("%d ",A[m][0]);\r\n		printf("\\n");\r\n	}\r\n	return 0;\r\n}', 'Main.c: In function ''main'':\r\nMain.c:8:3: error: ''for'' loop initial declarations are only allowed in C99 mode\r\nMain.c:8:3: note: use option -std=c99 or -std=gnu99 to compile your code\r\nMain.c:17:3: error: ''for'' loop initial declarations are only allowed in C99 mode\r\nMain.c:19:4: error: ''for'' loop initial declarations are only allowed in C99 mode\r\nMain.c:33:3: error: ''for'' loop initial declarations are only allowed in C99 mode\r\n', 0, 0, 2, 1, '2010-10-29 09:20:06', '0001-01-01 00:00:00'),
(820, 35, 336, 2, '#include<stdio.h>\r\nint main()\r\n{\r\n	int n=1;\r\n	while(scanf("%d ",&n)!=EOF&&n>=0&&n<=50000)\r\n	{\r\n		int A[50000][2];\r\n		for(int i=0;i<n;i++)\r\n		{\r\n			scanf("%d",&A[i][0]);\r\n			A[i][1]=A[i][0];\r\n			int times=0;\r\n			for(;A[i][1];A[i][1]&=A[i][1]-1)\r\n				times++;\r\n			A[i][1]=times;\r\n		}\r\n		for(int j=n-1;j>0;j--)\r\n		{\r\n			for(int i=0;i<j;i++)\r\n			{\r\n				if(A[i][1]>A[i+1][1])\r\n				{\r\n					int temp=A[i][1];A[i][1]=A[i+1][1];A[i+1][1]=temp;\r\n					temp=A[i][0];A[i][0]=A[i+1][0];A[i+1][0]=temp;\r\n				}\r\n				if(A[i][1]==A[i+1][1]&&A[i][0]>A[i+1][0])\r\n				{\r\n					int temp=A[i][1];A[i][1]=A[i+1][1];A[i+1][1]=temp;\r\n					temp=A[i][0];A[i][0]=A[i+1][0];A[i+1][0]=temp;\r\n				}\r\n			}\r\n		}\r\n		for(int m=0;m<n;m++)\r\n			printf("%d ",A[m][0]);\r\n		printf("\\n");\r\n	}\r\n	return 0;\r\n}', '', 200, 626688, 5, 2, '2010-10-29 09:20:17', '0001-01-01 00:00:00'),
(821, 36, 336, 2, '#include<iostream>\r\n#include<algorithm>\r\n#include<list>\r\n#define POW(c) (1<<(c))\r\n#define MASK(c) (((unsigned long)-1) / (POW(POW(c)) + 1))\r\n#define ROUND(n, c) (((n) & MASK(c)) + ((n) >> POW(c) & MASK(c)))\r\nusing std::list ;using std::cin ;\r\nusing std::cout; using std::sort ;\r\nusing std::endl ;\r\n\r\nint bit_count(int n)\r\n{\r\n	n = ROUND(n, 0);\r\n	n = ROUND(n, 1);\r\n	n = ROUND(n, 2);\r\n	n = ROUND(n, 3);\r\n	n = ROUND(n, 4);\r\n	return n;\r\n}\r\nstruct element{\r\n	int origin;\r\n	int number;\r\n};\r\nbool compare(const element& x, const element& y)\r\n{\r\n	if(x.number ==y.number )\r\n		return x.origin <y.origin ;\r\n	else  return x.number <y.number ;\r\n}\r\n\r\nint main()\r\n{\r\n	element a;\r\n	int size,i,x;\r\n	list<element>::iterator j;\r\n	while(cin>>size)\r\n	{\r\n		list<element> y;\r\n		for(i=0;i<size;i++)\r\n		{\r\n			cin>>x;\r\n			a.origin=x;\r\n			a.number =bit_count(x);\r\n			y.push_back (a);\r\n		}\r\n		y.sort (compare);\r\n		for(j=y.begin ();j!=y.end ();j++)\r\n			cout<<j->origin<<" ";\r\n		cout<<endl;\r\n	}\r\n	return 0;\r\n}\r\n', '', 46, 970752, 3, 2, '2010-10-29 09:24:28', '0001-01-01 00:00:00'),
(822, 36, 336, 2, '#include<iostream>\r\n#include<algorithm>\r\n#include<list>\r\n#define POW(c) (1<<(c))\r\n#define MASK(c) (((unsigned long)-1) / (POW(POW(c)) + 1))\r\n#define ROUND(n, c) (((n) & MASK(c)) + ((n) >> POW(c) & MASK(c)))\r\nusing std::list ;using std::cin ;\r\nusing std::cout; using std::sort ;\r\nusing std::endl ;\r\n\r\nint bit_count(int n)\r\n{\r\n	n = ROUND(n, 0);\r\n	n = ROUND(n, 1);\r\n	n = ROUND(n, 2);\r\n	n = ROUND(n, 3);\r\n	n = ROUND(n, 4);\r\n	return n;\r\n}\r\nstruct element{\r\n	int origin;\r\n	int number;\r\n};\r\nbool compare(const element& x, const element& y)\r\n{\r\n	if(x.number ==y.number )\r\n		return x.origin <y.origin ;\r\n	else  return x.number <y.number ;\r\n}\r\n\r\nint main()\r\n{\r\n	element a;\r\n	int size,i,x;\r\n	list<element>::iterator j;\r\n	while(cin>>size)\r\n	{\r\n		list<element> y;\r\n		for(i=0;i<size;i++)\r\n		{\r\n			cin>>x;\r\n			a.origin=x;\r\n			a.number =bit_count(x);\r\n			y.push_back (a);\r\n		}\r\n		y.sort (compare);\r\n		for(j=y.begin ();j!=y.end ();j++)\r\n			cout<<j->origin<<" ";\r\n		cout<<endl;\r\n	}\r\n	return 0;\r\n}\r\n', '', 46, 974848, 3, 2, '2010-10-29 09:26:32', '0001-01-01 00:00:00'),
(823, 36, 336, 2, '#include<iostream>\r\n#include<algorithm>\r\n#include<list>\r\n\r\n#define POW(c) (1<<(c))\r\n#define MASK(c) (((unsigned long)-1) / (POW(POW(c)) + 1))\r\n#define ROUND(n, c) (((n) & MASK(c)) + ((n) >> POW(c) & MASK(c)))\r\nusing std::list ;using std::cin ;\r\nusing std::cout; using std::sort ;\r\nusing std::endl ;\r\n\r\nint bit_count(int n)\r\n{\r\n	n = ROUND(n, 0);\r\n	n = ROUND(n, 1);\r\n	n = ROUND(n, 2);\r\n	n = ROUND(n, 3);\r\n	n = ROUND(n, 4);\r\n	return n;\r\n}\r\nstruct element{\r\n	int origin;\r\n	int number;\r\n};\r\nbool compare(const element& x, const element& y)\r\n{\r\n	if(x.number ==y.number )\r\n		return x.origin <y.origin ;\r\n	else  return x.number <y.number ;\r\n}\r\n\r\nint main()\r\n{\r\n	element a;\r\n	int size,i,x;\r\n	list<element>::iterator j;\r\n	while(cin>>size)\r\n	{\r\n		list<element> y;\r\n		for(i=0;i<size;i++)\r\n		{\r\n			cin>>x;\r\n			a.origin=x;\r\n			a.number =bit_count(x);\r\n			y.push_back (a);\r\n		}\r\n		y.sort (compare);\r\n		for(j=y.begin ();j!=--y.end ();j++)\r\n			cout<<j->origin<<" ";\r\n		cout<<j->origin <<endl;\r\n	}\r\n	return 0;\r\n}\r\n', '', 46, 970752, 4, 2, '2010-10-29 09:34:43', '0001-01-01 00:00:00'),
(824, 36, 336, 2, '#include<iostream>\r\n#include<algorithm>\r\n#include<list>\r\n\r\n#define POW(c) (1<<(c))\r\n#define MASK(c) (((unsigned long)-1) / (POW(POW(c)) + 1))\r\n#define ROUND(n, c) (((n) & MASK(c)) + ((n) >> POW(c) & MASK(c)))\r\nusing std::list ;using std::cin ;\r\nusing std::cout; using std::sort ;\r\nusing std::endl ;\r\n\r\nint bit_count(int n)\r\n{\r\n	n = ROUND(n, 0);\r\n	n = ROUND(n, 1);\r\n	n = ROUND(n, 2);\r\n	n = ROUND(n, 3);\r\n	n = ROUND(n, 4);\r\n	return n;\r\n}\r\nstruct element{\r\n	int origin;\r\n	int number;\r\n};\r\nbool compare(const element& x, const element& y)\r\n{\r\n	if(x.number ==y.number )\r\n		return x.origin <y.origin ;\r\n	else  return x.number <y.number ;\r\n}\r\n\r\nint main()\r\n{\r\n	element a;\r\n	int size,i,x;\r\n	list<element>::iterator j;\r\n	while(cin>>size)\r\n	{\r\n		list<element> y;\r\n		for(i=0;i<size;i++)\r\n		{\r\n			cin>>x;\r\n			a.origin=x;\r\n			a.number =bit_count(x);\r\n			y.push_back (a);\r\n		}\r\n		y.sort (compare);\r\n		for(j=y.begin ();j!=--y.end ();j++)\r\n			cout<<j->origin<<" ";\r\n		cout<<j->origin <<endl;\r\n	}\r\n	return 0;\r\n}\r\n\r\n', '', 46, 974848, 4, 2, '2010-10-29 09:39:02', '0001-01-01 00:00:00'),
(825, 36, 336, 2, '#include<iostream>\r\n#include<algorithm>\r\n#include<list>\r\n\r\n#define POW(c) (1<<(c))\r\n#define MASK(c) (((unsigned long)-1) / (POW(POW(c)) + 1))\r\n#define ROUND(n, c) (((n) & MASK(c)) + ((n) >> POW(c) & MASK(c)))\r\nusing std::list ;using std::cin ;\r\nusing std::cout; using std::sort ;\r\nusing std::endl ;\r\n\r\nint bit_count(int n)\r\n{\r\n	n = ROUND(n, 0);\r\n	n = ROUND(n, 1);\r\n	n = ROUND(n, 2);\r\n	n = ROUND(n, 3);\r\n	n = ROUND(n, 4);\r\n	return n;\r\n}\r\nstruct element{\r\n	int origin;\r\n	int number;\r\n};\r\nbool compare(const element& x, const element& y)\r\n{\r\n	if(x.number ==y.number )\r\n		return x.origin <y.origin ;\r\n	else  return x.number <y.number ;\r\n}\r\n\r\nint main()\r\n{\r\n	element a;\r\n	int size,i,x;\r\n	list<element>::iterator j;\r\n	while(cin>>size&&size<=50000)\r\n	{\r\n		list<element> y;\r\n		for(i=0;i<size;i++)\r\n		{\r\n			cin>>x;\r\n			a.origin=x;\r\n			a.number =bit_count(x);\r\n			y.push_back (a);\r\n		}\r\n		y.sort (compare);\r\n		for(j=y.begin ();j!=--y.end ();j++)\r\n			cout<<j->origin<<" ";\r\n		cout<<j->origin <<endl;\r\n	}\r\n	return 0;\r\n}\r\n', '', 46, 970752, 4, 2, '2010-10-29 09:40:09', '0001-01-01 00:00:00'),
(826, 35, 336, 2, '#include<stdio.h>\r\nstruct num\r\n{\r\n	int number;\r\n	int time;\r\n};\r\nvoid swap(num a,num b)\r\n{\r\n	num temp=a;a=b;b=temp;\r\n}\r\n\r\nint main()\r\n{\r\n	int n;\r\n	while(scanf("%d ",&n)!=EOF&&n>=0&&n<=50000)\r\n	{\r\n		num A[50000];\r\n		for(int i=0;i<n;i++)\r\n		{\r\n			scanf("%d",&A[i].number);\r\n			A[i].time=A[i].number;\r\n			int times=0;\r\n			for(;A[i].time;A[i].time&=A[i].time-1)\r\n				times++;\r\n			A[i].time=times;\r\n		}\r\n		for(int j=n-1;j>0;j--)\r\n		{\r\n			for(int i=0;i<j;i++)\r\n			{\r\n				if(A[i].time>A[i+1].time)\r\n				{\r\n					swap(A[i],A[i+1]);\r\n				}\r\n				if(A[i].time==A[i+1].time&&A[i].number>A[i+1].number)\r\n				{\r\n					swap(A[i],A[i+1]);\r\n				}\r\n			}\r\n		}\r\n		for(int m=0;m<n;m++)\r\n			printf("%d ",A[m].number);\r\n		printf("\\n");\r\n	}\r\n	return 0;\r\n}\r\n', '', 200, 618496, 5, 2, '2010-10-29 14:42:59', '0001-01-01 00:00:00'),
(827, 35, 336, 2, '#include<stdio.h>\r\nstruct num\r\n{\r\n	int number;\r\n	int time;\r\n};\r\n\r\nint partions(num l[],int low,int high)\r\n{\r\n    num prvotkey=l[low];\r\n    l[0]=l[low];\r\n    while (low<high)\r\n    {\r\n        while (low<high&&\r\n          (l[high].time>prvotkey.time||\r\n                     (l[high].time==prvotkey.time&&l[high].number>prvotkey.number)))\r\n        --high;\r\n        l[low]=l[high];\r\n        while (low<high&&\r\n          (l[low].time<prvotkey.time||\r\n                     (l[high].time==prvotkey.time&&l[high].number<prvotkey.number))) \r\n        ++low;\r\n        l[high]=l[low];\r\n    }\r\n    l[low]=l[0];\r\n    return low;\r\n}\r\n\r\nvoid qsort(num l[],int low,int high)\r\n{\r\n   int prvotloc;\r\n   if(low<high)\r\n   {\r\n     prvotloc=partions(l,low,high);    //将第一次排序的结果作为枢轴\r\n     qsort(l,low,prvotloc-1); //递归调用排序 由low 到prvotloc-1\r\n     qsort(l,prvotloc+1,high); //递归调用排序 由 prvotloc+1到 high\r\n   }\r\n   \r\n}\r\n\r\nvoid quicksort(num l[],int n)\r\n{\r\n    qsort(l,1,n); //第一个作为枢轴 ，从第一个排到第n个\r\n}\r\n\r\n\r\nint main()\r\n{\r\n	int n;\r\n	while(scanf("%d ",&n)!=EOF&&n>=0&&n<=50000)\r\n	{\r\n		num A[50000];\r\n		for(int i=1;i<=n;i++)\r\n		{\r\n			scanf("%d",&A[i].number);\r\n			\r\n			A[i].time=A[i].number;\r\n			int times=0;\r\n			for(;A[i].time;A[i].time&=A[i].time-1)\r\n				times++;\r\n			A[i].time=times;\r\n			\r\n		}\r\n		\r\n		quicksort (A,n);\r\n		for(int m=1;m<=n;m++)\r\n			printf("%d ",A[m].number);\r\n		printf("\\n");\r\n	}\r\n	return 0;\r\n}\r\n', '', 200, 610304, 5, 2, '2010-10-29 15:13:09', '0001-01-01 00:00:00'),
(828, 27, 374, 5, '#include <stdio.h>\r\n\r\nint main()\r\n{\r\n	int T,i,n,j;\r\n	int a[20000];\r\n	scanf("%d",&T);\r\n	for(i=0;i<T;++i){\r\n		int begin=1,end=1;\r\n		scanf("%d",&n);\r\n		for(j=0;j<n;++j)  scanf("%d",&a[j]);\r\n		int s=0,max=a[0];\r\n		for(j=0;j<n;++j){\r\n			s+=a[j];\r\n			if(s<0) { s=a[j];begin=j+1;}\r\n			else if(s>=max) { max=s;end=j+1;}\r\n		}\r\n		printf("Case %d:\\n",i+1);\r\n		printf("%d %d %d\\n\\n",max,begin,end);\r\n	}\r\n    return 0;\r\n}', '', 15, 299008, 4, 1, '2010-10-30 23:53:55', '0001-01-01 00:00:00'),
(829, 27, 374, 5, '#include <stdio.h>\r\n\r\nint main()\r\n{\r\n	int T,i,n,j;\r\n	int a[20000];\r\n	scanf("%d",&T);\r\n	for(i=0;i<T;++i){\r\n		int begin=1,end=1;\r\n		scanf("%d",&n);\r\n		for(j=0;j<n;++j)  scanf("%d",&a[j]);\r\n		int s=0,max=a[0];\r\n		for(j=0;j<n;++j){\r\n			s+=a[j];\r\n			if(s<0) { s=a[j];begin=j+1;}\r\n			else if(s>max) { max=s;end=j+1;}\r\n		}\r\n		printf("Case %d:\\n",i+1);\r\n		printf("%d %d %d\\n\\n",max,begin,end);\r\n	}\r\n    return 0;\r\n}', '', 31, 299008, 4, 1, '2010-10-31 00:00:10', '0001-01-01 00:00:00'),
(830, 27, 374, 5, '#include <stdio.h>\r\n\r\nint main()\r\n{\r\n	int T,i,n,j;\r\n	int a[20000];\r\n	scanf("%d",&T);\r\n	for(i=0;i<T;++i){\r\n		int begin=1,end=1;\r\n		scanf("%d",&n);\r\n		for(j=0;j<n;++j)  scanf("%d",&a[j]);\r\n		int s=0,max=a[0];\r\n		for(j=0;j<n;++j){\r\n			if(s<0) { s=a[j];begin=j+1;}\r\n			else {s+=a[j];}\r\n			if(s>max) { max=s;end=j+1;}\r\n		}\r\n		printf("Case %d:\\n",i+1);\r\n		printf("%d %d %d\\n\\n",max,begin,end);\r\n	}\r\n    return 0;\r\n}', '', 15, 299008, 4, 1, '2010-10-31 00:04:13', '0001-01-01 00:00:00'),
(831, 35, 336, 2, '#include<stdio.h>\r\n#include<stdlib.h>\r\nstruct num\r\n{\r\n int number;\r\n int time;\r\n};\r\nint comp(const void *p,const void *q)\r\n{\r\n	if((*(num *)p).time!= (*(num *)q).time)\r\n	return ((*(num *)p).time - (*(num *)q).time);\r\n	else return((*(num *)p).number - (*(num *)q).number);\r\n}\r\nint main()\r\n{\r\n int n;\r\n while(scanf("%d ",&n)!=EOF&&n>=0&&n<=50000)\r\n {\r\n  num A[50000];\r\n  for(int i=0;i<n;i++)\r\n  {\r\n   scanf("%d",&A[i].number);  \r\n   A[i].time=A[i].number;\r\n   int times=0;\r\n   for(;A[i].time;A[i].time&=A[i].time-1)\r\n    times++;\r\n   A[i].time=times;\r\n   \r\n  }\r\n  \r\n  qsort(A,n,sizeof(num),comp);\r\n  for(int m=0;m<n;m++)\r\n   printf("%d ",A[m].number);\r\n  printf("\\n");\r\n }\r\n return 0;\r\n}\r\n', '', 15, 618496, 3, 2, '2010-10-31 09:17:01', '0001-01-01 00:00:00'),
(832, 35, 336, 2, '#include<stdio.h>\r\n#include<stdlib.h>\r\nstruct num\r\n{\r\n int number;\r\n int time;\r\n};\r\nint comp(const void *p,const void *q)\r\n{\r\n	if((*(num *)p).time!= (*(num *)q).time)\r\n	return ((*(num *)p).time - (*(num *)q).time);\r\n	else return((*(num *)p).number - (*(num *)q).number);\r\n}\r\nint main()\r\n{\r\n int n;\r\n while(scanf("%d ",&n)!=EOF&&n>=0&&n<=50000)\r\n {\r\n  num A[50000];\r\n  for(int i=0;i<n;i++)\r\n  {\r\n   scanf("%d",&A[i].number);  \r\n   A[i].time=A[i].number;\r\n   int times=0;\r\n   for(;A[i].time;A[i].time&=A[i].time-1)\r\n    times++;\r\n   A[i].time=times;\r\n   \r\n  }\r\n  \r\n  qsort(A,n,sizeof(num),comp);\r\n  for(int m=0;m<n-1;m++)\r\n   printf("%d ",A[m].number);\r\n  printf("%d\\n",A[n-1].number);\r\n }\r\n return 0;\r\n}\r\n', '', 15, 622592, 4, 2, '2010-10-31 09:18:07', '0001-01-01 00:00:00'),
(833, 35, 336, 2, '#include<stdio.h>\r\n#include<stdlib.h>\r\nstruct num\r\n{\r\n int number;\r\n int time;\r\n};\r\nint comp(const void *p,const void *q)\r\n{\r\n	if((*(num *)p).time!= (*(num *)q).time)\r\n	return ((*(num *)p).time - (*(num *)q).time);\r\n	else return((*(num *)p).number - (*(num *)q).number);\r\n}\r\nint main()\r\n{\r\n int n;\r\n while(scanf("%d",&n)!=EOF&&n>=0&&n<=50000)\r\n {\r\n  num A[50000];\r\n  for(int i=0;i<n;i++)\r\n  {\r\n   scanf("%d",&A[i].number);  \r\n   A[i].time=A[i].number;\r\n   int times=0;\r\n   for(;A[i].time;A[i].time&=A[i].time-1)\r\n    times++;\r\n   A[i].time=times;\r\n   printf("%d ",A[i].time);\r\n  }\r\n  printf("\\n");\r\n  qsort(A,n,sizeof(num),comp);\r\n  for(int m=0;m<n-1;m++)\r\n   printf("%d ",A[m].number);\r\n  printf("%d\\n",A[n-1].number);\r\n }\r\n return 0;\r\n}', '', 31, 622592, 4, 2, '2010-10-31 09:22:35', '0001-01-01 00:00:00'),
(834, 35, 336, 2, '#include<stdio.h>\r\n#include<stdlib.h>\r\nstruct num\r\n{\r\n int number;\r\n int time;\r\n};\r\nint comp(const void *p,const void *q)\r\n{\r\n	if((*(num *)p).time!= (*(num *)q).time)\r\n	return ((*(num *)p).time - (*(num *)q).time);\r\n	else return((*(num *)p).number - (*(num *)q).number);\r\n}\r\nint main()\r\n{\r\n int n;\r\n while(scanf("%d",&n)!=EOF&&n>=0&&n<=50000)\r\n {\r\n  num A[50000];\r\n  for(int i=0;i<n;i++)\r\n  {\r\n   scanf("%d",&A[i].number);  \r\n   A[i].time=A[i].number;\r\n   int times=0;\r\n   for(;A[i].time;A[i].time&=A[i].time-1)\r\n    times++;\r\n   A[i].time=times;\r\n  }\r\n  qsort(A,n,sizeof(num),comp);\r\n  for(int m=0;m<n-1;m++)\r\n   printf("%d ",A[m].number);\r\n  printf("%d\\n",A[n-1].number);\r\n }\r\n return 0;\r\n}\r\n', '', 15, 626688, 4, 2, '2010-10-31 09:23:05', '0001-01-01 00:00:00'),
(835, 36, 336, 2, '#include<iostream>\r\n#include<algorithm>\r\n#include<list>\r\n\r\n#define POW(c) (1<<(c))\r\n#define MASK(c) (((unsigned long)-1) / (POW(POW(c)) + 1))\r\n#define ROUND(n, c) (((n) & MASK(c)) + ((n) >> POW(c) & MASK(c)))\r\nusing std::list ;using std::cin ;\r\nusing std::cout; using std::sort ;\r\nusing std::endl ;\r\n\r\nint bit_count(int n)\r\n{\r\n	n = ROUND(n, 0);\r\n	n = ROUND(n, 1);\r\n	n = ROUND(n, 2);\r\n	n = ROUND(n, 3);\r\n	n = ROUND(n, 4);\r\n	return n;\r\n}\r\nstruct element{\r\n	int origin;\r\n	int number;\r\n};\r\nbool compare(const element& x, const element& y)\r\n{\r\n	if(x.number ==y.number )\r\n		return x.origin <=y.origin ;\r\n	else  return x.number <=y.number ;\r\n}\r\n\r\nint main()\r\n{\r\n	element a;\r\n	int size,i,x;\r\n	list<element>::iterator j;\r\n	while(cin>>size&&size<=50000&&size>=0)\r\n	{\r\n		list<element> y;\r\n		for(i=0;i<size;i++)\r\n		{\r\n			cin>>x;\r\n			a.origin=x;\r\n			a.number =bit_count(x);\r\n			y.push_back (a);\r\n		}\r\n		y.sort (compare);\r\n		for(j=y.begin ();j!=--y.end ();j++)\r\n			cout<<j->origin<<" ";\r\n		cout<<j->origin <<endl;\r\n	}\r\n	return 0;\r\n}', '', 46, 978944, 4, 2, '2010-10-31 10:16:23', '0001-01-01 00:00:00'),
(836, 36, 336, 2, '#include<iostream>\r\n#include<algorithm>\r\n#include<list>\r\n\r\n#define POW(c) (1<<(c))\r\n#define MASK(c) (((unsigned long)-1) / (POW(POW(c)) + 1))\r\n#define ROUND(n, c) (((n) & MASK(c)) + ((n) >> POW(c) & MASK(c)))\r\nusing std::list ;using std::cin ;\r\nusing std::cout; using std::sort ;\r\nusing std::endl ;\r\n\r\nint bit_count(int n)\r\n{\r\n	n = ROUND(n, 0);\r\n	n = ROUND(n, 1);\r\n	n = ROUND(n, 2);\r\n	n = ROUND(n, 3);\r\n	n = ROUND(n, 4);\r\n	return n;\r\n}\r\nstruct element{\r\n	int origin;\r\n	int number;\r\n};\r\nbool compare(const element& x, const element& y)\r\n{\r\n	if(x.number !=y.number )\r\n		return x.number <=y.number ;\r\n	else  return  x.origin <=y.origin;\r\n}\r\n\r\nint main()\r\n{\r\n	element a;\r\n	int size,i,x;\r\n	list<element>::iterator j;\r\n	while(cin>>size&&size<=50000&&size>=0)\r\n	{\r\n		list<element> y;\r\n		for(i=0;i<size;i++)\r\n		{\r\n			cin>>x;\r\n			a.origin=x;\r\n			a.number =bit_count(x);\r\n			y.push_back (a);\r\n		}\r\n		y.sort (compare);\r\n		for(j=y.begin ();j!=--y.end ();j++)\r\n			cout<<j->origin<<" ";\r\n		cout<<j->origin <<endl;\r\n	}\r\n	return 0;\r\n}\r\n', '', 46, 974848, 4, 2, '2010-10-31 10:18:04', '0001-01-01 00:00:00'),
(837, 27, 374, 5, '#include <stdio.h>\r\n\r\nint main()\r\n{\r\n	int T,i,n,j;\r\n	int a[20001];\r\n	scanf("%d",&T);\r\n	for(i=0;i<T;++i){\r\n		int begin=1,sbegin=1,end=1;\r\n		scanf("%d",&n);\r\n		for(j=0;j<n;++j)  scanf("%d",&a[j]);\r\n		int s=0,max=a[0];\r\n		for(j=0;j<n;++j){\r\n			if(s<0) { s=a[j];sbegin=j+1;}\r\n			else {s+=a[j];}\r\n			if(s>max) { max=s;begin=sbegin;end=j+1;}\r\n		}\r\n		printf("Case %d:\\n",i+1);\r\n		printf("%d %d %d\\n\\n",max,begin,end);\r\n	}\r\n    return 0;\r\n}', '', 15, 299008, 3, 1, '2010-10-31 10:19:56', '0001-01-01 00:00:00'),
(838, 27, 374, 5, '#include <stdio.h>\r\n\r\nint main()\r\n{\r\n	int T,i,n,j;\r\n	int a[20001];\r\n	scanf("%d",&T);\r\n	for(i=0;i<T;++i){\r\n		int begin=1,sbegin=1,end=1;\r\n		scanf("%d",&n);\r\n		for(j=0;j<n;++j)  scanf("%d",&a[j]);\r\n		int s=0,max=a[0];\r\n		for(j=0;j<n;++j){\r\n			if(s<0) { s=a[j];sbegin=j+1;}\r\n			else {s+=a[j];}\r\n			if(s>max) { max=s;begin=sbegin;end=j+1;}\r\n		}\r\n		printf("Case %d:\\n",i+1);\r\n		printf("%d %d %d\\n",max,begin,end);\r\n		if(i<T-1) printf("\\n");\r\n	}\r\n    return 0;\r\n}', '', 15, 299008, 1, 1, '2010-10-31 10:29:01', '0001-01-01 00:00:00'),
(839, 36, 338, 3, '#include<iostream>\r\n#include<algorithm>\r\n#include<vector>\r\n\r\nusing std::cin ;  using std::cout;\r\nusing std::vector ;using std::sort ;\r\nusing std::endl;\r\n\r\nbool cmp(int&x,int&y)\r\n{\r\n	return x>y;\r\n}\r\nint main()\r\n{\r\n	int x,n,k;\r\n	while(cin>>n&&n>0&&n<=50000)\r\n	{\r\n		cin>>k;\r\n		if(k<0||k>n) break;\r\n		vector<int> y;\r\n		int i=0;\r\n		while(i!=n)\r\n		{\r\n			cin>>x;\r\n		   if(x>=0&&x<1000)\r\n			y.push_back (x);\r\n			i++;\r\n		}\r\n		sort(y.begin(), y.end(),cmp);\r\n		if(n==1&&k==0)\r\n		cout<<y[0]-y[0]<<endl;\r\n		else cout<<y[k]-y[n-k-1]<<endl;\r\n	}\r\n	return 0;\r\n}\r\n\r\n', 'In file included from e:\\shpchen\\oj\\jojserver\\tools\\gcc\\bin\\../lib/gcc/mingw32/4.5.0/include/c++/algorithm:63:0,\r\n                 from Main.cpp:2:\r\ne:\\shpchen\\oj\\jojserver\\tools\\gcc\\bin\\../lib/gcc/mingw32/4.5.0/include/c++/bits/stl_algo.h: In function ''_RandomAccessIterator std::__unguarded_partition(_RandomAccessIterator, _RandomAccessIterator, const _Tp&, _Compare) [with _RandomAccessIterator = __gnu_cxx::__normal_iterator<int*, std::vector<int> >, _Tp = int, _Compare = bool (*)(int&, int&)]''', 0, 0, 2, 2, '2010-10-31 11:01:42', '0001-01-01 00:00:00'),
(840, 36, 338, 3, '#include<iostream>\r\n#include<algorithm>\r\n#include<vector>\r\n\r\nusing std::cin ;  using std::cout;\r\nusing std::vector ;using std::sort ;\r\nusing std::endl;\r\n\r\nbool cmp(int&x,int&y)\r\n{\r\n	return x>y;\r\n}\r\nint main()\r\n{\r\n	int x,n,k;\r\n	while(cin>>n&&n>0&&n<=50000)\r\n	{\r\n		cin>>k;\r\n		if(k<0||k>n) break;\r\n		vector<int> y;\r\n		int i=0;\r\n		while(i!=n)\r\n		{\r\n			cin>>x;\r\n		   if(x>=0&&x<1000)\r\n			y.push_back (x);\r\n			i++;\r\n		}\r\n		sort(y.begin(), y.end(),cmp);\r\n		if(n==1&&k==0)\r\n		cout<<y[0]-y[0]<<endl;\r\n		else cout<<y[k]-y[n-k-1]<<endl;\r\n	}\r\n	return 0;\r\n}\r\n\r\n', 'In file included from e:\\shpchen\\oj\\jojserver\\tools\\gcc\\bin\\../lib/gcc/mingw32/4.5.0/include/c++/algorithm:63:0,\r\n                 from Main.cpp:2:\r\ne:\\shpchen\\oj\\jojserver\\tools\\gcc\\bin\\../lib/gcc/mingw32/4.5.0/include/c++/bits/stl_algo.h: In function ''_RandomAccessIterator std::__unguarded_partition(_RandomAccessIterator, _RandomAccessIterator, const _Tp&, _Compare) [with _RandomAccessIterator = __gnu_cxx::__normal_iterator<int*, std::vector<int> >, _Tp = int, _Compare = bool (*)(int&, int&)]''', 0, 0, 2, 2, '2010-10-31 11:02:05', '0001-01-01 00:00:00'),
(841, 36, 338, 3, '#include<iostream>\r\n#include<algorithm>\r\n#include<vector>\r\n\r\nusing std::cin ;  using std::cout;\r\nusing std::vector ;using std::sort ;\r\nusing std::endl;\r\n\r\nbool cmp(int&x,int&y)\r\n{\r\n	return x>y;\r\n}\r\nint main()\r\n{\r\n	int x,n,k;\r\n	while(cin>>n&&n>0&&n<=50000)\r\n	{\r\n		cin>>k;\r\n		if(k<0||k>n) break;\r\n		vector<int> y;\r\n		int i=0;\r\n		while(i!=n)\r\n		{\r\n			cin>>x;\r\n		   if(x>=0&&x<1000)\r\n			y.push_back (x);\r\n			i++;\r\n		}\r\n		sort(y.begin(), y.end(),cmp);\r\n		if(n==1&&k==0)\r\n		cout<<y[0]-y[0]<<endl;\r\n		else cout<<y[k]-y[n-k-1]<<endl;\r\n	}\r\n	return 0;\r\n}\r\n\r\n', 'In file included from e:\\shpchen\\oj\\jojserver\\tools\\gcc\\bin\\../lib/gcc/mingw32/4.5.0/include/c++/algorithm:63:0,\r\n                 from Main.cpp:2:\r\ne:\\shpchen\\oj\\jojserver\\tools\\gcc\\bin\\../lib/gcc/mingw32/4.5.0/include/c++/bits/stl_algo.h: In function ''_RandomAccessIterator std::__unguarded_partition(_RandomAccessIterator, _RandomAccessIterator, const _Tp&, _Compare) [with _RandomAccessIterator = __gnu_cxx::__normal_iterator<int*, std::vector<int> >, _Tp = int, _Compare = bool (*)(int&, int&)]''', 0, 0, 2, 2, '2010-10-31 11:03:02', '0001-01-01 00:00:00'),
(842, 17, 375, 5, '#include<stdio.h>\r\n#define M 50001\r\nint binary_search(int *a,int len,int n)\r\n{\r\n    int left,right,mid;\r\n    left=0;\r\n    right=len-1;\r\n    mid=(left+right)/2;\r\n    while(left<=right)\r\n    {\r\n       if(n>a[mid])left=mid+1;\r\n       else if(n<a[mid])right=mid-1;\r\n       else return mid;\r\n       mid=(left+right)/2;\r\n    }\r\n    return left;\r\n}\r\nint lis(int *a,int len)\r\n{   int i,j;\r\n    int maxlist;\r\n    int max[M];\r\n    int f[M];\r\n    maxlist=1;\r\n    max[0]=-1;\r\n    max[1]=a[0];\r\n    for(i=0;i<len;i++)\r\n    {\r\n              f[i]=binary_search(max,maxlist+1,a[i]);\r\n              if(f[i]>maxlist)\r\n              {\r\n                max[f[i]]=a[i];\r\n                maxlist=f[i];\r\n               }\r\n               else if(max[f[i]-1]<a[i]&&a[i]<max[f[i]])\r\n               {\r\n                  max[f[i]]=a[i];\r\n               }\r\n    }\r\n    return maxlist;\r\n}\r\nint main()\r\n{\r\n    int i,j,n;\r\n    int a[M];\r\n    while(scanf("%d",&n)!=EOF)\r\n    { \r\n      for(i=0;i<n;i++)\r\n        scanf("%d",&a[i]);\r\n      printf("%d\\n", lis(a,n));\r\n    }\r\n    return 0;\r\n}\r\n    \r\n', '', 187, 819200, 4, 1, '2010-11-02 12:08:20', '0001-01-01 00:00:00'),
(843, 17, 375, 5, '#include<stdio.h>\r\n#define M 50010\r\nint main()\r\n{\r\n    int i,j,n;\r\n    int num[M];\r\n    int f[M];\r\n    int max;\r\n    while(scanf("%d",&n)!=EOF)\r\n    { \r\n      max=0;\r\n      for(i=0;i<n;i++)\r\n        scanf("%d",&num[i]);\r\n      for(i=0;i<n;i++)\r\n      {\r\n         f[i]=1;\r\n         for(j=0;j<i;j++)\r\n         {\r\n           if(num[i]>num[j]&&f[j]+1>f[i])\r\n           {\r\n              f[i]=f[j]+1;\r\n           }\r\n         }\r\n       }\r\n       for(i=0;i<n;i++)\r\n        if(max<f[i])max=f[i];\r\n       printf("%d\\n",max);\r\n      }\r\n      return 0;\r\n\r\n}\r\n             \r\n           \r\n', '', 500, 622592, 5, 1, '2010-11-02 12:14:44', '0001-01-01 00:00:00'),
(844, 17, 375, 5, '#include<stdio.h>\r\n#define M 50001\r\nint binary_search(int *b,int len,int n)\r\n{\r\n    int left,right,mid;\r\n    left=0;\r\n    right=len-1;\r\n    mid=(left+right)/2;\r\n    while(left<=right)\r\n    {\r\n       if(n>b[mid])left=mid+1;\r\n       else if(n<b[mid])right=mid-1;\r\n       else return mid;\r\n       mid=(left+right)/2;\r\n    }\r\n    return left;\r\n}\r\nint lis(int *a,int len)\r\n{   \r\n    int i,j;\r\n    int maxlist;\r\n    int max[M];\r\n    int f[M];\r\n    maxlist=1;\r\n    max[0]=-1;\r\n    max[1]=a[0];\r\n    for(i=0;i<len;i++)\r\n    {\r\n              f[i]=binary_search(max,maxlist+1,a[i]);\r\n              if(f[i]>maxlist)\r\n              {\r\n                max[f[i]]=a[i];\r\n                maxlist=f[i];\r\n               }\r\n               else if(max[f[i]-1]<a[i]&&a[i]<max[f[i]])\r\n               {\r\n                  max[f[i]]=a[i];\r\n               }\r\n    }\r\n    return maxlist;\r\n}\r\nint main()\r\n{\r\n    int i,j,n;\r\n    int arr[M];\r\n    while(scanf("%d",&n)!=EOF)\r\n    { \r\n      for(i=0;i<n;i++)\r\n        scanf("%d",&arr[i]);\r\n      printf("%d\\n", lis(arr,n));\r\n    }\r\n    return 0;\r\n}\r\n    \r\n', '', 187, 819200, 4, 1, '2010-11-02 13:06:14', '0001-01-01 00:00:00'),
(845, 17, 375, 5, '#include<iostream>\r\n#define maxn 10001\r\nusing namespace std;\r\nint a[maxn],b[maxn];\r\nint main()\r\n{\r\n    int n,i,k,max;\r\n    while(cin>>n)\r\n    {\r\n        for(i=0;i<n;i++)\r\n            scanf("%d",&a[i]); \r\n        max=1,b[0]=0,b[1]=a[0];\r\n        for(i=1;i<n;i++)           \r\n        {\r\n            if(a[i]>=b[max])\r\n                b[++max]=a[i];\r\n            else \r\n            {\r\n                k=max-1;\r\n                while(a[i]<b[k])\r\n                    k--;\r\n                b[k+1]=a[i];\r\n            }\r\n        }\r\n        cout<<max<<endl;\r\n    }\r\n    return 0;\r\n}\r\n', 'Main.cpp: In function ''int main()'':\r\nMain.cpp:11:29: error: ''scanf'' was not declared in this scope\r\n', 0, 0, 2, 2, '2010-11-02 20:45:10', '0001-01-01 00:00:00'),
(846, 17, 375, 5, '#include<iostream>\r\n#include<stdio.h>\r\n#define maxn 10001\r\nusing namespace std;\r\nint a[maxn],b[maxn];\r\nint main()\r\n{\r\n    int n,i,k,max;\r\n    while(cin>>n)\r\n    {\r\n        for(i=0;i<n;i++)\r\n            scanf("%d",&a[i]); \r\n        max=1,b[0]=0,b[1]=a[0];\r\n        for(i=1;i<n;i++)           \r\n        {\r\n            if(a[i]>=b[max])\r\n                b[++max]=a[i];\r\n            else \r\n            {\r\n                k=max-1;\r\n                while(a[i]<b[k])\r\n                    k--;\r\n                b[k+1]=a[i];\r\n            }\r\n        }\r\n        cout<<max<<endl;\r\n    }\r\n    return 0;\r\n}\r\n', '', 171, 446464, 1, 2, '2010-11-02 20:46:11', '0001-01-01 00:00:00');
INSERT INTO `tbl_submitions` (`id`, `user_id`, `problem_id`, `exercise_id`, `source`, `result`, `used_time`, `used_memory`, `status`, `compiler_id`, `created`, `modified`) VALUES
(847, 17, 376, 5, '#include<stdio.h>\r\n#include<stdlib.h>\r\n#define M 50001\r\nint num[M];\r\nint left[M];\r\nint right[M];\r\nvoid left_i(int n)\r\n{\r\n    int i;\r\n    left[0]=1;\r\n    for(i=1;i<n;i++)\r\n      left[i]=left[i-1]*num[i-1];\r\n}\r\nvoid right_i(int n)\r\n{\r\n    int i;\r\n    right[n-1]=1;\r\n    for(i=n-2;i>=0;i--)\r\n        right[i]=right[i+1]*num[i+1];\r\n}\r\n   \r\nvoid get_max(int len)\r\n{   \r\n    int i;\r\n    int max;\r\n    max=left[0]*right[0];\r\n    for(i=1;i<len;++i)\r\n    {\r\n      if(left[i]*right[i]>max)\r\n      {\r\n           max=left[i]*right[i];\r\n      }\r\n    }\r\n    printf("%d\\n",max+1);\r\n    return;\r\n}\r\nint main()\r\n{\r\n    int n;\r\n    int i;\r\n    int max;\r\n    while(scanf("%d",&n)!=EOF)\r\n    {  \r\n       for(i=0;i<n;i++)\r\n         scanf("%d",num+i);\r\n       left_i(n);\r\n       right_i(n);\r\n       get_max(n);\r\n     }\r\n       return 0;\r\n    }\r\n', '', 78, 860160, 4, 1, '2010-11-02 21:44:06', '0001-01-01 00:00:00'),
(848, 10, 338, 3, '#include<stdio.h>\r\n#include<string.h>\r\n\r\nint main()\r\n{\r\n   int i,size,k,temp,shuzu[1000],count;\r\n   int kmin,kmax;\r\n   while(EOF != scanf("%d%d",&size,&k))\r\n   {\r\n	   memset(shuzu,0,1000*sizeof(int));\r\n   for(i = 0 ; i != size ; i++)\r\n   {\r\n    scanf("%d",&temp);\r\n    shuzu[temp] +=1;\r\n   }\r\n   count = 0;\r\n   i = 0;\r\n   while(count<k+1)\r\n   {\r\n    ++i;\r\n    count += shuzu[i];\r\n   }    \r\n   kmin = i;\r\n   count = 0;\r\n   i = 1000;\r\n   while(count<k+1)\r\n   {\r\n    --i;\r\n    count += shuzu[i];\r\n   }    \r\n   kmax = i;\r\n   printf("%d\\n",kmax - kmin);\r\n   }\r\n   return 0;\r\n}\r\n', '', 374, 258048, 4, 2, '2010-11-03 09:44:57', '0001-01-01 00:00:00'),
(849, 10, 338, 3, '#include<stdio.h>\r\n#include<string.h>\r\n\r\nint main()\r\n{\r\n   int i,size,k,temp,shuzu[1000],count;\r\n   int kmin,kmax;\r\n   while(EOF != scanf("%d%d",&size,&k))\r\n   {\r\n	   memset(shuzu,0,1000*sizeof(int));\r\n   for(i = 0 ; i != size ; i++)\r\n   {\r\n    scanf("%d",&temp);\r\n    shuzu[temp] +=1;\r\n   }\r\n   count = 0;\r\n   i = 0;\r\n   while(1)\r\n   {\r\n    count += shuzu[i];\r\n	if(count>=k+1)\r\n	{\r\n		kmin = i;\r\n		break;\r\n	}\r\n	 ++i;\r\n   }    \r\n\r\n   count = 0;\r\n   i = 999;\r\n   while(1)\r\n   {\r\n    count += shuzu[i];\r\n	if(count>=k+1)\r\n	{\r\n		kmax = i;\r\n		break;\r\n	}\r\n    --i;\r\n   }    \r\n   printf("%d\\n",kmax - kmin);\r\n   }\r\n   return 0;\r\n}\r\n', '', 390, 262144, 1, 2, '2010-11-03 09:59:19', '0001-01-01 00:00:00'),
(850, 10, 339, 3, '#include<stdio.h>\r\n#include<vector>\r\n#include<algorithm>\r\n\r\nusing std::vector;\r\n\r\nbool compare(int num1,int num2)\r\n{\r\n return num1>num2;\r\n}\r\n\r\nint iterator_index(vector<int>& shuzu,int i)\r\n{\r\n vector<int>::iterator iter = shuzu.begin();\r\n while(i != 0)\r\n {\r\n  ++iter;\r\n  --i;\r\n }\r\n return *iter;\r\n}\r\nint main()\r\n{\r\n int size,k,i,temp;\r\n vector<int> shuzu,choice;\r\n while(EOF != scanf("%d%d",&size,&k))\r\n {\r\n	 shuzu.clear();\r\n	 choice.clear();\r\n for(i=0;i != k;i++)\r\n {\r\n  scanf("%d",&temp);\r\n  choice.push_back(temp);\r\n }\r\n for(i=0;i != size; i++)\r\n {\r\n  scanf("%d",&temp);\r\n  shuzu.push_back(temp);\r\n }\r\n sort(shuzu.begin(),shuzu.end(),compare);\r\n\r\n for(vector<int>::iterator iter = choice.begin();\r\n  iter != choice.end();iter++)\r\n  printf("%d\\n",iterator_index(shuzu,*iter));\r\n }\r\n\r\n return 0;\r\n}\r\n\r\n', '', 342, 1339392, 1, 2, '2010-11-03 10:05:16', '0001-01-01 00:00:00'),
(851, 10, 344, 4, '#include<string>\r\n#include<iostream>\r\n#include<map>\r\n\r\n\r\nusing std::string;using std::map;\r\nusing std::cin;using std::cout;\r\nusing std::pair;using std::endl;\r\n\r\nint main()\r\n{\r\n int i,size;\r\n string temp;\r\n map<string,int> line;\r\n    pair<map<string, int>::iterator, bool> Insert_Pair;\r\n\r\n while(EOF != scanf("%d",&size))\r\n {\r\n	 line.clear();\r\n for(i=0;i != size;i++)\r\n {\r\n  cin >>temp;\r\n  Insert_Pair = line.insert(map<string,int>::value_type (temp,i));\r\n        if(Insert_Pair.second == false)\r\n        break;\r\n }\r\n  if(i == size) cout << 0 << endl;\r\n  else          cout << i-line[temp] << endl;\r\n }\r\n\r\n return 0;\r\n}\r\n', 'Main.cpp: In function ''int main()'':\r\nMain.cpp:17:8: error: ''EOF'' was not declared in this scope\r\nMain.cpp:17:31: error: ''scanf'' was not declared in this scope\r\n', 0, 0, 2, 2, '2010-11-03 10:16:09', '0001-01-01 00:00:00'),
(852, 10, 344, 4, '#include<string>\r\n#include<iostream>\r\n#include<map>\r\n#include<stdio.h>\r\n\r\n\r\nusing std::string;using std::map;\r\nusing std::cin;using std::cout;\r\nusing std::pair;using std::endl;\r\n\r\nint main()\r\n{\r\n int i,size;\r\n string temp;\r\n map<string,int> line;\r\n    pair<map<string, int>::iterator, bool> Insert_Pair;\r\n\r\n while(EOF != scanf("%d",&size))\r\n {\r\n	 line.clear();\r\n for(i=0;i != size;i++)\r\n {\r\n  cin >>temp;\r\n  Insert_Pair = line.insert(map<string,int>::value_type (temp,i));\r\n        if(Insert_Pair.second == false)\r\n        break;\r\n }\r\n  if(i == size) cout << 0 << endl;\r\n  else          cout << i-line[temp] << endl;\r\n }\r\n\r\n return 0;\r\n}\r\n', '', 62, 1134592, 1, 2, '2010-11-03 10:17:10', '0001-01-01 00:00:00'),
(853, 6, 368, 0, '#include <stdio.h>\r\n#include <vector>\r\n#include <algorithm>\r\n#include <queue>\r\nusing namespace std;\r\n#define MAXN 200\r\n\r\nstruct Rectangle\r\n{\r\n   int x1, y1;\r\n   int x2, y2;\r\n}r[MAXN];\r\nbool operator<(const Rectangle &a,const Rectangle &b)\r\n{\r\n	return a.x1 < b.x1;\r\n}\r\n\r\nstruct Edge\r\n{\r\n	int dest,cost;\r\n	Edge(int d,int c)\r\n	{\r\n		dest = d;\r\n		cost = c;\r\n	}\r\n};\r\nbool operator<(const Edge &a,const Edge &b)\r\n{\r\n	return a.cost >  b.cost;\r\n}\r\ntypedef vector<Edge> VE;\r\n\r\nint n;\r\nint px[MAXN*4], py[MAXN*4], ind[MAXN*4];\r\nbool byx(int a,int b)\r\n{\r\n	return px[a] < px[b];\r\n}\r\n\r\nbool is_inner_point(int x,int y)\r\n{\r\n	for(int i=0;i<n;++i)\r\n	{ \r\n		if(x>r[i].x1 && x<r[i].x2 && y>r[i].y1 && y<r[i].y2)\r\n		   return 1;\r\n	}\r\n	return 0;\r\n}\r\n\r\nVE adj[MAXN*8];\r\nint len[MAXN*8];\r\n\r\nint main()\r\n{\r\n	while(scanf("%d",&n)!=EOF)\r\n	{\r\n		for(int i=0;i<n;++i)\r\n		    scanf("%d %d %d %d",&r[i].x1,&r[i].y1,&r[i].x2,&r[i].y2);\r\n\r\n		int X = r[0].x1;\r\n		int Y = r[0].y1;\r\n		sort(r,r+n);\r\n\r\n		int N = 0;\r\n		for(int i=0;i<n;++i)\r\n		{\r\n			if(!is_inner_point(r[i].x1,r[i].y1))\r\n			{\r\n		       px[N] = r[i].x1;\r\n			   py[N++] = r[i].y1;\r\n			}\r\n\r\n			if(!is_inner_point(r[i].x2,r[i].y1))\r\n			{\r\n		       px[N] = r[i].x2;\r\n			   py[N++] = r[i].y1;\r\n			}\r\n		\r\n			if(!is_inner_point(r[i].x1,r[i].y2))\r\n			{\r\n		       px[N] = r[i].x1;\r\n			   py[N++] = r[i].y2;\r\n			}\r\n\r\n			if(!is_inner_point(r[i].x2,r[i].y2))\r\n			{\r\n		       px[N] = r[i].x2;\r\n			   py[N++] = r[i].y2;\r\n			}\r\n		}\r\n\r\n\r\n		for(int i=0;i<N;++i) ind[i] = i;\r\n		sort(ind,ind+N,byx);\r\n		for(int i=0;i<2*N;++i) adj[i].clear();\r\n\r\n		for(int ii=0;ii<N;++ii)\r\n		{\r\n		    int i = ind[ii];\r\n			int j = 0;\r\n			int maxy = 1<<30, miny = 0;\r\n			while(j<n && r[j].x1<px[i])\r\n			{\r\n			   if(r[j].x2 > px[i])\r\n			   {\r\n				  if(r[j].y1 >= py[i])       maxy = min(maxy,r[j].y1);\r\n				  else if(r[j].y2 <= py[i])  miny = max(miny,r[j].y2);\r\n			   }\r\n			   ++j;\r\n			}\r\n\r\n	    	for(int jj=ii+1;jj<N;++jj)\r\n			{\r\n				int k = ind[jj];\r\n				while(j<n && r[j].x1<px[k])\r\n				{\r\n				   if(r[j].y1<py[i] && r[j].y2>py[i])\r\n				   {\r\n					   miny = r[j].y2;\r\n					   maxy = r[j].y1;\r\n				   }\r\n				   else if(r[j].y1 >= py[i]) maxy = min(maxy,r[j].y1);\r\n				   else if(r[j].y2 <= py[i]) miny = max(miny,r[j].y2);\r\n				   ++j;\r\n				}\r\n				if(maxy < miny) break;\r\n			\r\n				if(py[k]>=miny && py[k]<=maxy)\r\n				{\r\n				  int from = i;\r\n				  int to = k;\r\n				  int len = abs(px[to]-px[from]) + abs(py[to]-py[from]);\r\n				  if(px[from]<=X && px[to]>X && py[from]<=Y &&py[to]<=Y)\r\n				  {\r\n					  adj[from].push_back( Edge(to+N,len) );\r\n					  adj[from+N].push_back( Edge(to,len) );\r\n					  adj[to].push_back( Edge(from+N,len) );\r\n					  adj[to+N].push_back( Edge(from,len) );\r\n				  }\r\n				  else				  \r\n				  {\r\n					  adj[from].push_back( Edge(to,len) );\r\n					  adj[from+N].push_back( Edge(to+N,len) );\r\n					  adj[to].push_back( Edge(from,len) );\r\n					  adj[to+N].push_back( Edge(from+N,len) );\r\n				  }\r\n				}\r\n			}\r\n		}\r\n\r\n		const int INF = 1<<30;\r\n		int best = INF;\r\n		for(int i=0;i<n;++i)\r\n		{\r\n		   for(int j=0;j<2*N;++j)\r\n			    len[j] = INF;\r\n		   \r\n		   priority_queue<Edge> Q;\r\n		   Q.push( Edge(i,0) );\r\n		   len[i] = 0;\r\n		   while(!Q.empty())\r\n		   {\r\n			   Edge e = Q.top();\r\n			   Q.pop();\r\n			   \r\n			   if(e.cost >= best) break;\r\n			   if(e.dest == i+N)\r\n			   {\r\n				  best = e.cost;\r\n				  break;\r\n			   }\r\n			   if(e.cost > len[e.dest]) continue;\r\n			   \r\n			   for(VE::iterator it=adj[e.dest].begin();it!=adj[e.dest].end();++it)\r\n			   {\r\n				   Edge next(it->dest, e.cost+it->cost);\r\n				   if(next.cost < len[it->dest])\r\n				   {\r\n					  len[it->dest] = next.cost;\r\n					  Q.push(next);\r\n				   }\r\n			   }\r\n		   }\r\n		}\r\n		printf("%d\\n",best);\r\n	}\r\n	return 0;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n		\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n		\r\n		\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n', '', 358, 1572864, 1, 2, '2010-11-03 20:54:50', '0001-01-01 00:00:00'),
(854, 6, 300, 0, '#include <stdio.h>\r\nint main()\r\n{\r\n    int i, x;\r\n	long long p, q ,n;\r\n\r\n	while(scanf("%lld %lld",&p,&q)!=EOF) \r\n	{\r\n		if(p==0 && q==0) break;\r\n	    \r\n		x = 0;\r\n		for( i = 2; i <= 50000; i++ )\r\n		{\r\n			n = (long long)i*(i-1)*p;\r\n			while( (long long)x*(x-1)*q < n ) x++;\r\n			if( (long long)x*(x-1)*q == n ) break;\r\n		}\r\n		if( i > 50000 )\r\n			printf("impossible\\n" );\r\n		else\r\n			printf("%d %d\\n",x, i-x);\r\n	}\r\n	return 0;\r\n}\r\n\r\n', '', 45, 262144, 1, 1, '2010-11-06 11:15:34', '0001-01-01 00:00:00'),
(855, 14, 375, 5, '#include<stdio.h>\r\n#include<math.h>\r\n#include<limits.h>\r\n\r\nint missleHeight[50000];\r\nint systemNum[50000];\r\n\r\nint findSystem(int val[],int num,int height)\r\n{\r\n	int i=0,pos=num;\r\n	int min= INT_MAX;\r\n	for(;i<num;++i)\r\n	{\r\n		int dis = abs(val[i] - height);\r\n		if( dis < min && height <val[i])\r\n		{\r\n			min=dis;\r\n			pos =i;\r\n		}\r\n	}\r\n	return pos;\r\n}\r\n\r\nint main()\r\n{\r\n	int num;\r\n	while( 1 == scanf("%d",&num) )\r\n	{\r\n		int i,maxheight,minheight;\r\n		int systemCount=1;\r\n\r\n		for(i=0;i<num;++i)\r\n			scanf("%d",&missleHeight[i]);\r\n		\r\n		maxheight = minheight = missleHeight[0];\r\n		systemNum[0]=minheight;\r\n		for(i=1;i<num;++i)\r\n		{\r\n\r\n			int systemPos = findSystem(systemNum, systemCount,missleHeight[i]);\r\n			systemNum[systemPos] = missleHeight[i];\r\n			\r\n			if(systemPos == systemCount) \r\n				++systemCount;\r\n		\r\n		}\r\n		printf("%d\\n",systemCount);\r\n		\r\n\r\n\r\n	}\r\n	return 0;\r\n}', '', 468, 655360, 1, 1, '2010-11-06 16:27:02', '0001-01-01 00:00:00'),
(856, 14, 375, 5, '#include<stdio.h>\r\n#include<math.h>\r\n#include<limits.h>\r\n\r\nint missleHeight[50000];\r\nint systemNum[50000];\r\n\r\n\r\n\r\nint main()\r\n{\r\n	int num;\r\n	while( 1 == scanf("%d",&num) )\r\n	{\r\n		int i,maxheight,minheight;\r\n		int systemCount=1;\r\n\r\n		for(i=0;i<num;++i)\r\n			scanf("%d",&missleHeight[i]);\r\n		\r\n		maxheight = minheight = missleHeight[0];\r\n		systemNum[0]=minheight;\r\n		for(i=1;i<num;++i)\r\n		{\r\n\r\n			int systemPos=systemCount,j=0;\r\n			int min= INT_MAX;\r\n			\r\n			for(;j<systemCount;++j)\r\n			{\r\n				int dis = abs(systemNum[j] - missleHeight[i]);\r\n				if( dis < min && missleHeight[i] <systemNum[j])\r\n				{\r\n					min=dis;\r\n					systemPos =j;\r\n				}\r\n			}\r\n	\r\n			systemNum[systemPos] = missleHeight[i];\r\n			\r\n			if(systemPos == systemCount) \r\n				++systemCount;\r\n		\r\n		}\r\n		printf("%d\\n",systemCount);\r\n		\r\n\r\n\r\n	}\r\n	return 0;\r\n}', '', 452, 659456, 1, 1, '2010-11-06 16:36:54', '0001-01-01 00:00:00'),
(857, 6, 23, 0, '#include <stdio.h>\r\n#define N 5\r\nint res, n;\r\nchar map[N][N];\r\n\r\nchar check(int x, int y)\r\n{\r\n	int i;\r\n	for(i = x - 1; i >= 0; --i){\r\n		if(map[i][y] == ''Y'')       return 0;\r\n		else if(map[i][y] == ''X'')  break;\r\n	}\r\n\r\n	for(i = y - 1; i >= 0; --i){\r\n		if(map[x][i] == ''Y'')       return 0;\r\n		else if(map[x][i] == ''X'')  break;\r\n	}\r\n	return 1;\r\n}\r\n\r\nvoid dfs(int x, int y, int m)\r\n{\r\n	if(x == n){\r\n		if(m > res) res = m;\r\n	}\r\n	else if(y == n) dfs(x+1, 0, m);  \r\n	else {\r\n		if(map[x][y] == ''.'' && check(x,y)){\r\n			map[x][y] = ''Y'';\r\n			dfs(x, y+1, m+1);\r\n			map[x][y] = ''.'';\r\n		}\r\n		dfs(x, y+1, m);\r\n	}\r\n}\r\n\r\nint main()\r\n{\r\n	int i;\r\n	while(scanf("%d",&n)!=EOF && n){\r\n		for(i = 0; i < n; ++i)\r\n		    scanf("%s",map[i]);\r\n\r\n		res = 0;\r\n		dfs(0, 0, 0);\r\n		printf("%d\\n",res);\r\n	}\r\n	return 0;\r\n}\r\n', '', 499, 262144, 1, 1, '2010-11-09 22:36:38', '0001-01-01 00:00:00'),
(858, 17, 376, 5, '#include<stdio.h>\r\n#include<stdlib.h>\r\n#define M 50001\r\nint num[M];\r\nint left[M];\r\nint right[M];\r\nvoid left_i(int n)\r\n{\r\n    int i;\r\n    left[0]=1;\r\n    for(i=1;i<n;i++)\r\n      left[i]=left[i-1]*num[i-1];\r\n}\r\nvoid right_i(int n)\r\n{\r\n    int i;\r\n    right[n-1]=1;\r\n    for(i=n-2;i>=0;i--)\r\n        right[i]=right[i+1]*num[i+1];\r\n}\r\n   \r\nvoid get_max(int len)\r\n{   \r\n    int i;\r\n    int max;\r\n    max=left[0]*right[0];\r\n    for(i=1;i<len;++i)\r\n    {\r\n      if(left[i]*right[i]>max)\r\n      {\r\n           max=left[i]*right[i];\r\n      }\r\n    }\r\n    printf("%d\\n",max);\r\n    return;\r\n}\r\nint main()\r\n{\r\n    int n;\r\n    int i;\r\n    int max;\r\n    while(scanf("%d",&n)!=EOF)\r\n    {  \r\n       for(i=0;i<n;i++)\r\n         scanf("%d",num+i);\r\n       left_i(n);\r\n       right_i(n);\r\n       get_max(n);\r\n     }\r\n       return 0;\r\n    }\r\n', '', 62, 860160, 4, 1, '2010-11-10 21:51:46', '0001-01-01 00:00:00'),
(859, 17, 376, 5, '#include<stdio.h>\r\n#include<stdlib.h>\r\n#define M 50001\r\nint num[M];\r\nint left[M];\r\nint right[M];\r\nvoid left_i(int n)\r\n{\r\n    int i;\r\n    left[0]=1;\r\n    for(i=1;i<n;i++)\r\n      left[i]=left[i-1]*num[i-1];\r\n}\r\nvoid right_i(int n)\r\n{\r\n    int i;\r\n    right[n-1]=1;\r\n    for(i=n-2;i>=0;i--)\r\n        right[i]=right[i+1]*num[i+1];\r\n}\r\n   \r\nvoid get_max(int len)\r\n{   \r\n    int i;\r\n    int max;\r\n    max=left[0]*right[0];\r\n    for(i=1;i<len;++i)\r\n    {\r\n      if(left[i]*right[i]>max)\r\n      {\r\n           max=left[i]*right[i];\r\n      }\r\n    }\r\n    printf("%d\\n",max);\r\n    return;\r\n}\r\nint main()\r\n{\r\n    int n;\r\n    int i;\r\n    int max;\r\n    while(scanf("%d",&n)!=EOF)\r\n    {  \r\n       for(i=0;i<n;i++)\r\n         scanf("%d",num+i);\r\n       left_i(n);\r\n       right_i(n);\r\n       get_max(n);\r\n     }\r\n       return 0;\r\n    }\r\n', '', 62, 860160, 4, 1, '2010-11-10 21:55:10', '0001-01-01 00:00:00'),
(860, 1, 377, 0, '#include <stdio.h>\r\nstruct point\r\n{\r\n    double x;\r\n    double y;\r\n};\r\ntypedef struct point Point;\r\nstruct line\r\n{\r\n    Point s;\r\n    Point e;\r\n};\r\ntypedef struct line Line;\r\nLine data[300];\r\ndouble min(double x,double y)\r\n{\r\n    return x>y ? y:x;\r\n}\r\ndouble max(double x,double y)\r\n{\r\n    return x<y ? y:x;\r\n}\r\nbool iszero(double f)\r\n{\r\n    if (f < 0.00001 && f > -0.00001)\r\n        return true;\r\n    return false;\r\n}\r\ndouble direction(Point pi,Point pj,Point pk )\r\n{\r\n    double x1,x2,y1,y2;\r\n    x1 = pk.x - pi.x;y1=pk.y-pi.y;\r\n    x2 = pj.x - pi.x;y2=pj.y-pi.y;\r\n    return x1*y2-x2*y1;\r\n}\r\nbool onsegment(Point pi,Point pj,Point pk ) //我换一种表示\r\n{\r\n    if(( min(pi.x,pj.x) <= pk.x && pk.x <= max(pi.x,pj.x)) && ( min(pi.y,pj.y) <= pk.y && pk.y <= max(pi.y,pj.y) ))\r\n      //if( (pk.x-pi.x)*(pk.x-pj.x) <=0 && (pk.y-pi.y)*(pk.y-pj.y)<=0 ) //这也是判断点在pi pj 为对角线的矩形内\r\n        return true;\r\n    return false;\r\n}\r\nbool SEGMENTS_INTERSECT(Point p1,Point p2,Point p3,Point p4)\r\n{\r\n    double d1,d2,d3,d4;\r\n    d1 = direction(p3,p4,p1);\r\n    d2 = direction(p3,p4,p2);\r\n    d3 = direction(p1,p2,p3);\r\n    d4 = direction(p1,p2,p4);\r\n\r\n    if((d1*d2 < 0) &&( d3*d4<0))\r\n        return true;\r\n    else if( iszero(d1) && onsegment(p3,p4,p1) ) return true;\r\n    else if( iszero(d2) && onsegment(p3,p4,p2) ) return true;\r\n    else if( iszero(d3) && onsegment(p1,p2,p3) ) return true;\r\n    else if( iszero(d4) && onsegment(p1,p2,p4) ) return true;\r\n    else return false;\r\n}\r\n\r\nint main(int argc, char* argv[])\r\n{\r\n    int n,i,j,count;\r\n    while(scanf("%d",&n),n)\r\n    {\r\n        for(i = 1; i <= n; i ++)\r\n            scanf("%lf%lf%lf%lf",&data[i].s.x,&data[i].s.y,&data[i].e.x,&data[i].e.y);\r\n        for(count = 0,i = 1; i <= n;i ++)\r\n            for(j = i+1; j <= n; j ++)\\\r\n                if(SEGMENTS_INTERSECT(data[i].s,data[i].e,data[j].s,data[j].e))\r\n                    count++;\r\n        printf("%d\\n",count);\r\n    }\r\n    return 0;\r\n}', '', 421, 266240, 1, 2, '2010-11-10 21:58:47', '0001-01-01 00:00:00'),
(861, 17, 376, 5, '#include<stdio.h>\r\n#include<stdlib.h>\r\n#define M 50001\r\nint max(int * arr, int len) \r\n{ \r\n     int  left[M];  \r\n     int  right[M]; \r\n     int  p[M]; \r\n     int  i;\r\n     int  max_num;\r\n     left[0] = 1; \r\n     right[len] = 1; \r\n     \r\n     for( i=1;i<=len;i++) \r\n     { \r\n        left[i] = left[i-1] * arr[i-1]; \r\n        right[len-i] = right[len-i+1] * arr[len-i]; \r\n     } \r\n     max_num = left[0] * right[1]; \r\n    \r\n     for( i=1;i<len;i++) \r\n     { \r\n        p[i] = left[i] * right[i+1]; \r\n        if(p[i] > max_num) \r\n	            max_num = p[i]; \r\n	    } \r\n	    return max_num; \r\n	} \r\nint main()\r\n{\r\n    int n;\r\n    int i;\r\n    int num[M];\r\n    while(scanf("%d",&n)!=EOF)\r\n    {  \r\n       for(i=0;i<n;i++)\r\n         scanf("%d",num+i);\r\n       printf("%d\\n",max(num,n));\r\n     }\r\n       return 0;\r\n    }\r\n\r\n', '', 78, 1019904, 4, 1, '2010-11-10 22:30:21', '0001-01-01 00:00:00'),
(862, 17, 376, 5, '#include<stdio.h>\r\n#include<stdlib.h>\r\n#define M 50001\r\nlong max(long * arr, int len) \r\n{ \r\n     long  left[M];  \r\n     long  right[M]; \r\n     long  p[M]; \r\n     int  i;\r\n     long  max_num;\r\n     left[0] = 1; \r\n     right[len] = 1; \r\n     \r\n     for( i=1;i<=len;i++) \r\n     { \r\n        left[i] = left[i-1] * arr[i-1]; \r\n        right[len-i] = right[len-i+1] * arr[len-i]; \r\n     } \r\n     max_num = left[0] * right[1]; \r\n    \r\n     for( i=1;i<len;i++) \r\n     { \r\n        p[i] = left[i] * right[i+1]; \r\n        if(p[i] > max_num) \r\n	            max_num = p[i]; \r\n	    } \r\n	    return max_num; \r\n	} \r\nint main()\r\n{\r\n    int n;\r\n    int i;\r\n    long num[M];\r\n    while(scanf("%d",&n)!=EOF)\r\n    {  \r\n       for(i=0;i<n;i++)\r\n         scanf("%ld",num+i);\r\n       printf("%ld\\n",max(num,n));\r\n     }\r\n       return 0;\r\n    }\r\n\r\n', '', 78, 1019904, 4, 1, '2010-11-10 22:55:43', '0001-01-01 00:00:00'),
(863, 17, 376, 5, '#include<stdio.h>\r\n#include<stdlib.h>\r\n#define M 50001\r\nlong max(long * arr, long len) \r\n{ \r\n     long  left[M];  \r\n     long  right[M]; \r\n     long  p[M]; \r\n     long  i;\r\n     long  max_num;\r\n     left[0] = 1; \r\n     right[len] = 1; \r\n     \r\n     for( i=1;i<=len;i++) \r\n     { \r\n        left[i] = left[i-1] * arr[i-1]; \r\n        right[len-i] = right[len-i+1] * arr[len-i]; \r\n     } \r\n     max_num = left[0] * right[1]; \r\n    \r\n     for( i=1;i<len;i++) \r\n     { \r\n        p[i] = left[i] * right[i+1]; \r\n        if(p[i] > max_num) \r\n	            max_num = p[i]; \r\n	    } \r\n	    return max_num; \r\n	} \r\nint main()\r\n{\r\n    long n;\r\n    long i;\r\n    long num[M];\r\n    while(scanf("%ld",&n)!=EOF)\r\n    {  \r\n       for(i=0;i<n;i++)\r\n         scanf("%ld",num+i);\r\n       printf("%ld\\n",max(num,n));\r\n     }\r\n       return 0;\r\n    }\r\n\r\n', '', 62, 1019904, 4, 1, '2010-11-10 23:03:47', '0001-01-01 00:00:00'),
(864, 1, 378, 0, '#include<vector>\r\n#include<cstdio>\r\n#include<cmath>\r\nusing namespace std;\r\n\r\nconst double ESP = 1e-5;\r\n\r\nconst int MAX_N = 1000;\r\n\r\n\r\n\r\nstruct Point {\r\n\r\n	double x, y;\r\n\r\n};\r\n\r\nstruct LineSegment {\r\n\r\n	Point pt1, pt2;\r\n\r\n};\r\n\r\ntypedef vector<Point> Polygon;\r\n\r\n\r\ndouble Multiply(Point p1, Point p2, Point p0)\r\n\r\n{\r\n\r\n	return ( (p1.x - p0.x) * (p2.y - p0.y) - (p2.x - p0.x) * (p1.y - p0.y) );\r\n\r\n}\r\n\r\n\r\nbool IsOnline(Point point, LineSegment line)\r\n\r\n{\r\n\r\n	return( ( fabs(Multiply(line.pt1, line.pt2, point)) < ESP ) &&\r\n\r\n		( ( point.x - line.pt1.x ) * ( point.x - line.pt2.x ) <= 0 ) &&\r\n\r\n		( ( point.y - line.pt1.y ) * ( point.y - line.pt2.y ) <= 0 ) );\r\n\r\n}\r\n\r\n\r\nbool Intersect(LineSegment L1, LineSegment L2)\r\n\r\n{\r\n\r\n	return( (max(L1.pt1.x, L1.pt2.x) >= min(L2.pt1.x, L2.pt2.x)) &&\r\n\r\n		(max(L2.pt1.x, L2.pt2.x) >= min(L1.pt1.x, L1.pt2.x)) &&\r\n\r\n		(max(L1.pt1.y, L1.pt2.y) >= min(L2.pt1.y, L2.pt2.y)) &&\r\n\r\n		(max(L2.pt1.y, L2.pt2.y) >= min(L1.pt1.y, L1.pt2.y)) &&\r\n\r\n		(Multiply(L2.pt1, L1.pt2, L1.pt1) * Multiply(L1.pt2, L2.pt2, L1.pt1) >= 0) &&\r\n\r\n		(Multiply(L1.pt1, L2.pt2, L2.pt1) * Multiply(L2.pt2, L1.pt2, L2.pt1) >= 0)\r\n\r\n		);\r\n\r\n}\r\n\r\nint InPolygon(const Polygon& polygon, Point point)\r\n\r\n{\r\n\r\n	int n = polygon.size();\r\n\r\n	int count = 0;\r\n\r\n	LineSegment line;\r\n\r\n	line.pt1 = point;\r\n\r\n	line.pt2.y = point.y;\r\n\r\n	line.pt2.x = - INFINITY;\r\n\r\n\r\n\r\n	for( int i = 0; i < n; i++ ) {\r\n\r\n		LineSegment side;\r\n\r\n		side.pt1 = polygon[i];\r\n\r\n		side.pt2 = polygon[(i + 1) % n];\r\n\r\n\r\n\r\n		if( IsOnline(point, side) ) {\r\n\r\n			return 0;\r\n\r\n		}\r\n\r\n\r\n\r\n		if( fabs(side.pt1.y - side.pt2.y) < ESP ) {\r\n\r\n			continue;\r\n\r\n		}\r\n\r\n\r\n\r\n		if( IsOnline(side.pt1, line) ) {\r\n\r\n			if( side.pt1.y > side.pt2.y ) count++;\r\n\r\n		} else if( IsOnline(side.pt2, line) ) {\r\n\r\n			if( side.pt2.y > side.pt1.y ) count++;\r\n\r\n		} else if( Intersect(line, side) ) {\r\n\r\n			count++;\r\n\r\n		}\r\n\r\n	}\r\n\r\n\r\n\r\n	if ( count % 2 == 1 ) {return 1;}\r\n\r\n	else { return -1;}\r\n\r\n}\r\nPolygon pol;\r\nint main()\r\n{\r\n	//freopen("c:/ti.txt","r",stdin);\r\n	//freopen("c:/to.txt","w",stdout);\r\n	int n,m;\r\n	while(scanf("%d%d",&n,&m)==2)\r\n	{\r\n		pol.clear();\r\n		pol.reserve(n);\r\n		Point p;\r\n\r\n		for(int i=0;i<n;++i)\r\n		{\r\n			scanf("%lf%lf",&p.x,&p.y);\r\n			pol.push_back(p);\r\n		}\r\n		for(int i=0;i<m;++i)\r\n		{\r\n			scanf("%lf%lf",&p.x,&p.y);\r\n			printf("%d\\n", InPolygon(pol,p));\r\n		}\r\n	}\r\n}', '', 0, 299008, 1, 2, '2010-11-11 01:27:11', '0001-01-01 00:00:00'),
(865, 6, 377, 6, '#include<iostream>\r\n#include<cstdio>\r\n#include<cmath>\r\n#include<cstring>\r\n#include<string>\r\nusing namespace std;\r\nconst double eps=1e-10;\r\ntemplate<class T> T& min(const T& a, const T& b){\r\n	return a<b?a:b;\r\n}\r\ntemplate<class T> T& max(const T& a, const T& b){\r\n	return a>b?a:b;\r\n}\r\nstruct Node\r\n{    \r\n	double x, y;\r\n};\r\n\r\nbool inter(Node a, Node b, Node c, Node d)\r\n//(a,b)-(c,d)\r\n{  \r\n	if ( min(a.x, b.x) > max(c.x, d.x) \r\n		||  min(a.y, b.y) > max(c.y, d.y)\r\n		||  min(c.x, d.x) > max(a.x, b.x) \r\n		||  min(c.y, d.y) > max(a.y, b.y) ) \r\n	     return 0;  \r\n	double h, i, j, k; \r\n	h = (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x); \r\n	i = (b.x - a.x) * (d.y - a.y) - (b.y - a.y) * (d.x - a.x); \r\n	j = (d.x - c.x) * (a.y - c.y) - (d.y - c.y) * (a.x - c.x); \r\n	k = (d.x - c.x) * (b.y - c.y) - (d.y - c.y) * (b.x - c.x); \r\n	return h * i <= eps && j * k <= eps;\r\n}\r\nNode a[110],b[110];\r\nint main()\r\n{    \r\n	int n, i, j;    \r\n	while(scanf("%d",&n)==1&&n)  \r\n	{      \r\n		for(i=0;i<n;i++)\r\n			scanf("%lf%lf%lf%lf",&a[i].x,&a[i].y,&b[i].x,&b[i].y);    \r\n		int cnt=0;       \r\n		for(i=0;i<n;i++)     \r\n		{            \r\n			for(j=i+1;j<n;j++)           \r\n				if(inter(a[i],b[i],a[j],b[j])) \r\n				   cnt++;        \r\n		}\r\n		printf("%d\\n",cnt);    \r\n	}\r\n	return 0;\r\n}', 'Main.cpp: In function ''bool inter(Node, Node, Node, Node)'':\r\nMain.cpp:22:19: error: call of overloaded ''min(double&, double&)'' is ambiguous\r\nMain.cpp:8:22: note: candidates are: T& min(const T&, const T&) [with T = double]\r\ne:\\shpchen\\oj\\jojserver\\tools\\gcc\\bin\\../lib/gcc/mingw32/4.5.0/include/c++/bits/stl_algobase.h:186:5: note:                 const _Tp& std::min(const _Tp&, const _Tp&) [with _Tp = double]\r\nMain.cpp:22:35: error: call of overloaded ''max(double&, double&)'' is ambiguous\r\nMain.cp', 0, 0, 2, 2, '2010-11-11 08:30:41', '0001-01-01 00:00:00'),
(866, 6, 377, 6, '#include<iostream>\r\n#include<cstdio>\r\n#include<cmath>\r\n#include<cstring>\r\n#include<string>\r\nusing namespace std;\r\nconst double eps=1e-10;\r\n/*template<class T> T& min(const T& a, const T& b){\r\n	return a<b?a:b;\r\n}\r\ntemplate<class T> T& max(const T& a, const T& b){\r\n	return a>b?a:b;\r\n}*/\r\nstruct Node\r\n{    \r\n	double x, y;\r\n};\r\n\r\nbool inter(Node a, Node b, Node c, Node d)\r\n//(a,b)-(c,d)\r\n{  \r\n	if ( min(a.x, b.x) > max(c.x, d.x) \r\n		||  min(a.y, b.y) > max(c.y, d.y)\r\n		||  min(c.x, d.x) > max(a.x, b.x) \r\n		||  min(c.y, d.y) > max(a.y, b.y) ) \r\n	     return 0;  \r\n	double h, i, j, k; \r\n	h = (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x); \r\n	i = (b.x - a.x) * (d.y - a.y) - (b.y - a.y) * (d.x - a.x); \r\n	j = (d.x - c.x) * (a.y - c.y) - (d.y - c.y) * (a.x - c.x); \r\n	k = (d.x - c.x) * (b.y - c.y) - (d.y - c.y) * (b.x - c.x); \r\n	return h * i <= eps && j * k <= eps;\r\n}\r\nNode a[110],b[110];\r\nint main()\r\n{    \r\n	int n, i, j;    \r\n	while(scanf("%d",&n)==1&&n)  \r\n	{      \r\n		for(i=0;i<n;i++)\r\n			scanf("%lf%lf%lf%lf",&a[i].x,&a[i].y,&b[i].x,&b[i].y);    \r\n		int cnt=0;       \r\n		for(i=0;i<n;i++)     \r\n		{            \r\n			for(j=i+1;j<n;j++)           \r\n				if(inter(a[i],b[i],a[j],b[j])) \r\n				   cnt++;        \r\n		}\r\n		printf("%d\\n",cnt);    \r\n	}\r\n	return 0;\r\n}\r\n\r\n', '', 171, 372736, 7, 2, '2010-11-11 08:31:49', '0001-01-01 00:00:00'),
(867, 6, 377, 6, '#include<iostream>\r\n#include<cstdio>\r\n#include<cmath>\r\n#include<cstring>\r\n#include<string>\r\nusing namespace std;\r\nconst double eps=1e-10;\r\n/*template<class T> T& min(const T& a, const T& b){\r\n	return a<b?a:b;\r\n}\r\ntemplate<class T> T& max(const T& a, const T& b){\r\n	return a>b?a:b;\r\n}*/\r\nstruct Node\r\n{    \r\n	double x, y;\r\n};\r\n\r\nbool inter(Node a, Node b, Node c, Node d)\r\n//(a,b)-(c,d)\r\n{  \r\n	if ( min(a.x, b.x) > max(c.x, d.x) \r\n		||  min(a.y, b.y) > max(c.y, d.y)\r\n		||  min(c.x, d.x) > max(a.x, b.x) \r\n		||  min(c.y, d.y) > max(a.y, b.y) ) \r\n	     return 0;  \r\n	double h, i, j, k; \r\n	h = (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x); \r\n	i = (b.x - a.x) * (d.y - a.y) - (b.y - a.y) * (d.x - a.x); \r\n	j = (d.x - c.x) * (a.y - c.y) - (d.y - c.y) * (a.x - c.x); \r\n	k = (d.x - c.x) * (b.y - c.y) - (d.y - c.y) * (b.x - c.x); \r\n	return h * i <= eps && j * k <= eps;\r\n}\r\nNode a[300],b[300];\r\nint main()\r\n{    \r\n	int n, i, j;    \r\n	while(scanf("%d",&n)==1&&n)  \r\n	{      \r\n		for(i=0;i<n;i++)\r\n			scanf("%lf%lf%lf%lf",&a[i].x,&a[i].y,&b[i].x,&b[i].y);    \r\n		int cnt=0;       \r\n		for(i=0;i<n;i++)     \r\n		{            \r\n			for(j=i+1;j<n;j++)           \r\n				if(inter(a[i],b[i],a[j],b[j])) \r\n				   cnt++;        \r\n		}\r\n		printf("%d\\n",cnt);    \r\n	}\r\n	return 0;\r\n}', '', 155, 380928, 1, 2, '2010-11-11 08:32:54', '0001-01-01 00:00:00'),
(868, 21, 377, 6, '#include<stdio.h>\r\nint between(float u, float v, float w)\r\n{ float max,min;\r\n  max=(v>w)?v:w;\r\n  min=(v<w)?v:w;\r\n  return ((u<=max&&u>=min)?1:0);\r\n}\r\nint main()\r\n{ \r\n  int n,i,j,num; \r\n  float x1[100],y1[100],x2[100],y2[100],a[100],b[100],c[100],jx,jy;\r\n  while(scanf("%d",&n)&&n!=0)\r\n  {   \r\n   num=0;    \r\n   for(i=0;i<n;++i)\r\n   { scanf("%f%f%f%f",&x1[i],&y1[i],&x2[i],&y2[i]);\r\n     if(x1[i]==x2[i])\r\n     { \r\n       a[i]=1;b[i]=0;c[i]=-x1[i];\r\n     }\r\n     else\r\n     { \r\n       a[i]=(y2[i]-y1[i])/(x1[i]-x2[i]);b[i]=1;\r\n       c[i]=(x1[i]*y2[i]-x2[i]*y1[i])/(x2[i]-x1[i]);\r\n     }\r\n   }\r\n   for(i=0;i<n;++i)\r\n   { \r\n      for(j=i+1;j<n;++j)\r\n      { \r\n         if(a[i]*b[j]-a[j]*b[i]!=0)\r\n        { \r\n          jx=(b[i]*c[j]-b[j]*c[i])/(a[i]*b[j]-a[j]*b[i]);\r\n          jy=(c[i]*a[j]-c[j]*a[i])/(a[i]*b[j]-a[j]*b[i]);\r\n          if(between(jx,x1[i],x2[i])&&between(jx,x1[j],x2[j])&&between(jy,y1[i],y2[i])&&between(jy,y1[j],y2[j]))\r\n          num++;\r\n       }\r\n      }\r\n   }\r\n   printf("%d\\n",num);\r\n  }\r\n  return 0;\r\n}\r\n', '', 0, 258048, 4, 1, '2010-11-11 08:33:36', '0001-01-01 00:00:00'),
(869, 13, 377, 6, '#include<stdio.h>\r\ndouble p[100][2],q[100][2];\r\ndouble direction(double p[],double q[],double r[])\r\n{\r\n    return((r[0]-p[0])*(q[1]-p[1])-(r[1]-p[1])*(q[0]-p[0]));\r\n}\r\nint onsegment(double p[],double q[], double r[])\r\n{\r\n    if(((r[0]-p[0])*(r[0]-q[0])<=0)&&((r[1]-p[1])*(r[1]-q[1])<=0))\r\n        return 1;\r\n    else \r\n        return 0;\r\n}\r\n\r\nint judge(int i, int j)\r\n{\r\n    double d1,d2,d3,d4;\r\n    d1=direction(p[i],q[i],p[j]);\r\n    d2=direction(p[i],q[i],q[j]);\r\n    d3=direction(p[j],q[j],p[i]);\r\n    d4=direction(p[j],q[j],q[i]);\r\n    if((d1*d2<0)&&(d3*d4<0))\r\n        return 1;\r\n    else if(d1==0&&onsegment(p[i],q[i],p[j])==1)\r\n        return 1;\r\n    else if(d2==0&&onsegment(p[i],q[i],q[j])==1)\r\n        return 1;\r\n    else if(d3==0&&onsegment(p[j],q[j],p[i])==1)\r\n        return 1;\r\n    else if(d4==0&&onsegment(p[j],q[j],q[i])==1)\r\n        return 1;\r\n    else return 0;\r\n}\r\n\r\nint main()\r\n{\r\n    int n,i,j,count;\r\n    while(scanf("%d",&n)&&n!=0)\r\n    {\r\n        for(i=0;i<n;i++)\r\n        {\r\n            scanf("%lf%lf%lf%lf",&p[i][0],&p[i][1],&q[i][0],&q[i][1]);\r\n        }\r\n        for(i=0,count=0;i<n;i++)\r\n            for(j=i+1;j<n;j++)\r\n                if(judge(i,j)==1)\r\n                    count++;\r\n        printf("%d\\n",count);\r\n    }\r\n    return 0;\r\n} ', '', 15, 262144, 7, 1, '2010-11-11 08:45:54', '0001-01-01 00:00:00'),
(870, 35, 377, 6, '#include <stdio.h>\r\n#include <stdlib.h>\r\nint between(float u, float v, float w)\r\n{ float max,min;\r\n  max=(v>w)?v:w;\r\n  min=(v<w)?v:w;\r\n  return ((u<=max&&u>=min)?1:0);\r\n}\r\nint main()\r\n{ \r\n  int n,i,j,num;\r\n  float x1[100],y1[100],x2[100],y2[100],a[100],b[100],c[100],jx,jy;\r\n  while(scanf("%d",&n)&&n!=0)\r\n  {   \r\n   num=0;    \r\n   for(i=0;i<n;++i)\r\n   { scanf("%f%f%f%f",&x1[i],&y1[i],&x2[i],&y2[i]);\r\n     if(x1[i]==x2[i])\r\n     { \r\n       a[i]=1;b[i]=0;c[i]=-x1[i];\r\n     }\r\n     else\r\n     { \r\n       a[i]=(y2[i]-y1[i])/(x1[i]-x2[i]);b[i]=1;\r\n       c[i]=(x1[i]*y2[i]-x2[i]*y1[i])/(x2[i]-x1[i]);\r\n     }\r\n   }\r\n   for(i=0;i<n;++i)\r\n   { \r\n      for(j=i+1;j<n;++j)\r\n      { \r\n         if(a[i]*b[j]-a[j]*b[i]!=0)\r\n        { \r\n          jx=(b[i]*c[j]-b[j]*c[i])/(a[i]*b[j]-a[j]*b[i]);\r\n          jy=(c[i]*a[j]-c[j]*a[i])/(a[i]*b[j]-a[j]*b[i]);\r\n          if(between(jx,x1[i],x2[i])&&between(jx,x1[j],x2[j])\r\n          &&between(jy,y1[i],y2[i])&&between(jy,y1[j],y2[j]))\r\n          num++;\r\n       }\r\n      }\r\n   }\r\n   printf("%d\\n",num);\r\n  }\r\n  return 0;\r\n} ', '', 0, 258048, 4, 2, '2010-11-11 08:52:36', '0001-01-01 00:00:00'),
(871, 13, 377, 6, '#include <stdio.h>\r\n#include <stdlib.h>\r\nint between(float u, float v, float w)\r\n{ float max,min;\r\n  max=(v>w)?v:w;\r\n  min=(v<w)?v:w;\r\n  return ((u<=max&&u>=min)?1:0);\r\n}\r\nint main()\r\n{ \r\n  int n,i,j,num[100],m=0;\r\n  float x1[300],y1[300],x2[300],y2[300],a[300],b[300],c[300],jx,jy;\r\n  while(scanf("%d",&n)&&n!=0)\r\n  {   \r\n   int temp=0;    \r\n   for(i=0;i<n;++i)\r\n   { \r\n	 scanf("%f%f%f%f",&x1[i],&y1[i],&x2[i],&y2[i]);\r\n     if(x1[i]==x2[i])\r\n     { \r\n       a[i]=1;b[i]=0;c[i]=-x1[i];\r\n     }\r\n     else\r\n     { \r\n       a[i]=(y2[i]-y1[i])/(x1[i]-x2[i]);b[i]=1;\r\n       c[i]=(x1[i]*y2[i]-x2[i]*y1[i])/(x2[i]-x1[i]);\r\n     }\r\n   }\r\n   for(i=0;i<n;++i)\r\n   { \r\n      for(j=i+1;j<n;++j)\r\n      { \r\n         if(a[i]*b[j]-a[j]*b[i]!=0)\r\n        { \r\n          jx=(b[i]*c[j]-b[j]*c[i])/(a[i]*b[j]-a[j]*b[i]);\r\n          jy=(c[i]*a[j]-c[j]*a[i])/(a[i]*b[j]-a[j]*b[i]);\r\n          if(between(jx,x1[i],x2[i])&&between(jx,x1[j],x2[j])\r\n          &&between(jy,y1[i],y2[i])&&between(jy,y1[j],y2[j]))\r\n          temp++;\r\n       }\r\n      }\r\n   }\r\n   num[m++]=temp;\r\n  }\r\n  for(i=0;i<m;++i)\r\n	  printf("%d\\n",num[i]);\r\n\r\n  return 0;\r\n} ', '', 0, 258048, 4, 1, '2010-11-11 08:57:33', '0001-01-01 00:00:00'),
(872, 21, 377, 6, '#include<stdio.h>\r\nint between(float u, float v, float w)\r\n{ float max,min;\r\n  max=(v>w)?v:w;\r\n  min=(v<w)?v:w;\r\n  return ((u<=max&&u>=min)?1:0);\r\n}\r\nint main()\r\n{ \r\n  int n,i,j,num; \r\n  float x1[100],y1[100],x2[100],y2[100],a[100],b[100],c[100],jx,jy;\r\n  while(scanf("%d",&n)&&n!=0)\r\n  {   \r\n   num=0;    \r\n   for(i=0;i<n;++i)\r\n   { scanf("%f%f%f%f",&x1[i],&y1[i],&x2[i],&y2[i]);\r\n     if(x1[i]==x2[i])\r\n     { \r\n       a[i]=1;b[i]=0;c[i]=-x1[i];\r\n     }\r\n     else\r\n     { \r\n       a[i]=(y2[i]-y1[i])/(x1[i]-x2[i]);\r\n	   b[i]=1;\r\n       c[i]=(x1[i]*y2[i]-x2[i]*y1[i])/(x2[i]-x1[i]);\r\n     }\r\n   }\r\n   for(i=0;i<n;++i)\r\n   { \r\n      for(j=0;j<n;++j)\r\n      { if(i!=j){\r\n         if(a[i]*b[j]-a[j]*b[i]!=0)\r\n        { \r\n          jx=(b[i]*c[j]-b[j]*c[i])/(a[i]*b[j]-a[j]*b[i]);\r\n          jy=(c[i]*a[j]-c[j]*a[i])/(a[i]*b[j]-a[j]*b[i]);\r\n          if(between(jx,x1[i],x2[i])&&between(jx,x1[j],x2[j])&&between(jy,y1[i],y2[i])&&between(jy,y1[j],y2[j]))\r\n			  num++;\r\n		}\r\n			}\r\n      }\r\n   }\r\n   printf("%d\\n",num/2);\r\n  }\r\n  return 0;\r\n}\r\n', '', 0, 258048, 4, 1, '2010-11-11 08:59:36', '0001-01-01 00:00:00'),
(873, 35, 377, 6, '#include<stdio.h>\r\ndouble p[100][2],q[100][2];\r\ndouble direction(double p[],double q[],double r[])\r\n{\r\n    return((r[0]-p[0])*(q[1]-p[1])-(r[1]-p[1])*(q[0]-p[0]));\r\n}\r\nint onsegment(double p[],double q[], double r[])\r\n{\r\n    if(((r[0]-p[0])*(r[0]-q[0])<=0)&&((r[1]-p[1])*(r[1]-q[1])<=0))\r\n        return 1;\r\n    else \r\n        return 0;\r\n}\r\n\r\nint judge(int i, int j)\r\n{\r\n    double d1,d2,d3,d4;\r\n    d1=direction(p[i],q[i],p[j]);\r\n    d2=direction(p[i],q[i],q[j]);\r\n    d3=direction(p[j],q[j],p[i]);\r\n    d4=direction(p[j],q[j],q[i]);\r\n    if((d1*d2<0)&&(d3*d4<0))\r\n        return 1;\r\n    else if(d1==0&&onsegment(p[i],q[i],p[j])==1)\r\n        return 1;\r\n    else if(d2==0&&onsegment(p[i],q[i],q[j])==1)\r\n        return 1;\r\n    else if(d3==0&&onsegment(p[j],q[j],p[i])==1)\r\n        return 1;\r\n    else if(d4==0&&onsegment(p[j],q[j],q[i])==1)\r\n        return 1;\r\n    else return 0;\r\n}\r\n\r\nint main()\r\n{\r\n    int n,i,j,count;\r\n    while(scanf("%d",&n)&&n!=0)\r\n    {\r\n        for(i=0;i<n;i++)\r\n        {\r\n            scanf("%lf%lf%lf%lf",&p[i][0],&p[i][1],&q[i][0],&q[i][1]);\r\n        }\r\n        for(i=0,count=0;i<n;i++)\r\n            for(j=i+1;j<n;j++)\r\n                if(judge(i,j)==1)\r\n                    count++;\r\n        printf("%d\\n",count);\r\n    }\r\n    return 0;\r\n} ', '', 15, 262144, 7, 2, '2010-11-11 08:59:42', '0001-01-01 00:00:00'),
(874, 35, 377, 6, '#include <stdio.h>\r\n#include <stdlib.h>\r\nint between(float u, float v, float w)\r\n{ float max,min;\r\n  max=(v>w)?v:w;\r\n  min=(v<w)?v:w;\r\n  return ((u<=max&&u>=min)?1:0);\r\n}\r\nint main()\r\n{ \r\n  int n,i,j,num;\r\n  float x1[100],y1[100],x2[100],y2[100],a[100],b[100],c[100],jx,jy;\r\n  while(scanf("%d",&n)&&n!=0)\r\n  {   \r\n   num=0;    \r\n   for(i=0;i<n;++i)\r\n   { scanf("%f%f%f%f",&x1[i],&y1[i],&x2[i],&y2[i]);\r\n     if(x1[i]==x2[i])\r\n     { \r\n       a[i]=1;b[i]=0;c[i]=-x1[i];\r\n     }\r\n     else\r\n     { \r\n       a[i]=(y2[i]-y1[i])/(x2[i]-x1[i]);b[i]=1;\r\n       c[i]=(x1[i]*y2[i]-x2[i]*y1[i])/(x2[i]-x1[i]);\r\n     }\r\n   }\r\n   for(i=0;i<n;++i)\r\n   { \r\n      for(j=i+1;j<n;++j)\r\n      { \r\n         if(a[i]*b[j]-a[j]*b[i]!=0)\r\n        { \r\n          jx=(b[i]*c[j]-b[j]*c[i])/(a[i]*b[j]-a[j]*b[i]);\r\n          jy=(c[i]*a[j]-c[j]*a[i])/(a[i]*b[j]-a[j]*b[i]);\r\n          if(between(jx,x1[i],x2[i])&&between(jx,x1[j],x2[j])\r\n          &&between(jy,y1[i],y2[i])&&between(jy,y1[j],y2[j]))\r\n          num++;\r\n       }\r\n      }\r\n   }\r\n   printf("%d\\n",num);\r\n  }\r\n  return 0;\r\n} ', '', 0, 258048, 4, 2, '2010-11-11 09:02:19', '0001-01-01 00:00:00'),
(875, 13, 377, 6, '#include<stdio.h>\r\n#include<stdlib.h>\r\ndouble p[100][2],q[100][2];\r\ndouble direction(double p[],double q[],double r[])\r\n{\r\n    return((r[0]-p[0])*(q[1]-p[1])-(r[1]-p[1])*(q[0]-p[0]));\r\n}\r\nint onsegment(double p[],double q[], double r[])\r\n{\r\n    if(((r[0]-p[0])*(r[0]-q[0])<=0)&&((r[1]-p[1])*(r[1]-q[1])<=0))\r\n        return 1;\r\n    else \r\n        return 0;\r\n}\r\n\r\nint judge(int i, int j)\r\n{\r\n    double d1,d2,d3,d4;\r\n    d1=direction(p[i],q[i],p[j]);\r\n    d2=direction(p[i],q[i],q[j]);\r\n    d3=direction(p[j],q[j],p[i]);\r\n    d4=direction(p[j],q[j],q[i]);\r\n    if((d1*d2<0)&&(d3*d4<0))\r\n        return 1;\r\n    else if(d1==0&&onsegment(p[i],q[i],p[j])==1)\r\n        return 1;\r\n    else if(d2==0&&onsegment(p[i],q[i],q[j])==1)\r\n        return 1;\r\n    else if(d3==0&&onsegment(p[j],q[j],p[i])==1)\r\n        return 1;\r\n    else if(d4==0&&onsegment(p[j],q[j],q[i])==1)\r\n        return 1;\r\n    else return 0;\r\n}\r\n\r\nint main()\r\n{\r\n    int n,i,j,count,num[100],m=0;\r\n    while(scanf("%d",&n)&&n!=0)\r\n    {\r\n        for(i=0;i<n;i++)\r\n        {\r\n            scanf("%lf%lf%lf%lf",&p[i][0],&p[i][1],&q[i][0],&q[i][1]);\r\n        }\r\n        for(i=0,count=0;i<n;i++)\r\n            for(j=i+1;j<n;j++)\r\n                if(judge(i,j)==1)\r\n                    count++;\r\n        num[m++]=count;\r\n    }\r\n	for(i=0;i<m;++i)\r\n		printf("%d\\n",num[i]);\r\n\r\n	\r\n\r\n    return 0;\r\n} ', '', 15, 262144, 7, 1, '2010-11-11 09:07:56', '0001-01-01 00:00:00'),
(876, 6, 378, 6, '#include <stdio.h>\r\n#include <iostream>\r\n#include <vector>\r\n#include <math.h>\r\n#include <algorithm>\r\nusing namespace std;\r\nconst double INFINITY = 1e10; \r\nconst double ESP = 1e-5; \r\nconst int MAX_N = 1000; \r\n/*template<class T> T& min(const T& a, const T& b){\r\n	return a<b?a:b;\r\n}\r\ntemplate<class T> T& max(const T& a, const T& b){\r\n	return a>b?a:b;\r\n}*/\r\nstruct Point { \r\n	double x, y; \r\n}; \r\n\r\nstruct LineSegment { \r\n	Point pt1, pt2; \r\n}; \r\ntypedef vector<Point> Polygon; \r\n\r\n// 计算叉乘 |P0P1| × |P0P2| \r\ndouble Multiply(Point p1, Point p2, Point p0) { \r\n	return ( (p1.x - p0.x) * (p2.y - p0.y) - (p2.x - p0.x) * (p1.y - p0.y) ); \r\n} \r\n\r\n// 判断线段是否包含点point \r\nbool IsOnline(Point point, LineSegment line) \r\n{ \r\n	return( ( fabs(Multiply(line.pt1, line.pt2, point)) < ESP ) && \r\n		  ( ( point.x - line.pt1.x ) * ( point.x - line.pt2.x ) <= 0 ) && \r\n		  ( ( point.y - line.pt1.y ) * ( point.y - line.pt2.y ) <= 0 ) ); \r\n} \r\n\r\n// 判断线段相交 \r\nbool Intersect(LineSegment L1, LineSegment L2) \r\n{ \r\n	return ( (max(L1.pt1.x, L1.pt2.x) >= min(L2.pt1.x, L2.pt2.x)) && \r\n		   (max(L2.pt1.x, L2.pt2.x) >= min(L1.pt1.x, L1.pt2.x)) && \r\n		   (max(L1.pt1.y, L1.pt2.y) >= min(L2.pt1.y, L2.pt2.y)) && \r\n		   (max(L2.pt1.y, L2.pt2.y) >= min(L1.pt1.y, L1.pt2.y)) && \r\n		   (Multiply(L2.pt1, L1.pt2, L1.pt1) * Multiply(L1.pt2, L2.pt2, L1.pt1) >= 0) && \r\n		   (Multiply(L1.pt1, L2.pt2, L2.pt1) * Multiply(L2.pt2, L1.pt2, L2.pt1) >= 0) \r\n		   ); \r\n} \r\n\r\n// 判断点在多边形内 \r\nint InPolygon(const Polygon& polygon, Point point) \r\n{ \r\n	int n = polygon.size(); \r\n	int count = 0; \r\n	LineSegment line; \r\n	line.pt1 = point; \r\n	line.pt2.y = point.y; \r\n	line.pt2.x = - INFINITY; \r\n	\r\n	for( int i = 0; i < n; i++ ) { \r\n		// 得到多边形的一条边 \r\n		LineSegment side; \r\n		side.pt1 = polygon[i]; \r\n		side.pt2 = polygon[(i + 1) % n]; \r\n		\r\n		if( IsOnline(point, side) ) \r\n			return 0;\r\n		\r\n		// 如果side平行x轴则不作考虑 \r\n		if( fabs(side.pt1.y - side.pt2.y) < ESP ) \r\n			continue; \r\n		\r\n		if( IsOnline(side.pt1, line) ) { \r\n			if( side.pt1.y > side.pt2.y ) count++; \r\n		} \r\n		else if( IsOnline(side.pt2, line) ) { \r\n			if( side.pt2.y > side.pt1.y )    count++; \r\n		}\r\n		else if( Intersect(line, side) ) count++; \r\n	} \r\n	if ( count % 2 == 1 ) return 1;\r\n	else                  return -1;\r\n}\r\n\r\nint main()\r\n{\r\n	int n, m, i;\r\n	Point p;\r\n	Polygon po;\r\n	while(scanf("%d %d",&n,&m)){\r\n		po.clear();\r\n		for(i = 0; i < n; ++i){\r\n			scanf("%lf %lf",&p.x,&p.y);\r\n			po.push_back(p);\r\n		}\r\n		\r\n		while(m--){\r\n			scanf("%lf %lf",&p.x,&p.y);\r\n			printf("%d\\n",InPolygon(po,p));\r\n		}\r\n	}\r\n	return 0;\r\n}\r\n\r\n', 'Main.cpp:7:14: warning: new declaration ''const double __builtin_inf()''\r\nMain.cpp:7:14: warning: ambiguates built-in declaration ''double __builtin_inf()''\r\nMain.cpp:7:29: error: invalid pure specifier (only ''= 0'' is allowed) before '';'' token\r\nMain.cpp:7:29: error: function ''const double __builtin_inf()'' is initialized like a variable\r\n', 0, 0, 2, 2, '2010-11-11 09:11:08', '0001-01-01 00:00:00'),
(877, 35, 377, 6, '#include <stdio.h>\r\n#include <stdlib.h>\r\nint between(float u, float v, float w)\r\n{ float max,min;\r\n  max=(v>w)?v:w;\r\n  min=(v<w)?v:w;\r\n  return ((u<=max&&u>=min)?1:0);\r\n}\r\nint main()\r\n{ \r\n  int n,i,j,num;\r\n  float x1[３00],y1[３00],x2[３00],y2[３00],a[３00],b[３00],c[３00],jx,jy;\r\n  while(scanf("%d",&n)&&n!=0)\r\n  {   \r\n   num=0;    \r\n   for(i=0;i<n;++i)\r\n   { scanf("%f%f%f%f",&x1[i],&y1[i],&x2[i],&y2[i]);\r\n     if(x1[i]==x2[i])\r\n     { \r\n       a[i]=1;b[i]=0;c[i]=-x1[i];\r\n     }\r\n     else\r\n     { \r\n       a[i]=(y2[i]-y1[i])/(x1[i]-x2[i]);b[i]=1;\r\n       c[i]=(x1[i]*y2[i]-x2[i]*y1[i])/(x2[i]-x1[i]);\r\n     }\r\n   }\r\n   for(i=0;i<n;++i)\r\n   { \r\n      for(j=i+1;j<n;++j)\r\n      { \r\n         if(a[i]*b[j]-a[j]*b[i]!=0)\r\n        { \r\n          jx=(b[i]*c[j]-b[j]*c[i])/(a[i]*b[j]-a[j]*b[i]);\r\n          jy=(c[i]*a[j]-c[j]*a[i])/(a[i]*b[j]-a[j]*b[i]);\r\n          if(between(jx,x1[i],x2[i])&&between(jx,x1[j],x2[j])\r\n          &&between(jy,y1[i],y2[i])&&between(jy,y1[j],y2[j]))\r\n          num++;\r\n       }\r\n      }\r\n   }\r\n   printf("%d\\n",num);\r\n  }\r\n  return 0;\r\n} ', 'Main.cpp:12:3: error: stray ''\\357'' in program\r\nMain.cpp:12:3: error: stray ''\\274'' in program\r\nMain.cpp:12:3: error: stray ''\\223'' in program\r\nMain.cpp:12:3: error: stray ''\\357'' in program\r\nMain.cpp:12:3: error: stray ''\\274'' in program\r\nMain.cpp:12:3: error: stray ''\\223'' in program\r\nMain.cpp:12:3: error: stray ''\\357'' in program\r\nMain.cpp:12:3: error: stray ''\\274'' in program\r\nMain.cpp:12:3: error: stray ''\\223'' in program\r\nMain.cpp:12:3: error: stray ''\\357'' in program\r\nMain.cpp:12:3: error: stray ''\\', 0, 0, 2, 2, '2010-11-11 09:14:26', '0001-01-01 00:00:00'),
(878, 35, 377, 6, '#include <stdio.h>\r\n#include <stdlib.h>\r\nint between(float u, float v, float w)\r\n{ float max,min;\r\n  max=(v>w)?v:w;\r\n  min=(v<w)?v:w;\r\n  return ((u<=max&&u>=min)?1:0);\r\n}\r\nint main()\r\n{ \r\n  int n,i,j,num;\r\n  float x1[３00],y1[３00],x2[３00],y2[３00],a[３00],b[３00],c[３00],jx,jy;\r\n  while(scanf("%d",&n)&&n!=0)\r\n  {   \r\n   num=0;    \r\n   for(i=0;i<n;++i)\r\n   { scanf("%f%f%f%f",&x1[i],&y1[i],&x2[i],&y2[i]);\r\n     if(x1[i]==x2[i])\r\n     { \r\n       a[i]=1;b[i]=0;c[i]=-x1[i];\r\n     }\r\n     else\r\n     { \r\n       a[i]=(y2[i]-y1[i])/(x1[i]-x2[i]);b[i]=1;\r\n       c[i]=(x1[i]*y2[i]-x2[i]*y1[i])/(x2[i]-x1[i]);\r\n     }\r\n   }\r\n   for(i=0;i<n;++i)\r\n   { \r\n      for(j=i+1;j<n;++j)\r\n      { \r\n         if(a[i]*b[j]-a[j]*b[i]!=0)\r\n        { \r\n          jx=(b[i]*c[j]-b[j]*c[i])/(a[i]*b[j]-a[j]*b[i]);\r\n          jy=(c[i]*a[j]-c[j]*a[i])/(a[i]*b[j]-a[j]*b[i]);\r\n          if(between(jx,x1[i],x2[i])&&between(jx,x1[j],x2[j])\r\n          &&between(jy,y1[i],y2[i])&&between(jy,y1[j],y2[j]))\r\n          num++;\r\n       }\r\n      }\r\n   }\r\n   printf("%d\\n",num);\r\n  }\r\n  return 0;\r\n} ', 'Main.c: In function ''main'':\r\nMain.c:12:3: error: stray ''\\357'' in program\r\nMain.c:12:3: error: stray ''\\274'' in program\r\nMain.c:12:3: error: stray ''\\223'' in program\r\nMain.c:12:3: error: stray ''\\357'' in program\r\nMain.c:12:3: error: stray ''\\274'' in program\r\nMain.c:12:3: error: stray ''\\223'' in program\r\nMain.c:12:3: error: stray ''\\357'' in program\r\nMain.c:12:3: error: stray ''\\274'' in program\r\nMain.c:12:3: error: stray ''\\223'' in program\r\nMain.c:12:3: error: stray ''\\357'' in program\r\nMain.c:12:3: error: s', 0, 0, 2, 1, '2010-11-11 09:15:32', '0001-01-01 00:00:00'),
(879, 17, 377, 6, '#include<stdio.h>\r\n#include<iostream>\r\nusing namespace std;\r\n#define M 101\r\ndouble cal(double x1,double y1,double x2,double y2)\r\n{\r\n       double k;\r\n       k=(y2-y1)/(x2-x1);\r\n       return k;\r\n}\r\nint binarysear(double *a,double num,int len)\r\n{\r\n    int mid,start,end;\r\n    start=0;\r\n    end=len-1;\r\n    int count;\r\n    count=0;\r\n    while(start<=end){\r\n    mid=(start+end)/2;\r\n    if(a[mid]<num)\r\n    start=mid+1;\r\n    else if(a[mid]>num)\r\n    end=mid-1;\r\n    else {\r\n         count++;\r\n        }\r\n   }\r\n   return count;\r\n}        \r\nint main()\r\n{\r\n    int test;\r\n    int i,j;\r\n    double seg_x1[M];\r\n    double seg_y1[M];\r\n    double seg_x2[M];\r\n    double seg_y2[M];\r\n    double k[M];\r\n    int cou[M];\r\n    int count;\r\n    int max;\r\n    while(scanf("%d",&test)!=EOF)\r\n    { \r\n      max=0;\r\n      for(i=0;i<test;i++)\r\n        cin>>seg_x1[i]>>seg_y1[i]>>seg_x2[i]>>seg_y2[i];\r\n      for(i=0;i<test;i++){\r\n        k[i]=cal(seg_x1[i],seg_y1[i],seg_x2[i],seg_y2[i]);\r\n        }\r\n      for(i=0;i<test;i++)\r\n        cou[i]=binarysear(k,k[i],test);\r\n      for(i=0;i<test;i++)\r\n       if(max<=cou[i])\r\n         max=cou[i];\r\n      printf("%d\\n",test-max+1);\r\n      }\r\n      return 0;\r\n      }\r\n', '', 1000, 364544, 5, 2, '2010-11-11 09:16:27', '0001-01-01 00:00:00'),
(880, 35, 377, 6, '#include <stdio.h>\r\n#include <stdlib.h>\r\nint between(float u, float v, float w)\r\n{ float max,min;\r\n  max=(v>w)?v:w;\r\n  min=(v<w)?v:w;\r\n  return ((u<=max&&u>=min)?1:0);\r\n}\r\nint main()\r\n{ \r\n  int n,i,j,num;\r\n  float x1[300],y1[300],x2[300],y2[300],a[300],b[300],c[300],jx,jy;\r\n  while(scanf("%d",&n)&&n!=0&&n<=300)\r\n  {   \r\n   num=0;    \r\n   for(i=0;i<n;++i)\r\n   { scanf("%f%f%f%f",&x1[i],&y1[i],&x2[i],&y2[i]);\r\n     if(x1[i]==x2[i])\r\n     { \r\n       a[i]=1;b[i]=0;c[i]=-x1[i];\r\n     }\r\n     else\r\n     { \r\n       a[i]=(y2[i]-y1[i])/(x1[i]-x2[i]);b[i]=1;\r\n       c[i]=(x1[i]*y2[i]-x2[i]*y1[i])/(x2[i]-x1[i]);\r\n     }\r\n   }\r\n   for(i=0;i<n;++i)\r\n   { \r\n      for(j=i+1;j<n;++j)\r\n      { \r\n         if(a[i]*b[j]-a[j]*b[i]!=0)\r\n        { \r\n          jx=(b[i]*c[j]-b[j]*c[i])/(a[i]*b[j]-a[j]*b[i]);\r\n          jy=(c[i]*a[j]-c[j]*a[i])/(a[i]*b[j]-a[j]*b[i]);\r\n          if(between(jx,x1[i],x2[i])&&between(jx,x1[j],x2[j])\r\n          &&between(jy,y1[i],y2[i])&&between(jy,y1[j],y2[j]))\r\n          num++;\r\n       }\r\n      }\r\n   }\r\n   printf("%d\\n",num);\r\n  }\r\n  return 0;\r\n} ', '', 0, 262144, 4, 2, '2010-11-11 09:17:52', '0001-01-01 00:00:00');
INSERT INTO `tbl_submitions` (`id`, `user_id`, `problem_id`, `exercise_id`, `source`, `result`, `used_time`, `used_memory`, `status`, `compiler_id`, `created`, `modified`) VALUES
(881, 6, 378, 6, '#include <stdio.h>\r\n#include <iostream>\r\n#include <vector>\r\n#include <math.h>\r\n#include <algorithm>\r\nusing namespace std;\r\nconst double INFINITY = 1e9; \r\nconst double EPS = 1e-5; \r\nconst int MAX_N = 1000; \r\n/*template<class T> T& min(const T& a, const T& b){\r\n	return a<b?a:b;\r\n}\r\ntemplate<class T> T& max(const T& a, const T& b){\r\n	return a>b?a:b;\r\n}*/\r\nstruct Point { \r\n	double x, y;\r\n	Point(double a, double b):x(a),y(b){}\r\n	Point(){}\r\n}; \r\n\r\nstruct LineSegment { \r\n	Point pt1, pt2; \r\n	LineSegment(){}\r\n}; \r\ntypedef vector<Point> Polygon; \r\n\r\n// 计算叉乘 |P0P1| × |P0P2| \r\ndouble Multiply(Point p1, Point p2, Point p0) { \r\n	return ( (p1.x - p0.x) * (p2.y - p0.y) - (p2.x - p0.x) * (p1.y - p0.y) ); \r\n} \r\n\r\n// 判断线段是否包含点point \r\nbool IsOnline(Point point, LineSegment line) \r\n{ \r\n	return( ( fabs(Multiply(line.pt1, line.pt2, point)) < EPS ) && \r\n		  ( ( point.x - line.pt1.x ) * ( point.x - line.pt2.x ) <= 0 ) && \r\n		  ( ( point.y - line.pt1.y ) * ( point.y - line.pt2.y ) <= 0 ) ); \r\n} \r\n\r\n// 判断线段相交 \r\nbool Intersect(LineSegment L1, LineSegment L2) \r\n{ \r\n	return ( (max(L1.pt1.x, L1.pt2.x) >= min(L2.pt1.x, L2.pt2.x)) && \r\n		   (max(L2.pt1.x, L2.pt2.x) >= min(L1.pt1.x, L1.pt2.x)) && \r\n		   (max(L1.pt1.y, L1.pt2.y) >= min(L2.pt1.y, L2.pt2.y)) && \r\n		   (max(L2.pt1.y, L2.pt2.y) >= min(L1.pt1.y, L1.pt2.y)) && \r\n		   (Multiply(L2.pt1, L1.pt2, L1.pt1) * Multiply(L1.pt2, L2.pt2, L1.pt1) >= 0) && \r\n		   (Multiply(L1.pt1, L2.pt2, L2.pt1) * Multiply(L2.pt2, L1.pt2, L2.pt1) >= 0) \r\n		   ); \r\n} \r\n\r\n// 判断点在多边形内 \r\nint InPolygon(const Polygon& polygon, Point point) \r\n{ \r\n	int n = polygon.size(); \r\n	int count = 0; \r\n	LineSegment line; \r\n	line.pt1 = point; \r\n	line.pt2.y = point.y; \r\n	line.pt2.x = - INFINITY; \r\n	\r\n	for( int i = 0; i < n; i++ ) { \r\n		// 得到多边形的一条边 \r\n		LineSegment side; \r\n		side.pt1 = polygon[i]; \r\n		side.pt2 = polygon[(i + 1) % n]; \r\n		\r\n		if( IsOnline(point, side) ) \r\n			return 0;\r\n		\r\n		// 如果side平行x轴则不作考虑 \r\n		if( fabs(side.pt1.y - side.pt2.y) < EPS ) \r\n			continue; \r\n		\r\n		if( IsOnline(side.pt1, line) ) { \r\n			if( side.pt1.y > side.pt2.y ) count++; \r\n		} \r\n		else if( IsOnline(side.pt2, line) ) { \r\n			if( side.pt2.y > side.pt1.y )    count++; \r\n		}\r\n		else if( Intersect(line, side) ) count++; \r\n	} \r\n	if ( count % 2 == 1 ) return 1;\r\n	else                  return -1;\r\n}\r\n\r\nint main()\r\n{\r\n	int n, m, i;\r\n	double a, b;\r\n	Polygon po;\r\n	while(scanf("%d %d",&n,&m)){\r\n		po.clear();\r\n		for(i = 0; i < n; ++i){\r\n			scanf("%lf %lf",&a,&b);\r\n			Point p(a,b);\r\n			po.push_back(p);\r\n		}\r\n		\r\n		while(m--){\r\n		//	printf("1111\\n");\r\n			scanf("%lf %lf",&a,&b);\r\n			Point p(a,b);\r\n			printf("%d\\n",InPolygon(po,p));\r\n		}\r\n	}\r\n	return 0;\r\n}\r\n\r\n\r\n', 'Main.cpp:7:14: warning: new declaration ''const double __builtin_inf()''\r\nMain.cpp:7:14: warning: ambiguates built-in declaration ''double __builtin_inf()''\r\nMain.cpp:7:28: error: invalid pure specifier (only ''= 0'' is allowed) before '';'' token\r\nMain.cpp:7:28: error: function ''const double __builtin_inf()'' is initialized like a variable\r\n', 0, 0, 2, 2, '2010-11-11 09:20:49', '0001-01-01 00:00:00'),
(882, 6, 378, 6, '#include <stdio.h>\r\n#include <iostream>\r\n#include <vector>\r\n#include <math.h>\r\n#include <algorithm>\r\nusing namespace std;\r\nconst double INF = 1e9; \r\nconst double EPS = 1e-5; \r\nconst int MAX_N = 1000; \r\n/*template<class T> T& min(const T& a, const T& b){\r\n	return a<b?a:b;\r\n}\r\ntemplate<class T> T& max(const T& a, const T& b){\r\n	return a>b?a:b;\r\n}*/\r\nstruct Point { \r\n	double x, y;\r\n	Point(double a, double b):x(a),y(b){}\r\n	Point(){}\r\n}; \r\n\r\nstruct LineSegment { \r\n	Point pt1, pt2; \r\n	LineSegment(){}\r\n}; \r\ntypedef vector<Point> Polygon; \r\n\r\n// 计算叉乘 |P0P1| × |P0P2| \r\ndouble Multiply(Point p1, Point p2, Point p0) { \r\n	return ( (p1.x - p0.x) * (p2.y - p0.y) - (p2.x - p0.x) * (p1.y - p0.y) ); \r\n} \r\n\r\n// 判断线段是否包含点point \r\nbool IsOnline(Point point, LineSegment line) \r\n{ \r\n	return( ( fabs(Multiply(line.pt1, line.pt2, point)) < EPS ) && \r\n		  ( ( point.x - line.pt1.x ) * ( point.x - line.pt2.x ) <= 0 ) && \r\n		  ( ( point.y - line.pt1.y ) * ( point.y - line.pt2.y ) <= 0 ) ); \r\n} \r\n\r\n// 判断线段相交 \r\nbool Intersect(LineSegment L1, LineSegment L2) \r\n{ \r\n	return ( (max(L1.pt1.x, L1.pt2.x) >= min(L2.pt1.x, L2.pt2.x)) && \r\n		   (max(L2.pt1.x, L2.pt2.x) >= min(L1.pt1.x, L1.pt2.x)) && \r\n		   (max(L1.pt1.y, L1.pt2.y) >= min(L2.pt1.y, L2.pt2.y)) && \r\n		   (max(L2.pt1.y, L2.pt2.y) >= min(L1.pt1.y, L1.pt2.y)) && \r\n		   (Multiply(L2.pt1, L1.pt2, L1.pt1) * Multiply(L1.pt2, L2.pt2, L1.pt1) >= 0) && \r\n		   (Multiply(L1.pt1, L2.pt2, L2.pt1) * Multiply(L2.pt2, L1.pt2, L2.pt1) >= 0) \r\n		   ); \r\n} \r\n\r\n// 判断点在多边形内 \r\nint InPolygon(const Polygon& polygon, Point point) \r\n{ \r\n	int n = polygon.size(); \r\n	int count = 0; \r\n	LineSegment line; \r\n	line.pt1 = point; \r\n	line.pt2.y = point.y; \r\n	line.pt2.x = - INFINITY; \r\n	\r\n	for( int i = 0; i < n; i++ ) { \r\n		// 得到多边形的一条边 \r\n		LineSegment side; \r\n		side.pt1 = polygon[i]; \r\n		side.pt2 = polygon[(i + 1) % n]; \r\n		\r\n		if( IsOnline(point, side) ) \r\n			return 0;\r\n		\r\n		// 如果side平行x轴则不作考虑 \r\n		if( fabs(side.pt1.y - side.pt2.y) < EPS ) \r\n			continue; \r\n		\r\n		if( IsOnline(side.pt1, line) ) { \r\n			if( side.pt1.y > side.pt2.y ) count++; \r\n		} \r\n		else if( IsOnline(side.pt2, line) ) { \r\n			if( side.pt2.y > side.pt1.y )    count++; \r\n		}\r\n		else if( Intersect(line, side) ) count++; \r\n	} \r\n	if ( count % 2 == 1 ) return 1;\r\n	else                  return -1;\r\n}\r\n\r\nint main()\r\n{\r\n	int n, m, i;\r\n	double a, b;\r\n	Polygon po;\r\n	while(scanf("%d %d",&n,&m)){\r\n		po.clear();\r\n		for(i = 0; i < n; ++i){\r\n			scanf("%lf %lf",&a,&b);\r\n			Point p(a,b);\r\n			po.push_back(p);\r\n		}\r\n		\r\n		while(m--){\r\n		//	printf("1111\\n");\r\n			scanf("%lf %lf",&a,&b);\r\n			Point p(a,b);\r\n			printf("%d\\n",InPolygon(po,p));\r\n		}\r\n	}\r\n	return 0;\r\n}\r\n\r\n\r\n', '', 1000, 368640, 5, 2, '2010-11-11 09:22:23', '0001-01-01 00:00:00'),
(883, 6, 378, 6, '#include <stdio.h>\r\n#include <iostream>\r\n#include <vector>\r\n#include <math.h>\r\n#include <algorithm>\r\nusing namespace std;\r\nconst double INF = 1e9; \r\nconst double EPS = 1e-5; \r\nconst int MAX_N = 1000; \r\nconst int M = 350;\r\n/*template<class T> T& min(const T& a, const T& b){\r\n	return a<b?a:b;\r\n}\r\ntemplate<class T> T& max(const T& a, const T& b){\r\n	return a>b?a:b;\r\n}*/\r\nstruct Point { \r\n	double x, y;\r\n}po[M]; \r\n\r\nstruct LineSegment { \r\n	Point pt1, pt2; \r\n}; \r\n\r\n\r\n// 计算叉乘 |P0P1| × |P0P2| \r\ndouble Multiply(Point p1, Point p2, Point p0) { \r\n	return ( (p1.x - p0.x) * (p2.y - p0.y) - (p2.x - p0.x) * (p1.y - p0.y) ); \r\n} \r\n\r\n// 判断线段是否包含点point \r\nbool IsOnline(Point point, LineSegment line) \r\n{ \r\n	return( ( fabs(Multiply(line.pt1, line.pt2, point)) < EPS ) && \r\n		  ( ( point.x - line.pt1.x ) * ( point.x - line.pt2.x ) <= 0 ) && \r\n		  ( ( point.y - line.pt1.y ) * ( point.y - line.pt2.y ) <= 0 ) ); \r\n} \r\n\r\n// 判断线段相交 \r\nbool Intersect(LineSegment L1, LineSegment L2) \r\n{ \r\n	return ( (max(L1.pt1.x, L1.pt2.x) >= min(L2.pt1.x, L2.pt2.x)) && \r\n		   (max(L2.pt1.x, L2.pt2.x) >= min(L1.pt1.x, L1.pt2.x)) && \r\n		   (max(L1.pt1.y, L1.pt2.y) >= min(L2.pt1.y, L2.pt2.y)) && \r\n		   (max(L2.pt1.y, L2.pt2.y) >= min(L1.pt1.y, L1.pt2.y)) && \r\n		   (Multiply(L2.pt1, L1.pt2, L1.pt1) * Multiply(L1.pt2, L2.pt2, L1.pt1) >= 0) && \r\n		   (Multiply(L1.pt1, L2.pt2, L2.pt1) * Multiply(L2.pt2, L1.pt2, L2.pt1) >= 0) \r\n		   ); \r\n} \r\n\r\n// 判断点在多边形内 \r\nint InPolygon(Point point,int n) \r\n{ \r\n	int count = 0; \r\n	LineSegment line; \r\n	line.pt1 = point; \r\n	line.pt2.y = point.y; \r\n	line.pt2.x = - INF; \r\n	\r\n	for( int i = 0; i < n; i++ ) { \r\n		// 得到多边形的一条边 \r\n		LineSegment side; \r\n		side.pt1 = po[i]; \r\n		side.pt2 = po[(i + 1) % n]; \r\n		\r\n		if( IsOnline(point, side) ) \r\n			return 0;\r\n		\r\n		// 如果side平行x轴则不作考虑 \r\n		if( fabs(side.pt1.y - side.pt2.y) < EPS ) \r\n			continue; \r\n		\r\n		if( IsOnline(side.pt1, line) ) { \r\n			if( side.pt1.y > side.pt2.y ) count++; \r\n		} \r\n		else if( IsOnline(side.pt2, line) ) { \r\n			if( side.pt2.y > side.pt1.y )    count++; \r\n		}\r\n		else if( Intersect(line, side) ) count++; \r\n	} \r\n	if ( count % 2 == 1 ) return 1;\r\n	else                  return -1;\r\n}\r\n\r\nint main()\r\n{\r\n	int n, m, i, j, len;\r\n	Point p;\r\n	while(scanf("%d %d",&n,&m)){\r\n		j = 0;\r\n		for(i = 0; i < n; ++i){\r\n			scanf("%lf %lf",&p.x,&p.y);\r\n			po[j++] = p;\r\n		}\r\n		len = j;\r\n		\r\n		while(m--){\r\n			scanf("%lf %lf",&p.x,&p.y);\r\n			printf("%d\\n",InPolygon(p,len));\r\n		}\r\n	}\r\n	return 0;\r\n}\r\n\r\n\r\n', '', 1000, 376832, 5, 2, '2010-11-11 09:27:34', '0001-01-01 00:00:00'),
(884, 6, 378, 6, '#include <stdio.h>\r\n#include <math.h>\r\n#include <algorithm>\r\nusing namespace std;\r\nconst double INF = 1e9; \r\nconst double EPS = 1e-5; \r\nconst int MAX_N = 1000; \r\nconst int M = 350;\r\n/*template<class T> T& min(const T& a, const T& b){\r\n	return a<b?a:b;\r\n}\r\ntemplate<class T> T& max(const T& a, const T& b){\r\n	return a>b?a:b;\r\n}*/\r\nstruct Point { \r\n	double x, y;\r\n}po[M]; \r\n\r\nstruct LineSegment { \r\n	Point pt1, pt2; \r\n}; \r\n\r\n\r\n// 计算叉乘 |P0P1| × |P0P2| \r\ndouble Multiply(Point p1, Point p2, Point p0) { \r\n	return ( (p1.x - p0.x) * (p2.y - p0.y) - (p2.x - p0.x) * (p1.y - p0.y) ); \r\n} \r\n\r\n// 判断线段是否包含点point \r\nbool IsOnline(Point point, LineSegment line) \r\n{ \r\n	return( ( fabs(Multiply(line.pt1, line.pt2, point)) < EPS ) && \r\n		  ( ( point.x - line.pt1.x ) * ( point.x - line.pt2.x ) <= 0 ) && \r\n		  ( ( point.y - line.pt1.y ) * ( point.y - line.pt2.y ) <= 0 ) ); \r\n} \r\n\r\n// 判断线段相交 \r\nbool Intersect(LineSegment L1, LineSegment L2) \r\n{ \r\n	return ( (max(L1.pt1.x, L1.pt2.x) >= min(L2.pt1.x, L2.pt2.x)) && \r\n		   (max(L2.pt1.x, L2.pt2.x) >= min(L1.pt1.x, L1.pt2.x)) && \r\n		   (max(L1.pt1.y, L1.pt2.y) >= min(L2.pt1.y, L2.pt2.y)) && \r\n		   (max(L2.pt1.y, L2.pt2.y) >= min(L1.pt1.y, L1.pt2.y)) && \r\n		   (Multiply(L2.pt1, L1.pt2, L1.pt1) * Multiply(L1.pt2, L2.pt2, L1.pt1) >= 0) && \r\n		   (Multiply(L1.pt1, L2.pt2, L2.pt1) * Multiply(L2.pt2, L1.pt2, L2.pt1) >= 0) \r\n		   ); \r\n} \r\n\r\n// 判断点在多边形内 \r\nint InPolygon(Point point,int n) \r\n{ \r\n	int count = 0; \r\n	LineSegment line; \r\n	line.pt1 = point; \r\n	line.pt2.y = point.y; \r\n	line.pt2.x = - INF; \r\n	\r\n	for( int i = 0; i < n; i++ ) { \r\n		// 得到多边形的一条边 \r\n		LineSegment side; \r\n		side.pt1 = po[i]; \r\n		side.pt2 = po[(i + 1) % n]; \r\n		\r\n		if( IsOnline(point, side) ) \r\n			return 0;\r\n		\r\n		// 如果side平行x轴则不作考虑 \r\n		if( fabs(side.pt1.y - side.pt2.y) < EPS ) \r\n			continue; \r\n		\r\n		if( IsOnline(side.pt1, line) ) { \r\n			if( side.pt1.y > side.pt2.y ) count++; \r\n		} \r\n		else if( IsOnline(side.pt2, line) ) { \r\n			if( side.pt2.y > side.pt1.y )    count++; \r\n		}\r\n		else if( Intersect(line, side) ) count++; \r\n	} \r\n	if ( count % 2 == 1 ) return 1;\r\n	else                  return -1;\r\n}\r\n\r\nint main()\r\n{\r\n	int n, m, i, j, len;\r\n	Point p;\r\n	while(scanf("%d %d",&n,&m)!=EOF){\r\n		j = 0;\r\n		for(i = 0; i < n; ++i){\r\n			scanf("%lf %lf",&p.x,&p.y);\r\n			po[j++] = p;\r\n		}\r\n		len = j;\r\n		\r\n		while(m--){\r\n			scanf("%lf %lf",&p.x,&p.y);\r\n			printf("%d\\n",InPolygon(p,len));\r\n		}\r\n	}\r\n	return 0;\r\n}', '', 0, 266240, 4, 2, '2010-11-11 09:29:20', '0001-01-01 00:00:00'),
(885, 21, 377, 6, '#include<stdio.h>\r\nint between(float u, float v, float w)\r\n{ float max,min;\r\n  max=(v>w)?v:w;\r\n  min=(v<w)?v:w;\r\n  return ((u<=max&&u>=min)?1:0);\r\n}\r\nint main()\r\n{ \r\n  int n,i,j,num;\r\n  float x1[100],y1[100],x2[100],y2[100],a[100],b[100],c[100],jx,jy,x[5000],y[5000];\r\n  while(scanf("%d",&n)&&n!=0)\r\n  {   \r\n   num=0;    \r\n   for(i=0;i<n;++i)\r\n   { scanf("%f%f%f%f",&x1[i],&y1[i],&x2[i],&y2[i]);\r\n     if(x1[i]==x2[i])\r\n     { \r\n       a[i]=1;b[i]=0;c[i]=-x1[i];\r\n     }\r\n     else\r\n     { \r\n       a[i]=(y2[i]-y1[i])/(x1[i]-x2[i]);\r\n	   b[i]=1;\r\n       c[i]=(x1[i]*y2[i]-x2[i]*y1[i])/(x2[i]-x1[i]);\r\n     }\r\n   }\r\n   for(i=0;i<n;++i)\r\n   { \r\n      for(j=i+1;j<n;++j)\r\n      { \r\n         if(a[i]*b[j]-a[j]*b[i]!=0)\r\n        { \r\n          jx=(b[i]*c[j]-b[j]*c[i])/(a[i]*b[j]-a[j]*b[i]);\r\n          jy=(c[i]*a[j]-c[j]*a[i])/(a[i]*b[j]-a[j]*b[i]);\r\n\r\n		  if(num==0){if(between(jx,x1[i],x2[i])&&between(jx,x1[j],x2[j])&&between(jy,y1[i],y2[i])&&between(jy,y1[j],y2[j]))\r\n						 {x[num]=jx;y[num]=jy;num++;}\r\n					}\r\n		  else{\r\n			  for(int v=0;v<=num-1;v++){\r\n				if(jx!=x[v]||jy!=y[v])\r\n					{\r\n					if(between(jx,x1[i],x2[i])&&between(jx,x1[j],x2[j])&&between(jy,y1[i],y2[i])&&between(jy,y1[j],y2[j]))\r\n					{	x[num]=jx;y[num]=jy;num++;}}\r\n					}\r\n				}\r\n       }\r\n      }\r\n   }\r\n   printf("%d\\n",num);\r\n  }\r\n  return 0;\r\n}\r\n', 'Main.c: In function ''main'':\r\nMain.c:41:6: error: ''for'' loop initial declarations are only allowed in C99 mode\r\nMain.c:41:6: note: use option -std=c99 or -std=gnu99 to compile your code\r\n', 0, 0, 2, 1, '2010-11-11 09:31:35', '0001-01-01 00:00:00'),
(886, 30, 377, 6, '#include < stdio.h >\r\n#include <math.h>\r\n\r\nint main()\r\n{\r\n	int n,i,j,sum;\r\n	double xielv[101],p[5];\r\n	while(scanf("%d",&n)&&n)\r\n	{\r\n		sum = n*(n-1)/2;\r\n		for( i = 0;i < n;i++)\r\n		{ \r\n			scanf("%lf %lf %lf %lf",p,p+1,p+2,p+3);\r\n			if( p[1] != p[3])\r\n				xielv[i]=(p[0]-p[2])/(p[1]-p[3]);\r\n			else\r\n				xielv[i] = pow( 2, 32 )-1;\r\n			for( j = 0;j < i-1;j++)\r\n				if( xielv[i] == xielv[j] )\r\n					sum--;\r\n		}\r\n		printf("%d\\n",sum);\r\n	}\r\n	return 0;\r\n}\r\n\r\n', 'Main.cpp:1:21: fatal error:  stdio.h : No such file or directory\r\ncompilation terminated.\r\n', 0, 0, 2, 2, '2010-11-11 09:35:12', '0001-01-01 00:00:00'),
(887, 30, 377, 6, '#include <stdio.h>\r\n#include <math.h>\r\n\r\nint main()\r\n{\r\n	int n,i,j,sum;\r\n	double xielv[101],p[5];\r\n	while(scanf("%d",&n)&&n)\r\n	{\r\n		sum = n*(n-1)/2;\r\n		for( i = 0;i < n;i++)\r\n		{ \r\n			scanf("%lf %lf %lf %lf",p,p+1,p+2,p+3);\r\n			if( p[1] != p[3])\r\n				xielv[i]=(p[0]-p[2])/(p[1]-p[3]);\r\n			else\r\n				xielv[i] = pow( 2, 32 )-1;\r\n			for( j = 0;j < i-1;j++)\r\n				if( xielv[i] == xielv[j] )\r\n					sum--;\r\n		}\r\n		printf("%d\\n",sum);\r\n	}\r\n	return 0;\r\n}', '', 15, 258048, 4, 2, '2010-11-11 09:36:32', '0001-01-01 00:00:00'),
(888, 14, 376, 5, '#include<limits.h>\r\n#include<stdio.h>\r\nint num[50001];\r\n\r\nint productBef_i[50001];\r\nint productAft_i[50001];\r\n\r\n\r\nint main()\r\n{\r\n	int n;\r\n	while( scanf("%d",&n) == 1)\r\n	{\r\n		int max=INT_MIN, i,temp;\r\n\r\n		for(i=0;i<n;++i)\r\n			scanf("%d",&num[i]);\r\n\r\n		productBef_i[0]= 1;\r\n		for (i=1; i < n; ++i) {\r\n            productBef_i[i] = productBef_i[i - 1] * num[i-1] ;\r\n        }\r\n\r\n        productAft_i[n-1] = 1;\r\n\r\n		for (i=n-2; i>=0; --i) {\r\n            productAft_i[i] = productAft_i[i + 1] * num[i+1] ;\r\n        }\r\n		\r\n		for (i = 0; i < n; ++i) \r\n		{\r\n            temp = productBef_i[i] * productAft_i[i];\r\n			if (temp > max) {\r\n                max = temp;\r\n            }\r\n        }\r\n\r\n		printf("%d\\n",max);\r\n\r\n\r\n	}\r\n\r\n\r\n\r\n	return 0;\r\n}', '', 62, 856064, 4, 1, '2010-11-11 09:39:44', '0001-01-01 00:00:00'),
(889, 6, 378, 6, '#include <stdio.h>\r\n#include <math.h>\r\n//#include <vector>\r\n#include <algorithm>\r\nusing namespace std;\r\nconst double INF = 1e9; \r\nconst double EPS = 1e-6; \r\nconst int MAX_N = 1000; \r\nconst int M = 350;\r\n/*template<class T> T& min(const T& a, const T& b){\r\n	return a<b?a:b;\r\n}\r\ntemplate<class T> T& max(const T& a, const T& b){\r\n	return a>b?a:b;\r\n}*/\r\nstruct Point { \r\n	double x, y;\r\n}po[M]; \r\n\r\nstruct LineSegment { \r\n	Point pt1, pt2; \r\n}; \r\n\r\n\r\n// 计算叉乘 |P0P1| × |P0P2| \r\ndouble Multiply(Point p1, Point p2, Point p0) { \r\n	return ( (p1.x - p0.x) * (p2.y - p0.y) - (p2.x - p0.x) * (p1.y - p0.y) ); \r\n} \r\n\r\n// 判断线段是否包含点point \r\nbool IsOnline(Point point, LineSegment line) \r\n{ \r\n	return( ( fabs(Multiply(line.pt1, line.pt2, point)) < EPS ) && \r\n		  ( ( point.x - line.pt1.x ) * ( point.x - line.pt2.x ) <= 0 ) && \r\n		  ( ( point.y - line.pt1.y ) * ( point.y - line.pt2.y ) <= 0 ) ); \r\n} \r\n\r\n// 判断线段相交 \r\nbool Intersect(LineSegment L1, LineSegment L2) \r\n{ \r\n	return ( (max(L1.pt1.x, L1.pt2.x) >= min(L2.pt1.x, L2.pt2.x)) && \r\n		   (max(L2.pt1.x, L2.pt2.x) >= min(L1.pt1.x, L1.pt2.x)) && \r\n		   (max(L1.pt1.y, L1.pt2.y) >= min(L2.pt1.y, L2.pt2.y)) && \r\n		   (max(L2.pt1.y, L2.pt2.y) >= min(L1.pt1.y, L1.pt2.y)) && \r\n		   (Multiply(L2.pt1, L1.pt2, L1.pt1) * Multiply(L1.pt2, L2.pt2, L1.pt1) >= 0) && \r\n		   (Multiply(L1.pt1, L2.pt2, L2.pt1) * Multiply(L2.pt2, L1.pt2, L2.pt1) >= 0) \r\n		   ); \r\n} \r\n\r\n// 判断点在多边形内 \r\nint InPolygon(Point point,int n) \r\n{ \r\n	int count = 0; \r\n	LineSegment line; \r\n	line.pt1 = point; \r\n	line.pt2.y = point.y; \r\n	line.pt2.x = - INF; \r\n	\r\n	for( int i = 0; i < n; i++ ) { \r\n		// 得到多边形的一条边 \r\n		LineSegment side; \r\n		side.pt1 = po[i]; \r\n		side.pt2 = po[(i + 1) % n]; \r\n		\r\n		if( IsOnline(point, side) ) \r\n			return 0;\r\n		\r\n		// 如果side平行x轴则不作考虑 \r\n		if( fabs(side.pt1.y - side.pt2.y) < EPS ) \r\n			continue; \r\n		\r\n		if( IsOnline(side.pt1, line) ) count++; \r\n		if( IsOnline(side.pt2, line) ) count++; \r\n		if( Intersect(line, side) ) count++; \r\n	} \r\n	if ( count % 2 == 1 ) return 1;\r\n	else                  return -1;\r\n}\r\n\r\nint main()\r\n{\r\n	int n, m, i, j, len;\r\n	Point p;\r\n	while(scanf("%d %d",&n,&m)!=EOF){\r\n		j = 0;\r\n		for(i = 0; i < n; ++i){\r\n			scanf("%lf %lf",&p.x,&p.y);\r\n			po[j++] = p;\r\n		}\r\n		len = j;\r\n		\r\n		while(m--){\r\n			scanf("%lf %lf",&p.x,&p.y);\r\n			printf("%d\\n",InPolygon(p,len));\r\n		}\r\n	}\r\n	return 0;\r\n}', '', 0, 266240, 1, 2, '2010-11-11 09:39:48', '0001-01-01 00:00:00'),
(890, 30, 377, 6, '#include <stdio.h>\r\n#include <math.h>\r\n\r\nint main()\r\n{\r\n	int n,i,j,sum;\r\n	double xielv[101],p[5];\r\n	while(scanf("%d",&n)&&n)\r\n	{\r\n		sum = n*(n-1)/2;\r\n		for( i = 0;i < n;i++)\r\n		{ \r\n			scanf("%lf %lf %lf %lf",p,p+1,p+2,p+3);\r\n			if( p[1] != p[3])\r\n				xielv[i]=(p[0]-p[2])/(p[1]-p[3]);\r\n			else\r\n				xielv[i] = pow( 2, 32 )-1;\r\n			for( j = 0;j < i;j++)\r\n				if( xielv[i] == xielv[j] )\r\n					sum--;\r\n		}\r\n		printf("%d\\n",sum);\r\n	}\r\n	return 0;\r\n}', '', 0, 262144, 4, 2, '2010-11-11 09:41:40', '0001-01-01 00:00:00'),
(891, 21, 377, 6, '#include<stdio.h>\r\nint between(float u, float v, float w)\r\n{ float max,min;\r\n  max=(v>w)?v:w;\r\n  min=(v<w)?v:w;\r\n  return ((u<=max&&u>=min)?1:0);\r\n}\r\nint main()\r\n{ \r\n  int n,i,j,num;\r\n  float x1[100],y1[100],x2[100],y2[100],a[100],b[100],c[100],jx,jy,x[5000],y[5000];\r\n  while(scanf("%d",&n)&&n!=0)\r\n  {   \r\n   num=0;    \r\n   for(i=0;i<n;++i)\r\n   { scanf("%f%f%f%f",&x1[i],&y1[i],&x2[i],&y2[i]);\r\n     if(x1[i]==x2[i])\r\n     { \r\n       a[i]=1;b[i]=0;c[i]=-x1[i];\r\n     }\r\n     else\r\n     { \r\n       a[i]=(y2[i]-y1[i])/(x1[i]-x2[i]);\r\n	   b[i]=1;\r\n       c[i]=(x1[i]*y2[i]-x2[i]*y1[i])/(x2[i]-x1[i]);\r\n     }\r\n   }\r\n   for(i=0;i<n;++i)\r\n   { \r\n      for(j=i+1;j<n;++j)\r\n      { \r\n         if(a[i]*b[j]-a[j]*b[i]!=0)\r\n        { \r\n          jx=(b[i]*c[j]-b[j]*c[i])/(a[i]*b[j]-a[j]*b[i]);\r\n          jy=(c[i]*a[j]-c[j]*a[i])/(a[i]*b[j]-a[j]*b[i]);\r\n		  if(between(jx,x1[i],x2[i])&&between(jx,x1[j],x2[j])&&between(jy,y1[i],y2[i])&&between(jy,y1[j],y2[j]))\r\n		  {\r\n			 if(num==0){x[num]=jx;y[num]=jy;num++;}\r\n			 else{\r\n			  for(int v=0;v<=num-1;v++){\r\n				if(jx!=x[v]||jy!=y[v])	{x[num]=jx;y[num]=jy;num++;}\r\n				}\r\n			 }\r\n		  }\r\n	\r\n		 }\r\n      }\r\n   }\r\n   printf("%d\\n",num);\r\n  }\r\n  return 0;\r\n}\r\n', 'Main.c: In function ''main'':\r\nMain.c:40:6: error: ''for'' loop initial declarations are only allowed in C99 mode\r\nMain.c:40:6: note: use option -std=c99 or -std=gnu99 to compile your code\r\n', 0, 0, 2, 1, '2010-11-11 09:46:35', '0001-01-01 00:00:00'),
(892, 14, 376, 5, '#include<limits.h>\r\n#include<stdio.h>\r\nint num[50001];\r\n\r\n__int64  productBef_i[50001];\r\n__int64  productAft_i[50001];\r\n\r\n\r\nint main()\r\n{\r\n	int n;\r\n	while( scanf("%d",&n) == 1)\r\n	{\r\n		__int64 max=INT_MIN,temp;\r\n		int i;\r\n\r\n		for(i=0;i<n;++i)\r\n			scanf("%d",&num[i]);\r\n\r\n		productBef_i[0]= 1;\r\n		for (i=1; i < n; ++i) {\r\n            productBef_i[i] = productBef_i[i - 1] * num[i-1] ;\r\n        }\r\n\r\n        productAft_i[n-1] = 1;\r\n\r\n		for (i=n-2; i>=0; --i) {\r\n            productAft_i[i] = productAft_i[i + 1] * num[i+1] ;\r\n        }\r\n		\r\n		for (i = 0; i < n; ++i) \r\n		{\r\n            temp = productBef_i[i] * productAft_i[i];\r\n			if (temp > max) {\r\n                max = temp;\r\n            }\r\n        }\r\n\r\n		printf("%I64d\\n",max);\r\n\r\n\r\n	}\r\n\r\n\r\n\r\n	return 0;\r\n}', '', 78, 1261568, 4, 1, '2010-11-11 09:54:33', '0001-01-01 00:00:00'),
(893, 20, 377, 6, '#include <stdio.h>\r\n#include <stdlib.h>\r\nint com(float u, float v, float w)\r\n{\r\n	float max,min;\r\n	max=(v>w)?v:w;\r\n	min=(v<w)?v:w;\r\n	if(u<=max&&u>=min)\r\n		return 1;\r\n	else\r\n		return 0;\r\n}\r\nint main()\r\n{ \r\n	int n,i,j,num;\r\n	float x1[50],y1[50],x2[50],y2[50],a[50],b[50],c[50]; //a[]为斜率，b[]为\r\n	float Tx,Ty;\r\n	while(scanf("%d",&n)&&n!=0)\r\n	{   \r\n		num=0;    \r\n		for(i=0;i<n;++i)\r\n		{ \r\n			scanf("%f%f%f%f",&x1[i],&y1[i],&x2[i],&y2[i]);\r\n			if(x1[i]==x2[i])\r\n			{ \r\n				a[i]=1;b[i]=0;c[i]=-x1[i];\r\n			}\r\n			else\r\n			{ \r\n				a[i]=(y2[i]-y1[i])/(x1[i]-x2[i]);b[i]=1; \r\n				c[i]=(x1[i]*y2[i]-x2[i]*y1[i])/(x2[i]-x1[i]);\r\n			}\r\n		}\r\n		for(i=0;i<n;++i)\r\n		{ \r\n			for(j=i+1;j<n;++j)\r\n			{ \r\n				if(a[i]*b[j]-a[j]*b[i]!=0)\r\n				{ \r\n					Tx=(b[i]*c[j]-b[j]*c[i])/(a[i]*b[j]-a[j]*b[i]);\r\n					Ty=(c[i]*a[j]-c[j]*a[i])/(a[i]*b[j]-a[j]*b[i]);\r\n					if(com(Tx,x1[i],x2[i])&&com(Tx,x1[j],x2[j])&&com(Ty,y1[i],y2[i])&&com(Ty,y1[j],y2[j]))\r\n					num++;\r\n				}\r\n			}\r\n		}\r\n		printf("%d\\n",num);\r\n	}\r\n	return 0;\r\n} ', '', 0, 258048, 4, 1, '2010-11-11 09:54:36', '0001-01-01 00:00:00'),
(894, 14, 376, 5, '#include<limits.h>\r\n#include<stdio.h>\r\n__int64 num[50001];\r\n\r\n__int64  productBef_i[50001];\r\n__int64  productAft_i[50001];\r\n\r\n\r\nint main()\r\n{\r\n	int n;\r\n	while( scanf("%d",&n) == 1)\r\n	{\r\n		__int64 max=INT_MIN,temp;\r\n		int i;\r\n\r\n		for(i=0;i<n;++i)\r\n			scanf("%I64d",&num[i]);\r\n\r\n		productBef_i[0]= 1;\r\n		for (i=1; i < n; ++i) {\r\n            productBef_i[i] = productBef_i[i - 1] * num[i-1] ;\r\n        }\r\n\r\n        productAft_i[n-1] = 1;\r\n\r\n		for (i=n-2; i>=0; --i) {\r\n            productAft_i[i] = productAft_i[i + 1] * num[i+1] ;\r\n        }\r\n		\r\n		for (i = 0; i < n; ++i) \r\n		{\r\n            temp = productBef_i[i] * productAft_i[i];\r\n			if (temp > max) {\r\n                max = temp;\r\n            }\r\n        }\r\n\r\n		printf("%I64d\\n",max);\r\n\r\n\r\n	}\r\n\r\n\r\n\r\n	return 0;\r\n}', '', 78, 1458176, 4, 1, '2010-11-11 09:55:18', '0001-01-01 00:00:00'),
(895, 17, 376, 5, '#include<stdio.h>\r\n#include<stdlib.h>\r\n#define M 50001\r\nvoid max(__int64 * arr, __int64 len) \r\n{ \r\n     __int64  left[M];  \r\n     __int64  right[M]; \r\n     __int64  p[M]; \r\n     __int64  i;\r\n     __int64  max_num;\r\n     left[0] = 1; \r\n     right[len] = 1; \r\n     \r\n     for( i=1;i<=len;i++) \r\n     { \r\n        left[i] = left[i-1] * arr[i-1]; \r\n        right[len-i] = right[len-i+1] * arr[len-i]; \r\n     } \r\n     max_num = left[0] * right[1]; \r\n    \r\n     for( i=1;i<len;i++) \r\n     { \r\n        p[i] = left[i] * right[i+1]; \r\n        if(p[i] > max_num) \r\n	            max_num = p[i]; \r\n	    } \r\n	     printf("%I64d\\n", max_num); \r\n	} \r\nint main()\r\n{\r\n    __int64 n;\r\n    __int64 i;\r\n    __int64 num[M];\r\n    while(scanf("%I64d",&n)!=EOF)\r\n    {  \r\n       for(i=0;i<n;i++)\r\n         scanf("%I64d",num+i);\r\n      max(num,n);\r\n     }\r\n       return 0;\r\n    }\r\n\r\n', '', 93, 1826816, 1, 1, '2010-11-11 09:57:48', '0001-01-01 00:00:00'),
(896, 27, 377, 6, '#include <stdio.h>\r\ndouble x1[300],x2[300],y1[300],y2[300];\r\n\r\nint judge(int i,int j)\r\n{\r\n	double a,b;\r\n	a=(x2[j]-x2[i])*(y1[i]-x1[i])-(x1[j]-x1[i])*(y2[i]-x2[i]);\r\n	b=(y2[j]-x2[i])*(y1[i]-x1[i])-(y1[j]-x1[i])*(y2[i]-x2[i]);\r\n	if( a*b<=0.0 ) return 1;\r\n	else return 0;\r\n}\r\n\r\nint judge_intersete(int i,int j)\r\n{\r\n	if(judge(i,j)==1 && judge(j,i)==1)\r\n		return 1;\r\n	else return 0;\r\n}\r\n\r\nint main()\r\n{\r\n	int n,i,count;\r\n	while(scanf("%d",&n) && n>0){	\r\n		count=0;\r\n		for(i=0;i<n;++i){\r\n			scanf("%lf %lf %lf %lf",&x1[i],&x2[i],&y1[i],&y2[i]);\r\n		}\r\n		for(i=0;i<n-1;++i){\r\n			for(int j=i+1;j<n;++j){\r\n				count+=judge_intersete(i,j);\r\n			}\r\n		}\r\n		printf("%d\\n",count);\r\n\r\n	}\r\n	return 0;\r\n}', 'Main.c:2:24: warning: built-in function ''y1'' declared as non-function\r\nMain.c: In function ''main'':\r\nMain.c:29:4: error: ''for'' loop initial declarations are only allowed in C99 mode\r\nMain.c:29:4: note: use option -std=c99 or -std=gnu99 to compile your code\r\n', 0, 0, 2, 1, '2010-11-11 09:58:19', '0001-01-01 00:00:00'),
(897, 27, 377, 6, '#include <stdio.h>\r\ndouble x1[300],x2[300],y1[300],y2[300];\r\n\r\nint judge(int i,int j)\r\n{\r\n	double a,b;\r\n	a=(x2[j]-x2[i])*(y1[i]-x1[i])-(x1[j]-x1[i])*(y2[i]-x2[i]);\r\n	b=(y2[j]-x2[i])*(y1[i]-x1[i])-(y1[j]-x1[i])*(y2[i]-x2[i]);\r\n	if( a*b<=0.0 ) return 1;\r\n	else return 0;\r\n}\r\n\r\nint judge_intersete(int i,int j)\r\n{\r\n	if(judge(i,j)==1 && judge(j,i)==1)\r\n		return 1;\r\n	else return 0;\r\n}\r\n\r\nint main()\r\n{\r\n	int n,i,count;\r\n	while(scanf("%d",&n) && n>0){	\r\n		count=0;\r\n		for(i=0;i<n;++i){\r\n			scanf("%lf %lf %lf %lf",&x1[i],&x2[i],&y1[i],&y2[i]);\r\n		}\r\n		for(i=0;i<n-1;++i){\r\n			for(int j=i+1;j<n;++j){\r\n				count+=judge_intersete(i,j);\r\n			}\r\n		}\r\n		printf("%d\\n",count);\r\n\r\n	}\r\n	return 0;\r\n}', 'Main.c:2:24: warning: built-in function ''y1'' declared as non-function\r\nMain.c: In function ''main'':\r\nMain.c:29:4: error: ''for'' loop initial declarations are only allowed in C99 mode\r\nMain.c:29:4: note: use option -std=c99 or -std=gnu99 to compile your code\r\n', 0, 0, 2, 1, '2010-11-11 10:00:41', '0001-01-01 00:00:00'),
(898, 27, 377, 6, '#include <stdio.h>\r\ndouble x1[300],x2[300],y1[300],y2[300];\r\n\r\nint judge(int i,int j)\r\n{\r\n	double a,b;\r\n	a=(x2[j]-x2[i])*(y1[i]-x1[i])-(x1[j]-x1[i])*(y2[i]-x2[i]);\r\n	b=(y2[j]-x2[i])*(y1[i]-x1[i])-(y1[j]-x1[i])*(y2[i]-x2[i]);\r\n	if( a*b<=0.0 ) return 1;\r\n	else return 0;\r\n}\r\n\r\nint judge_intersete(int i,int j)\r\n{\r\n	if(judge(i,j)==1 && judge(j,i)==1)\r\n		return 1;\r\n	else return 0;\r\n}\r\n\r\nint main()\r\n{\r\n	int n,i,j,count;\r\n	while(scanf("%d",&n) && n>0){	\r\n		count=0;\r\n		for(i=0;i<n;++i){\r\n			scanf("%lf %lf %lf %lf",&x1[i],&x2[i],&y1[i],&y2[i]);\r\n		}\r\n		for(i=0;i<n-1;++i){\r\n			for(j=i+1;j<n;++j){\r\n				count+=judge_intersete(i,j);\r\n			}\r\n		}\r\n		printf("%d\\n",count);\r\n\r\n	}\r\n	return 0;\r\n}\r\n', '', 0, 266240, 4, 1, '2010-11-11 10:12:58', '0001-01-01 00:00:00'),
(899, 6, 378, 6, '#include <stdio.h>\r\n#include <math.h>\r\n//#include <vector>\r\n#include <algorithm>\r\nusing namespace std;\r\nconst double INF = 1e9; \r\nconst double EPS = 1e-6; \r\nconst int MAX_N = 1000; \r\nconst int M = 350;\r\n/*template<class T> T& min(const T& a, const T& b){\r\n	return a<b?a:b;\r\n}\r\ntemplate<class T> T& max(const T& a, const T& b){\r\n	return a>b?a:b;\r\n}*/\r\nstruct Point { \r\n	double x, y;\r\n}po[M]; \r\n\r\nstruct LineSegment { \r\n	Point pt1, pt2; \r\n}; \r\ndouble low_y, high_y;\r\n\r\n\r\n// 计算叉乘 |P0P1| × |P0P2| \r\ndouble Multiply(Point p1, Point p2, Point p0) { \r\n	return ( (p1.x - p0.x) * (p2.y - p0.y) - (p2.x - p0.x) * (p1.y - p0.y) ); \r\n} \r\n\r\n// 判断线段是否包含点point \r\nbool IsOnline(Point point, LineSegment line) \r\n{ \r\n	return( ( fabs(Multiply(line.pt1, line.pt2, point)) < EPS ) && \r\n		  ( ( point.x - line.pt1.x ) * ( point.x - line.pt2.x ) <= 0 ) && \r\n		  ( ( point.y - line.pt1.y ) * ( point.y - line.pt2.y ) <= 0 ) ); \r\n} \r\n\r\n// 判断线段相交 \r\nbool Intersect(LineSegment L1, LineSegment L2) \r\n{ \r\n	return ( (max(L1.pt1.x, L1.pt2.x) >= min(L2.pt1.x, L2.pt2.x)) && \r\n		   (max(L2.pt1.x, L2.pt2.x) >= min(L1.pt1.x, L1.pt2.x)) && \r\n		   (max(L1.pt1.y, L1.pt2.y) >= min(L2.pt1.y, L2.pt2.y)) && \r\n		   (max(L2.pt1.y, L2.pt2.y) >= min(L1.pt1.y, L1.pt2.y)) && \r\n		   (Multiply(L2.pt1, L1.pt2, L1.pt1) * Multiply(L1.pt2, L2.pt2, L1.pt1) >= 0) && \r\n		   (Multiply(L1.pt1, L2.pt2, L2.pt1) * Multiply(L2.pt2, L1.pt2, L2.pt1) >= 0) \r\n		   ); \r\n} \r\n\r\n// 判断点在多边形内 \r\nint InPolygon(Point point,int n) \r\n{ \r\n	int count = 0; \r\n	LineSegment line; \r\n	line.pt1 = point; \r\n	line.pt2.y = point.y; \r\n	line.pt2.x = - INF; \r\n	\r\n	for( int i = 0; i < n; i++ ) { \r\n		// 得到多边形的一条边 \r\n		LineSegment side; \r\n		side.pt1 = po[i]; \r\n		side.pt2 = po[(i + 1) % n]; \r\n		\r\n		if( IsOnline(point, side) ) \r\n			return 0;\r\n		\r\n		// 如果side平行x轴则不作考虑 \r\n		if( fabs(side.pt1.y - side.pt2.y) < EPS ) \r\n			continue; \r\n		\r\n		if( IsOnline(side.pt1, line) && ( side.pt1.y==low_y || side.pt1.y==high_y ) ) count++; \r\n		if( IsOnline(side.pt2, line) && ( side.pt2.y==low_y || side.pt2.y==high_y ) ) count++; \r\n		if( Intersect(line, side) ) count++; \r\n	} \r\n	if ( count % 2 == 1 ) return 1;\r\n	else                  return -1;\r\n}\r\n\r\nint main()\r\n{\r\n	int n, m, i, j, len;\r\n	Point p;\r\n	while(scanf("%d %d",&n,&m)!=EOF){\r\n		j = 0, low_y = INF, high_y = -INF;\r\n		for(i = 0; i < n; ++i){\r\n			scanf("%lf %lf",&p.x,&p.y);\r\n			po[j++] = p;\r\n			if(low_y > p.y) low_y = p.y;\r\n			if(high_y < p.y) high_y = p.y;\r\n		}\r\n		len = j;\r\n		\r\n		while(m--){\r\n			scanf("%lf %lf",&p.x,&p.y);\r\n			printf("%d\\n",InPolygon(p,len));\r\n		}\r\n	}\r\n	return 0;\r\n}\r\n', '', 15, 266240, 1, 2, '2010-11-11 12:57:44', '0001-01-01 00:00:00'),
(900, 6, 378, 0, '#include <stdio.h>\r\n#include <math.h>\r\n#include <algorithm>\r\nusing namespace std;\r\nconst double INF = 1e9; \r\nconst double EPS = 1e-6; \r\nconst int MAX_N = 1000; \r\nconst int M = 350;\r\nstruct Point { \r\n	double x, y;\r\n}po[M]; \r\n\r\nstruct LineSegment { \r\n	Point pt1, pt2; \r\n}; \r\ndouble low_y, high_y;\r\n\r\n// 计算叉乘 |P0P1| × |P0P2| \r\ndouble Multiply(Point p1, Point p2, Point p0) { \r\n	return ( (p1.x - p0.x) * (p2.y - p0.y) - (p2.x - p0.x) * (p1.y - p0.y) ); \r\n} \r\n\r\n// 判断线段是否包含点point \r\nbool IsOnline(Point point, LineSegment line) \r\n{ \r\n	return( ( fabs(Multiply(line.pt1, line.pt2, point)) < EPS ) && \r\n		  ( ( point.x - line.pt1.x ) * ( point.x - line.pt2.x ) <= 0 ) && \r\n		  ( ( point.y - line.pt1.y ) * ( point.y - line.pt2.y ) <= 0 ) ); \r\n} \r\n\r\n// 判断线段相交 \r\nbool Intersect(LineSegment L1, LineSegment L2) \r\n{ \r\n	return ( (max(L1.pt1.x, L1.pt2.x) >= min(L2.pt1.x, L2.pt2.x)) && \r\n		   (max(L2.pt1.x, L2.pt2.x) >= min(L1.pt1.x, L1.pt2.x)) && \r\n		   (max(L1.pt1.y, L1.pt2.y) >= min(L2.pt1.y, L2.pt2.y)) && \r\n		   (max(L2.pt1.y, L2.pt2.y) >= min(L1.pt1.y, L1.pt2.y)) && \r\n		   (Multiply(L2.pt1, L1.pt2, L1.pt1) * Multiply(L1.pt2, L2.pt2, L1.pt1) >= 0) && \r\n		   (Multiply(L1.pt1, L2.pt2, L2.pt1) * Multiply(L2.pt2, L1.pt2, L2.pt1) >= 0) \r\n		   ); \r\n} \r\n\r\n// 判断点在多边形内 \r\nint InPolygon(Point point,int n) \r\n{ \r\n	int count = 0; \r\n	LineSegment line; \r\n	line.pt1 = point; \r\n	line.pt2.y = point.y; \r\n	line.pt2.x = - INF; \r\n	\r\n	for( int i = 0; i < n; i++ ) { \r\n		// 得到多边形的一条边 \r\n		LineSegment side; \r\n		side.pt1 = po[i]; \r\n		side.pt2 = po[(i + 1) % n]; \r\n		\r\n		if( IsOnline(point, side) ) \r\n			return 0;\r\n		\r\n		// 如果side平行x轴则不作考虑 \r\n		if( fabs(side.pt1.y - side.pt2.y) < EPS ) \r\n			continue; \r\n		\r\n		if( IsOnline(side.pt1, line) && ( side.pt1.y==low_y || side.pt1.y==high_y ) )      count+=2; \r\n		else if( IsOnline(side.pt2, line) && ( side.pt2.y==low_y || side.pt2.y==high_y ) ) count+=2; \r\n		else if( Intersect(line, side) ) count++; \r\n	} \r\n	if ( count % 2 == 1 ) return 1;\r\n	else                  return -1;\r\n}\r\n\r\nint main()\r\n{\r\n	int n, m, i, j, len;\r\n	Point p;\r\n	while(scanf("%d %d",&n,&m)!=EOF){\r\n		j = 0, low_y = INF, high_y = -INF;\r\n		for(i = 0; i < n; ++i){\r\n			scanf("%lf %lf",&p.x,&p.y);\r\n			po[j++] = p;\r\n			if(low_y > p.y) low_y = p.y;\r\n			if(high_y < p.y) high_y = p.y;\r\n		}\r\n		len = j;\r\n		\r\n		while(m--){\r\n			scanf("%lf %lf",&p.x,&p.y);\r\n			printf("%d\\n",InPolygon(p,len));\r\n		}\r\n	}\r\n	return 0;\r\n}\r\n', '', 15, 266240, 1, 2, '2010-11-11 13:03:43', '0001-01-01 00:00:00'),
(901, 23, 338, 3, '#include<stdio.h>\r\nint a[1001];\r\nint main(){\r\n	int n,k,num,m,i,j,max;\r\n	scanf("%d%d",&n,&k);\r\n	for(i=0;i<n;++i){\r\n		scanf("%d",&num);\r\n		++a[num];\r\n	}\r\n    i=-1;j=-1;\r\n	while(i<k) if(0!=(num=a[++j])) i+=num;\r\n	i=-1;m=1001;\r\n	while(i<k) if(0!=(num=a[--m])) i+=num;\r\n\r\n    printf("%d\\n",m-j);\r\n\r\n	return 0;\r\n}', '', 0, 262144, 4, 1, '2010-11-11 15:57:48', '0001-01-01 00:00:00'),
(902, 23, 338, 3, '#include<stdio.h>\r\nint a[1001];\r\nint main(){\r\n	int n,k,num,m,i,j,max;\r\n	scanf("%d%d",&n,&k);\r\n	for(i=0;i<n;++i){\r\n		scanf("%d",&num);\r\n		++a[num];\r\n	}\r\n    i=-1;j=-1;\r\n	while(i<k) if(0!=(num=a[++j])) i+=num;\r\n	i=-1;m=1001;\r\n	while(i<k) if(0!=(num=a[--m])) i+=num;\r\n\r\n    printf("%d\\n",m-j);\r\n\r\n	return 0;\r\n}', '', 0, 266240, 4, 1, '2010-11-11 16:01:34', '0001-01-01 00:00:00'),
(903, 23, 338, 3, '#include<stdio.h>\r\nint a[1001];\r\nint main(){\r\n	int n,k,num,m,i,j,max;\r\n	scanf("%d%d",&n,&k);\r\n	for(i=0;i<n;++i){\r\n		scanf("%d",&num);\r\n		++a[num];\r\n	}\r\n    i=-1;j=-1;\r\n	while(i<k) if(0!=(num=a[++j])) i+=num;\r\n	i=-1;m=1001;\r\n	while(i<k) if(0!=(num=a[--m])) i+=num;\r\n\r\n    printf("%d",m-j);\r\n\r\n	return 0;\r\n}', '', 0, 266240, 4, 2, '2010-11-11 16:04:28', '0001-01-01 00:00:00'),
(904, 17, 378, 6, '#include<stdio.h>\r\n#include<math.h>\r\n#define M 301\r\ntypedef struct Point\r\n{\r\n        double x;\r\n        double y;\r\n}Point;\r\nPoint mul_pat[M];\r\nint judge(Point p3,Point p1,Point p2)\r\n{\r\n    double k;\r\n    k=(p2.x-p1.x)*(p3.y-p1.y)-(p2.y-p1.y)*(p3.x-p1.x);\r\n    if(k>0)\r\n      return 1;\r\n    else if(k==0)\r\n      return 0;\r\n    else if(k<0)\r\n      return -1;\r\n}\r\nint main()\r\n{\r\n    int n,m;\r\n    int i,j;\r\n    Point test;\r\n    int count1,count2,count3;\r\n    while(scanf("%d",&n)!=EOF)\r\n    {\r\n      scanf("%d",&m);\r\n      for(i=0;i<n;i++)\r\n        scanf("%lf%lf",&mul_pat[i].x,&mul_pat[i].y);\r\n      while(m--)\r\n      {   \r\n          count1=count2=count3=0;\r\n          scanf("%lf%lf",&test.x,&test.y);\r\n          for(i=0;i<n-1;i++)\r\n          {\r\n              if(judge(test,mul_pat[i],mul_pat[i+1])==1)\r\n              count1++;\r\n              else if(judge(test,mul_pat[i],mul_pat[i+1])==0)\r\n              count2++;\r\n              else \r\n              count3++;\r\n          }\r\n          if(judge(test,mul_pat[n-1],mul_pat[0])==1)\r\n              count1++;\r\n          else if(judge(test,mul_pat[n-1],mul_pat[0])==0)\r\n              count2++;\r\n          else \r\n              count3++;\r\n          if(count2!=0&&count3==0)\r\n            printf("0\\n");\r\n          else if(count3!=0)\r\n           printf("-1\\n");\r\n          else \r\n           printf("1\\n");\r\n       }\r\n       }\r\n       return 0;\r\n}\r\n              \r\n    \r\n', '', 0, 266240, 4, 1, '2010-11-13 15:29:09', '0001-01-01 00:00:00'),
(905, 17, 378, 6, '#include<stdio.h>\r\n#include<math.h>\r\n#define M 301\r\ntypedef struct Point\r\n{\r\n        double x;\r\n        double y;\r\n}Point;\r\nPoint mul_pat[M];\r\nint judge(Point p3,Point p1,Point p2)\r\n{\r\n    double k;\r\n    k=(p2.x-p1.x)*(p3.y-p1.y)-(p2.y-p1.y)*(p3.x-p1.x);\r\n    if(k>0)\r\n      return 1;\r\n    else if(k==0)\r\n      return 0;\r\n    else if(k<0)\r\n      return -1;\r\n}\r\nint main()\r\n{\r\n    int n,m;\r\n    int i,j;\r\n    Point test;\r\n    int count1,count2,count3;\r\n    while(scanf("%d",&n)!=EOF)\r\n    {\r\n      scanf("%d",&m);\r\n      for(i=0;i<n;i++)\r\n        scanf("%lf%lf",&mul_pat[i].x,&mul_pat[i].y);\r\n      while(m--)\r\n      {   \r\n          count1=count2=count3=0;\r\n          scanf("%lf%lf",&test.x,&test.y);\r\n          for(i=0;i<n;i++)\r\n          {\r\n              if(judge(test,mul_pat[i],mul_pat[(i+1)%n])==1)\r\n              count1++;\r\n              else if(judge(test,mul_pat[i],mul_pat[(i+1)%n])==0)\r\n              count2++;\r\n              else \r\n              count3++;\r\n          }\r\n          if(count2!=0&&count3==0)\r\n            printf("0\\n");\r\n          else if(count3!=0)\r\n           printf("-1\\n");\r\n          else \r\n           printf("1\\n");\r\n       }\r\n       }\r\n       return 0;\r\n}\r\n              \r\n    \r\n', '', 0, 266240, 4, 1, '2010-11-13 15:51:33', '0001-01-01 00:00:00'),
(906, 17, 378, 6, '#include<stdio.h>\r\n#include<math.h>\r\n#define M 301\r\ntypedef struct Point\r\n{\r\n        double x;\r\n        double y;\r\n}Point;\r\nPoint mul_pat[M];\r\nint judge(Point p3,Point p1,Point p2)\r\n{\r\n    double k;\r\n    k=(p2.x-p1.x)*(p3.y-p1.y)-(p2.y-p1.y)*(p3.x-p1.x);\r\n    if(k>0)\r\n      return 1;\r\n    else if(k==0)\r\n      return 0;\r\n    else if(k<0)\r\n      return -1;\r\n}\r\nint main()\r\n{\r\n    int n,m;\r\n    int i,j;\r\n    Point test;\r\n    int count1,count2,count3;\r\n    while(scanf("%d",&n)!=EOF)\r\n    {\r\n      scanf("%d",&m);\r\n      for(i=0;i<n;i++)\r\n        scanf("%lf%lf",&mul_pat[i].x,&mul_pat[i].y);\r\n      while(m--)\r\n      {   \r\n          count1=count2=count3=0;\r\n          scanf("%lf%lf",&test.x,&test.y);\r\n          for(i=0;i<n;i++)\r\n          {\r\n              if(judge(test,mul_pat[i],mul_pat[(i+1)%n])==1)\r\n              count1++;\r\n              else if(judge(test,mul_pat[i],mul_pat[(i+1)%n])==0)\r\n              count2++;\r\n              else \r\n              count3++;\r\n          }\r\n          if(count1==n)\r\n            printf("1\\n");\r\n          else if(count3!=0)\r\n           printf("-1\\n");\r\n          else \r\n           printf("0\\n");\r\n       }\r\n       }\r\n       return 0;\r\n}\r\n              \r\n    \r\n', '', 0, 266240, 4, 1, '2010-11-13 16:06:21', '0001-01-01 00:00:00'),
(907, 17, 378, 6, '#include<stdio.h>\r\n#include<math.h>\r\n#define M 301\r\ntypedef struct Point\r\n{\r\n        double x;\r\n        double y;\r\n}Point;\r\ntypedef struct Tpoint{\r\n        double x1,y1;\r\n        double x2,y2;\r\n}TPoint;\r\nPoint mul_pat[M];\r\nint judge(Point p3,Point p1,Point p2)\r\n{\r\n    double k;\r\n    double min,max;\r\n    if(p1.x>=p2.x)\r\n    {max=p1.x;\r\n    min=p2.x;\r\n    }\r\n    else \r\n    {\r\n         max=p2.x;\r\n         min=p1.x;\r\n    }\r\n    k=(p2.x-p1.x)*(p3.y-p1.y)-(p2.y-p1.y)*(p3.x-p1.x);\r\n    if(k==0){\r\n      if(p3.x<=max&&p3.x>=min) \r\n      return 0;\r\n      else \r\n      return 1;\r\n    }\r\n    else \r\n      return 1;\r\n}\r\nint cal(Point test0,Point test1,Point p2,Point p3)\r\n{   \r\n     double z1,z2;\r\n     TPoint p0,p1;\r\n     p0.x1=p2.x;\r\n     p0.y1=p2.y;\r\n     p0.x2=p3.x;\r\n     p0.y2=p3.y;\r\n     p1.x1=test0.x;\r\n     p1.y1=test0.y;\r\n     p1.x2=test1.x;\r\n     p1.y2=test1.y;\r\n     z1=(p0.x1-p1.x1)*(p1.y2-p1.y1)-(p0.y1-p1.y1)*(p1.x2-p1.x1);\r\n     z2=(p1.x2-p1.x1)*(p0.y2-p1.y1)-(p1.y2-p1.y1)*(p0.x2-p1.x1);\r\n     if(z1*z2>=0)\r\n       return 1;\r\n     else \r\n     return 0;\r\n} \r\nint main()\r\n{\r\n    int n,m;\r\n    int i,j;\r\n    Point test;\r\n    Point test1;\r\n    int max;\r\n    int min;\r\n    int count,count2,count3;\r\n    while(scanf("%d",&n)!=EOF)\r\n    { \r\n      max=min=0;\r\n      scanf("%d",&m);\r\n      for(i=0;i<n;i++)\r\n      {\r\n           scanf("%lf%lf",&mul_pat[i].x,&mul_pat[i].y);\r\n           if(max<mul_pat[i].y)max=mul_pat[i].y;\r\n           if(min>mul_pat[i].y)min=mul_pat[i].y;\r\n      }\r\n      while(m--)\r\n      {   \r\n          count=count2=count3=0;\r\n          scanf("%lf%lf",&test.x,&test.y);\r\n          if(test.x<=min)test1.x=max+1;\r\n          else if(test.x>=max)test1.x=min-1;\r\n          else test1.x=max+1;\r\n          test1.y=test.y;\r\n          for(i=0;i<n;i++)\r\n          {\r\n              if(judge(test,mul_pat[i],mul_pat[(i+1)%n])==0){\r\n                  count2=1;}\r\n              else {\r\n               if(cal(test,test1,mul_pat[i],mul_pat[(i+1)%n])&&cal(mul_pat[i],mul_pat[(i+1)%n],test,test1))\r\n                 count++;    \r\n               }                        \r\n          }\r\n          if(count2==1)\r\n          printf("0\\n");\r\n          else \r\n          {\r\n               if(count%2==0)\r\n               printf("-1\\n");\r\n               else \r\n               printf("1\\n");\r\n          }\r\n          \r\n\r\n          }\r\n       }\r\n       return 0;\r\n}\r\n              \r\n    \r\n', '', 0, 266240, 4, 1, '2010-11-14 10:56:04', '0001-01-01 00:00:00'),
(908, 17, 378, 6, '#include<stdio.h>\r\n#define INFINITY 1e9  \r\n#define ESP 1e-7\r\n#define M 301\r\ntypedef struct Point\r\n{\r\n        double x;\r\n        double y;\r\n}Point;\r\ntypedef struct Tpoint{\r\n        double x1,y1;\r\n        double x2,y2;\r\n}TPoint;\r\nPoint mul_pat[M];\r\nint judge(Point p3,Point p1,Point p2)\r\n{\r\n    double k;\r\n    double min_x,max_x,min_y,max_y;\r\n    if(p1.x>=p2.x)\r\n    {\r\n       max_x=p1.x;\r\n       min_x=p2.x;\r\n    }\r\n    else \r\n    {\r\n         max_x=p2.x;\r\n         min_x=p1.x;\r\n    }\r\n   \r\n    if(p1.y>=p2.y)\r\n    {\r\n       max_y=p1.y;\r\n       min_y=p2.y;\r\n    }\r\n    else \r\n    {\r\n         max_y=p2.y;\r\n         min_y=p1.y;\r\n    }\r\n  \r\n    k=(p2.x-p1.x)*(p3.y-p1.y)-(p2.y-p1.y)*(p3.x-p1.x);\r\n    if(k==0){\r\n      if(p3.x<=max_x&&p3.x>=min_x&&p3.y<=max_y&&p3.y>=min_y) \r\n      return 0;\r\n      else \r\n      return 1;\r\n    }\r\n    else \r\n      return 1;\r\n}\r\nint cal(Point test0,Point test1,Point p2,Point p3)\r\n{   \r\n     double z1,z2;\r\n     TPoint p0,p1;\r\n     p0.x1=p2.x;\r\n     p0.y1=p2.y;\r\n     p0.x2=p3.x;\r\n     p0.y2=p3.y;\r\n     p1.x1=test0.x;\r\n     p1.y1=test0.y;\r\n     p1.x2=test1.x;\r\n     p1.y2=test1.y;\r\n     z1=(p0.x1-p1.x1)*(p1.y2-p1.y1)-(p0.y1-p1.y1)*(p1.x2-p1.x1);\r\n     z2=(p1.x2-p1.x1)*(p0.y2-p1.y1)-(p1.y2-p1.y1)*(p0.x2-p1.x1);\r\n     if(z1*z2>=0)\r\n       return 1;\r\n     else \r\n     return 0;\r\n} \r\nint main()\r\n{\r\n    int n,m;\r\n    int i,j;\r\n    Point test;\r\n    Point test1;\r\n    double max;\r\n    double min;\r\n    int count,count2,count3;\r\n    int tests;\r\n    tests=0;\r\n    while(scanf("%d",&n)&&n!=0)\r\n    {  \r\n      max=min=0;\r\n      scanf("%d",&m);\r\n      for(i=0;i<n;i++)\r\n      {\r\n           scanf("%lf%lf",&mul_pat[i].x,&mul_pat[i].y);\r\n           if(max<mul_pat[i].y)max=mul_pat[i].y;\r\n           if(min>mul_pat[i].y)min=mul_pat[i].y;\r\n      }\r\n      while(m--)\r\n      {   \r\n          \r\n          count=count2=0;\r\n          scanf("%lf%lf",&test.x,&test.y);\r\n          test1.x=-INFINITY;\r\n          test1.y=test.y;\r\n          for(i=0;i<n;i++)\r\n          {\r\n              if(judge(test,mul_pat[i],mul_pat[(i+1)%n])==0){\r\n                  count2=1;\r\n              }\r\n              else {\r\n              if(mul_pat[i].y==mul_pat[(i+1)%n].y)\r\n                  continue;\r\n               else {\r\n               if(cal(test,test1,mul_pat[i],mul_pat[(i+1)%n])&&cal(mul_pat[i],mul_pat[(i+1)%n],test,test1))\r\n                  count++; \r\n               }  \r\n               }                      \r\n          }\r\n          if(count2==1)\r\n          printf("0\\n");\r\n          else \r\n          {\r\n               if(count%2==0)\r\n               printf("-1\\n");\r\n               else \r\n               printf("1\\n");\r\n          }\r\n       }\r\n       }\r\n       return 0;\r\n}\r\n              \r\n    \r\n', '', 1000, 262144, 5, 1, '2010-11-14 15:35:42', '0001-01-01 00:00:00'),
(909, 17, 378, 6, '#include<stdio.h>\r\n#define INFINITY 1e9  \r\n#define ESP 1e-7\r\n#define M 301\r\ntypedef struct Point\r\n{\r\n        double x;\r\n        double y;\r\n}Point;\r\ntypedef struct Tpoint{\r\n        double x1,y1;\r\n        double x2,y2;\r\n}TPoint;\r\nPoint mul_pat[M];\r\nint judge(Point p3,Point p1,Point p2)\r\n{\r\n    double k;\r\n    k=(p2.x-p1.x)*(p3.y-p1.y)-(p2.y-p1.y)*(p3.x-p1.x);\r\n    if(k==0&& ((p3.x-p1.x)*(p3.x-p2.x)<=0) &&((p3.y-p1.y)*(p3.y-p2.y)<=0))\r\n      return 0;\r\n    else \r\n      return 1;\r\n}\r\nint cal(Point test0,Point test1,Point p2,Point p3)\r\n{   \r\n     double z1,z2;\r\n     TPoint p0,p1;\r\n     p0.x1=p2.x;\r\n     p0.y1=p2.y;\r\n     p0.x2=p3.x;\r\n     p0.y2=p3.y;\r\n     p1.x1=test0.x;\r\n     p1.y1=test0.y;\r\n     p1.x2=test1.x;\r\n     p1.y2=test1.y;\r\n     z1=(p0.x1-p1.x1)*(p1.y2-p1.y1)-(p0.y1-p1.y1)*(p1.x2-p1.x1);\r\n     z2=(p1.x2-p1.x1)*(p0.y2-p1.y1)-(p1.y2-p1.y1)*(p0.x2-p1.x1);\r\n     if(z1*z2>=0)\r\n       return 1;\r\n     else \r\n     return 0;\r\n} \r\nint main()\r\n{\r\n    int n,m;\r\n    int i,j;\r\n    Point test;\r\n    Point test1;\r\n    double max;\r\n    double min;\r\n    int count,count2,count3;\r\n    int tests;\r\n    tests=0;\r\n    while(scanf("%d",&n)&&n!=0)\r\n    {  \r\n      max=min=0;\r\n      scanf("%d",&m);\r\n      for(i=0;i<n;i++)\r\n      {\r\n           scanf("%lf%lf",&mul_pat[i].x,&mul_pat[i].y);\r\n           if(max<mul_pat[i].y)max=mul_pat[i].y;\r\n           if(min>mul_pat[i].y)min=mul_pat[i].y;\r\n      }\r\n      while(m--)\r\n      {   \r\n          \r\n          count=count2=0;\r\n          scanf("%lf%lf",&test.x,&test.y);\r\n          test1.x=-INFINITY;\r\n          test1.y=test.y;\r\n          for(i=0;i<n;i++)\r\n          {\r\n              if(judge(test,mul_pat[i],mul_pat[(i+1)%n])==0){\r\n                  count2=1;\r\n                  break;\r\n              }\r\n              \r\n              else {\r\n              if(mul_pat[i].y==mul_pat[(i+1)%n].y)\r\n                  continue;\r\n               else {\r\n               if(cal(test,test1,mul_pat[i],mul_pat[(i+1)%n])&&cal(mul_pat[i],mul_pat[(i+1)%n],test,test1))\r\n                  count++; \r\n               }  \r\n               }                      \r\n          }\r\n          if(count2==1)\r\n             printf("0\\n");\r\n          else \r\n          {\r\n               if(count%2==0)\r\n               printf("-1\\n");\r\n               else \r\n               printf("1\\n");\r\n          }\r\n       }\r\n       }\r\n       return 0;\r\n}\r\n              \r\n    \r\n', '', 1000, 266240, 5, 1, '2010-11-14 15:49:43', '0001-01-01 00:00:00');
INSERT INTO `tbl_submitions` (`id`, `user_id`, `problem_id`, `exercise_id`, `source`, `result`, `used_time`, `used_memory`, `status`, `compiler_id`, `created`, `modified`) VALUES
(910, 17, 378, 6, '#include<stdio.h>\r\n#define INFINITY 1e9  \r\n#define ESP 1e-7\r\n#define M 301\r\ntypedef struct Point\r\n{\r\n        double x;\r\n        double y;\r\n}Point;\r\ntypedef struct Tpoint{\r\n        double x1,y1;\r\n        double x2,y2;\r\n}TPoint;\r\nPoint mul_pat[M];\r\nint judge(Point p3,Point p1,Point p2)\r\n{\r\n    double k;\r\n    k=(p2.x-p1.x)*(p3.y-p1.y)-(p2.y-p1.y)*(p3.x-p1.x);\r\n    if(k==0&& ((p3.x-p1.x)*(p3.x-p2.x)<=0) &&((p3.y-p1.y)*(p3.y-p2.y)<=0))\r\n      return 0;\r\n    else \r\n      return 1;\r\n}\r\nint cal(Point test0,Point test1,Point p2,Point p3)\r\n{   \r\n     double z1,z2;\r\n     TPoint p0,p1;\r\n     p0.x1=p2.x;\r\n     p0.y1=p2.y;\r\n     p0.x2=p3.x;\r\n     p0.y2=p3.y;\r\n     p1.x1=test0.x;\r\n     p1.y1=test0.y;\r\n     p1.x2=test1.x;\r\n     p1.y2=test1.y;\r\n     z1=(p0.x1-p1.x1)*(p1.y2-p1.y1)-(p0.y1-p1.y1)*(p1.x2-p1.x1);\r\n     z2=(p1.x2-p1.x1)*(p0.y2-p1.y1)-(p1.y2-p1.y1)*(p0.x2-p1.x1);\r\n     if(z1*z2>=0)\r\n       return 1;\r\n     else \r\n     return 0;\r\n} \r\nint main()\r\n{\r\n    int n,m;\r\n    int i,j;\r\n    Point test;\r\n    Point test1;\r\n    int count,count2,count3;\r\n    int tests;\r\n    tests=0;\r\n    while(scanf("%d",&n)&&n!=0)\r\n    {  \r\n      scanf("%d",&m);\r\n      for(i=0;i<n;i++)\r\n           scanf("%lf%lf",&mul_pat[i].x,&mul_pat[i].y);\r\n      while(m--)\r\n      {   \r\n          \r\n          count=count2=0;\r\n          scanf("%lf%lf",&test.x,&test.y);\r\n          test1.x=-INFINITY;\r\n          test1.y=test.y;\r\n          for(i=0;i<n;i++)\r\n          {\r\n              if(judge(test,mul_pat[i],mul_pat[(i+1)%n])==0){\r\n                  count2=1;\r\n                  break;\r\n              }\r\n              \r\n              else {\r\n               if(mul_pat[i].y==mul_pat[(i+1)%n].y)\r\n                  continue;\r\n               else {\r\n               if(cal(test,test1,mul_pat[i],mul_pat[(i+1)%n])&&cal(mul_pat[i],mul_pat[(i+1)%n],test,test1))\r\n                  count++; \r\n               }  \r\n               }                      \r\n          }\r\n          if(count2==1)\r\n             printf("0\\n");\r\n          else \r\n          {\r\n               if(count%2==0)\r\n               printf("-1\\n");\r\n               else \r\n               printf("1\\n");\r\n          }\r\n       }\r\n       }\r\n       return 0;\r\n}\r\n              \r\n    \r\n', '', 1000, 262144, 5, 1, '2010-11-14 15:52:24', '0001-01-01 00:00:00'),
(911, 17, 377, 6, '#include<stdio.h>\r\n#include<iostream>\r\nusing namespace std;\r\n#define M 101\r\ntypedef struct point{\r\n        double x1,y1;\r\n        double x2,y2;\r\n}Point;\r\nPoint seg[M];\r\nint cal(Point p0,Point p1)\r\n{   \r\n     double z1,z2;\r\n     z1=(p0.x1-p1.x1)*(p1.y2-p1.y1)-(p0.y1-p1.y1)*(p1.x2-p1.x1);\r\n     z2=(p1.x2-p1.x1)*(p0.y2-p1.y1)-(p1.y2-p1.y1)*(p0.x2-p1.x1);\r\n     if(z1*z2>=0)\r\n       return 1;\r\n     else \r\n     return 0;\r\n}         \r\nint main()\r\n{\r\n    int i,test,j;\r\n    int count;\r\n    while(scanf("%d",&test)&&test!=0)\r\n    {   \r\n        count=0;\r\n        for(i=0;i<test;i++)\r\n          cin>>seg[i].x1>>seg[i].y1>>seg[i].x2>>seg[i].y2;\r\n        for(i=0;i<test;i++)\r\n         for(j=i+1;j<test;j++)\r\n          if(cal(seg[i],seg[j])&&cal(seg[j],seg[i]))\r\n           count++;\r\n        printf("%d\\n",count);\r\n    }\r\n}\r\n', 'Main.c:2:19: fatal error: iostream: No such file or directory\r\ncompilation terminated.\r\n', 0, 0, 2, 1, '2010-11-14 15:57:07', '0001-01-01 00:00:00'),
(912, 17, 377, 6, '#include<stdio.h>\r\n#include<iostream>\r\nusing namespace std;\r\n#define M 101\r\ntypedef struct point{\r\n        double x1,y1;\r\n        double x2,y2;\r\n}Point;\r\nPoint seg[M];\r\nint cal(Point p0,Point p1)\r\n{   \r\n     double z1,z2;\r\n     z1=(p0.x1-p1.x1)*(p1.y2-p1.y1)-(p0.y1-p1.y1)*(p1.x2-p1.x1);\r\n     z2=(p1.x2-p1.x1)*(p0.y2-p1.y1)-(p1.y2-p1.y1)*(p0.x2-p1.x1);\r\n     if(z1*z2>=0)\r\n       return 1;\r\n     else \r\n     return 0;\r\n}         \r\nint main()\r\n{\r\n    int i,test,j;\r\n    int count;\r\n    while(scanf("%d",&test)&&test!=0)\r\n    {   \r\n        count=0;\r\n        for(i=0;i<test;i++)\r\n          cin>>seg[i].x1>>seg[i].y1>>seg[i].x2>>seg[i].y2;\r\n        for(i=0;i<test;i++)\r\n         for(j=i+1;j<test;j++)\r\n          if(cal(seg[i],seg[j])&&cal(seg[j],seg[i]))\r\n           count++;\r\n        printf("%d\\n",count);\r\n    }\r\n}\r\n', '', 0, 372736, 4, 2, '2010-11-14 15:57:29', '0001-01-01 00:00:00'),
(913, 17, 377, 6, '#include<stdio.h>\r\n#include<iostream>\r\nusing namespace std;\r\n#define M 301\r\ntypedef struct point{\r\n        double x1,y1;\r\n        double x2,y2;\r\n}Point;\r\nPoint seg[M];\r\nint cal(Point p0,Point p1)\r\n{   \r\n     double z1,z2;\r\n     z1=(p0.x1-p1.x1)*(p1.y2-p1.y1)-(p0.y1-p1.y1)*(p1.x2-p1.x1);\r\n     z2=(p1.x2-p1.x1)*(p0.y2-p1.y1)-(p1.y2-p1.y1)*(p0.x2-p1.x1);\r\n     if(z1*z2>=0)\r\n       return 1;\r\n     else \r\n     return 0;\r\n}         \r\nint main()\r\n{\r\n    int i,test,j;\r\n    int count;\r\n    while(scanf("%d",&test)&&test!=0)\r\n    {   \r\n        count=0;\r\n        for(i=0;i<test;i++)\r\n          cin>>seg[i].x1>>seg[i].y1>>seg[i].x2>>seg[i].y2;\r\n        for(i=0;i<test;i++)\r\n         for(j=i+1;j<test;j++)\r\n          if(cal(seg[i],seg[j])&&cal(seg[j],seg[i]))\r\n           count++;\r\n        printf("%d\\n",count);\r\n    }\r\n}\r\n', '', 0, 376832, 4, 2, '2010-11-14 16:02:02', '0001-01-01 00:00:00'),
(914, 24, 338, 3, '#include <iostream>\r\n#include <vector>\r\n\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n	int n;\r\n	int k;\r\n	int num;\r\n	int i;\r\n	i = 0;\r\n	vector<int> number;\r\n	while(scanf("%d",&n) != EOF)\r\n	{\r\n		cin>>k;\r\n		for(i=0;i<n;i++)\r\n		{\r\n			cin>>num;\r\n			number.push_back(num);\r\n		}\r\n		int scort;\r\n		scort=number[k]-number[n-k-1];\r\n		cout<<scort<<endl;\r\n		number.clear();\r\n	}\r\n	return 0;\r\n}', 'Main.cpp: In function ''int main()'':\r\nMain.cpp:14:21: error: ''scanf'' was not declared in this scope\r\nMain.cpp:14:26: error: ''EOF'' was not declared in this scope\r\n', 0, 0, 2, 2, '2010-11-15 17:56:44', '0001-01-01 00:00:00'),
(915, 24, 338, 3, '#include <iostream>\r\n#include <vector>\r\n\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n	int n;\r\n	int k;\r\n	int num;\r\n	int i;\r\n	vector<int> number;\r\n	while(cin>>n>>k)\r\n	{\r\n		for(i=0;i<n;i++)\r\n		{\r\n			cin>>num;\r\n			number.push_back(num);\r\n		}\r\n		int scort;\r\n		scort=number[k]-number[n-k-1];\r\n		cout<<scort<<endl;\r\n		number.clear();\r\n	}\r\n	return 0;\r\n}', '', 400, 622592, 5, 2, '2010-11-15 17:59:01', '0001-01-01 00:00:00'),
(916, 24, 338, 3, '#include <iostream>\r\n#include <vector>\r\n\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n	int n;\r\n	int k;\r\n	int num;\r\n	int i;\r\n	vector<int> number;\r\n	while(cin>>n)\r\n	{\r\n		cin>>k;\r\n		for(i=0;i<n;i++)\r\n		{\r\n			cin>>num;\r\n			number.push_back(num);\r\n		}\r\n		int scort;\r\n		scort=number[k]-number[n-k-1];\r\n		cout<<scort<<endl;\r\n		number.clear();\r\n	}\r\n	return 0;\r\n}', '', 400, 618496, 5, 2, '2010-11-15 18:00:26', '0001-01-01 00:00:00'),
(917, 24, 338, 3, '#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\nint main()\r\n{\r\n	int n;\r\n	int k;\r\n	int i;\r\n	int *p;\r\n	int num;\r\n	int scort;\r\n	while(scanf("%d %d",&n,&k) != EOF)\r\n	{\r\n		p = (int *)malloc(sizeof(int) * n);\r\n		if (p == 0)\r\n		{ \r\n			printf("malloc fail!\\n"); \r\n			exit(0);\r\n		}\r\n		for (i = 0; i < n; i++)\r\n			scanf("%d",&p[i]);		\r\n		scort = p[k] - p[n-k-1];\r\n		printf("%d\\n",scort);\r\n		free(p);\r\n	}\r\n	return 0;\r\n}', '', 400, 512000, 5, 1, '2010-11-15 21:26:57', '0001-01-01 00:00:00'),
(918, 24, 338, 3, '#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\nint main()\r\n{\r\n	int n;\r\n	int k;\r\n	int i;\r\n	int *p;\r\n	int scort;\r\n	while(scanf("%d %d",&n,&k) != EOF)\r\n	{\r\n		p = (int *)malloc(sizeof(int) * n);\r\n		if (p == 0)\r\n		{ \r\n			printf("malloc fail!\\n"); \r\n			exit(0);\r\n		}\r\n		for (i = 0; i < n; i++)\r\n			scanf("%d",&p[i]);\r\n		//scort = p[k] - p[n-k-1];\r\n		printf("%d\\n",p[k] - p[n-k-1]);\r\n		free(p);\r\n	}\r\n	return 0;\r\n}', '', 374, 512000, 4, 1, '2010-11-15 21:34:34', '0001-01-01 00:00:00'),
(919, 24, 338, 3, '#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\nint main()\r\n{\r\n	int n;\r\n	int k;\r\n	int i;\r\n	int *p;\r\n	int scort;\r\n	while(scanf("%d %d",&n,&k) != EOF)\r\n	{\r\n		p = (int *)malloc(sizeof(int) * n);\r\n		if (p == 0)\r\n		{ \r\n			printf("malloc fail!\\n"); \r\n			exit(0);\r\n		}\r\n		for (i = 0; i < n; i++)\r\n			scanf("%d",&p[i]);\r\n		scort = p[k] - p[n-k-1];\r\n		printf("%d\\n",p[k] - p[n-k-1]);\r\n		free(p);\r\n	}\r\n	return 0;\r\n}', '', 374, 516096, 4, 1, '2010-11-15 21:38:08', '0001-01-01 00:00:00'),
(920, 24, 338, 3, '#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\nint main()\r\n{\r\n	int n;\r\n	int k;\r\n	int i;\r\n	int *p;\r\n	int scort;\r\n	while(scanf("%d %d",&n,&k) != EOF)\r\n	{\r\n		p = (int *)malloc(sizeof(int) * n);\r\n		if (p == 0)\r\n		{ \r\n			printf("malloc fail!\\n"); \r\n			exit(0);\r\n		}\r\n		for (i = 0; i < n; i++)\r\n		{\r\n			scanf("%d",&p[i]);\r\n			if(p[i] > 1000)\r\n				exit(0);\r\n		}\r\n		printf("%d\\n",p[k] - p[n-k-1]);\r\n		free(p);\r\n	}\r\n	return 0;\r\n}', '', 374, 512000, 4, 1, '2010-11-15 21:42:32', '0001-01-01 00:00:00'),
(921, 24, 338, 3, '#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\nint main()\r\n{\r\n	int n;\r\n	int k;\r\n	int i;\r\n	int *p;\r\n	int scort;\r\n	while(scanf("%d %d",&n,&k) != EOF)\r\n	{\r\n		if(n<k)\r\n			exit(0);\r\n		else\r\n		{\r\n			p = (int *)malloc(sizeof(int) * n);\r\n			if (p == 0)\r\n			{ \r\n				printf("malloc fail!\\n"); \r\n				exit(0);\r\n			}\r\n			for (i = 0; i < n; i++)\r\n			{\r\n				scanf("%d",&p[i]);\r\n				if(p[i] > 1000)\r\n					exit(0);\r\n			}\r\n			printf("%d\\n",p[k] - p[n-k-1]);\r\n			free(p);\r\n		}\r\n	}\r\n	return 0;\r\n}', '', 390, 512000, 4, 1, '2010-11-15 21:44:29', '0001-01-01 00:00:00'),
(922, 24, 338, 3, '#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\nint main()\r\n{\r\n	int n;\r\n	int k;\r\n	int i;\r\n	int *p;\r\n	int scort;\r\n	while(scanf("%d %d",&n,&k) != EOF)\r\n	{\r\n		if((n < k) || (k < 0) || (n < 0))\r\n		{\r\n			exit(0);\r\n		}\r\n		else\r\n		{\r\n			p = (int *)malloc(sizeof(int) * n);\r\n			if (p == 0)\r\n			{\r\n				printf("malloc fail!\\n"); \r\n				exit(0);\r\n			}\r\n			for (i = 0; i < n; i++)\r\n			{\r\n				scanf("%d",&p[i]);\r\n				if(p[i] > 1000)\r\n					exit(0);\r\n			}\r\n			printf("%d\\n",p[k] - p[n-k-1]);\r\n			free(p);\r\n		}\r\n	}\r\n	return 0;\r\n}', '', 390, 512000, 4, 1, '2010-11-15 21:55:27', '0001-01-01 00:00:00'),
(923, 24, 338, 3, '#include <iostream>\r\n#include <vector>\r\n#include <algorithm>\r\n\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n	int n;\r\n	int k;\r\n	int num;\r\n	int i;\r\n	vector<int> number;\r\n	while(cin>>n>>k)\r\n	{\r\n		if((n < k) || (k < 0) || (n < 0) || (n > 50000))\r\n			exit(0);\r\n		else\r\n		{\r\n			for(i=0;i<n;i++)\r\n			{\r\n				cin>>num;\r\n				if(num>1000)\r\n					exit(0);\r\n				number.push_back(num);\r\n			}\r\n			sort(number.begin(),number.end());\r\n			int scort;\r\n			scort=number[n-k-1]-number[k];\r\n			cout<<scort<<endl;\r\n			number.clear();\r\n		}\r\n	}\r\n	return 0;\r\n}', '', 400, 622592, 5, 2, '2010-11-15 22:07:35', '0001-01-01 00:00:00'),
(924, 24, 338, 3, '#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\nint main()\r\n{\r\n	int n;\r\n	int k;\r\n	int i;\r\n	int *p;\r\n	int j;\r\n	int t;\r\n	while(scanf("%d %d",&n,&k) != EOF)\r\n	{\r\n		if((n < k) || (k < 0) || (n < 0))\r\n		{\r\n			exit(0);\r\n		}\r\n		else\r\n		{\r\n			p = (int *)malloc(sizeof(int) * n);\r\n			if (p == 0)\r\n			{\r\n				printf("malloc fail!\\n"); \r\n				exit(0);\r\n			}\r\n			for (i = 0; i < n; i++)\r\n			{\r\n				scanf("%d",&p[i]);\r\n				if(p[i] > 1000)\r\n					exit(0);\r\n			}\r\n\r\n			for(j = 0;j < n-1;j++)\r\n			{\r\n				for(i = 0;i < n - j-1;i++)\r\n					if(p[i]>p[i+1])\r\n					{\r\n						t=p[i];\r\n						p[i]=p[i+1];\r\n						p[i+1]=t;\r\n					}\r\n			}\r\n\r\n			printf("%d\\n",p[n-k-1] - p[k]);\r\n			free(p);\r\n		}\r\n	}\r\n	return 0;\r\n}', '', 400, 389120, 5, 1, '2010-11-15 22:34:16', '0001-01-01 00:00:00'),
(925, 27, 377, 6, '#include <stdio.h>\r\ndouble x1[300],x2[300],y1[300],y2[300];\r\n\r\nint judge(int i,int j)\r\n{\r\n	double a,b;\r\n	a=(x2[j]-x2[i])*(y1[i]-x1[i])-(x1[j]-x1[i])*(y2[i]-x2[i]);\r\n	b=(y2[j]-x2[i])*(y1[i]-x1[i])-(y1[j]-x1[i])*(y2[i]-x2[i]);\r\n	if( a*b<=0.0 ) return 1;\r\n	else return 0;\r\n}\r\n\r\nint judge_intersete(int i,int j)\r\n{\r\n	if(judge(i,j)==1 && judge(j,i)==1)\r\n		return 1;\r\n	else return 0;\r\n}\r\n\r\nint main()\r\n{\r\n	int n,i,j,count;\r\n	while(scanf("%d",&n) && n>0){	\r\n		count=0;\r\n		for(i=0;i<n;++i){\r\n			scanf("%lf %lf %lf %lf",&x1[i],&x2[i],&y1[i],&y2[i]);\r\n		}\r\n		for(i=0;i<n-1;++i){\r\n			for(j=i+1;j<n;++j){\r\n				count+=judge_intersete(i,j);\r\n			}\r\n		}\r\n		printf("%d\\n",count);\r\n\r\n	}\r\n	return 0;\r\n}', '', 0, 270336, 4, 1, '2010-11-16 22:13:40', '0001-01-01 00:00:00'),
(926, 6, 23, 0, '#include <stdio.h>\r\nint  n,res;\r\nchar map[6][6];\r\n\r\nchar check(int x, int y){\r\n     int i;\r\n     for(i = y-1; i >= 0; --i){\r\n         if( map[x][i] == ''P'')     return 0;\r\n         else if(map[x][i] == ''X'') break;\r\n     }\r\n     \r\n     for(i = x-1; i >= 0; --i){\r\n         if( map[i][y] == ''P'')     return 0;\r\n         else if(map[i][y] == ''X'') break;\r\n     }\r\n     return 1;\r\n}\r\n\r\nvoid dfs(int x, int y, int m){\r\n     if(x == n){\r\n        if( m > res ) res = m;     \r\n        return ;\r\n     }     \r\n     \r\n     if(y == n) dfs(x+1,0,m);\r\n     else {\r\n        if(map[x][y] == ''.'' && check(x,y)){\r\n           map[x][y] = ''P'';\r\n           dfs(x,y+1,m+1);\r\n           map[x][y] = ''.'';\r\n        }\r\n        dfs(x,y+1,m);\r\n     }\r\n}\r\n\r\nint main(){\r\n   // freopen("1.in","r",stdin);\r\n   // freopen("1.out","w",stdout);\r\n    int i;\r\n    while(scanf("%d",&n)!=EOF&&n){\r\n        for(i = 0; i< n; ++i)\r\n            scanf("%s",map[i]);\r\n\r\n        res = 0;\r\n        dfs(0,0,0);\r\n        printf("%d\\n",res);\r\n    }    \r\n    return 0;\r\n}\r\n', '', 452, 258048, 1, 1, '2010-11-16 22:59:57', '0001-01-01 00:00:00'),
(927, 30, 335, 2, '#include<stdio.h>\r\n\r\nint bit_count(unsigned int n)\r\n{\r\nint count;\r\nfor(count = 0; n; n >>= 1)\r\n{\r\n       count += n & 1;\r\n}\r\nreturn count;\r\n}\r\n\r\nint main()\r\n{\r\n	int a,b,c;\r\n	while(scanf("%d %d",&a,&b) == 2)\r\n	{\r\n		c = a^b;\r\n		c = bit_count(c);\r\n		printf("%d\\n",c);\r\n	}\r\n	return 0;\r\n}', '', 78, 262144, 1, 2, '2010-11-17 08:16:23', '0001-01-01 00:00:00'),
(928, 30, 336, 2, '#include<stdio.h>\r\n#include<algorithm>\r\n\r\nstruct int_bit{\r\n	int num;\r\n	int sum;\r\n};\r\n\r\nint bit_count(unsigned int n)\r\n{\r\nint count;\r\nfor(count = 0; n; n >>= 1)\r\n{\r\n       count += n & 1;\r\n}\r\nreturn count;\r\n}\r\n\r\nbool compare(int_bit x,int_bit y)\r\n{\r\n	if(x.sum == y.sum)\r\n		return x.num < y.num;\r\n	else \r\n		return \r\n		x.sum < y.sum;\r\n}\r\n\r\nint main()\r\n{\r\n	int_bit nums[50001],Num;\r\n	int n,i;\r\n	while(scanf("%d",&n) == 1&&n)\r\n	{\r\n		for(i = 0;i < n;i++)\r\n		{\r\n			scanf("%d",&nums[i].num);\r\n			nums[i].sum = bit_count(nums[i].num);\r\n		}\r\n		std::sort(nums,nums+n,compare);\r\n		for(i = 0;i < n-1;i++)\r\n			printf("%d ",nums[i].num);\r\n		printf("%d\\n",nums[i].num);\r\n	}\r\n	return 0;\r\n}\r\n\r\n\r\n', '', 15, 622592, 4, 2, '2010-11-17 08:30:47', '0001-01-01 00:00:00'),
(929, 30, 336, 2, '#include<stdio.h>\r\n#include<algorithm>\r\n\r\nstruct int_bit{\r\n	int num;\r\n	int sum;\r\n};\r\n\r\nint bit_count(unsigned int n)\r\n{\r\nint count;\r\nfor(count = 0; n; n >>= 1)\r\n{\r\n       count += n & 1;\r\n}\r\nreturn count;\r\n}\r\n\r\nbool compare(int_bit x,int_bit y)\r\n{\r\n	if(x.sum == y.sum)\r\n		return x.num < y.num;\r\n	else \r\n		return x.sum < y.sum;\r\n}\r\n\r\nint main()\r\n{\r\n	int_bit nums[50001];\r\n	int n,i;\r\n	while(scanf("%d",&n) == 1&&n)\r\n	{\r\n		for(i = 0;i < n;i++)\r\n		{\r\n			scanf("%d",&nums[i].num);\r\n			nums[i].sum = bit_count(nums[i].num);\r\n		}\r\n		std::sort(nums,nums+n,compare);\r\n		for(i = 0;i < n-1;i++)\r\n			printf("%d ",nums[i].num);\r\n		printf("%d\\n",nums[i].num);\r\n	}\r\n	return 0;\r\n}\r\n\r\n\r\n', '', 15, 622592, 4, 2, '2010-11-17 08:33:13', '0001-01-01 00:00:00'),
(930, 30, 336, 2, '#include<stdio.h>\r\n#include<algorithm>\r\n\r\nstruct int_bit{\r\n	int num;\r\n	int sum;\r\n};\r\n\r\nint bit_count(unsigned int n)\r\n{\r\nint count;\r\nfor(count = 0; n; n >>= 1)\r\n{\r\n       count += n & 1;\r\n}\r\nreturn count;\r\n}\r\n\r\nbool compare(int_bit x,int_bit y)\r\n{\r\n	if(x.sum == y.sum)\r\n		return x.num < y.num;\r\n	else \r\n		return x.sum < y.sum;\r\n}\r\n\r\nint main()\r\n{\r\n	int_bit nums[50001];\r\n	int n,i;\r\n	while(scanf("%d",&n) == 1)\r\n	{\r\n		for(i = 0;i < n;i++)\r\n		{\r\n			scanf("%d",&nums[i].num);\r\n			nums[i].sum = bit_count(nums[i].num);\r\n		}\r\n		std::sort(nums,nums+n,compare);\r\n		for(i = 0;i < n-1;i++)\r\n			printf("%d ",nums[i].num);\r\n		printf("%d\\n",nums[i].num);\r\n	}\r\n	return 0;\r\n}\r\n\r\n\r\n', '', 15, 622592, 4, 2, '2010-11-17 08:34:38', '0001-01-01 00:00:00'),
(931, 30, 336, 2, '#include<stdio.h>\r\n#include<algorithm>\r\n\r\nstruct int_bit{\r\n	int num;\r\n	int sum;\r\n};\r\n\r\nint bit_count(unsigned int n)\r\n{\r\nint count;\r\nfor(count = 0; n; n >>= 1)\r\n{\r\n       count += n & 1;\r\n}\r\nreturn count;\r\n}\r\n\r\nbool compare(int_bit x,int_bit y)\r\n{\r\n	if(x.sum == y.sum)\r\n		return x.num < y.num;\r\n	else \r\n		return x.sum < y.sum;\r\n}\r\n\r\nint main()\r\n{\r\n	int n,i;\r\n	while(scanf("%d",&n) == 1)\r\n	{\r\n		int_bit nums[50001];\r\n		for(i = 0;i < n;i++)\r\n		{\r\n			scanf("%d",&nums[i].num);\r\n			nums[i].sum = bit_count(nums[i].num);\r\n		}\r\n		std::sort(nums,nums+n,compare);\r\n		for(i = 0;i < n-1;i++)\r\n			printf("%d ",nums[i].num);\r\n		printf("%d\\n",nums[i].num);\r\n	}\r\n	return 0;\r\n}\r\n\r\n\r\n', '', 15, 622592, 4, 2, '2010-11-17 08:56:57', '0001-01-01 00:00:00'),
(932, 27, 377, 6, '#include <stdio.h>\r\nfloat x1[300],x2[300],y1[300],y2[300];\r\n\r\nint judge(int i,int j)\r\n{\r\n	float a,b;\r\n	a=(x2[j]-x2[i])*(y1[i]-x1[i])-(x1[j]-x1[i])*(y2[i]-x2[i]);\r\n	b=(y2[j]-x2[i])*(y1[i]-x1[i])-(y1[j]-x1[i])*(y2[i]-x2[i]);\r\n	if( (a*b)<0 ) return 1;\r\n	else if(a==0.0){\r\n		if( (x1[j]>=x1[i] && x1[j]<=y1[i]) || (x1[j]<=x1[i] && x1[j]>=y1[i]) )\r\n		    return 1;\r\n	}\r\n	else if(b==0.0){    \r\n	    if( (y1[j]>=x1[i] && y1[j]<=y1[i]) || (y1[j]<=x1[i] && y1[j]>=y1[i]) )\r\n		    return 1;\r\n	}\r\n	else return 0;\r\n}\r\n\r\nint judge_intersete(int i,int j)\r\n{\r\n	if(judge(i,j)==1 && judge(j,i)==1)\r\n		return 1;\r\n	else return 0;\r\n}\r\n\r\nint main()\r\n{\r\n	int n,i,j,count;\r\n	while(scanf("%d",&n) && n>0){	\r\n		count=0;\r\n		for(i=0;i<n;++i){\r\n			scanf("%f %f %f %f",&x1[i],&x2[i],&y1[i],&y2[i]);\r\n		}\r\n		for(i=0;i<n-1;++i){\r\n			for(j=i+1;j<n;++j){\r\n				count+=judge_intersete(i,j);\r\n			}\r\n		}\r\n		printf("%d\\n",count);\r\n\r\n	}\r\n	return 0;\r\n}\r\n', '', 0, 262144, 4, 1, '2010-11-17 09:34:18', '0001-01-01 00:00:00'),
(933, 17, 377, 6, '#include<stdio.h>\r\n#include<iostream>\r\nusing namespace std;\r\n#define M 301\r\ntypedef struct point{\r\n        double x1,y1;\r\n        double x2,y2;\r\n}Point;\r\nPoint seg[M];\r\nint cal(Point p0,Point p1)\r\n{   \r\n     double z1,z2;\r\n     z1=(p0.x1-p1.x1)*(p1.y2-p1.y1)-(p0.y1-p1.y1)*(p1.x2-p1.x1);\r\n     z2=(p1.x2-p1.x1)*(p0.y2-p1.y1)-(p1.y2-p1.y1)*(p0.x2-p1.x1);\r\n     if(z1*z2>=0)\r\n       return 1;\r\n     else \r\n     return 0;\r\n}         \r\nint main()\r\n{\r\n    int i,test,j;\r\n    int count;\r\n    while(scanf("%d",&test)&&test!=0)\r\n    {   \r\n        count=0;\r\n        for(i=0;i<test;i++)\r\n          cin>>seg[i].x1>>seg[i].y1>>seg[i].x2>>seg[i].y2;\r\n        for(i=0;i<test;i++)\r\n         for(j=i+1;j<test;j++)\r\n          if(cal(seg[i],seg[j])&&cal(seg[j],seg[i]))\r\n           count++;\r\n        printf("%d\\n",count);\r\n    }\r\n}\r\n', '', 0, 380928, 4, 2, '2010-11-17 09:41:58', '0001-01-01 00:00:00'),
(934, 30, 344, 4, '#include<stdio.h>\r\n#include<string>\r\n#include<iostream>\r\n\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n	int n,i,sum;\r\n	string sna[20001];\r\n	while(scanf("%d",&n) == 1)\r\n	{\r\n		sum = 0;\r\n		for(i = 0;i < n;i++)\r\n			cin>>sna[i];\r\n		for(i = 0;i < n-1;i++)\r\n		{\r\n			if ( sna[n-1] == sna[i] )\r\n			{\r\n				sum = n-i-1;\r\n				break;\r\n			}\r\n		}\r\n		printf("%d\\n",sum);\r\n	}\r\n	return 0;\r\n}\r\n', '', 31, 880640, 1, 2, '2010-11-17 09:48:55', '0001-01-01 00:00:00'),
(935, 30, 377, 6, '#include<stdio.h>\r\n#include<math.h>\r\n#define eps 1e-8\r\n#define zero(x) (((x)>0?(x):-(x))<eps)\r\nstruct point{double x,y;};\r\n\r\n//计算交叉乘积(P1-P0)x(P2-P0)\r\ndouble xmult(point p1,point p2,point p0){\r\n return (p1.x-p0.x)*(p2.y-p0.y)-(p2.x-p0.x)*(p1.y-p0.y);\r\n}\r\n\r\n//判点是否在线段上,包括端点\r\nint dot_online_in(point p,point l1,point l2){\r\n return zero(xmult(p,l1,l2))&&(l1.x-p.x)*(l2.x-p.x)<eps&&(l1.y-p.y)*(l2.y-p.y)<eps;\r\n}\r\n\r\n//判两点在线段同侧,点在线段上返回0\r\nint same_side(point p1,point p2,point l1,point l2){\r\n return xmult(l1,p1,l2)*xmult(l1,p2,l2)>eps;\r\n}\r\n\r\n//判两直线平行\r\nint parallel(point u1,point u2,point v1,point v2){\r\n return zero((u1.x-u2.x)*(v1.y-v2.y)-(v1.x-v2.x)*(u1.y-u2.y));\r\n}\r\n\r\n//判三点共线\r\nint dots_inline(point p1,point p2,point p3){\r\n return zero(xmult(p1,p2,p3));\r\n}\r\n\r\n//判两线段相交,包括端点和部分重合\r\nint intersect_in(point u1,point u2,point v1,point v2){\r\n if (!dots_inline(u1,u2,v1)||!dots_inline(u1,u2,v2))\r\n  return !same_side(u1,u2,v1,v2)&&!same_side(v1,v2,u1,u2);\r\n return dot_online_in(u1,v1,v2)||dot_online_in(u2,v1,v2)||dot_online_in(v1,u1,u2)||dot_online_in(v2,u1,u2);\r\n}\r\n\r\n//计算两线段交点,请判线段是否相交(同时还是要判断是否平行!)\r\npoint intersection(point u1,point u2,point v1,point v2){\r\n point ret=u1;\r\n double t=((u1.x-v1.x)*(v1.y-v2.y)-(u1.y-v1.y)*(v1.x-v2.x))\r\n   /((u1.x-u2.x)*(v1.y-v2.y)-(u1.y-u2.y)*(v1.x-v2.x));\r\n ret.x+=(u2.x-u1.x)*t;\r\n ret.y+=(u2.y-u1.y)*t;\r\n return ret;\r\n}\r\n\r\nstruct seg{\r\n	point point1;\r\n	point point2;\r\n};\r\n\r\nint main()\r\n{\r\n	int n,i,j,sum;\r\n	seg segs[101];\r\n	while(scanf("%d",&n) == 1)\r\n	{\r\n		sum=n*(n-1)/2;\r\n		for(i = 0;i < n;i++)\r\n			scanf("%lf %lf %lf %lf",&segs[i].point1.x,\r\n				&segs[i].point1.y,&segs[i].point2.x,&segs[i].point2.y);\r\n		for(i = 0;i < n-1;i++)\r\n		{\r\n			for(j = i+1;j < n;j++)\r\n			{\r\n				if (parallel(segs[i].point1,segs[i].point2,segs[j].point1,segs[j].point2)\r\n					||!intersect_in(segs[i].point1,segs[i].point2,segs[j].point1,segs[j].point2))\r\n					sum--;\r\n			}\r\n		}\r\n		printf("%d\\n",sum);\r\n	}\r\n	return 0;\r\n} ', '', 0, 258048, 4, 2, '2010-11-17 10:05:18', '0001-01-01 00:00:00'),
(936, 30, 377, 6, '#include<stdio.h>\r\n#include<math.h>\r\n#define eps 1e-8\r\n#define zero(x) (((x)>0?(x):-(x))<eps)\r\nstruct point{double x,y;};\r\n\r\n//计算交叉乘积(P1-P0)x(P2-P0)\r\ndouble xmult(point p1,point p2,point p0){\r\n return (p1.x-p0.x)*(p2.y-p0.y)-(p2.x-p0.x)*(p1.y-p0.y);\r\n}\r\n\r\n//判点是否在线段上,包括端点\r\nint dot_online_in(point p,point l1,point l2){\r\n return zero(xmult(p,l1,l2))&&(l1.x-p.x)*(l2.x-p.x)<eps&&(l1.y-p.y)*(l2.y-p.y)<eps;\r\n}\r\n\r\n//判两点在线段同侧,点在线段上返回0\r\nint same_side(point p1,point p2,point l1,point l2){\r\n return xmult(l1,p1,l2)*xmult(l1,p2,l2)>eps;\r\n}\r\n\r\n//判两直线平行\r\nint parallel(point u1,point u2,point v1,point v2){\r\n return zero((u1.x-u2.x)*(v1.y-v2.y)-(v1.x-v2.x)*(u1.y-u2.y));\r\n}\r\n\r\n//判三点共线\r\nint dots_inline(point p1,point p2,point p3){\r\n return zero(xmult(p1,p2,p3));\r\n}\r\n\r\n//判两线段相交,包括端点和部分重合\r\nint intersect_in(point u1,point u2,point v1,point v2){\r\n if (!dots_inline(u1,u2,v1)||!dots_inline(u1,u2,v2))\r\n  return !same_side(u1,u2,v1,v2)&&!same_side(v1,v2,u1,u2);\r\n return dot_online_in(u1,v1,v2)||dot_online_in(u2,v1,v2)||dot_online_in(v1,u1,u2)||dot_online_in(v2,u1,u2);\r\n}\r\n\r\n\r\nstruct seg{\r\n	point point1;\r\n	point point2;\r\n};\r\n\r\nint main()\r\n{\r\n	int n,i,j,sum;\r\n	seg segs[101];\r\n	while(scanf("%d",&n) == 1)\r\n	{\r\n		sum=n*(n-1)/2;\r\n		for(i = 0;i < n;i++)\r\n			scanf("%lf %lf %lf %lf",&segs[i].point1.x,\r\n				&segs[i].point1.y,&segs[i].point2.x,&segs[i].point2.y);\r\n		for(i = 0;i < n-1;i++)\r\n		{\r\n			for(j = i+1;j < n;j++)\r\n			{\r\n				if (parallel(segs[i].point1,segs[i].point2,segs[j].point1,segs[j].point2)\r\n					||!intersect_in(segs[i].point1,segs[i].point2,segs[j].point1,segs[j].point2))\r\n					sum--;\r\n			}\r\n		}\r\n		printf("%d\\n",sum);\r\n	}\r\n	return 0;\r\n} ', '', 0, 258048, 4, 2, '2010-11-17 10:28:44', '0001-01-01 00:00:00'),
(937, 27, 377, 6, '#include <stdio.h>\r\nfloat x1[300],x2[300],y1[300],y2[300];\r\n\r\nint judge(int i,int j)\r\n{\r\n	float a,b;\r\n	a=(x2[j]-x2[i])*(y1[i]-x1[i])-(x1[j]-x1[i])*(y2[i]-x2[i]);\r\n	b=(y2[j]-x2[i])*(y1[i]-x1[i])-(y1[j]-x1[i])*(y2[i]-x2[i]);\r\n	if( (a*b)<0 )   return 1;  \r\n	else if(a*b==0.0){\r\n		if( (x1[j]>=x1[i] && x1[j]<=y1[i]) || (x1[j]<=x1[i] && x1[j]>=y1[i]) )\r\n		    return 1;\r\n		if( (y1[j]>=x1[i] && y1[j]<=y1[i]) || (y1[j]<=x1[i] && y1[j]>=y1[i]) )\r\n		    return 1;\r\n	}\r\n	else  return 0;\r\n}\r\n\r\nint judge_intersete(int i,int j)\r\n{\r\n	if(judge(i,j)==1 && judge(j,i)==1)\r\n		return 1;\r\n	else return 0;\r\n}\r\n\r\nint main()\r\n{\r\n	int n,i,j,count;\r\n	while(scanf("%d",&n) && n>0){	\r\n		count=0;\r\n		for(i=0;i<n;++i){\r\n			scanf("%f %f %f %f",&x1[i],&x2[i],&y1[i],&y2[i]);\r\n		}\r\n		for(i=0;i<n-1;++i){\r\n			for(j=i+1;j<n;++j){\r\n				count+=judge_intersete(i,j);\r\n			}\r\n		}\r\n		printf("%d\\n",count);\r\n\r\n	}\r\n	return 0;\r\n}\r\n\r\n', '', 61, 266240, 1, 1, '2010-11-17 10:29:48', '0001-01-01 00:00:00'),
(938, 30, 336, 2, '#include<stdio.h>\r\n#include<algorithm>\r\n\r\nstruct int_bit{\r\n	int num;\r\n	int sum;\r\n};\r\n\r\nint bit_count(unsigned int n)\r\n{\r\nint count;\r\nfor(count = 0; n; n >>= 1)\r\n{\r\n       count += n & 1;\r\n}\r\nreturn count;\r\n}\r\n\r\nbool compare(int_bit x,int_bit y)\r\n{\r\n	if(x.sum == y.sum)\r\n		return x.num < y.num;\r\n	else \r\n		return x.sum < y.sum;\r\n}\r\n\r\nint main()\r\n{\r\n	int n,i;\r\n	while(scanf("%d",&n) == 1)\r\n	{\r\n		int_bit nums[50001];\r\n		for(i = 0;i < n;i++)\r\n		{\r\n			scanf("%d",&nums[i].num);\r\n			nums[i].sum = bit_count(nums[i].num);\r\n		}\r\n		std::sort(nums,nums+n,compare);\r\n		for(i = 0;i < n;i++)\r\n			if(i!=n-1)\r\n				printf("%d ",nums[i].num);\r\n			else\r\n				printf("%d\\n",nums[i].num);\r\n	}\r\n	return 0;\r\n}\r\n', '', 15, 622592, 3, 2, '2010-11-17 10:33:14', '0001-01-01 00:00:00'),
(939, 30, 336, 2, '#include<stdio.h>\r\n#include<algorithm>\r\n\r\nstruct int_bit{\r\n	int num;\r\n	int sum;\r\n};\r\n\r\nint bit_count(unsigned int n)\r\n{\r\nint count;\r\nfor(count = 0; n; n >>= 1)\r\n{\r\n       count += n & 1;\r\n}\r\nreturn count;\r\n}\r\n\r\nbool compare(int_bit x,int_bit y)\r\n{\r\n	if(x.sum == y.sum)\r\n		return x.num < y.num;\r\n	else \r\n		return x.sum < y.sum;\r\n}\r\n\r\nint main()\r\n{\r\n	int n,i;\r\n	while(scanf("%d",&n) == 1)\r\n	{\r\n		int_bit nums[50001];\r\n		for(i = 0;i < n;i++)\r\n		{\r\n			scanf("%d",&nums[i].num);\r\n			nums[i].sum = bit_count(nums[i].num);\r\n		}\r\n		std::sort(nums,nums+n,compare);\r\n		for(i = 0;i < n;i++)\r\n			if(i != n-1)\r\n				printf("%d ",nums[i].num);\r\n			else\r\n				printf("%d \\n",nums[i].num);\r\n	}\r\n	return 0;\r\n}\r\n', '', 15, 622592, 3, 2, '2010-11-17 10:36:37', '0001-01-01 00:00:00'),
(940, 30, 336, 2, '#include<stdio.h>\r\n#include<algorithm>\r\n\r\nstruct int_bit{\r\n	int num;\r\n	int sum;\r\n};\r\n\r\nint bit_count(unsigned int n)\r\n{\r\nint count;\r\nfor(count = 0; n; n >>= 1)\r\n{\r\n       count += n & 1;\r\n}\r\nreturn count;\r\n}\r\n\r\nbool compare(int_bit x,int_bit y)\r\n{\r\n	if(x.sum == y.sum)\r\n		return x.num < y.num;\r\n	else \r\n		return x.sum < y.sum;\r\n}\r\n\r\nint main()\r\n{\r\n	int n,i;\r\n	while(scanf("%d",&n) == 1)\r\n	{\r\n		int_bit nums[50001];\r\n		for(i = 0;i < n;i++)\r\n		{\r\n			scanf("%d",&nums[i].num);\r\n			nums[i].sum = bit_count(nums[i].num);\r\n		}\r\n		std::sort(nums,nums+n,compare);\r\n		for(i = 0;i < n;i++)\r\n			if(i != n-1)\r\n				printf("%d ",nums[i].num);\r\n			else\r\n				printf("%d \\n",nums[i].num);\r\n	}\r\n	return 0;\r\n}\r\n', '', 15, 622592, 3, 2, '2010-11-17 10:42:31', '0001-01-01 00:00:00'),
(941, 30, 336, 2, '#include<stdio.h>\r\n#include<algorithm>\r\n\r\nstruct int_bit{\r\n	int num;\r\n	int sum;\r\n};\r\n\r\nint bit_count(unsigned int n)\r\n{\r\nint count;\r\nfor(count = 0; n; n >>= 1)\r\n{\r\n       count += n & 1;\r\n}\r\nreturn count;\r\n}\r\n\r\nbool compare(int_bit x,int_bit y)\r\n{\r\n	if(x.sum == y.sum)\r\n		return x.num < y.num;\r\n	else \r\n		return x.sum < y.sum;\r\n}\r\n\r\nint main()\r\n{\r\n	int n,i;\r\n	while(scanf("%d",&n) == 1)\r\n	{\r\n		if(!n)\r\n			continue;\r\n		int_bit nums[50001];\r\n		for(i = 0;i < n;i++)\r\n		{\r\n			scanf("%d",&nums[i].num);\r\n			nums[i].sum = bit_count(nums[i].num);\r\n		}\r\n		std::sort(nums,nums+n,compare);\r\n		printf("%d",nums[0].num);\r\n		for(i = 1;i < n;i++)\r\n			printf(" %d",nums[i].num);\r\n		printf("\\n");\r\n	}\r\n	return 0;\r\n}\r\n', '', 31, 626688, 3, 2, '2010-11-17 10:48:11', '0001-01-01 00:00:00'),
(942, 6, 140, 0, '#include <stdio.h>\r\n#include <algorithm>\r\nusing namespace std;\r\n#define N 200\r\n\r\nstruct Block{\r\n    int x,y,z;\r\n}b[N];\r\nint h[N];\r\n\r\nbool cmp(const Block& a, const Block& b){\r\n    if(a.x == a.x) return a.y > b.y;\r\n    else           return a.x > b.x;\r\n}\r\n\r\nint main(){\r\n    int i, j, x, y, z, tmp, res, n, cnt =1;\r\n    while(scanf("%d",&n)!=EOF && n){\r\n       for(i = 0; i < n; ++i){\r\n           scanf("%d %d %d",&x,&y,&z);\r\n           b[6*i].x = x, b[6*i].y = y, b[6*i].z = z; \r\n           b[6*i+1].x = x, b[6*i+1].y = z, b[6*i+1].z = y;\r\n           b[6*i+2].x = y, b[6*i+2].y = x, b[6*i+2].z = z;\r\n           b[6*i+3].x = y, b[6*i+3].y = z, b[6*i+3].z = x;\r\n           b[6*i+4].x = z, b[6*i+4].y = x, b[6*i+4].z = y;\r\n           b[6*i+5].x = z, b[6*i+5].y = y, b[6*i+5].z = x;\r\n       }\r\n       sort(b, b+6*n, cmp);\r\n       \r\n       h[0] = b[0].z;\r\n       for(i = 1; i < 6*n; ++i){\r\n           tmp = 0;\r\n           for(j = 0; j < i; ++j){\r\n               if(b[j].x > b[i].x && b[j].y > b[i].y && h[j] > tmp)\r\n                  tmp = h[j];\r\n           }\r\n           h[i] = tmp + b[i].z;\r\n       }\r\n       \r\n       res = h[0];\r\n       for(i = 1; i < 6*n; ++i){\r\n           if(h[i] > res) res = h[i];\r\n       }\r\n       printf("Case %d: maximum height = %d\\n",cnt++,res);       \r\n    } \r\n    return 0;\r\n}', '', 0, 262144, 1, 2, '2010-11-17 11:06:48', '0001-01-01 00:00:00'),
(943, 6, 141, 0, '#include <stdio.h>\r\n#define N 6000\r\n#define min(a,b) ((a)<(b)?(a):(b))\r\n#define min4(a,b,c,d) min(min(a,b),min(c,d))\r\nint q[N];\r\n\r\nint main() {\r\n    int n, p2 ,p3, p5, p7;\r\n    \r\n    q[1] = n = p2 = p3 = p5 = p7 = 1;\r\n    while(n <= 5900) {\r\n        q[++n] = min4(2*q[p2],3*q[p3],5*q[p5],7*q[p7]);\r\n        if(q[n] == 2*q[p2]) ++p2;\r\n        if(q[n] == 3*q[p3]) ++p3;\r\n        if(q[n] == 5*q[p5]) ++p5;\r\n        if(q[n] == 7*q[p7]) ++p7;\r\n    }\r\n    \r\n    while(scanf("%d",&n)!=EOF && n){\r\n        printf("The %d",n);\r\n        if     (n%10 == 1 && n/10%10 != 1) printf("st");\r\n        else if(n%10 == 2 && n/10%10 != 2) printf("nd");\r\n        else if(n%10 == 3 && n/10%10 != 3) printf("rd");\r\n        else                               printf("th");\r\n        printf(" humble number is %d.\\n",q[n]);\r\n    }\r\n    return 0;\r\n}\r\n', '', 15, 278528, 4, 1, '2010-11-17 13:30:27', '0001-01-01 00:00:00'),
(944, 6, 141, 0, '#include <stdio.h>\r\n#define N 6000\r\n#define min(a,b) ((a)<(b)?(a):(b))\r\n#define min4(a,b,c,d) min(min(a,b),min(c,d))\r\nint q[N];\r\n\r\nint main() {\r\n    int n, p2 ,p3, p5, p7;\r\n    \r\n    q[1] = n = p2 = p3 = p5 = p7 = 1;\r\n    while(n <= 5900) {\r\n        q[++n] = min4(2*q[p2],3*q[p3],5*q[p5],7*q[p7]);\r\n        if(q[n] == 2*q[p2]) ++p2;\r\n        if(q[n] == 3*q[p3]) ++p3;\r\n        if(q[n] == 5*q[p5]) ++p5;\r\n        if(q[n] == 7*q[p7]) ++p7;\r\n    }\r\n    \r\n    while(scanf("%d",&n)!=EOF && n){\r\n        printf("The %d",n);\r\n        if     (n%10 == 1 && n/10%10 != 1) printf("st");\r\n        else if(n%10 == 2 && n/10%10 != 1) printf("nd");\r\n        else if(n%10 == 3 && n/10%10 != 1) printf("rd");\r\n        else                               printf("th");\r\n        printf(" humble number is %d.\\n",q[n]);\r\n    }\r\n    return 0;\r\n}', '', 0, 278528, 1, 1, '2010-11-17 13:31:28', '0001-01-01 00:00:00'),
(945, 30, 336, 2, '#include<stdio.h>\r\n#include<algorithm>\r\n\r\nstruct int_bit{\r\n	int num;\r\n	int sum;\r\n};\r\n\r\nint bit_count(unsigned int n)\r\n{\r\nint count;\r\nfor(count = 0; n; n >>= 1)\r\n{\r\n       count += n & 1;\r\n}\r\nreturn count;\r\n}\r\n\r\nbool compare(int_bit x,int_bit y)\r\n{\r\n	if(x.sum == y.sum)\r\n		return x.num < y.num;\r\n	else \r\n		return x.sum < y.sum;\r\n}\r\n\r\nint main()\r\n{\r\n	int n,i;\r\n	while(scanf("%d",&n) == 1)\r\n	{\r\n		int_bit nums[50001];\r\n		for(i = 0;i < n;i++)\r\n		{\r\n			scanf("%d",&nums[i].num);\r\n			nums[i].sum = bit_count(nums[i].num);\r\n		}\r\n		std::sort(nums,nums+n,compare);\r\n		for(i = 0;i < n;i++)\r\n			if(i == 0)\r\n				printf("%d",nums[i].num);\r\n			else\r\n				printf(" %d",nums[i].num);\r\n		printf("\\n");\r\n	}\r\n	return 0;\r\n}\r\n', '', 76, 622592, 1, 2, '2010-11-17 14:47:41', '0001-01-01 00:00:00'),
(946, 6, 163, 0, '#include <math.h>\r\n#include <stdio.h>\r\nchar buf[5];\r\ndouble x, y;\r\ndouble de;\r\n\r\nvoid xuan(int d) {\r\n    de += (double)d;\r\n}\r\n\r\nvoid cal(int len) {\r\n    x += len * cos(de/180*M_PI); \r\n    y += len * sin(de/180*M_PI);\r\n}\r\n\r\nint main() {\r\n    int T, n, d;\r\n    scanf("%d",&T);\r\n    while(T--) {\r\n       de = x = y = 0;\r\n       scanf("%d",&n);\r\n       while(n--) {\r\n          scanf("%s %d",buf,&d);\r\n          switch(buf[0]) {\r\n             case ''f'': cal(d);  break;\r\n             case ''b'': cal(d);  break;\r\n             case ''l'': xuan(d); break;\r\n             case ''r'': xuan(d); break;\r\n          } \r\n       }\r\n       printf("%.0lf\\n",sqrt(x*x+y*y));\r\n    }\r\n    return 0;\r\n}', '', 31, 258048, 4, 1, '2010-11-17 20:50:21', '0001-01-01 00:00:00'),
(947, 6, 163, 0, '#include <math.h>\r\n#include <stdio.h>\r\nchar buf[5];\r\ndouble x, y;\r\ndouble de;\r\n\r\nvoid xuan(int d) {\r\n    de += (double)d;\r\n}\r\n\r\nvoid cal(int len) {\r\n    x += 1.0 * len * cos(de/180*M_PI); \r\n    y += 1.0 * len * sin(de/180*M_PI);\r\n}\r\n\r\nint main() {\r\n    int T, n, d;\r\n    freopen("163.in","r",stdin);\r\n    freopen("163.out","w",stdout);\r\n    scanf("%d",&T);\r\n    while(T--) {\r\n       de = x = y = 0;\r\n       scanf("%d",&n);\r\n       while(n--) {\r\n          scanf("%s %d",buf,&d);\r\n          switch(buf[0]) {\r\n             case ''f'': cal(d);  break;\r\n             case ''b'': cal(-d);  break;\r\n             case ''l'': xuan(d); break;\r\n             case ''r'': xuan(-d); break;\r\n          } \r\n       }\r\n       printf("%.0lf\\n",sqrt(x*x+y*y));\r\n    }\r\n    return 0;\r\n}\r\n', '', 15, 258048, 4, 1, '2010-11-17 21:35:00', '0001-01-01 00:00:00'),
(948, 6, 163, 0, '#include <math.h>\r\n#include <stdio.h>\r\nchar buf[5];\r\ndouble x, y;\r\ndouble de;\r\n\r\nvoid xuan(int d) {\r\n    de += (double)d;\r\n}\r\n\r\nvoid cal(int len) {\r\n    x += 1.0 * len * cos(de/180*M_PI); \r\n    y += 1.0 * len * sin(de/180*M_PI);\r\n}\r\n\r\nint main() {\r\n    int T, n, d;\r\n    scanf("%d",&T);\r\n    while(T--) {\r\n       de = x = y = 0;\r\n       scanf("%d",&n);\r\n       while(n--) {\r\n          scanf("%s %d",buf,&d);\r\n          switch(buf[0]) {\r\n             case ''f'': cal(d);  break;\r\n             case ''b'': cal(-d);  break;\r\n             case ''l'': xuan(d); break;\r\n             case ''r'': xuan(-d); break;\r\n          } \r\n       }\r\n       printf("%.0lf\\n",sqrt(x*x+y*y));\r\n    }\r\n    return 0;\r\n}', '', 31, 258048, 1, 1, '2010-11-17 21:38:48', '0001-01-01 00:00:00'),
(949, 21, 335, 2, '#include<stdio.h>\r\nint bit_count(unsigned int n)\r\n{\r\nint count;\r\nfor(count = 0; n; n &= n - 1)\r\n{\r\n       count++;\r\n}\r\nreturn count;\r\n}\r\n\r\n\r\n\r\nint main(){\r\n	int a,b,c;\r\n	while(scanf("%d%d",&a,&b)){\r\n		c=a^b;\r\n		c=bit_count(c);\r\n		printf("%d\\n",c);\r\n	}\r\n	return 0;\r\n}', '', 100, 258048, 5, 1, '2010-11-18 13:04:09', '0001-01-01 00:00:00'),
(950, 21, 335, 2, '#include<stdio.h>\r\n\r\nint main(){\r\n	int a,b,n,count;\r\n	while(scanf("%d%d",&a,&b)){\r\n		n=a^b;\r\n	for(count = 0; n; n &= n - 1)\r\n	{\r\n       count++;\r\n	}\r\n		printf("%d\\n",count);\r\n	}\r\n	return 0;\r\n}', '', 100, 262144, 5, 1, '2010-11-18 13:07:06', '0001-01-01 00:00:00'),
(951, 21, 335, 2, '#include<stdio.h>\r\nint main(){\r\n	unsigned int a,b,count;\r\n	while(scanf("%d%d",&a,&b)){\r\n		for(count = 0; a||b; a >>= 1,b>>=1)\r\n		{\r\n			count += (a & 1 ) ^ ( b & 1 );\r\n		}\r\n		printf("%d\\n",count);\r\n	}\r\n\r\n	return 0;\r\n}', '', 100, 258048, 5, 1, '2010-11-18 13:31:20', '0001-01-01 00:00:00'),
(952, 21, 335, 2, '#include<stdio.h>\r\n\r\nint main(){\r\n	unsigned int a,b,count;\r\n	while(scanf("%d%d",&a,&b)){\r\n		for(count = 0; a||b; a >>= 1,b>>=1)\r\n		{\r\n			if((a & 1 )!=( b & 1 ))count++;\r\n		}\r\n		printf("%d\\n",count);\r\n	}\r\n\r\n	return 0;\r\n}', '', 100, 258048, 5, 1, '2010-11-18 13:34:53', '0001-01-01 00:00:00'),
(953, 21, 335, 2, '#include<stdio.h>\r\nint count(int a, int b)\r\n{\r\n    unsigned int n1,n2,num=0;\r\n    n1=a-(a&(a-1));\r\n    n2=b-(b&(b-1));\r\n     while((n1!=0)&&(n2!=0))\r\n    {\r\n        if(n1==n2)\r\n        {\r\n            a&=~n1;\r\n            b&=~n2;\r\n            n1=a-(a&(a-1));\r\n            n2=b-(b&(b-1));\r\n        }\r\n        else\r\n        {\r\n            num++;\r\n            if(n1<n2)\r\n            {a&=(~n1);n1=a-(a&(a-1));\r\n            }\r\n            else\r\n            {b&=(~n2);n2=b-(b&(b-1));\r\n            }\r\n        }\r\n    }\r\n    while(n1!=0)\r\n    {\r\n     num++;a&=(~n1);n1=a-(a&(a-1));\r\n    }\r\n    while(n2!=0)\r\n    {num++;b&=(~n2);n2=b-(b&(b-1));\r\n    }\r\n    return num;\r\n}\r\n\r\nint main(){\r\n	unsigned int a,b,n;\r\n	while(scanf("%d%d",&a,&b)){\r\n		n=count(a,b);\r\n		printf("%d\\n",n);\r\n	}\r\n	return 0;\r\n}', '', 100, 258048, 5, 1, '2010-11-18 13:48:15', '0001-01-01 00:00:00'),
(954, 21, 335, 2, '#include<stdio.h>\r\nint main(){\r\n	unsigned int a,b,n,count;\r\n	while(scanf("%d%d",&a,&b)==2){\r\n		n=a^b;\r\n	for(count = 0; n; n &= n - 1)\r\n	{\r\n       count++;\r\n	}\r\n		printf("%d\\n",count);\r\n	}\r\n	return 0;\r\n}', '', 62, 262144, 1, 1, '2010-11-18 13:51:16', '0001-01-01 00:00:00'),
(955, 6, 4, 0, '#include <stdio.h>\r\n#include <string.h>\r\n#define N  5500\r\n#define M  100000\r\nstruct Edge {\r\n    int v;\r\n    int next;\r\n}et[M];\r\nint  mp, head[N], sta[N], belong[N];\r\nint  dfn[N], low[N], d[N];\r\nint  vcnt, bcnt, scnt, n, m;\r\nchar in[N];\r\n\r\nvoid tarjan(int i) {\r\n    int p, j;\r\n    dfn[i] = low[i] = ++vcnt;\r\n    in[i] = 1, sta[++scnt] = i;\r\n    for(int p = head[i]; p != -1; p = et[p].next) {\r\n        j = et[p].v;\r\n        if(dfn[j] == 0){\r\n           tarjan(j);\r\n           if(low[j] < low[i]) low[i] = low[j];\r\n        }\r\n        else if(in[j] && dfn[j] < low[i])\r\n            low[i] = dfn[j];\r\n    }\r\n    \r\n    if(dfn[i] == low[i]) {\r\n       ++bcnt;\r\n       do {\r\n           j = sta[scnt--];\r\n           in[j] = 0;\r\n           belong[j] = bcnt;\r\n       }while(j != i);\r\n    }\r\n}\r\n\r\nvoid add(int a, int b) {\r\n    et[mp].v = b;\r\n    et[mp].next = head[a];\r\n    head[a] = mp++;\r\n}\r\n\r\nvoid init() {\r\n     int a, b;\r\n     scanf("%d",&m);\r\n     mp = 0;\r\n     memset(head, -1, sizeof(head));\r\n     while(m--) {\r\n        scanf("%d %d",&a,&b);\r\n        add(a,b);\r\n     }\r\n}\r\n\r\nvoid solve() {\r\n    int i, j, v;\r\n    init();\r\n    vcnt = scnt = bcnt = 0;\r\n    memset(dfn, 0, sizeof(dfn));\r\n    for(i = 1; i <= n; ++i) {\r\n        if(dfn[i] == 0) tarjan(i);\r\n    }\r\n    if(bcnt == 1) {\r\n       for(i = 1; i < n; ++i)\r\n           printf("%d ",i);\r\n       printf("%d\\n",i);\r\n       return ;\r\n    }\r\n    \r\n    memset(d, 0, sizeof(d));\r\n    for(i = 1; i <= n; ++i) {\r\n        for(j = head[i]; j != -1; j = et[j].next) {\r\n            v = et[j].v;\r\n            if(belong[i] != belong[v]) \r\n               ++d[ belong[i] ];\r\n        }\r\n    }\r\n    \r\n    char f = 0;\r\n    for(i = 1; i <= n; ++i) {\r\n        if(d[ belong[i] ] == 0) {\r\n           if(f == 1) printf(" ");\r\n           else       f = 1;\r\n           printf("%d",i);\r\n        }\r\n    }\r\n    printf("\\n");\r\n}\r\n\r\nint main() {\r\n    while(scanf("%d",&n)!=EOF && n) \r\n       solve();\r\n    return 0;\r\n}', 'Main.c: In function ''tarjan'':\r\nMain.c:18:13: error: redeclaration of ''p'' with no linkage\r\nMain.c:15:9: note: previous declaration of ''p'' was here\r\nMain.c:18:5: error: ''for'' loop initial declarations are only allowed in C99 mode\r\nMain.c:18:5: note: use option -std=c99 or -std=gnu99 to compile your code\r\n', 0, 0, 2, 1, '2010-11-18 15:56:37', '0001-01-01 00:00:00'),
(956, 6, 4, 0, '#include <stdio.h>\r\n#include <string.h>\r\n#define N  5500\r\n#define M  100000\r\nstruct Edge {\r\n    int v;\r\n    int next;\r\n}et[M];\r\nint  mp, head[N], sta[N], belong[N];\r\nint  dfn[N], low[N], d[N];\r\nint  vcnt, bcnt, scnt, n, m;\r\nchar in[N];\r\n\r\nvoid tarjan(int i) {\r\n    int p, j;\r\n    dfn[i] = low[i] = ++vcnt;\r\n    in[i] = 1, sta[++scnt] = i;\r\n    for(p = head[i]; p != -1; p = et[p].next) {\r\n        j = et[p].v;\r\n        if(dfn[j] == 0){\r\n           tarjan(j);\r\n           if(low[j] < low[i]) low[i] = low[j];\r\n        }\r\n        else if(in[j] && dfn[j] < low[i])\r\n            low[i] = dfn[j];\r\n    }\r\n    \r\n    if(dfn[i] == low[i]) {\r\n       ++bcnt;\r\n       do {\r\n           j = sta[scnt--];\r\n           in[j] = 0;\r\n           belong[j] = bcnt;\r\n       }while(j != i);\r\n    }\r\n}\r\n\r\nvoid add(int a, int b) {\r\n    et[mp].v = b;\r\n    et[mp].next = head[a];\r\n    head[a] = mp++;\r\n}\r\n\r\nvoid init() {\r\n     int a, b;\r\n     scanf("%d",&m);\r\n     mp = 0;\r\n     memset(head, -1, sizeof(head));\r\n     while(m--) {\r\n        scanf("%d %d",&a,&b);\r\n        add(a,b);\r\n     }\r\n}\r\n\r\nvoid solve() {\r\n    int i, j, v;\r\n    init();\r\n    vcnt = scnt = bcnt = 0;\r\n    memset(dfn, 0, sizeof(dfn));\r\n    for(i = 1; i <= n; ++i) {\r\n        if(dfn[i] == 0) tarjan(i);\r\n    }\r\n    if(bcnt == 1) {\r\n       for(i = 1; i < n; ++i)\r\n           printf("%d ",i);\r\n       printf("%d\\n",i);\r\n       return ;\r\n    }\r\n    \r\n    memset(d, 0, sizeof(d));\r\n    for(i = 1; i <= n; ++i) {\r\n        for(j = head[i]; j != -1; j = et[j].next) {\r\n            v = et[j].v;\r\n            if(belong[i] != belong[v]) \r\n               ++d[ belong[i] ];\r\n        }\r\n    }\r\n    \r\n    char f = 0;\r\n    for(i = 1; i <= n; ++i) {\r\n        if(d[ belong[i] ] == 0) {\r\n           if(f == 1) printf(" ");\r\n           else       f = 1;\r\n           printf("%d",i);\r\n        }\r\n    }\r\n    printf("\\n");\r\n}\r\n\r\nint main() {\r\n    while(scanf("%d",&n)!=EOF && n) \r\n       solve();\r\n    return 0;\r\n}', '', 31, 1273856, 1, 1, '2010-11-18 15:57:10', '0001-01-01 00:00:00'),
(957, 6, 327, 0, '#include <stdio.h>\r\ntypedef long long LL;\r\n#define N 10000000\r\nLL a[N];\r\n\r\nLL minx(LL x, LL y, LL z) {  \r\n   if(x > y) x = y;\r\n   if(x > z) x = z;\r\n   return x;\r\n}\r\n \r\nint main() {\r\n    int p1, p2, p3, t1, t2, t3, i, n;\r\n    while(scanf("%d %d %d %d",&p1,&p2,&p3,&n)!=EOF) {\r\n        a[1] = i = t1 = t2 = t3 = 1;\r\n        while(i <= n) {\r\n           a[++i] = minx(p1*a[t1], p2*a[t2], p3*a[t3]);\r\n           if(a[i] == p1*a[t1]) ++t1;\r\n           if(a[i] == p2*a[t2]) ++t2;\r\n           if(a[i] == p3*a[t3]) ++t3;\r\n        }\r\n        printf("%lld\\n",a[n+1]);\r\n    }\r\n    return 0;\r\n}', '', 0, 33554432, 6, 1, '2010-11-18 16:37:36', '0001-01-01 00:00:00'),
(958, 6, 327, 0, '#include <stdio.h>\r\ntypedef long long LL;\r\n#define N 1000000\r\nLL a[N];\r\n\r\nLL minx(LL x, LL y, LL z) {  \r\n   if(x > y) x = y;\r\n   if(x > z) x = z;\r\n   return x;\r\n}\r\n \r\nint main() {\r\n    int p1, p2, p3, t1, t2, t3, i, n;\r\n    while(scanf("%d %d %d %d",&p1,&p2,&p3,&n)!=EOF) {\r\n        a[1] = i = t1 = t2 = t3 = 1;\r\n        while(i <= n) {\r\n           a[++i] = minx(p1*a[t1], p2*a[t2], p3*a[t3]);\r\n           if(a[i] == p1*a[t1]) ++t1;\r\n           if(a[i] == p2*a[t2]) ++t2;\r\n           if(a[i] == p3*a[t3]) ++t3;\r\n        }\r\n        printf("%lld\\n",a[n+1]);\r\n    }\r\n    return 0;\r\n}\r\n', '', 0, 8269824, 1, 1, '2010-11-18 16:37:53', '0001-01-01 00:00:00'),
(959, 21, 336, 2, '#include<stdio.h>\r\n\r\nint bit_count(int n){\r\n	int count;\r\n	for(count = 0; n; n &= n - 1)\r\n	{\r\n       count++;\r\n	}	\r\n	return count;\r\n}\r\n\r\n\r\nint main(){\r\n	int n,a[50000],i,j,temp;\r\n	while(scanf("%d",&n)!=EOF){\r\n	for(i=0;i<n;i++)\r\n	{\r\n		int c;\r\n		scanf("%d",&c);\r\n		a[i]=c;\r\n	}\r\n\r\n	for(i=0;i<n-1;i++){\r\n		for(j=0;j<n-1-i;j++){\r\n			if(bit_count(a[j])>bit_count(a[j+1])){temp=a[j];a[j]=a[j+1];a[j+1]=temp;}\r\n			if(bit_count(a[j])==bit_count(a[j+1])){\r\n				if(a[j]>a[j+1]){temp=a[j];a[j]=a[j+1];a[j+1]=temp;}\r\n			}\r\n		}\r\n	}\r\n\r\n	for(i=0;i<n;i++)printf("%d ",a[i]);\r\n	printf("\\n");\r\n	}\r\n	return 0;		\r\n}', '', 200, 417792, 5, 1, '2010-11-20 11:15:39', '0001-01-01 00:00:00'),
(960, 21, 336, 2, '#include<stdio.h>\r\n\r\nint bit_count(int n){\r\n	int count;\r\n	for(count = 0; n; n &= n - 1)\r\n	{\r\n       count++;\r\n	}	\r\n	return count;\r\n}\r\n\r\n\r\nint main(){\r\n	int n,a[50000],i,j,temp,c;\r\n	while(scanf("%d",&n)==1){\r\n	for(i=0;i<n;i++)\r\n	{\r\n		scanf("%d",&c);\r\n		a[i]=c;\r\n	}\r\n\r\n	for(i=0;i<n-1;i++){\r\n		for(j=0;j<n-1-i;j++){\r\n			if(bit_count(a[j])>bit_count(a[j+1])){temp=a[j];a[j]=a[j+1];a[j+1]=temp;}\r\n			if(bit_count(a[j])==bit_count(a[j+1])){\r\n				if(a[j]>a[j+1]){temp=a[j];a[j]=a[j+1];a[j+1]=temp;}\r\n			}\r\n		}\r\n	}\r\n\r\n	for(i=0;i<n;i++)printf("%d ",a[i]);\r\n	printf("\\n");\r\n	}\r\n	return 0;		\r\n}', '', 200, 417792, 5, 1, '2010-11-20 11:22:55', '0001-01-01 00:00:00'),
(961, 21, 336, 2, '#include<stdio.h>\r\n\r\nint bit_count(int n){\r\n	int count;\r\n	for(count = 0; n; n &= n - 1)\r\n	{\r\n       count++;\r\n	}	\r\n	return count;\r\n}\r\n\r\n\r\nint main(){\r\n	int n,a[50000][2],i,j,temp,c;\r\n	while(scanf("%d",&n)==1){\r\n	for(i=0;i<n;i++)\r\n	{\r\n		scanf("%d",&c);\r\n		a[i][0]=c;\r\n		a[i][1]=bit_count(a[i][0]);\r\n	}\r\n\r\n	for(i=0;i<n-1;i++){\r\n		for(j=0;j<n-1-i;j++){\r\n			if(a[j][1]>a[j+1][1]){\r\n				temp=a[j][0];a[j][0]=a[j+1][0];a[j+1][0]=temp;\r\n				temp=a[j][1];a[j][1]=a[j+1][1];a[j+1][1]=temp;\r\n			}\r\n			if(a[j][1]==a[j+1][1]){\r\n				if(a[j][0]>a[j+1][0]){\r\n				temp=a[j][0];a[j][0]=a[j+1][0];a[j+1][0]=temp;\r\n				temp=a[j][1];a[j][1]=a[j+1][1];a[j+1][1]=temp;}\r\n			}\r\n		}\r\n	}\r\n\r\n	for(i=0;i<n;i++)printf("%d ",a[i][0]);\r\n	printf("\\n");\r\n	}\r\n	return 0;		\r\n}', '', 200, 626688, 5, 1, '2010-11-20 14:04:15', '0001-01-01 00:00:00'),
(962, 21, 336, 2, '#include<stdio.h>\r\n\r\nint bit_count(int n){\r\n	int count;\r\n	for(count = 0; n; n &= n - 1)\r\n	{\r\n       count++;\r\n	}	\r\n	return count;\r\n}\r\n\r\n\r\nint main(){\r\n	int n,a[50000][2],i,j,temp,c;\r\n	while(scanf("%d",&n)==1){\r\n	for(i=0;i<n;i++)\r\n	{\r\n		scanf("%d",&c);\r\n		a[i][0]=c;\r\n		a[i][1]=bit_count(c);\r\n	}\r\n\r\n	for(i=0;i<n-1;i++){\r\n		for(j=0;j<n-1-i;j++){\r\n			if((a[j][1]>a[j+1][1])||((a[j][1]==a[j+1][1])&&(a[j][0]>a[j+1][0]))){\r\n				temp=a[j][0];a[j][0]=a[j+1][0];a[j+1][0]=temp;\r\n				temp=a[j][1];a[j][1]=a[j+1][1];a[j+1][1]=temp;\r\n			}\r\n		}\r\n	}\r\n\r\n	for(i=0;i<n;i++)printf("%d ",a[i][0]); \r\n	printf("\\n");\r\n	}\r\n	return 0;		\r\n}', '', 200, 606208, 5, 1, '2010-11-20 15:36:23', '0001-01-01 00:00:00'),
(963, 6, 261, 0, '#include <cstdio>\r\n#include <cstring>\r\n#include <map>\r\n#include <string>\r\nusing std::map; using std::string;\r\n\r\nint main()\r\n{\r\n    int n, m, f;\r\n    int val, res;\r\n    char str[100];\r\n    map<string,int> mp;\r\n    map<string,int>::iterator it;\r\n    f = 0;\r\n    while(scanf("%d %d",&n,&m)!=EOF) {\r\n       if(f == 1) mp.clear();\r\n       while(n--) {\r\n          scanf("%s %d",str,&val);\r\n          mp[str] = val;\r\n       }\r\n       while(m--) {\r\n          res = 0;\r\n          while(1) {\r\n             scanf("%s",str);\r\n             if(strcmp(str,".") == 0) break;\r\n             it = mp.find(str);\r\n             if(it != mp.end()) res += it->second;\r\n          }\r\n          printf("%d\\n",res);\r\n       }\r\n       f = 1;\r\n    }    \r\n    return 0;\r\n}', '', 0, 397312, 1, 2, '2010-11-21 20:16:51', '0001-01-01 00:00:00');
INSERT INTO `tbl_submitions` (`id`, `user_id`, `problem_id`, `exercise_id`, `source`, `result`, `used_time`, `used_memory`, `status`, `compiler_id`, `created`, `modified`) VALUES
(964, 6, 262, 0, '#include <stdio.h>\r\n#include <string.h>\r\n#define INF 1<<29\r\n#define N 16\r\nint d[N][N], n, m;\r\nint cost[1<<N];\r\n\r\nint match(int e)\r\n{\r\n    if(!e)           return 0;\r\n    if(cost[e] != 0) return cost[e];\r\n    \r\n    int i, j, k, best = INF;\r\n    for(i = 1; (e&(1<<i)) != 0; ++i) {\r\n        for(j = i+1; j <= n; ++j) {\r\n            if((e&(1<<j)) == 0) continue;\r\n            k = match(e - (1<<i) - (1<<j));\r\n            if(d[i][j] + k < best) best = d[i][j] + k;\r\n        }\r\n    }\r\n    return cost[e] = best;\r\n}\r\n\r\nint main()\r\n{\r\n    int e, tot, i, j, k;\r\n    while(scanf("%d",&n)!=EOF) {\r\n        if(n == 0) break;\r\n        scanf("%d",&m);\r\n        for(i = 1; i <= n; ++i) { \r\n            for(j = i; j <= n; ++j) {\r\n                if(i == j) d[i][j] = 0;\r\n                else       d[i][j] = d[j][i]= INF; \r\n            }\r\n        }\r\n        memset(cost, 0, sizeof(cost));\r\n        e = tot = 0;\r\n        while(m--) {\r\n           scanf("%d %d %d",&i,&j,&k);\r\n           if(k < d[i][j]) d[i][j] = d[j][i] = k;\r\n           tot += k;\r\n           e ^= (1<<i);\r\n           e ^= (1<<j);\r\n        }\r\n        for(i = 1; i <= n; ++i) {\r\n            for(j = 1; j <= n; ++j) {\r\n                for(k = 1; k <= n; ++k) {\r\n                    if(d[i][k]+d[k][j] < d[i][j])\r\n                       d[i][j] = d[i][k] + d[k][j];\r\n                }\r\n            }\r\n        }\r\n        printf("%d\\n",tot+match(e));\r\n    }\r\n    return 0;\r\n}\r\n', '', 15, 520192, 4, 1, '2010-11-21 21:33:41', '0001-01-01 00:00:00'),
(965, 6, 262, 0, '#include <stdio.h>\r\n#include <string.h>\r\n#define INF 1000000\r\n#define N 16\r\nint d[N][N], n, m;\r\nint cost[1<<N];\r\n\r\nint match(int e)\r\n{\r\n    if(e == 0)        return 0;\r\n    if(cost[e] != 0)  return cost[e];\r\n    \r\n    int i, j, k, best = -1;\r\n    for(i = 1; i <= n && (e&(1<<i)) == 0; ++i) ;\r\n    for(j = i+1; j <= n; ++j) {\r\n        if((e&(1<<j)) == 0) continue;\r\n        k = match(e - (1<<i) - (1<<j));\r\n        if(best == -1 || d[i][j] + k < best)  best = d[i][j] + k;\r\n    }\r\n    return cost[e] = best;\r\n}\r\n\r\nint main()\r\n{\r\n    int e, tot, i, j, k;\r\n    while(scanf("%d",&n)!=EOF) {\r\n        if(n == 0) break;\r\n        scanf("%d",&m);\r\n        for(i = 1; i <= n; ++i) { \r\n            for(j = i; j <= n; ++j) {\r\n                if(i == j) d[i][j] = 0;\r\n                else       d[i][j] = d[j][i] = INF;\r\n            }\r\n        }\r\n        memset(cost, 0, sizeof(cost));\r\n        e = tot = 0;\r\n        while(m--) {\r\n           scanf("%d %d %d",&i,&j,&k);\r\n           if(k < d[i][j]) d[i][j] = d[j][i] = k;\r\n           tot += k;\r\n           e ^= (1<<i);\r\n           e ^= (1<<j);\r\n        }\r\n        for(i = 1; i <= n; ++i) {\r\n            for(j = 1; j <= n; ++j) {\r\n                for(k = 1; k <= n; ++k) {\r\n                    if(d[i][k]+d[k][j] < d[i][j])\r\n                       d[i][j] = d[i][k] + d[k][j];\r\n                }\r\n            }\r\n        }\r\n        printf("%d\\n",tot+match(e));\r\n    }\r\n    return 0;\r\n}\r\n', '', 0, 520192, 1, 1, '2010-11-22 09:38:09', '0001-01-01 00:00:00'),
(966, 6, 263, 0, '#include <stdio.h>\r\n#include <math.h>\r\n#define EPS 1e-8\r\n\r\nint main()\r\n{\r\n    double D, V, R, r, v;\r\n    double PI = acos(-1.0);\r\n    double rl, rh;\r\n    while(scanf("%lf %lf",&D,&V) == 2 && D) {\r\n       V /= 2; R = D / 2;\r\n       rl = 0;  rh = R;\r\n       while(fabs(rl-rh) > EPS) {\r\n          r = (rl + rh) / 2;\r\n          v = PI*R*R*R - 1.0/3*PI*(R-r)*(R*R+r*R+r*r) - PI*r*r*r;\r\n          if(v < V) rh = r;\r\n          else      rl = r;\r\n       }\r\n       printf("%.3lf\\n",2*r);\r\n    }     \r\n    return 0;\r\n}', '', 0, 258048, 1, 1, '2010-11-22 10:07:38', '0001-01-01 00:00:00'),
(967, 6, 264, 0, '#include <stdio.h>\r\n#include <string.h>\r\n#define N 1000001\r\nint  next[N];\r\nchar str[N];\r\n\r\nvoid getnext()\r\n{\r\n     int i = 0, j = -1;\r\n     next[0] = -1;\r\n     while(str[i]) {\r\n        if(j == -1 || str[i] == str[j]) {\r\n           ++i, ++j;\r\n           next[i] = j;\r\n        }\r\n        else j = next[j];\r\n     }\r\n}\r\n\r\nint main()\r\n{\r\n    int n, t;\r\n    while(gets(str) && strcmp(str,".")) {\r\n        getnext();\r\n        n = strlen(str);\r\n        t = n - next[n];\r\n        if(n%t == 0) printf("%d\\n",n/t);\r\n        else         printf("1\\n");\r\n    }\r\n    return 0;\r\n}', '', 62, 5263360, 1, 1, '2010-11-22 11:28:21', '0001-01-01 00:00:00'),
(968, 6, 264, 0, '#include <stdio.h>\r\n#include <string.h>\r\n#define N 1000100\r\nchar s[N];\r\n\r\nint main()\r\n{\r\n    int i, j, k, m, n, len;\r\n    while(gets(s) && strcmp(s,".")) {\r\n        len = strlen(s);\r\n        m = n = len;\r\n        for(i = 2; i <= n; ++i) {\r\n            while(n%i == 0) {\r\n               n /= i;\r\n               for(j = 0; j < (m-m/i) && s[j] == s[j+m/i]; ++j) ;\r\n               if(j == (m-m/i)) m /= i;\r\n            }\r\n        }\r\n        printf("%d\\n",len/m);\r\n    }\r\n    return 0;\r\n}\r\n', '', 156, 1257472, 1, 1, '2010-11-22 12:12:58', '0001-01-01 00:00:00'),
(969, 6, 265, 0, '#include <stdio.h>\r\n\r\nint main()\r\n{\r\n    int n, i, sum;\r\n    while(scanf("%d",&n) == 1 && n) {\r\n       sum = n;\r\n       for(i = 2; (i*i) <= n; ++i) {\r\n           if(n%i == 0) sum -= sum/i;\r\n           while(n%i == 0) n /= i;\r\n       }\r\n       if(n > 1) sum -= sum/n;\r\n       printf("%d\\n",sum);\r\n    }\r\n    return 0;\r\n}\r\n', '', 0, 262144, 1, 1, '2010-11-22 13:49:04', '0001-01-01 00:00:00'),
(970, 6, 265, 0, '#include <stdio.h>\r\n\r\nint gcd(int a, int b) \r\n{\r\n    if(b == 0) return a;\r\n    return  gcd(b, a%b);\r\n}\r\n\r\nint main()\r\n{\r\n    int n, i, sum;\r\n    while(scanf("%d",&n) == 1 && n) {\r\n       sum = 0;\r\n       for(i = 1; i < n; ++i)\r\n           if(gcd(i,n) == 1)\r\n              ++sum;\r\n       printf("%d\\n",sum);\r\n    }\r\n    return 0;\r\n}\r\n', '', 1000, 262144, 5, 1, '2010-11-22 13:54:05', '0001-01-01 00:00:00'),
(971, 6, 265, 0, '#include <stdio.h>\r\n\r\nint main()\r\n{\r\n    int i, n;\r\n    double phi;\r\n    while(scanf("%d",&n) == 1 && n) {\r\n       phi = n * 1.0;\r\n       for(i = 2; (i*i) <= n; ++i) {\r\n           if(n%i == 0) phi *= (1 - 1.0/i);\r\n           while(n%i == 0) n /= i;       \r\n       }\r\n       if(n > 1) phi *= (1-1.0/n);\r\n       printf("%0.0lf\\n",phi);\r\n    }\r\n    return 0;\r\n}', '', 15, 258048, 1, 1, '2010-11-22 13:59:51', '0001-01-01 00:00:00'),
(972, 6, 36, 0, '#include <stdio.h>\r\nint a[1600];\r\n\r\nint getmin(int x, int y, int z)\r\n{\r\n    if(x > y) x = y;\r\n    if(x > z) x = z;\r\n    return x;\r\n}\r\n\r\nint main()\r\n{\r\n    int p2, p3, p5, p;\r\n    a[1] = p2 = p3 = p5 = p = 1;\r\n    while(p<=1499){\r\n       a[++p] = getmin(2*a[p2], 3*a[p3], 5*a[p5]);\r\n       if(a[p] == 2*a[p2]) ++p2;\r\n       if(a[p] == 3*a[p3]) ++p3;\r\n       if(a[p] == 5*a[p5]) ++p5;\r\n    }\r\n    printf("The 1500''th ugly number is %d.",a[1500]);\r\n    return 0;\r\n}', '', 0, 262144, 3, 1, '2010-11-22 14:08:18', '0001-01-01 00:00:00'),
(973, 6, 36, 0, '#include <stdio.h>\r\nint a[1600];\r\n\r\nint getmin(int x, int y, int z)\r\n{\r\n    if(x > y) x = y;\r\n    if(x > z) x = z;\r\n    return x;\r\n}\r\n\r\nint main()\r\n{\r\n    int p2, p3, p5, p;\r\n    a[1] = p2 = p3 = p5 = p = 1;\r\n    while(p<=1499){\r\n       a[++p] = getmin(2*a[p2], 3*a[p3], 5*a[p5]);\r\n       if(a[p] == 2*a[p2]) ++p2;\r\n       if(a[p] == 3*a[p3]) ++p3;\r\n       if(a[p] == 5*a[p5]) ++p5;\r\n    }\r\n    printf("The 1500''th ugly number is %d.\\n",a[1500]);\r\n    return 0;\r\n}\r\n', '', 0, 262144, 1, 1, '2010-11-22 14:08:42', '0001-01-01 00:00:00'),
(974, 6, 35, 0, '#include <stdio.h>\r\n#include <math.h>\r\n\r\nint main()\r\n{\r\n    double a, r, co, si, angle;\r\n    double PI = acos(-1.0);\r\n    while(scanf("%lf %lf",&a,&r) == 2) {\r\n        if(r >= (a/sqrt(2.0))) printf("%.3lf\\n",1.0*a*a);\r\n        else if(r <= (a/2))    printf("%.3lf\\n",PI*r*r);\r\n        else {\r\n           co = a/2/r;\r\n           si = sqrt(1-co*co);\r\n           angle = atan(si/co);\r\n           printf("%.3lf\\n",( r*si*a/2 + (PI/2-angle*2)*r*r/2 )*4);\r\n        }\r\n    }\r\n    return 0;\r\n}', '', 0, 258048, 1, 1, '2010-11-22 19:07:26', '0001-01-01 00:00:00'),
(975, 6, 34, 0, '#include <stdio.h>\r\n#include <string.h>\r\n#define N 100002\r\n#define max(a,b) (a)>(b)?(a):(b);\r\nchar a[N], b[N];\r\nint  dp[2][N];\r\n\r\nint main()\r\n{\r\n    int i, j, n1, n2, t;\r\n    while(scanf("%s %s",a,b) == 2) {\r\n       memset(dp, 0, sizeof(dp));\r\n       t = 0, n1 = strlen(a), n2 = strlen(b);\r\n       for(i = 0; i < n1; ++i) {\r\n           for(j = 0; j< n2; ++j) {\r\n               if(a[i] == b[j]) dp[t][j+1] = dp[1-t][j] + 1;\r\n               else  dp[t][j+1] = max(dp[1-t][j+1], dp[t][j]);\r\n           }\r\n           t = 1 - t;\r\n       }\r\n       if(dp[1 - t][n2] == n1) printf("Yes\\n");\r\n       else                    printf("No\\n");\r\n    }\r\n    return 0;\r\n}\r\n', '', 15, 1261568, 1, 1, '2010-11-22 19:46:16', '0001-01-01 00:00:00'),
(976, 6, 224, 0, '#include <stdio.h>\r\n#define INF 1<<30\r\nint c[100];\r\n\r\nint gcd(int a, int b) {\r\n    return b? gcd(b,a%b):a;\r\n}\r\n\r\nint lcm(int a, int b) {\r\n    return a/gcd(a,b)*b;\r\n}\r\n\r\nint main() {\r\n    int g, lo, bestlo, besthi, L;\r\n    int i, j, k, m, n, t;\r\n    while(scanf("%d %d",&n,&t) == 2 && (n||t)) {\r\n       for(i = 0; i < n; ++i)\r\n           scanf("%d",c+i);\r\n       while(t--) {\r\n           scanf("%d",&L);\r\n           bestlo = 0; \r\n           besthi = INF;\r\n           for(i = 0; i < n; ++i) \r\n               for(j = i+1; j < n; ++j)\r\n                   for(k = j+1; k < n; ++k)\r\n                       for(m = k+1; m < n; ++m) {\r\n                           g = lcm(c[i], c[j]);\r\n                           g = lcm(g, c[k]);\r\n                           g = lcm(g, c[m]);\r\n                           lo = L/g*g;\r\n                           if(lo > bestlo) bestlo = lo;\r\n                           if(lo != L) lo += g;\r\n                           if(lo < besthi) besthi = lo;\r\n                       }\r\n           printf("%d %d\\n",bestlo,besthi);\r\n       }\r\n    }\r\n    return 0;\r\n}', '', 499, 262144, 1, 1, '2010-11-22 22:35:27', '0001-01-01 00:00:00'),
(977, 6, 377, 0, '#include <stdio.h>\r\n#define EPS 1e-8\r\n#define zero(x)   (((x)>0?(x):-(x))<EPS)\r\nstruct Point{ double x,y; };\r\nstruct Line{  Point a,b;  }L[150];\r\n\r\ndouble xmult(Point p1, Point p2, Point p0) {\r\n    return (p1.x-p0.x)*(p2.y-p0.y) - (p2.x-p0.x)*(p1.y-p0.y);\r\n}\r\n\r\nint same_side(Point p1, Point p2, Line l) {\r\n    return xmult(l.a,p1,l.b)*xmult(l.a,p2,l.b) > EPS;\r\n}\r\n\r\nint dot_online_in(Point p, Line l) {\r\n    return zero(xmult(p,l.a,l.b)) && (l.a.x-p.x)*(l.b.x-p.x)<EPS\r\n           && (l.a.y-p.y)*(l.b.y-p.y)<EPS;\r\n}\r\n\r\nint dots_inline(Point p1, Point p2, Point p3) {\r\n    return zero(xmult(p1,p2,p3));\r\n}\r\n\r\nint intersect_in(Line u, Line v) {\r\n    if(!dots_inline(u.a,u.b,v.a) || !dots_inline(u.a,u.b,v.b))\r\n       return !same_side(u.a,u.b,v) && !same_side(v.a,v.b,u);\r\n    return dot_online_in(u.a,v) || dot_online_in(u.b,v)\r\n           || dot_online_in(v.a,u) || dot_online_in(v.b,u);\r\n}\r\n\r\nint main() {\r\n    int i, j, n, cnt;\r\n    while(scanf("%d",&n) == 1) {\r\n       for(i = 0; i < n; ++i)\r\n           scanf("%lf %lf %lf %lf",&L[i].a.x,&L[i].a.y,&L[i].b.x,&L[i].b.y);\r\n       cnt = 0;\r\n       for(i = 0; i < n; ++i) {\r\n           for(j = i+1; j < n; ++j) \r\n               if(intersect_in(L[i], L[j])) ++cnt;\r\n       }\r\n       printf("%d\\n",cnt);\r\n    }\r\n    return 0;\r\n}', 'Main.c:5:15: error: expected specifier-qualifier-list before ''Point''\r\nMain.c:7:20: error: expected '')'' before ''p1''\r\nMain.c:11:21: error: expected '')'' before ''p1''\r\nMain.c:15:25: error: expected '')'' before ''p''\r\nMain.c:20:23: error: expected '')'' before ''p1''\r\nMain.c:24:23: error: expected '')'' before ''u''\r\nMain.c: In function ''main'':\r\nMain.c:35:41: error: ''struct Line'' has no member named ''a''\r\nMain.c:35:51: error: ''struct Line'' has no member named ''a''\r\nMain.c:35:61: error: ''struct Line'' has no member ', 0, 0, 2, 1, '2010-11-23 14:05:51', '0001-01-01 00:00:00'),
(978, 6, 377, 0, '#include <stdio.h>\r\n#define EPS 1e-8\r\n#define zero(x)   (((x)>0?(x):-(x))<EPS)\r\nstruct Point{ double x,y; };\r\nstruct Line{  Point a,b;  }L[150];\r\n\r\ndouble xmult(Point p1, Point p2, Point p0) {\r\n    return (p1.x-p0.x)*(p2.y-p0.y) - (p2.x-p0.x)*(p1.y-p0.y);\r\n}\r\n\r\nint same_side(Point p1, Point p2, Line l) {\r\n    return xmult(l.a,p1,l.b)*xmult(l.a,p2,l.b) > EPS;\r\n}\r\n\r\nint dot_online_in(Point p, Line l) {\r\n    return zero(xmult(p,l.a,l.b)) && (l.a.x-p.x)*(l.b.x-p.x)<EPS\r\n           && (l.a.y-p.y)*(l.b.y-p.y)<EPS;\r\n}\r\n\r\nint dots_inline(Point p1, Point p2, Point p3) {\r\n    return zero(xmult(p1,p2,p3));\r\n}\r\n\r\nint intersect_in(Line u, Line v) {\r\n    if(!dots_inline(u.a,u.b,v.a) || !dots_inline(u.a,u.b,v.b))\r\n       return !same_side(u.a,u.b,v) && !same_side(v.a,v.b,u);\r\n    return dot_online_in(u.a,v) || dot_online_in(u.b,v)\r\n           || dot_online_in(v.a,u) || dot_online_in(v.b,u);\r\n}\r\n\r\nint main() {\r\n    int i, j, n, cnt;\r\n    while(scanf("%d",&n) == 1) {\r\n       for(i = 0; i < n; ++i)\r\n           scanf("%lf %lf %lf %lf",&L[i].a.x,&L[i].a.y,&L[i].b.x,&L[i].b.y);\r\n       cnt = 0;\r\n       for(i = 0; i < n; ++i) {\r\n           for(j = i+1; j < n; ++j) \r\n               if(intersect_in(L[i], L[j])) ++cnt;\r\n       }\r\n       printf("%d\\n",cnt);\r\n    }\r\n    return 0;\r\n}\r\n', '', 0, 266240, 4, 2, '2010-11-23 14:06:57', '0001-01-01 00:00:00'),
(979, 6, 377, 0, '#include <stdio.h>\r\n#define EPS 1e-8\r\n#define zero(x)   (((x)>0?(x):-(x))<EPS)\r\nstruct Point{ double x,y; };\r\nstruct Line{  Point a,b;  }L[150];\r\n\r\ndouble xmult(Point p1, Point p2, Point p0) {\r\n    return (p1.x-p0.x)*(p2.y-p0.y) - (p2.x-p0.x)*(p1.y-p0.y);\r\n}\r\n\r\nint same_side(Point p1, Point p2, Line l) {\r\n    return xmult(l.a,p1,l.b)*xmult(l.a,p2,l.b) > EPS;\r\n}\r\n\r\nint dot_online_in(Point p, Line l) {\r\n    return zero(xmult(p,l.a,l.b)) && (l.a.x-p.x)*(l.b.x-p.x)<EPS\r\n           && (l.a.y-p.y)*(l.b.y-p.y)<EPS;\r\n}\r\n\r\nint dots_inline(Point p1, Point p2, Point p3) {\r\n    return zero(xmult(p1,p2,p3));\r\n}\r\n\r\nint intersect_in(Line u, Line v) {\r\n    if(!dots_inline(u.a,u.b,v.a) || !dots_inline(u.a,u.b,v.b))\r\n       return !same_side(u.a,u.b,v) && !same_side(v.a,v.b,u);\r\n    return dot_online_in(u.a,v) || dot_online_in(u.b,v)\r\n           || dot_online_in(v.a,u) || dot_online_in(v.b,u);\r\n}\r\n\r\nint main() {\r\n    int i, j, n, cnt;\r\n    while(scanf("%d",&n) == 1 && n) {\r\n       for(i = 0; i < n; ++i)\r\n           scanf("%lf %lf %lf %lf",&L[i].a.x,&L[i].a.y,&L[i].b.x,&L[i].b.y);\r\n       cnt = 0;\r\n       for(i = 0; i < n; ++i) {\r\n           for(j = i+1; j < n; ++j) \r\n               if(intersect_in(L[i], L[j])) ++cnt;\r\n       }\r\n       printf("%d\\n",cnt);\r\n    }\r\n    return 0;\r\n}\r\n', '', 499, 266240, 1, 2, '2010-11-23 14:07:32', '0001-01-01 00:00:00'),
(980, 1, 379, 0, '{\r\nID:asiapeak1\r\nPROG:butter\r\nLANG:PASCAL\r\n}\r\nprogram butter;\r\nconst\r\n  oo=$FFFFFFFF;\r\ntype\r\n  link=^node;\r\n  node=\r\n  record\r\n    b:word;\r\n    dis:dword;\r\n    next:link;\r\n  end;\r\n  data=\r\n  record\r\n    pi:word;\r\n    dis:dword;\r\n  end;\r\nvar\r\n  cow:array[1..500]of word;\r\n  n,p,c,i,j,a,b,d:word;\r\n  e:array[1..800]of link;\r\n  t:link;\r\n  dis:array[1..500,1..800]of dword;\r\n  tot,re,empt:dword;\r\n  heap:array[1..1500]of data;\r\n  sw:data;\r\n  tick:array[1..800]of boolean;\r\n//\r\nprocedure add (pi:word;dis:dword);\r\nvar\r\n  i:word;\r\nbegin\r\n  heap[empt].dis:=dis;\r\n  heap[empt].pi:=pi;\r\n  i:=empt;\r\n  while (i>1) and (heap[i div 2].dis>heap[i].dis) do\r\n  begin\r\n    sw:=heap[i];\r\n    heap[i]:=heap[i div 2];\r\n    heap[i div 2]:=sw;\r\n    i:=i div 2;\r\n  end;\r\n  while heap[empt].dis<>oo do\r\n    inc(empt);\r\nend;\r\n//\r\nprocedure fix (s:word);\r\nvar\r\n  a,b:word;\r\nbegin\r\n  a:=s*2;\r\n  b:=a+1;\r\n  if (heap[a].dis=oo) and (heap[b].dis=oo) or (a>1500) then\r\n  begin\r\n    if s<empt then\r\n      empt:=s;\r\n    heap[s].dis:=oo;\r\n    exit;\r\n  end;\r\n  if heap[a].dis>heap[b].dis then\r\n  begin\r\n    heap[s]:=heap[b];\r\n    fix(b);\r\n  end\r\n  else\r\n  begin\r\n    heap[s]:=heap[a];\r\n    fix(a);\r\n  end;\r\nend;\r\n//\r\nprocedure dijkstra (cowi:word);\r\nvar\r\n  i,pi:word;\r\n  pdis:dword;\r\nbegin\r\n  fillchar(tick,sizeof(tick),false);\r\n  for i:=1 to 1500 do\r\n    heap[i].dis:=oo;\r\n  empt:=1;\r\n  add(cow[cowi],0);\r\n  for i:=1 to p do\r\n  begin\r\n    repeat\r\n      pi:=heap[1].pi;\r\n      pdis:=heap[1].dis;\r\n      fix(1);\r\n    until not tick[pi];\r\n    dis[cowi,pi]:=pdis;\r\n    tick[pi]:=true;\r\n    t:=e[pi];\r\n    while t<>nil do\r\n    begin\r\n      if not tick[t^.b] then\r\n        add(t^.b,t^.dis+dis[cowi,pi]);\r\n      t:=t^.next;\r\n    end;\r\n  end;\r\nend;\r\n//\r\nbegin\r\n  assign(input,''butter.in'');\r\n  assign(output,''butter.out'');\r\n  reset(input);\r\n  rewrite(output);\r\n  readln(n,p,c);\r\n  for i:=1 to n do\r\n    readln(cow[i]);\r\n  for i:=1 to c do\r\n  begin\r\n    readln(a,b,d);\r\n    new(t);\r\n    t^.b:=b;\r\n    t^.dis:=d;\r\n    t^.next:=e[a];\r\n    e[a]:=t;\r\n    new(t);\r\n    t^.b:=a;\r\n    t^.dis:=d;\r\n    t^.next:=e[b];\r\n    e[b]:=t;\r\n  end;\r\n  for i:=1 to n do\r\n    dijkstra(i);\r\n  re:=oo;\r\n  for i:=1 to p do\r\n  begin\r\n    tot:=0;\r\n    for j:=1 to n do\r\n      inc(tot,dis[j,i]);\r\n    if tot<re then\r\n      re:=tot;\r\n  end;\r\n  writeln(re);\r\n  close(output);\r\nend.', '', 0, 2420736, 4, 3, '2010-11-23 23:01:39', '0001-01-01 00:00:00'),
(981, 1, 379, 0, '/*\r\nID:cmykrgb2\r\nLANG:C++\r\nTASK:butter\r\n*/\r\n/* \r\n * Problem: USACO Training 3.2.6\r\n * Author: Guo Jiabao\r\n * Time: 2009.4.6 10:20\r\n * State: Solved\r\n * Memo: Dijkstra + 堆\r\n*/\r\n#include <iostream>\r\n#include <cstdio>\r\n#include <cstdlib>\r\n#include <cmath>\r\n#include <cstring>\r\nconst int MAXC=501,MAXN=801,MAXM=1451*2,INF=0x7FFFFFFF;\r\nusing namespace std;\r\nstruct edge\r\n{\r\n	edge *next;\r\n	int t,v;\r\n}ES[MAXM];\r\nstruct HeapElement\r\n{\r\n	int key,value;\r\n};\r\nstruct MinHeap\r\n{\r\n	HeapElement H[MAXN];\r\n	int size;\r\n	int Position[MAXN];\r\n	void init(){H[size=0].value=-INF;}\r\n	void ins(int key,int value)\r\n	{\r\n		int i,f;\r\n		HeapElement p={key,value};\r\n		for (i=++size;p.value<H[f=i>>1].value;i=f)\r\n		{\r\n			H[i]=H[f];\r\n			Position[H[i].key]=i;\r\n		}\r\n		H[i]=p;\r\n		Position[H[i].key]=i;\r\n	}\r\n	void decrease(int key,int value)\r\n	{\r\n		int i,f;\r\n		HeapElement p={key,value};\r\n		for (i=Position[key];p.value<H[f=i>>1].value;i=f)\r\n		{\r\n			H[i]=H[f];\r\n			Position[H[i].key]=i;\r\n		}\r\n		H[i]=p;\r\n		Position[H[i].key]=i;\r\n	}\r\n	void delmin()\r\n	{\r\n		int i,c;\r\n		HeapElement p=H[size--];\r\n		for (i=1;(c=i<<1)<=size;i=c)\r\n		{\r\n			if (c+1<=size && H[c+1].value<H[c].value)\r\n				c++;\r\n			if (H[c].value<p.value)\r\n			{\r\n				H[i]=H[c];\r\n				Position[H[i].key]=i;\r\n			}\r\n			else\r\n				break;\r\n		}\r\n		H[i]=p;\r\n		Position[H[i].key]=i;\r\n	}\r\n}H;\r\nint N,M,C,EC=-1,Ans=INF;\r\nint Cow[MAXC],sp[MAXN];\r\nedge *V[MAXN];\r\ninline void addedge(int a,int b,int c)\r\n{\r\n	ES[++EC].next=V[a];\r\n	ES[EC].t=b;ES[EC].v=c;\r\n	V[a]=&ES[EC];\r\n}\r\nvoid init()\r\n{\r\n	int i,a,b,c;\r\n	//freopen("butter.in","r",stdin);\r\n	//freopen("butter.out","w",stdout);\r\n	scanf("%d%d%d",&C,&N,&M);\r\n	for (i=1;i<=C;i++)\r\n		scanf("%d",&Cow[i]);\r\n	for (i=1;i<=M;i++)\r\n	{\r\n		scanf("%d%d%d",&a,&b,&c);\r\n		addedge(a,b,c);\r\n		addedge(b,a,c);\r\n	}\r\n}\r\nvoid Dijkstra(int S)\r\n{\r\n	int i,j;\r\n	sp[S]=0;\r\n	H.decrease(S,0);\r\n	for (i=S;;)\r\n	{\r\n		H.delmin();\r\n		for (edge *k=V[i];k;k=k->next)\r\n		{\r\n			if (sp[i]+k->v < sp[j=k->t])\r\n			{\r\n				sp[j]=sp[i]+k->v;\r\n				H.decrease(j,sp[j]);\r\n			}\r\n		}\r\n		if (H.size)\r\n			i=H.H[1].key;\r\n		else\r\n			break;\r\n	}\r\n}\r\nvoid solve()\r\n{\r\n	int i,j,Total;\r\n	for (i=1;i<=N;i++)\r\n	{\r\n		H.init();\r\n		for (j=1;j<=N;j++)\r\n		{\r\n			H.ins(j,INF);\r\n			sp[j]=INF;\r\n		}\r\n		Total=0;\r\n		Dijkstra(i);\r\n		for (j=1;j<=C;j++)\r\n			Total+=sp[Cow[j]];\r\n		if (Total<Ans)\r\n			Ans=Total;\r\n	}\r\n}\r\nint main()\r\n{\r\n	init();\r\n	solve();\r\n	printf("%d\\n",Ans);\r\n	return 0;\r\n}', '', 436, 421888, 1, 2, '2010-11-23 23:03:49', '0001-01-01 00:00:00'),
(982, 1, 380, 0, '#include <cstdio>\r\nconst int Max = 105 ;            // 最大顶点数\r\nconst int MaxInt = 0x7ffffff ;  // 最大32位带符整数  \r\n\r\nint map[Max][Max];  // 加权有向图\r\nint dic[Max];      // 源点到 i点 的最短时间 \r\nint path[Max];      // 最短路径 \r\nint cost[Max] ;    // 路过城市i所要的缴费 \r\n\r\nint N ;\r\nint a, b ;\r\n\r\nvoid Init( int G[][Max] )\r\n{\r\n    int i, j;\r\n    for( i=0; i<Max; ++i )\r\n        for( j=0; j<Max ;++j )\r\n            G[i][j]=MaxInt;\r\n}\r\n\r\nint compare( int i , int j )\r\n{\r\n    int x[N], y[N];\r\n    int k , l  ;\r\n    \r\n    k = 0 ;\r\n    while( i != a && i != -1)\r\n    {\r\n        x[k++] = i ;\r\n        i = path[i] ;\r\n    }\r\n    \r\n    l = 0 ;\r\n    while( j != a && j != -1)\r\n    {\r\n        y[l++] = j ;\r\n        j = path[j] ;\r\n    }\r\n    \r\n    for( --k, --l ; k >= 0 && l >=0 ; --k, --l  )\r\n        if( x[k]!=y[l] )\r\n        {\r\n            if( x[k] < y[l] ) return 1 ;\r\n            else return 0;\r\n        }\r\n\r\n    return  0 ;\r\n}\r\n\r\nvoid Dijkstra( int G[][Max], int k, int D[], int N, int path[] ) // 顶点k到其余顶点i的最短路径 D[i] , 顶点数 N  \r\n{\r\n    int i, j, t ;\r\n    int min ;\r\n    bool flag[Max];        //  是否已求得源点k到此的最短路径 \r\n    \r\n    for( i=0; i<=N ;++i ){\r\n        flag[i] = false;\r\n        D[i] = G[k][i];        // 源点到其余点的距离\r\n        if( D[i] < MaxInt ) path[i] = k ;  // 记录初始路径 \r\n        else path[i] = -1 ;\r\n    }\r\n    D[k] = 0;  flag[k] = true;\r\n    \r\n    for( i=1; i<=N; ++i )      //  分别求出 源点k 到其余i顶点 的最短路径  \r\n    {\r\n        min = MaxInt ;\r\n        for( t = j = 1; j <= N; ++j )\r\n            if( !flag[j] && D[j] + cost[j] < min  ) // 还要计算路过城市缴费 \r\n            {\r\n                min = D[j] + cost[j];\r\n                t = j ;\r\n            }\r\n            \r\n        if( min == MaxInt ) break;\r\n        \r\n        flag[t] = true;      // 距离k点最近的顶点 \r\n        for( j=1; j<=N; ++j )\r\n            if( !flag[j] && G[t][j]!=MaxInt && min + G[t][j] <= D[j]  ) \r\n            {\r\n                if( min + G[t][j] == D[j] ) // 处理字典顺序 \r\n                {\r\n                    if(  compare( t, j ) )  // 比较前驱 \r\n                        path[j] = t ;\r\n                }\r\n                else\r\n                    path[j] = t ;  // 路径更新\r\n                D[j] = min + G[t][j]  ;\r\n            }\r\n    }\r\n}\r\n\r\nint main( )\r\n{  \r\n#ifndef ONLINE_JUDGE\r\n    freopen("_in.txt","r",stdin); freopen("_out.txt","w",stdout);\r\n#endif\r\n    int i, j ;\r\n    int opt[Max] ; // 输出路径 \r\n    \r\n    while( scanf("%d", &N )!=EOF && N!=0 )\r\n    {\r\n        for( i = 1; i <= N ; ++i )\r\n            for( j = 1; j <= N ; ++j )\r\n            {\r\n                scanf("%d", &map[i][j] );\r\n                if( map[i][j] == 0 || map[i][j] == -1 )\r\n                    map[i][j] = MaxInt ;\r\n            }\r\n        for( i = 1; i <= N ; ++i )\r\n            scanf("%d", &cost[i] );\r\n        \r\n        while( scanf("%d %d", &a ,&b ) && a!=-1 )\r\n        {\r\n            Dijkstra( map, a, dic, N, path ) ;  \r\n            \r\n            printf("From %d to %d :\\n", a, b );\r\n            printf("Path: ");\r\n            \r\n            i = b ;  j = 0 ;\r\n            opt[j++] = b ;\r\n            while( i != a && i != -1)\r\n            {\r\n                opt[j++] = i ; \r\n                i = path[i] ;\r\n            }\r\n            opt[j] = a ;\r\n            \r\n            for( i = j; i > 0; --i )\r\n            {\r\n                if( i == j )\r\n                    printf("%d", opt[i] );\r\n                else\r\n                    printf("-->%d", opt[i] );\r\n            }\r\n            printf("\\nTotal cost : %d\\n\\n", dic[b] ) ;\r\n        }\r\n    }\r\n    return 0;\r\n}\r\n\r\n', '', 15, 307200, 1, 2, '2010-11-23 23:09:21', '0001-01-01 00:00:00'),
(983, 14, 378, 6, '#include<stdio.h>\r\n#include<math.h>\r\n\r\ntypedef struct {\r\n	float x;\r\n	float y;\r\n}Point;\r\n\r\nfloat min(float x,float y)\r\n{\r\n	return x>y? y : x ;\r\n\r\n}\r\n\r\nfloat max(float x,float y)\r\n{\r\n	return x>y? x : y ;\r\n\r\n}\r\n\r\nint isInPolygon( Point test, Point *PolygonPoint,int edge)\r\n{\r\n	int i,n = 0;\r\n	for (i = 0; i < edge; ++i)\r\n	{\r\n\r\n		Point p1 = PolygonPoint[i]; \r\n		Point p2 = PolygonPoint[(i + 1) % edge]; \r\n		\r\n		float k1,k2;\r\n\r\n		if(  ( p1.x == test.x && p1.y == test.y) ||  (p2.x == test.x && p2.y == test.y ) )\r\n			return 0;\r\n\r\n		if ( p1.y == p2.y ) \r\n			continue; \r\n		if ( test.y < min(p1.y, p2.y) )\r\n			continue; \r\n		if ( test.y >= max(p1.y, p2.y) ) \r\n			continue;\r\n\r\n		k1 =  p2.x == p1.x ? 0 : (p2.y - p1.y)/(p2.x - p1.x);\r\n		k2 =  test.x == p1.x ? 0 : (test.y - p1.y)/(test.x - p1.x);\r\n\r\n		if( fabs( k1-k2) <0.001)\r\n			return 0;\r\n		\r\n		float x = (float)(test.y - p1.y) * (float)(p2.x - p1.x) / (float)(p2.y - p1.y) + p1.x; \r\n		if ( x > test.x ) \r\n			++n;  \r\n	} \r\n\r\n    if(n%2 == 1)\r\n	   return 1;\r\n    else\r\n	   return -1;\r\n} \r\n\r\n\r\nint main()\r\n{\r\n	int i,edgecount,pointcount;\r\n	Point pointArray[301], testPoint[301];\r\n	while( scanf("%d %d",&edgecount,&pointcount) == 2 )\r\n	{\r\n		if( 0 == edgecount && 0 == pointcount )\r\n			break;\r\n		\r\n		for(i=0;i<edgecount;++i)\r\n		{\r\n			scanf("%f",&(pointArray[i].x) );\r\n			scanf("%f",&(pointArray[i].y) );\r\n		}\r\n\r\n		for(i=0;i<pointcount;++i)\r\n		{\r\n			scanf("%f",&(testPoint[i].x ) );\r\n			scanf("%f",&(testPoint[i].y ) );\r\n		}\r\n\r\n		for(i=0;i<pointcount;++i)\r\n		{\r\n			printf("%d\\n",isInPolygon(testPoint[i],  pointArray ,edgecount) );\r\n			\r\n		}\r\n\r\n	}\r\n\r\n\r\n	return 0;\r\n}', '', 0, 262144, 4, 1, '2010-11-24 20:22:04', '0001-01-01 00:00:00'),
(984, 14, 378, 6, '#include<stdio.h>\r\n#include<math.h>\r\n\r\ntypedef struct {\r\n	float x;\r\n	float y;\r\n}Point;\r\n\r\nfloat min(float x,float y)\r\n{\r\n	return x>y? y : x ;\r\n\r\n}\r\n\r\nfloat max(float x,float y)\r\n{\r\n	return x>y? x : y ;\r\n\r\n}\r\n\r\nint isInPolygon( Point test, Point *PolygonPoint,int edge)\r\n{\r\n	int i,n = 0;\r\n	for (i = 0; i < edge; ++i)\r\n	{\r\n\r\n		Point p1 = PolygonPoint[i]; \r\n		Point p2 = PolygonPoint[(i + 1) % edge]; \r\n		\r\n		float k1,k2;\r\n\r\n		if(  ( p1.x == test.x && p1.y == test.y) ||  (p2.x == test.x && p2.y == test.y ) )\r\n			return 0;\r\n\r\n		if ( p1.y == p2.y ) \r\n		{\r\n			if(test.y == p1.y)\r\n				return 0;\r\n			continue; \r\n		}\r\n\r\n		if ( test.y < min(p1.y, p2.y) )\r\n			continue; \r\n		if ( test.y >= max(p1.y, p2.y) ) \r\n			continue;\r\n\r\n		k1 =  p2.x == p1.x ? 0 : (p2.y - p1.y)/(p2.x - p1.x);\r\n		k2 =  test.x == p1.x ? 0 : (test.y - p1.y)/(test.x - p1.x);\r\n\r\n		if( fabs( k1-k2) <0.001)\r\n			return 0;\r\n		\r\n		float x = (float)(test.y - p1.y) * (float)(p2.x - p1.x) / (float)(p2.y - p1.y) + p1.x; \r\n		if ( x > test.x ) \r\n			++n;  \r\n	} \r\n\r\n    if(n%2 == 1)\r\n	   return 1;\r\n    else\r\n	   return -1;\r\n} \r\n\r\n\r\nint main()\r\n{\r\n	int i,edgecount,pointcount;\r\n	Point pointArray[301], testPoint[301];\r\n	while( scanf("%d %d",&edgecount,&pointcount) == 2 )\r\n	{\r\n		if( 0 == edgecount && 0 == pointcount )\r\n			break;\r\n		\r\n		for(i=0;i<edgecount;++i)\r\n		{\r\n			scanf("%f",&(pointArray[i].x) );\r\n			scanf("%f",&(pointArray[i].y) );\r\n		}\r\n\r\n		for(i=0;i<pointcount;++i)\r\n		{\r\n			scanf("%f",&(testPoint[i].x ) );\r\n			scanf("%f",&(testPoint[i].y ) );\r\n		}\r\n\r\n		for(i=0;i<pointcount;++i)\r\n		{\r\n			printf("%d\\n",isInPolygon(testPoint[i],  pointArray ,edgecount) );\r\n			\r\n		}\r\n\r\n	}\r\n\r\n\r\n	return 0;\r\n}', '', 0, 258048, 4, 1, '2010-11-24 20:32:55', '0001-01-01 00:00:00'),
(985, 14, 378, 6, '#include<stdio.h>\r\n#include<math.h>\r\n\r\ntypedef struct {\r\n	float x;\r\n	float y;\r\n}Point;\r\n\r\nfloat min(float x,float y)\r\n{\r\n	return x>y? y : x ;\r\n\r\n}\r\n\r\nfloat max(float x,float y)\r\n{\r\n	return x>y? x : y ;\r\n\r\n}\r\n\r\nint isInPolygon( Point test, Point *PolygonPoint,int edge)\r\n{\r\n	int i,n = 0;\r\n	for (i = 0; i < edge; ++i)\r\n	{\r\n\r\n		Point p1 = PolygonPoint[i]; \r\n		Point p2 = PolygonPoint[(i + 1) % edge]; \r\n		\r\n		float k1,k2;\r\n\r\n		if(  ( p1.x == test.x && p1.y == test.y) ||  (p2.x == test.x && p2.y == test.y ) )\r\n			return 0;\r\n\r\n		if ( p1.y == p2.y ) \r\n		{\r\n			if(test.y == p1.y)\r\n				return 0;\r\n			continue; \r\n		}\r\n\r\n		if ( test.y < min(p1.y, p2.y) )\r\n			continue; \r\n		if ( test.y >= max(p1.y, p2.y) ) \r\n			continue;\r\n\r\n		k1 =  p2.x == p1.x ? 0 : (p2.y - p1.y)/(p2.x - p1.x);\r\n		k2 =  test.x == p1.x ? 0 : (test.y - p1.y)/(test.x - p1.x);\r\n\r\n		if( fabs( k1-k2) <0.001)\r\n			return 0;\r\n		\r\n		float x = (float)(test.y - p1.y) * (float)(p2.x - p1.x) / (float)(p2.y - p1.y) + p1.x; \r\n		if ( x > test.x ) \r\n			++n;  \r\n	} \r\n\r\n    if(n%2 == 1)\r\n	   return 1;\r\n    else\r\n	   return -1;\r\n} \r\n\r\n\r\nint main()\r\n{\r\n	int i,edgecount,pointcount;\r\n	Point pointArray[301], testPoint[301];\r\n	while( scanf("%d %d",&edgecount,&pointcount) == 2 )\r\n	{\r\n		if( 0 == edgecount && 0 == pointcount )\r\n			break;\r\n		\r\n		for(i=0;i<edgecount;++i)\r\n		{\r\n			scanf("%f",&(pointArray[i].x) );\r\n			scanf("%f",&(pointArray[i].y) );\r\n		}\r\n\r\n		for(i=0;i<pointcount;++i)\r\n		{\r\n			scanf("%f",&(testPoint[i].x ) );\r\n			scanf("%f",&(testPoint[i].y ) );\r\n		}\r\n\r\n		for(i=0;i<pointcount;++i)\r\n		{\r\n			printf("%d\\n",isInPolygon(testPoint[i],  pointArray ,edgecount) );\r\n			\r\n		}\r\n\r\n	}\r\n\r\n\r\n	return 0;\r\n}', '', 0, 262144, 4, 1, '2010-11-24 20:42:54', '0001-01-01 00:00:00'),
(986, 10, 374, 5, '#include<stdio.h>\r\n#include<string.h>\r\n\r\n#define N 1000\r\n\r\nint main()\r\n{\r\n int i,start,size,sum,max,count=0,total;\r\n int max_start,max_end;\r\n int shuzu[N];\r\n scanf("%d",&total);\r\n while(count != total)\r\n {\r\n scanf("%d",&size);\r\n for(i = 0 ; i != size ;++i)\r\n  scanf("%d",&shuzu[i]);\r\n i = sum = start = max = 0;\r\n while(i != size)\r\n {\r\n  sum += shuzu[i];\r\n  if(sum < 0)\r\n  {\r\n   start = i+1;\r\n   sum = 0;\r\n  }\r\n  if(sum > max)\r\n  {\r\n   max = sum;\r\n   max_start = start;\r\n   max_end = i;\r\n  }\r\n  ++i;\r\n }\r\n printf("Case %d:\\n",count+1);\r\n printf("%d %d %d \\n",max,max_start+1,max_end+1);\r\n count++;\r\n }\r\n return 0;\r\n}\r\n ', '', 0, 258048, 7, 1, '2010-11-25 08:19:52', '0001-01-01 00:00:00'),
(987, 10, 374, 5, '#include<stdio.h>\r\n#include<string.h>\r\n\r\n#define N 10000\r\n\r\nint main()\r\n{\r\n int i,start,size,sum,max,count=0,total;\r\n int max_start,max_end;\r\n int shuzu[N];\r\n scanf("%d",&total);\r\n while(count != total)\r\n {\r\n scanf("%d",&size);\r\n for(i = 0 ; i != size ;++i)\r\n  scanf("%d",&shuzu[i]);\r\n i = sum = start = max = 0;\r\n while(i != size)\r\n {\r\n  sum += shuzu[i];\r\n  if(sum < 0)\r\n  {\r\n   start = i+1;\r\n   sum = 0;\r\n  }\r\n  if(sum > max)\r\n  {\r\n   max = sum;\r\n   max_start = start;\r\n   max_end = i;\r\n  }\r\n  ++i;\r\n }\r\n printf("Case %d:\\n",count+1);\r\n printf("%d %d %d \\n",max,max_start+1,max_end+1);\r\n count++;\r\n }\r\n return 0;\r\n}\r\n ', '', 15, 262144, 4, 1, '2010-11-25 08:23:53', '0001-01-01 00:00:00'),
(988, 14, 378, 6, '#include<stdio.h>\r\n#include<math.h>\r\n\r\ntypedef struct {\r\n	float x;\r\n	float y;\r\n}Point;\r\n\r\nfloat min(float x,float y)\r\n{\r\n	return x>y? y : x ;\r\n\r\n}\r\n\r\nfloat max(float x,float y)\r\n{\r\n	return x>y? x : y ;\r\n\r\n}\r\n\r\nint isInPolygon( Point test, Point *PolygonPoint,int edge)\r\n{\r\n	int i,n = 0;\r\n	for (i = 0; i < edge; ++i)\r\n	{\r\n\r\n		Point p1 = PolygonPoint[i]; \r\n		Point p2 = PolygonPoint[(i + 1) % edge]; \r\n		\r\n		float k1,k2;\r\n\r\n		if(  ( p1.x == test.x && p1.y == test.y) ||  (p2.x == test.x && p2.y == test.y ) )\r\n			return 0;\r\n\r\n		if ( p1.y == p2.y ) \r\n		{\r\n			if(test.y == p1.y)\r\n			{\r\n				if(test.x > min(p1.x,p2.x) & test.x > min(p1.x,p2.x) )\r\n					return -1;\r\n				return 0;\r\n			\r\n			}\r\n			continue; \r\n		}\r\n\r\n		if ( test.y <= min(p1.y, p2.y) )\r\n			continue; \r\n		if ( test.y >= max(p1.y, p2.y) ) \r\n			continue;\r\n\r\n		k1 =  p2.x == p1.x ? 0 : (p2.y - p1.y)/(p2.x - p1.x);\r\n		k2 =  test.x == p1.x ? 0 : (test.y - p1.y)/(test.x - p1.x);\r\n\r\n		if( fabs( k1-k2) <0.001)\r\n			return 0;\r\n		\r\n		float x = (float)(test.y - p1.y) * (float)(p2.x - p1.x) / (float)(p2.y - p1.y) + p1.x; \r\n		if ( x > test.x ) \r\n			++n;  \r\n	} \r\n\r\n    if(n%2 == 1)\r\n	   return 1;\r\n    else\r\n	   return -1;\r\n} \r\n\r\n\r\nint main()\r\n{\r\n	int i,edgecount,pointcount;\r\n	Point pointArray[301], testPoint[301];\r\n	while( scanf("%d %d",&edgecount,&pointcount) == 2 )\r\n	{\r\n		if( 0 == edgecount && 0 == pointcount )\r\n			break;\r\n		\r\n		for(i=0;i<edgecount;++i)\r\n		{\r\n			scanf("%f",&(pointArray[i].x) );\r\n			scanf("%f",&(pointArray[i].y) );\r\n		}\r\n\r\n		for(i=0;i<pointcount;++i)\r\n		{\r\n			scanf("%f",&(testPoint[i].x ) );\r\n			scanf("%f",&(testPoint[i].y ) );\r\n		}\r\n\r\n		for(i=0;i<pointcount;++i)\r\n		{\r\n			printf("%d\\n",isInPolygon(testPoint[i],  pointArray ,edgecount) );\r\n			\r\n		}\r\n\r\n	}\r\n\r\n\r\n	return 0;\r\n}', '', 0, 262144, 4, 1, '2010-11-25 08:26:25', '0001-01-01 00:00:00'),
(989, 13, 379, 7, '#include<stdio.h>\r\n#include<string.h>\r\n\r\nint n,p,c,l[801][801],cow[501],a[801][801],q[641601],f,e,dis[801],ans;\r\nbool flag[801];\r\n\r\nvoid spfa(int s)\r\n{     \r\n	int st,i,total = 0;     \r\n	flag[s] = true;     \r\n	while(f <= e)     \r\n	{            \r\n		st = q[f];            \r\n		for(i = 1; i <= l[st][0]; ++ i)            \r\n		{                  \r\n			if(dis[st] + a[st][l[st][i]] < dis[l[st][i]])                  \r\n			{                             \r\n				dis[l[st][i]] =  dis[st] + a[st][l[st][i]];                            \r\n				if(!flag[l[st][i]])                            \r\n				{                                                     \r\n					++ e;                                                     \r\n					q[e] = l[st][i];                                               \r\n					flag[l[st][i]] = true;   \r\n				}\r\n			}\r\n		}\r\n\r\n		flag[st] = false;          \r\n		++ f;    \r\n	}     \r\n	for(i = 1; i <= n; ++ i)          \r\n		total += dis[cow[i]];    \r\n	if(total < ans)     \r\n		ans = total;\r\n}\r\n\r\nint main()\r\n{      \r\n	int i,j,x,y,z;    \r\n	scanf("%d%d%d",&n,&p,&c);    \r\n	ans = 0x7FFFFFFF;    \r\n	for(i = 1; i <= n; ++ i)   \r\n		scanf("%d",&cow[i]);   \r\n	for(i = 1; i <= c; ++ i)   \r\n	{          \r\n		scanf("%d%d%d",&x,&y,&z);       \r\n		++ l[x][0];        \r\n		a[x][y] = z;          \r\n		l[x][l[x][0]] = y;        \r\n		++ l[y][0];         \r\n		a[y][x] = z;        \r\n		l[y][l[y][0]] = x;   \r\n}     \r\n	for(i = 1; i <= p; ++ i)    \r\n	{          \r\n		f = 1;        \r\n		e = 1;       \r\n		q[1] = i;       \r\n		memset(dis,0x7F,sizeof(dis));         \r\n		memset(flag,0,sizeof(flag));        \r\n		dis[i] = 0;        \r\n		spfa(i);    \r\n}    \r\n	printf("%d\\n",ans);    \r\n	return 0;\r\n}\r\n\r\n       ', 'Main.c:5:6: error: expected ''='', '','', '';'', ''asm'' or ''__attribute__'' before ''flag''\r\nMain.c: In function ''spfa'':\r\nMain.c:10:2: error: ''flag'' undeclared (first use in this function)\r\nMain.c:10:2: note: each undeclared identifier is reported only once for each function it appears in\r\nMain.c:10:12: error: ''true'' undeclared (first use in this function)\r\nMain.c:28:14: error: ''false'' undeclared (first use in this function)\r\nMain.c: In function ''main'':\r\nMain.c:60:10: error: ''flag'' undeclared (first use i', 0, 0, 2, 1, '2010-11-25 08:33:53', '0001-01-01 00:00:00'),
(990, 14, 378, 6, '#include<stdio.h>\r\n#include<math.h>\r\n\r\ntypedef struct {\r\n	float x;\r\n	float y;\r\n}Point;\r\nfloat min(float x,float y)\r\n{\r\n	return x>y? y : x ;\r\n\r\n}\r\n\r\nfloat max(float x,float y)\r\n{\r\n	return x>y? x : y ;\r\n\r\n}\r\n\r\nint isInPolygon( Point test, Point *PolygonPoint,int edge)\r\n{\r\n	int i,n = 0;\r\n	for (i = 0; i < edge; ++i)\r\n	{\r\n\r\n		Point p1 = PolygonPoint[i]; \r\n		Point p2 = PolygonPoint[(i + 1) % edge]; \r\n		\r\n		float k1,k2;\r\n\r\n		if(  ( p1.x == test.x && p1.y == test.y) ||  (p2.x == test.x && p2.y == test.y ) )\r\n			return 0;\r\n\r\n		if ( p1.y == p2.y ) \r\n		{\r\n			if(test.y == p1.y)\r\n			{\r\n				if(test.x > min(p1.x,p2.x) & test.x < max(p1.x,p2.x) )\r\n					return -1;\r\n				return 0;\r\n			\r\n			}\r\n			continue; \r\n		}\r\n\r\n		if ( test.y <= min(p1.y, p2.y) )\r\n			continue; \r\n		if ( test.y >= max(p1.y, p2.y) ) \r\n			continue;\r\n\r\n		k1 =  p2.x == p1.x ? 0 : (p2.y - p1.y)/(p2.x - p1.x);\r\n		k2 =  test.x == p1.x ? 0 : (test.y - p1.y)/(test.x - p1.x);\r\n\r\n		if( fabs( k1-k2) <0.001)\r\n			return 0;\r\n		\r\n		float x = (float)(test.y - p1.y) * (float)(p2.x - p1.x) / (float)(p2.y - p1.y) + p1.x; \r\n		if ( x > test.x ) \r\n			++n;  \r\n	} \r\n\r\n    if(n%2 == 1)\r\n	   return 1;\r\n    else\r\n	   return -1;\r\n} \r\n\r\n\r\nint main()\r\n{\r\n	int i,edgecount,pointcount;\r\n	Point pointArray[301], testPoint[301];\r\n	while( scanf("%d %d",&edgecount,&pointcount) == 2 )\r\n	{\r\n		if( 0 == edgecount && 0 == pointcount )\r\n			break;\r\n		\r\n		for(i=0;i<edgecount;++i)\r\n		{\r\n			scanf("%f",&(pointArray[i].x) );\r\n			scanf("%f",&(pointArray[i].y) );\r\n		}\r\n\r\n		for(i=0;i<pointcount;++i)\r\n		{\r\n			scanf("%f",&(testPoint[i].x ) );\r\n			scanf("%f",&(testPoint[i].y ) );\r\n		}\r\n\r\n		for(i=0;i<pointcount;++i)\r\n		{\r\n			printf("%d\\n",isInPolygon(testPoint[i],  pointArray ,edgecount) );\r\n			\r\n		}\r\n\r\n	}\r\n\r\n\r\n	return 0;\r\n}', '', 0, 258048, 4, 1, '2010-11-25 08:38:31', '0001-01-01 00:00:00'),
(991, 13, 379, 7, '#include<stdio.h>\r\n#include<string.h>\r\n\r\nint n,p,c,l[801][801],cow[501],a[801][801],q[641601],f,e,dis[801],ans;\r\nbool flag[801];\r\n\r\nvoid spfa(int s)\r\n{     \r\n	int st,i,total = 0;     \r\n	flag[s] = true;     \r\n	while(f <= e)     \r\n	{            \r\n		st = q[f];            \r\n		for(i = 1; i <= l[st][0]; ++ i)            \r\n		{                  \r\n			if(dis[st] + a[st][l[st][i]] < dis[l[st][i]])                  \r\n			{                             \r\n				dis[l[st][i]] =  dis[st] + a[st][l[st][i]];                            \r\n				if(!flag[l[st][i]])                            \r\n				{                                                     \r\n					++ e;                                                     \r\n					q[e] = l[st][i];                                               \r\n					flag[l[st][i]] = true;   \r\n				}\r\n			}\r\n		}\r\n\r\n		flag[st] = false;          \r\n		++ f;    \r\n	}     \r\n	for(i = 1; i <= n; ++ i)          \r\n		total += dis[cow[i]];    \r\n	if(total < ans)     \r\n		ans = total;\r\n}\r\n\r\nint main()\r\n{      \r\n	int i,x,y,z;    \r\n	scanf("%d%d%d",&n,&p,&c);    \r\n	ans = 0x7FFFFFFF;    \r\n	for(i = 1; i <= n; ++ i)   \r\n		scanf("%d",&cow[i]);   \r\n	for(i = 1; i <= c; ++ i)   \r\n	{          \r\n		scanf("%d%d%d",&x,&y,&z);       \r\n		++ l[x][0];        \r\n		a[x][y] = z;          \r\n		l[x][l[x][0]] = y;        \r\n		++ l[y][0];         \r\n		a[y][x] = z;        \r\n		l[y][l[y][0]] = x;   \r\n}     \r\n	for(i = 1; i <= p; ++ i)    \r\n	{          \r\n		f = 1;        \r\n		e = 1;       \r\n		q[1] = i;       \r\n		memset(dis,0x7F,sizeof(dis));         \r\n		memset(flag,0,sizeof(flag));        \r\n		dis[i] = 0;        \r\n		spfa(i);    \r\n}    \r\n	printf("%d\\n",ans);    \r\n	return 0;\r\n}\r\n\r\n       ', 'Main.c:5:6: error: expected ''='', '','', '';'', ''asm'' or ''__attribute__'' before ''flag''\r\nMain.c: In function ''spfa'':\r\nMain.c:10:2: error: ''flag'' undeclared (first use in this function)\r\nMain.c:10:2: note: each undeclared identifier is reported only once for each function it appears in\r\nMain.c:10:12: error: ''true'' undeclared (first use in this function)\r\nMain.c:28:14: error: ''false'' undeclared (first use in this function)\r\nMain.c: In function ''main'':\r\nMain.c:60:10: error: ''flag'' undeclared (first use i', 0, 0, 2, 1, '2010-11-25 08:40:45', '0001-01-01 00:00:00'),
(992, 10, 374, 5, '#include<stdio.h>\r\n#include<string.h>\r\n\r\n#define N 10000\r\n\r\nint main()\r\n{\r\n int i,start,size,sum,max,count=0,total;\r\n int max_start,max_end;\r\n int shuzu[N];\r\n int store[N];\r\n int n= -1;\r\n scanf("%d",&total);\r\n while(count != total)\r\n {\r\n scanf("%d",&size);\r\n for(i = 0 ; i != size ;++i)\r\n  scanf("%d",&shuzu[i]);\r\n i = sum = start = max = 0;\r\n while(i != size)\r\n {\r\n  sum += shuzu[i];\r\n  if(sum < 0)\r\n  {\r\n   start = i+1;\r\n   sum = 0;\r\n  }\r\n  if(sum > max)\r\n  {\r\n   max = sum;\r\n   max_start = start;\r\n   max_end = i;\r\n  }\r\n  ++i;\r\n }\r\n for(i = 0; i != 3;++i)\r\n {\r\n	 store[++n] = max;\r\n     store[++n] = max_start;\r\n	 store[++n] = max_end;\r\n }\r\n count++;\r\n }\r\n\r\n for(i = 0,n =0; i != total; ++i)\r\n {\r\n printf("Case %d:\\n",i+1);\r\n printf("%d %d %d\\n\\n",store[n],store[n+1],store[n+2]);\r\n n = n+3;\r\n }\r\n return 0;\r\n}\r\n ', '', 15, 299008, 4, 1, '2010-11-25 08:41:03', '0001-01-01 00:00:00'),
(993, 14, 378, 6, '#include<stdio.h>\r\n#include<math.h>\r\n\r\ntypedef struct {\r\n	float x;\r\n\r\n	float y;\r\n}Point;\r\nfloat min(float x,float y)\r\n{\r\n	return x>y? y : x ;\r\n\r\n}\r\n\r\nfloat max(float x,float y)\r\n{\r\n	return x>y? x : y ;\r\n\r\n}\r\n\r\nint isInPolygon( Point test, Point *PolygonPoint,int edge)\r\n{\r\n	int i,n = 0;\r\n	for (i = 0; i < edge; ++i)\r\n	{\r\n\r\n		Point p1 = PolygonPoint[i]; \r\n		Point p2 = PolygonPoint[(i + 1) % edge]; \r\n		\r\n		float k1,k2;\r\n\r\n		if(  ( p1.x == test.x && p1.y == test.y) ||  (p2.x == test.x && p2.y == test.y ) )\r\n			return 0;\r\n\r\n		if ( p1.y == p2.y ) \r\n		{\r\n			if(test.y == p1.y)\r\n			{\r\n				if(test.x > min(p1.x,p2.x) && test.x < max(p1.x,p2.x) )\r\n					return 0;\r\n				\r\n				return -1;\r\n			\r\n			}\r\n			continue; \r\n		}\r\n\r\n		if ( test.y <= min(p1.y, p2.y) )\r\n			continue; \r\n		if ( test.y >= max(p1.y, p2.y) ) \r\n			continue;\r\n\r\n		k1 =  p2.x == p1.x ? 0 : (p2.y - p1.y)/(p2.x - p1.x);\r\n		k2 =  test.x == p1.x ? 0 : (test.y - p1.y)/(test.x - p1.x);\r\n\r\n		if( fabs( k1-k2) <0.001)\r\n			return 0;\r\n		\r\n		float x = (float)(test.y - p1.y) * (float)(p2.x - p1.x) / (float)(p2.y - p1.y) + p1.x; \r\n		if ( x > test.x ) \r\n			++n;  \r\n	} \r\n\r\n    if(n%2 == 1)\r\n	   return 1;\r\n    else\r\n	   return -1;\r\n} \r\n\r\n\r\nint main()\r\n{\r\n	int i,edgecount,pointcount;\r\n	Point pointArray[301], testPoint[301];\r\n	while( scanf("%d %d",&edgecount,&pointcount) == 2 )\r\n	{\r\n		if( 0 == edgecount && 0 == pointcount )\r\n			break;\r\n		\r\n		for(i=0;i<edgecount;++i)\r\n		{\r\n			scanf("%f",&(pointArray[i].x) );\r\n			scanf("%f",&(pointArray[i].y) );\r\n		}\r\n\r\n		for(i=0;i<pointcount;++i)\r\n		{\r\n			scanf("%f",&(testPoint[i].x ) );\r\n			scanf("%f",&(testPoint[i].y ) );\r\n		}\r\n\r\n		for(i=0;i<pointcount;++i)\r\n		{\r\n			printf("%d\\n",isInPolygon(testPoint[i],  pointArray ,edgecount) );\r\n			\r\n		}\r\n\r\n	}\r\n\r\n\r\n	return 0;\r\n}', '', 0, 262144, 4, 1, '2010-11-25 08:50:22', '0001-01-01 00:00:00'),
(994, 10, 374, 5, '#include<stdio.h>\r\n#include<string.h>\r\n\r\n#define N 10000\r\n\r\nint main()\r\n{\r\n int i,start,size,sum,max,count=0,total;\r\n int max_start,max_end;\r\n int shuzu[N];\r\n int store[N];\r\n int n=0;\r\n scanf("%d",&total);\r\n while(count != total)\r\n {\r\n scanf("%d",&size);\r\n for(i = 0 ; i != size ;++i)\r\n  scanf("%d",&shuzu[i]);\r\n i = sum = start = max = max_start = max_end = 0;\r\n while(i != size)\r\n {\r\n  sum += shuzu[i];\r\n  if(sum < 0)\r\n  {\r\n   start = i+1;\r\n   sum = 0;\r\n  }\r\n  if(sum > max)\r\n  {\r\n   max = sum;\r\n   max_start = start;\r\n   max_end = i;\r\n  }\r\n  ++i;\r\n }\r\n store[n] = max;\r\n store[n+1] = max_start;\r\n store[2+n] = max_end;\r\n n = n+3;\r\n count++;\r\n }\r\n\r\n for(i = 0,n =0; i != total; ++i)\r\n {\r\n printf("Case %d:\\n",i+1);\r\n printf("%d %d %d\\n\\n",store[n],store[1+n]+1,store[2+n]+1);\r\n n=n+3;\r\n }\r\n return 0;\r\n}\r\n ', '', 15, 299008, 4, 1, '2010-11-25 08:53:19', '0001-01-01 00:00:00'),
(995, 13, 379, 7, '#include<stdio.h>\r\n#include<string.h>\r\n\r\nint n,p,c,l[801][801],cow[501],a[801][801],q[641601],f,e,dis[801],ans;\r\n\r\nvoid spfa(int s,bool flag[])\r\n{     \r\n	int st,i,total = 0;     \r\n	flag[s] = true;     \r\n	while(f <= e)     \r\n	{            \r\n		st = q[f];            \r\n		for(i = 1; i <= l[st][0]; ++ i)            \r\n		{                  \r\n			if(dis[st] + a[st][l[st][i]] < dis[l[st][i]])                  \r\n			{                             \r\n				dis[l[st][i]] =  dis[st] + a[st][l[st][i]];                            \r\n				if(!flag[l[st][i]])                            \r\n				{                                                     \r\n					++ e;                                                     \r\n					q[e] = l[st][i];                                               \r\n					flag[l[st][i]] = true;   \r\n				}\r\n			}\r\n		}\r\n\r\n		flag[st] = false;          \r\n		++ f;    \r\n	}     \r\n	for(i = 1; i <= n; ++ i)          \r\n		total += dis[cow[i]];    \r\n	if(total < ans)     \r\n		ans = total;\r\n}\r\n\r\nint main()\r\n{      \r\n	int i,x,y,z;\r\n    bool flag[801];\r\n	scanf("%d%d%d",&n,&p,&c);    \r\n	ans = 0x7FFFFFFF;    \r\n	for(i = 1; i <= n; ++ i)   \r\n		scanf("%d",&cow[i]);   \r\n	for(i = 1; i <= c; ++ i)   \r\n	{          \r\n		scanf("%d%d%d",&x,&y,&z);       \r\n		++ l[x][0];        \r\n		a[x][y] = z;          \r\n		l[x][l[x][0]] = y;        \r\n		++ l[y][0];         \r\n		a[y][x] = z;        \r\n		l[y][l[y][0]] = x;   \r\n}     \r\n	for(i = 1; i <= p; ++ i)    \r\n	{          \r\n		f = 1;        \r\n		e = 1;       \r\n		q[1] = i;       \r\n		memset(dis,0x7F,sizeof(dis));         \r\n		memset(flag,0,sizeof(flag));        \r\n		dis[i] = 0;        \r\n		spfa(i,flag);    \r\n}    \r\n	printf("%d\\n",ans);    \r\n	return 0;\r\n}\r\n\r\n       ', 'Main.c:6:17: error: expected declaration specifiers or ''...'' before ''bool''\r\nMain.c: In function ''spfa'':\r\nMain.c:9:2: error: ''flag'' undeclared (first use in this function)\r\nMain.c:9:2: note: each undeclared identifier is reported only once for each function it appears in\r\nMain.c:9:12: error: ''true'' undeclared (first use in this function)\r\nMain.c:27:14: error: ''false'' undeclared (first use in this function)\r\nMain.c: In function ''main'':\r\nMain.c:39:5: error: ''bool'' undeclared (first use in this func', 0, 0, 2, 1, '2010-11-25 08:53:59', '0001-01-01 00:00:00'),
(996, 14, 378, 6, '#include<stdio.h>\r\n#include<math.h>\r\n#include<limits.h>\r\n\r\ntypedef struct {\r\n	float x;\r\n\r\n	float y;\r\n}Point;\r\n\r\nfloat min(float x,float y)\r\n{\r\n	return x>y? y : x ;\r\n\r\n}\r\n\r\nfloat max(float x,float y)\r\n{\r\n	return x>y? x : y ;\r\n\r\n}\r\n\r\nint isInPolygon( Point test, Point *PolygonPoint,int edge)\r\n{\r\n	int i,n = 0;\r\n	for (i = 0; i < edge; ++i)\r\n	{\r\n\r\n		Point p1 = PolygonPoint[i]; \r\n		Point p2 = PolygonPoint[(i + 1) % edge]; \r\n		\r\n		float k1,k2;\r\n\r\n		if(  ( p1.x == test.x && p1.y == test.y) ||  (p2.x == test.x && p2.y == test.y ) )\r\n			return 0;\r\n\r\n		if ( p1.y == p2.y ) \r\n		{\r\n			if(test.y == p1.y)\r\n			{\r\n				if(test.x > min(p1.x,p2.x) && test.x < max(p1.x,p2.x) )\r\n					return 0;\r\n				\r\n			}\r\n			continue; \r\n		}\r\n\r\n		if ( test.y < min(p1.y, p2.y) )\r\n			continue; \r\n		if ( test.y >= max(p1.y, p2.y) ) \r\n			continue;\r\n\r\n		k1 =  p2.x == p1.x ? INT_MAX : (p2.y - p1.y)/(p2.x - p1.x);\r\n		k2 =  test.x == p1.x ? INT_MAX : (test.y - p1.y)/(test.x - p1.x);\r\n\r\n		if( fabs( k1-k2) <0.001)\r\n			return 0;\r\n		\r\n		float x = (float)(test.y - p1.y) * (float)(p2.x - p1.x) / (float)(p2.y - p1.y) + p1.x; \r\n		if ( x > test.x ) \r\n			++n;  \r\n	} \r\n\r\n    if(n%2 == 1)\r\n	   return 1;\r\n    else\r\n	   return -1;\r\n} \r\n\r\n\r\nint main()\r\n{\r\n	int i,edgecount,pointcount;\r\n	Point pointArray[301], testPoint[301];\r\n	while( scanf("%d %d",&edgecount,&pointcount) == 2 )\r\n	{\r\n		if( 0 == edgecount && 0 == pointcount )\r\n			break;\r\n		\r\n		for(i=0;i<edgecount;++i)\r\n		{\r\n			scanf("%f",&(pointArray[i].x) );\r\n			scanf("%f",&(pointArray[i].y) );\r\n		}\r\n\r\n		for(i=0;i<pointcount;++i)\r\n		{\r\n			scanf("%f",&(testPoint[i].x ) );\r\n			scanf("%f",&(testPoint[i].y ) );\r\n		}\r\n\r\n		for(i=0;i<pointcount;++i)\r\n		{\r\n			printf("%d\\n",isInPolygon(testPoint[i],  pointArray ,edgecount) );\r\n			\r\n		}\r\n\r\n	}\r\n\r\n\r\n	return 0;\r\n}', '', 0, 258048, 4, 1, '2010-11-25 09:27:22', '0001-01-01 00:00:00');
INSERT INTO `tbl_submitions` (`id`, `user_id`, `problem_id`, `exercise_id`, `source`, `result`, `used_time`, `used_memory`, `status`, `compiler_id`, `created`, `modified`) VALUES
(997, 6, 379, 7, '#include <stdio.h>\r\n#include <string.h>\r\n#define N 850\r\n#define M 3000\r\n#define INF 1<<30\r\nstruct Edge {\r\n   int v;\r\n   int w;\r\n   int next;\r\n}et[M];\r\nint head[N], mp, n, m, t;\r\nint in[N], dis[N], cow[N], Q[N*10];\r\n\r\nvoid add(int u, int v, int w)\r\n{\r\n    et[mp].v = v;\r\n    et[mp].w = w;\r\n    et[mp].next = head[u];\r\n    head[u] = mp++; \r\n}\r\n\r\nvoid add_e(int u, int v, int w)\r\n{\r\n    add(u, v, w);\r\n    add(v, u, w);\r\n}\r\n\r\n\r\nint spfa(int s)\r\n{\r\n    int i, front, rear, u, v, w, total;\r\n    for(i = 1; i <= n; ++i)\r\n        dis[i] = INF;\r\n    \r\n    memset(in, 0, sizeof(in));\r\n    front = rear = 0;\r\n    dis[s] = 0;\r\n    in[s] = 1;\r\n    Q[rear++] = s;\r\n    while(front < rear) {\r\n        u = Q[front++];\r\n        in[u] = 0;\r\n        \r\n        for(i = head[u]; i != -1; i=et[i].next) {\r\n            v = et[i].v;\r\n            w = et[i].w;\r\n            if(dis[v] > dis[u]+w) {\r\n               dis[v] = dis[u]+w;\r\n               if(in[v] == 0) {\r\n                  in[v] = 1;\r\n                  Q[rear++] = v;\r\n               }\r\n            }\r\n        }\r\n    }\r\n    \r\n    total = 0;\r\n    for(i = 1; i <= m; ++i) \r\n        total += dis[cow[i]];\r\n    return total;\r\n}\r\n\r\nint main()\r\n{\r\n    int i, a, b, c, res;\r\n    while(scanf("%d %d %d",&m,&n,&t) == 3) {\r\n       for(i = 1; i <= m; ++i)\r\n           scanf("%d",&cow[i]);\r\n       mp = 0;\r\n       memset(head, -1, sizeof(head));\r\n       while(t--) {\r\n          scanf("%d %d %d",&a,&b,&c);\r\n          add_e(a,b,c);\r\n       }\r\n       \r\n       res = INF;\r\n       for(i = 1; i <= n; ++i) {\r\n           c = spfa(i);\r\n           if(res > c)\r\n              res = c;\r\n       }\r\n       printf("%d\\n",res);\r\n    }\r\n    return 0;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n', '', 248, 344064, 1, 1, '2010-11-25 09:36:24', '0001-01-01 00:00:00'),
(998, 16, 374, 5, '#include<stdio.h>\r\nint main(){\r\n	int n;\r\n	scanf("%d",&n);\r\n	int out[1000][3];\r\n	for(int i=0;i!=n;++i){\r\n		int count,sum1,sum2,bg,end;\r\n		scanf("%d",&count);\r\n		int num[20000];\r\n		//cin.get(num,count);\r\n		for(int m=0;m!=count;++m)\r\n			scanf("%d",&num[m]);	\r\n		sum1=sum2=num[0];\r\n		bg=1;	\r\n		for(int a=1;a!=count;++a){\r\n			sum2+=num[a];\r\n			if(sum2<num[a])\r\n				bg=a+1;\r\n			else if(sum2>=sum1){\r\n				sum1=sum2;\r\n				end=a+1;\r\n			}\r\n		}\r\n		out[i][0]=sum1;\r\n		out[i][1]=bg;  out[i][2]=end;\r\n	}\r\n	for(int ou=0;ou!=n;++ou)\r\n		printf("Case %d:\\n%d  %d  %d\\n\\n",ou+1,out[ou][0],out[ou][1],out[ou][2]);\r\n	return 0;\r\n}\r\n\r\n', '', 15, 311296, 4, 2, '2010-11-25 09:51:14', '0001-01-01 00:00:00'),
(999, 6, 380, 7, '#include <stdio.h>\r\n#define N 100\r\n#define INF  100000\r\nint g[N][N], tax[N], n;\r\nint p[N][N];\r\n\r\nvoid floyd()\r\n{\r\n    int i, j, t, k;\r\n    for(i = 1; i <= n; ++i)\r\n        for(j = 1; j <= n; ++j)\r\n            p[i][j] = j;\r\n    for(k=1;k<=n;k++)\r\n        for(i=1;i<=n;i++)\r\n            for(j=1;j<=n;j++)\r\n            {\r\n                t=g[i][k]+g[k][j]+tax[k];\r\n                if(t<g[i][j])\r\n                {\r\n                    g[i][j]=t;\r\n                    p[i][j]=p[i][k];\r\n                }\r\n                else if(t==g[i][j])\r\n                    if(p[i][j]>p[i][k])\r\n                        p[i][j]=p[i][k];\r\n            }\r\n}\r\n\r\nint main()\r\n{\r\n    int i, j, k;\r\n    while(scanf("%d",&n) == 1 && n) {\r\n       for(i = 1; i <= n; ++i) {\r\n           for(j = 1; j <= n; ++j) {\r\n               scanf("%d",&g[i][j]);\r\n               if(g[i][j] == -1)\r\n                  g[i][j] = INF;\r\n           }\r\n       }\r\n       for(i = 1; i <= n; ++i)\r\n           scanf("%d",&tax[i]);\r\n       floyd();\r\n       \r\n       while(scanf("%d %d",&i,&j) && !(i == -1 && j == -1)) {\r\n           printf("From %d to %d :\\n",i,j);\r\n           printf("Path: %d",i);\r\n           k = i;\r\n           while(k != j) {  \r\n              printf("-->%d",p[k][j]);\r\n              k = p[k][j];\r\n           }\r\n           printf("\\nTotal cost : %d\\n\\n",g[i][j]);\r\n       }\r\n    }\r\n    return 0;\r\n}\r\n', '', 0, 335872, 1, 2, '2010-11-25 09:54:55', '0001-01-01 00:00:00'),
(1000, 27, 374, 5, '爱的发生的', 'Main.c:1:1: error: stray ''\\347'' in program\r\nMain.c:1:1: error: stray ''\\210'' in program\r\nMain.c:1:1: error: stray ''\\261'' in program\r\nMain.c:1:1: error: stray ''\\347'' in program\r\nMain.c:1:1: error: stray ''\\232'' in program\r\nMain.c:1:1: error: stray ''\\204'' in program\r\nMain.c:1:1: error: stray ''\\345'' in program\r\nMain.c:1:1: error: stray ''\\217'' in program\r\nMain.c:1:1: error: stray ''\\221'' in program\r\nMain.c:1:1: error: stray ''\\347'' in program\r\nMain.c:1:1: error: stray ''\\224'' in program\r\nMain.c:1:1: erro', 0, 0, 2, 1, '2010-11-25 09:55:47', '0001-01-01 00:00:00'),
(1001, 17, 377, 6, '#include <stdio.h>\r\ntypedef struct Point\r\n{\r\ndouble x1,y1;\r\ndouble x2,y2;\r\n}Point;\r\nPoint sec[302];\r\ndouble direction(double x1,double y1,double x2,double y2)\r\n{ \r\n       return x1*y2-x2*y1; \r\n}\r\n\r\nbool crossed(Point A,Point B)            \r\n{\r\n  return (direction(A.x1-B.x1, A.y1-B.y1 , B.x2-B.x1, B.y2-B.y1)\r\n             *direction(B.x2-B.x1, B.y2-B.y1, A.x2-B.x1, A.y2-B.y1) >= 0);       \r\n}\r\n\r\n\r\nint main()\r\n{\r\n  int test;\r\n  int i,j;\r\n  int cnt;\r\n  while(scanf("%d",&test) && test)\r\n {\r\n    for(i=0;i<test;i++)\r\n    {\r\n        scanf("%lf %lf %lf %lf",&sec[i].x1, &sec[i].y1, &sec[i].x2, &sec[i].y2);\r\n    }\r\n    cnt = 0;\r\n    for( i=0;i<test;i++)\r\n    {\r\n        for( j=i+1;j<test;j++)\r\n        {\r\n          if(crossed(sec[i], sec[j]) && crossed(sec[j],sec[i]) )\r\n            cnt++;\r\n        }\r\n    }\r\n    printf("%d\\n",cnt);\r\n }\r\nreturn 0;\r\n}\r\n \r\n\r\n', 'Main.c:13:6: error: expected ''='', '','', '';'', ''asm'' or ''__attribute__'' before ''crossed''\r\n', 0, 0, 2, 1, '2010-11-29 12:41:38', '0001-01-01 00:00:00'),
(1002, 17, 377, 6, '#include <stdio.h>\r\n#include<iostream>\r\nusing namespace std;\r\ntypedef struct Point\r\n{\r\ndouble x1,y1;\r\ndouble x2,y2;\r\n}Point;\r\nPoint sec[302];\r\ndouble direction(double x1,double y1,double x2,double y2)\r\n{ \r\n       return x1*y2-x2*y1; \r\n}\r\n\r\nbool crossed(Point A,Point B)            \r\n{\r\n  return (direction(A.x1-B.x1, A.y1-B.y1 , B.x2-B.x1, B.y2-B.y1)\r\n             *direction(B.x2-B.x1, B.y2-B.y1, A.x2-B.x1, A.y2-B.y1) >= 0);       \r\n}\r\n\r\n\r\nint main()\r\n{\r\n  int test;\r\n  int i,j;\r\n  int cnt;\r\n  while(scanf("%d",&test) && test)\r\n {\r\n    for(i=0;i<test;i++)\r\n    {\r\n        scanf("%lf %lf %lf %lf",&sec[i].x1, &sec[i].y1, &sec[i].x2, &sec[i].y2);\r\n    }\r\n    cnt = 0;\r\n    for( i=0;i<test;i++)\r\n    {\r\n        for( j=i+1;j<test;j++)\r\n        {\r\n          if(crossed(sec[i], sec[j]) && crossed(sec[j],sec[i]) )\r\n            cnt++;\r\n        }\r\n    }\r\n    printf("%d\\n",cnt);\r\n }\r\nreturn 0;\r\n}\r\n \r\n\r\n', '', 0, 380928, 4, 2, '2010-11-29 12:43:24', '0001-01-01 00:00:00'),
(1003, 17, 377, 6, '#include <iostream>\r\nusing namespace std;\r\n\r\ndouble direction(double x1,double y1,double x2,double y2)\r\n{ return x1*y2-x2*y1; }\r\n\r\nbool crossed(double A_x1,double A_y1,double A_x2,double A_y2,\r\n    double B_x1,double B_y1,double B_x2,double B_y2)            \r\n{\r\nreturn (direction(A_x1-B_x1, A_y1-B_y1 , B_x2-B_x1, B_y2-B_y1)\r\n   *direction(B_x2-B_x1, B_y2-B_y1, A_x2-B_x1, A_y2-B_y1) >= 0);       \r\n}\r\n\r\nstruct SECMENT\r\n{\r\ndouble x1,y1;\r\ndouble x2,y2;\r\n}sec[100];\r\n\r\nint main()\r\n{\r\nint N;\r\nwhile(scanf("%d",&N) && N)\r\n{\r\n    for(int i=0;i<N;i++)\r\n    {\r\n        scanf("%lf %lf %lf %lf",&sec[i].x1, &sec[i].y1, &sec[i].x2, &sec[i].y2);\r\n    }\r\n    int cnt = 0;\r\n    for(int i=0;i<N;i++)\r\n    {\r\n        for(int j=i+1;j<N;j++)\r\n        {\r\n          if(crossed(sec[i].x1, sec[i].y1, sec[i].x2, sec[i].y2, \r\n                     sec[j].x1, sec[j].y1, sec[j].x2, sec[j].y2)\r\n    && crossed(sec[j].x1, sec[j].y1, sec[j].x2, sec[j].y2, \r\n                     sec[i].x1, sec[i].y1, sec[i].x2, sec[i].y2) )\r\n            cnt++;\r\n        }\r\n    }\r\n    printf("%d\\n",cnt);\r\n}\r\nreturn true;\r\n}', 'Main.cpp: In function ''int main()'':\r\nMain.cpp:23:20: error: ''scanf'' was not declared in this scope\r\nMain.cpp:41:22: error: ''printf'' was not declared in this scope\r\n', 0, 0, 2, 2, '2010-11-29 13:00:17', '0001-01-01 00:00:00'),
(1004, 17, 377, 6, '#include <iostream>\r\n#include<stdio.h>\r\nusing namespace std;\r\n\r\ndouble direction(double x1,double y1,double x2,double y2)\r\n{ return x1*y2-x2*y1; }\r\n\r\nbool crossed(double A_x1,double A_y1,double A_x2,double A_y2,\r\n    double B_x1,double B_y1,double B_x2,double B_y2)            \r\n{\r\nreturn (direction(A_x1-B_x1, A_y1-B_y1 , B_x2-B_x1, B_y2-B_y1)\r\n   *direction(B_x2-B_x1, B_y2-B_y1, A_x2-B_x1, A_y2-B_y1) >= 0);       \r\n}\r\n\r\nstruct SECMENT\r\n{\r\ndouble x1,y1;\r\ndouble x2,y2;\r\n}sec[100];\r\n\r\nint main()\r\n{\r\nint N;\r\nwhile(scanf("%d",&N) && N)\r\n{\r\n    for(int i=0;i<N;i++)\r\n    {\r\n        scanf("%lf %lf %lf %lf",&sec[i].x1, &sec[i].y1, &sec[i].x2, &sec[i].y2);\r\n    }\r\n    int cnt = 0;\r\n    for(int i=0;i<N;i++)\r\n    {\r\n        for(int j=i+1;j<N;j++)\r\n        {\r\n          if(crossed(sec[i].x1, sec[i].y1, sec[i].x2, sec[i].y2, \r\n                     sec[j].x1, sec[j].y1, sec[j].x2, sec[j].y2)\r\n    && crossed(sec[j].x1, sec[j].y1, sec[j].x2, sec[j].y2, \r\n                     sec[i].x1, sec[i].y1, sec[i].x2, sec[i].y2) )\r\n            cnt++;\r\n        }\r\n    }\r\n    printf("%d\\n",cnt);\r\n}\r\nreturn true;\r\n}\r\n', '', 0, 368640, 4, 2, '2010-11-29 13:01:25', '0001-01-01 00:00:00'),
(1005, 17, 377, 6, '#include<stdio.h>\r\n#define M 301\r\ntypedef struct point{\r\n        float x1,y1;\r\n        float x2,y2;\r\n}Point;\r\nPoint seg[M];\r\nint cal(Point p0,Point p1)\r\n{   \r\n     float z1,z2;\r\n     z1=(p0.x1-p1.x1)*(p1.y2-p1.y1)-(p0.y1-p1.y1)*(p1.x2-p1.x1);\r\n     z2=(p1.x2-p1.x1)*(p0.y2-p1.y1)-(p1.y2-p1.y1)*(p0.x2-p1.x1);\r\n     if(z1*z2>=0)\r\n       return 1;\r\n     else \r\n     return 0;\r\n}         \r\nint main()\r\n{\r\n    int i,test,j;\r\n    int count;\r\n    while(scanf("%d",&test)&&test!=0)\r\n    {   \r\n        count=0;\r\n        for(i=0;i<test;i++)\r\n          scanf("%f %f %f %f",&seg[i].x1,&seg[i].y1,&seg[i].x2,&seg[i].y2);\r\n        for(i=0;i<test;i++)\r\n         for(j=i+1;j<test;j++)\r\n          if(cal(seg[i],seg[j])&&cal(seg[j],seg[i]))\r\n           count++;\r\n        printf("%d\\n",count);\r\n    }\r\n}\r\n', '', 0, 262144, 4, 1, '2010-11-29 13:29:11', '0001-01-01 00:00:00'),
(1006, 17, 377, 6, '#include<stdio.h>\r\n#define M 301\r\ntypedef struct point{\r\n        float x1,y1;\r\n        float x2,y2;\r\n}Point;\r\nPoint seg[M];\r\n\r\nint cal(Point p0,Point p1)\r\n{\r\n    float z1,z2;\r\n    z1=(p1.x2-p0.x2)*(p0.y1-p0.x1)-(p1.x1-p0.x1)*(p0.y2-p0.x2);\r\n    z2=(p1.y2-p0.x2)*(p0.y1-p0.x1)-(p1.y1-p0.x1)*(p0.y2-p0.x2);\r\n    	if( (z1*z2)<0 )   return 1;  \r\n	else if(z1*z2==0.0){\r\n		if( (p1.x1>=p0.x1 && p1.x1<=p0.y1) || (p1.x1<=p0.x1 && p1.x1>=p0.y1) ){\r\n		    return 1;\r\n		}\r\n		if( (p1.y1>=p0.x1 &&p1.y1<=p0.y1) || (p1.y1<=p0.x1 && p1.y1>=p0.y1) ){\r\n		    return 1;\r\n		}\r\n	}\r\n	else  return 0;\r\n}\r\nint main()\r\n{\r\n    int i,test,j;\r\n    int count;\r\n    while(scanf("%d",&test)&&test!=0)\r\n    {   \r\n        count=0;\r\n        for(i=0;i<test;i++)\r\n          scanf("%f %f %f %f",&seg[i].x1,&seg[i].y1,&seg[i].x2,&seg[i].y2);\r\n        for(i=0;i<test;i++)\r\n         for(j=i+1;j<test;j++)\r\n          if(cal(seg[i],seg[j])&&cal(seg[j],seg[i]))\r\n           count++;\r\n        printf("%d\\n",count);\r\n    }\r\n}', '', 15, 266240, 4, 1, '2010-11-29 13:45:41', '0001-01-01 00:00:00'),
(1007, 17, 377, 6, '#include<stdio.h>\r\n#define M 301\r\ntypedef struct point{\r\n        float x1,y1;\r\n        float x2,y2;\r\n}Point;\r\nPoint seg[M];\r\n\r\nint cal(Point p0,Point p1)\r\n{\r\n    float z1,z2;\r\n    z1=(p1.x2-p0.x2)*(p0.y1-p0.x1)-(p1.x1-p0.x1)*(p0.y2-p0.x2);\r\n    z2=(p1.y2-p0.x2)*(p0.y1-p0.x1)-(p1.y1-p0.x1)*(p0.y2-p0.x2);\r\n    	if( (z1*z2)<0 )   return 1;  \r\n	else if(z1*z2==0.0){\r\n		if( (p1.x1>=p0.x1 && p1.x1<=p0.y1) || (p1.x1<=p0.x1 && p1.x1>=p0.y1) ){\r\n		    return 1;\r\n		}\r\n		if( (p1.y1>=p0.x1 &&p1.y1<=p0.y1) || (p1.y1<=p0.x1 && p1.y1>=p0.y1) ){\r\n		    return 1;\r\n		}\r\n	}\r\n	else  return 0;\r\n}\r\nint main()\r\n{\r\n    int i,test,j;\r\n    int count;\r\n    while(scanf("%d",&test)&&test!=0)\r\n    {   \r\n        count=0;\r\n        for(i=0;i<test;i++)\r\n          scanf("%f %f %f %f",&seg[i].x1,&seg[i].x2,&seg[i].y1,&seg[i].y2);\r\n        for(i=0;i<test;i++)\r\n         for(j=i+1;j<test;j++)\r\n          if(cal(seg[i],seg[j])&&cal(seg[j],seg[i]))\r\n           count++;\r\n        printf("%d\\n",count);\r\n    }\r\n}\r\n', '', 0, 262144, 4, 1, '2010-11-29 13:51:01', '0001-01-01 00:00:00'),
(1008, 6, 371, 0, '#include <cstdio>\r\n#include <algorithm>\r\n#include <utility>\r\n#include <cstdlib>\r\nusing namespace std;\r\nconst int N = 10005;\r\nconst int dr[4] = {-1, 0, 1, 0};\r\nconst int dc[4] = {0, -1, 0, 1};\r\nint costs[4];\r\nint x[N], y[N], s[N];\r\n\r\npair<int, int> medians(int z[], int n)\r\n{\r\n    copy(z, z+n, s);\r\n    nth_element(s, s+n/2, s+n);\r\n    if (n&1) return make_pair(s[n/2], s[n/2]);\r\n    else     return make_pair(*max_element(s, s+n/2), s[n/2]);\r\n}\r\n\r\nint cal(int a, int b, int N)\r\n{\r\n    int i, cost = 0;\r\n    for (i = 0; i < N; i++)\r\n        cost += abs(x[i]-a) + abs(y[i]-b);\r\n    return cost;\r\n}\r\n\r\nint main()\r\n{\r\n    int n, i, d;\r\n    pair<int, int> xlh, ylh;\r\n    int cost, opts;\r\n\r\n    while (scanf("%d",&n) == 1) {\r\n        for (i = 0; i < n; ++i)\r\n            scanf("%d %d",x+i,y+i);\r\n        xlh = medians(x, n);\r\n        ylh = medians(y, n);\r\n        opts = (xlh.second - xlh.first + 1) * (ylh.second - ylh.first + 1);\r\n        \r\n        for (i = 0; i < n; i++) {\r\n            if (x[i] >= xlh.first && x[i] <= xlh.second\r\n                && y[i] >= ylh.first && y[i] <= ylh.second)\r\n                opts--;\r\n        }\r\n        \r\n        cost = cal(xlh.first, ylh.first, n);\r\n        if (opts == 0) {\r\n            for (d = 0; d < 4; d++)\r\n                costs[d] = cal(xlh.first + dr[d], ylh.first + dc[d], n);\r\n            cost = *min_element(costs, costs + 4);\r\n            opts = count(costs, costs + 4, cost);\r\n        }\r\n        printf("%d %d\\n",cost,opts);\r\n    }\r\n    return 0;\r\n}\r\n', '', 15, 380928, 1, 2, '2010-11-29 19:13:47', '0001-01-01 00:00:00'),
(1009, 6, 372, 0, '#include <cstdio>\r\n#include <algorithm>\r\n#include <vector>\r\n#include <utility>\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n    vector<pair<int, int> > cows;\r\n    int n, i, j, k, m, w, nxt;\r\n    int ans;\r\n    \r\n    while (scanf("%d",&n) == 1) {\r\n        for (i = 0; i < n; i++) {\r\n            scanf("%d",&w);\r\n            cows.push_back(make_pair(w, i));\r\n        }\r\n        sort(cows.begin(), cows.end());\r\n        \r\n        ans = 0;\r\n        m = cows[0].first;\r\n        for (int i = 0; i < n; i++) {\r\n            if (cows[i].second != -1) {\r\n                j = cows[i].second;\r\n                w = cows[i].first;\r\n                k = 1;\r\n                cows[i].second = -1;\r\n                while (j != i) {\r\n                    ans += cows[j].first;\r\n                    nxt = cows[j].second;\r\n                    cows[j].second = -1;\r\n                    j = nxt;\r\n                    k++;\r\n                }\r\n                ans += min((k - 1) * w, (k - 1) * m + 2 * (m + w));\r\n            }\r\n        }\r\n        printf("%d\\n",ans);\r\n    }\r\n    return 0;\r\n}\r\n', '', 0, 294912, 7, 2, '2010-11-29 21:42:15', '0001-01-01 00:00:00'),
(1010, 6, 372, 0, '#include <cstdio>\r\n#include <algorithm>\r\n#include <vector>\r\n#include <utility>\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n    vector<pair<int, int> > cows;\r\n    int n, i, j, k, m, w, nxt, f = 0;\r\n    int ans;\r\n    \r\n    while (scanf("%d",&n) == 1) {\r\n        if(f) cows.clear();\r\n        for (i = 0; i < n; i++) {\r\n            scanf("%d",&w);\r\n            cows.push_back(make_pair(w, i));\r\n        }\r\n        sort(cows.begin(), cows.end());\r\n        \r\n        ans = 0;\r\n        m = cows[0].first;\r\n        for (int i = 0; i < n; i++) {\r\n            if (cows[i].second != -1) {\r\n                j = cows[i].second;\r\n                w = cows[i].first;\r\n                k = 1;\r\n                cows[i].second = -1;\r\n                while (j != i) {\r\n                    ans += cows[j].first;\r\n                    nxt = cows[j].second;\r\n                    cows[j].second = -1;\r\n                    j = nxt;\r\n                    k++;\r\n                }\r\n                ans += min((k - 1) * w, (k - 1) * m + 2 * (m + w));\r\n            }\r\n        }\r\n        printf("%d\\n",ans);\r\n        f = 1;\r\n    }\r\n    return 0;\r\n}\r\n', '', 0, 557056, 1, 2, '2010-11-29 21:43:21', '0001-01-01 00:00:00'),
(1011, 21, 336, 2, '#include<stdio.h>\r\n\r\nint bit_count(int n){\r\n	int count;\r\n	for(count = 0; n; n &= n - 1)\r\n	{\r\n       count++;\r\n	}	\r\n	return count;\r\n}\r\n\r\n\r\nint main(){\r\n	int n,a[50000][2],i,j,temp,c;\r\n	while(scanf("%d",&n)==1){\r\n	for(i=0;i<n;i++)\r\n	{\r\n		scanf("%d",&c);\r\n		a[i][0]=c;\r\n		a[i][1]=bit_count(c);\r\n	}\r\n\r\n	for(i=0;i<n-1;i++){\r\n		for(j=0;j<n-1-i;j++){\r\n			if((a[j][1]>a[j+1][1])||((a[j][1]==a[j+1][1])&&(a[j][0]>a[j+1][0]))){\r\n				temp=a[j][0];a[j][0]=a[j+1][0];a[j+1][0]=temp;\r\n				temp=a[j][1];a[j][1]=a[j+1][1];a[j+1][1]=temp;\r\n			}\r\n		}\r\n	}\r\n\r\n	for(i=0;i<n;i++)printf("%d ",a[i][0]); \r\n	printf("\\n");\r\n	}\r\n	return 0;		\r\n}', '', 200, 622592, 5, 1, '2010-12-01 19:44:55', '0001-01-01 00:00:00'),
(1012, 6, 383, 0, '#include <stdio.h>\r\n#include <string.h>\r\n#define N 310\r\n#define M 610\r\nchar data[N], words[M][30];\r\nint  best[N], len[M], n, m;\r\n\r\nvoid tryword(int pos, int wnum)\r\n{\r\n    int i, p = pos, t = 0;\r\n    for (i = 0; i < len[wnum]; ++i) {\r\n        while (data[p] != words[wnum][i]) {\r\n            ++p, ++t;\r\n            if (p >= m) return ;        \r\n        }\r\n        ++p;\r\n    }\r\n    if (best[pos] + t < best[p]) \r\n        best[p] = best[pos] +t;\r\n}\r\n\r\nint main()\r\n{\r\n    int i, j;\r\n    while (scanf("%d %d",&n, &m) == 2) {\r\n        scanf("%s",data);\r\n        for (i = 0; i < n; ++i) {\r\n             scanf("%s",words+i);\r\n             len[i] = strlen(words[i]);\r\n        }\r\n        for (i = 0; i <= m; ++i)\r\n            best[i] = i;\r\n        for (i = 0; i < m; ++i) {\r\n            for (j = 0; j < n; ++j) {\r\n                if (i + len[j] <= m) {\r\n                    if (data[i] == words[j][0])\r\n                        tryword(i, j);\r\n                }\r\n            }\r\n            if (best[i] + 1 < best[i+1]) \r\n                best[i+1] = best[i] + 1;\r\n        }\r\n        printf("%d\\n",best[m]);\r\n    }\r\n    return 0;\r\n}', '', 93, 278528, 1, 1, '2010-12-04 15:54:40', '0001-01-01 00:00:00'),
(1013, 6, 382, 0, '#include <stdio.h>\r\n#define N 1050\r\n#define INF 1<<30\r\nint map[N][N];\r\nint d[N], tmp[N] ,in[N], Q[N*10];\r\n\r\nvoid spfa(int n, int x)\r\n{\r\n    int i, f, r, u;\r\n    for (i = 1; i <= n; ++i) {\r\n        d[i] = INF;\r\n        in[i] = 0;\r\n    }\r\n    \r\n    f = r = 0;\r\n    d[x] = 0, in[x] = 1, Q[r++] = x;\r\n    while (f < r) {\r\n        u = Q[f++];\r\n        for (i = 1; i <= n; ++i) {\r\n            if (map[u][i] != INF && d[i] > d[u] + map[u][i]) {\r\n                d[i] = d[u] + map[u][i];\r\n                if (in[i] == 0) {\r\n                    in[i] = 1;\r\n                    Q[r++] = i;\r\n                }\r\n            }\r\n        }\r\n        in[u] = 0;\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n    int i, j, c, t, res, n, m, x;\r\n    while (scanf("%d %d %d",&n, &m ,&x) == 3) {\r\n        for (i = 1; i <= n; ++i) {\r\n            for (j = i; j <= n; ++j) {\r\n                 if (j == i) map[i][j] = 0;\r\n                 else        map[i][j] = map[j][i] =INF;\r\n            }\r\n        }\r\n        \r\n       while (m--) {\r\n            scanf("%d %d %d",&i, &j, &c);\r\n            if (c < map[i][j]) map[i][j] = c;\r\n        }\r\n        spfa(n, x);\r\n        \r\n        for (i = 1; i <= n; ++i) tmp[i] = d[i]; \r\n        for (i = 1; i <= n; ++i) {\r\n            for (j = i + 1; j <= n; ++j) {\r\n                t = map[i][j];\r\n                map[i][j] = map[j][i];\r\n                map[j][i] = t;\r\n            }\r\n        }  \r\n        spfa(n, x);\r\n        \r\n        res = -1;\r\n        for (i = 1; i <= n; ++i) {\r\n            if(d[i] + tmp[i] > res) res = d[i] + tmp[i];\r\n        }\r\n        printf("%d\\n",res);\r\n    }\r\n    return 0;\r\n}', '', 31, 4730880, 1, 1, '2010-12-04 17:38:25', '0001-01-01 00:00:00'),
(1014, 6, 388, 0, '#include <stdio.h>\r\n#include <string.h>\r\n#define N 1010\r\n#define M 110\r\n#define W 25\r\nint cnt[W], w_cnt[W];\r\nchar str[N], word[M];\r\n\r\nint main()\r\n{\r\n    int T, n, f, i ,m;\r\n\r\n    scanf("%d",&T);\r\n    while (T--) {\r\n        memset(cnt, 0, sizeof(cnt));\r\n        scanf("%s",str);\r\n        i = 0;\r\n        while (str[i]) ++cnt[ str[i++] - ''A'' ];\r\n        \r\n        scanf("%d",&m);\r\n        while (m--) {\r\n            scanf("%s",word);\r\n            f = 0, i = 0;\r\n            memset(w_cnt, 0, sizeof(w_cnt));\r\n            while (word[i]) ++w_cnt[ word[i++] - ''A'' ];\r\n            for (i = 0; i < W; ++i) {\r\n                 if( w_cnt[i] > cnt[i]) break;\r\n            }\r\n            if (i == W) f = 1;\r\n            printf("%s\\n",f ? "YES" : "NO"); \r\n        }\r\n    }\r\n    return 0;\r\n}', '', 0, 262144, 1, 1, '2010-12-04 21:36:27', '0001-01-01 00:00:00'),
(1015, 6, 395, 0, '#include <stdio.h>\r\n#include <string.h>\r\n\r\nint main()\r\n{\r\n    int T;\r\n    char s[125], t[125];\r\n    scanf("%d",&T);\r\n    while (T--) {\r\n        scanf("%s %s",s,t);\r\n        printf("%s\\n",strcmp(s,t) ? "ERROR" : "OK");\r\n    }\r\n}', '', 0, 258048, 1, 1, '2010-12-04 21:55:45', '0001-01-01 00:00:00'),
(1016, 6, 37, 0, '#include <stdio.h>\r\n#include <stdlib.h>\r\n#define N 1010\r\ntypedef struct node {\r\n    int j, f;\r\n    double w;\r\n}Node;\r\nNode p[N];\r\n\r\nint cmp(const void* a, const void* b)\r\n{\r\n    Node *s = (Node*)a;\r\n    Node *t = (Node*)b;\r\n    if (s->w != t->w) return s->w > t->w ? -1 : 1;\r\n    else              return s->j > t->j ? -1 : 1;\r\n}\r\nint main()\r\n{\r\n    double c, ans;\r\n    int n, m, a, b, i;\r\n    while (scanf("%d %d",&n, &m) == 2) {\r\n        if ( n == -1 && m == -1) break;\r\n        for (i = 0; i < m; ++i) {\r\n            scanf("%d %d",&a, &b);\r\n            c = a * 1.0 / b; \r\n            p[i].j = a, p[i].f = b, p[i].w = c;\r\n        }\r\n        qsort(p, m, sizeof(Node), cmp);\r\n        \r\n        ans = 0.0;\r\n        for (i = 0; i < m; ++i) {\r\n            if (n < p[i].f) {\r\n                ans += n * p[i].w;\r\n                break;\r\n            }\r\n            ans += p[i].j;\r\n            n -= p[i].f;\r\n        }\r\n        printf("%.3lf\\n",ans);\r\n    }\r\n    return 0;\r\n}', '', 0, 278528, 1, 1, '2010-12-05 11:47:53', '0001-01-01 00:00:00'),
(1017, 6, 391, 0, '#include <stdio.h>\r\n#include <math.h>\r\n#define N 1010\r\n#define EPS 1e-6\r\n#define SQR(x) (x)*(x)\r\n\r\nstruct Circle {\r\n   double x, y, r;\r\n}c[N];\r\nint pc;\r\n\r\nstruct Rectangular {\r\n   double x1, y1;\r\n   double x2, y2;\r\n}r[N];\r\nint pr;\r\n\r\nstruct Triangle {\r\n   double x1, y1;\r\n   double x2, y2;\r\n   double x3, y3;\r\n   double area;\r\n}t[N];\r\nint pt;\r\n\r\nint check_c(double x, double y)\r\n{\r\n    int i, res = 0;\r\n    for (i = 0; i < pc; ++i) {\r\n        if (c[i].r - sqrt((SQR(x-c[i].x)+SQR(y-c[i].y))) > EPS)\r\n            ++res; \r\n    }\r\n    return res;\r\n}\r\n\r\nint check_r(double x, double y)\r\n{\r\n    int i, res = 0;\r\n    for (i = 0; i < pr; ++i) {\r\n        if ( x - r[i].x1 > EPS && r[i].x2 - x > EPS &&\r\n             y - r[i].y1 > EPS && r[i].y2 - y > EPS )\r\n        ++res;\r\n    }\r\n    return res;\r\n}\r\n\r\ndouble cal_area(double x1, double y1, double x2, double y2,\r\n                double x3, double y3)\r\n{\r\n    return fabs(x1*(y2 - y3) + x2*(y3 - y1) + x3*(y1 - y2));\r\n}\r\n\r\nint check_t(double x, double y)\r\n{\r\n    int i, res = 0;\r\n    for (i = 0; i < pt; ++i) {\r\n        if (  cal_area(t[i].x1,t[i].y1,t[i].x2,t[i].y2,x,y)  \r\n            + cal_area(t[i].x2,t[i].y2,t[i].x3,t[i].y3,x,y)\r\n            + cal_area(t[i].x1,t[i].y1,t[i].x3,t[i].y3,x,y) \r\n            - t[i].area < EPS)\r\n        ++res;\r\n    }\r\n    return res;\r\n}\r\n\r\nint main()\r\n{\r\n    char str[3];\r\n    int i, n, m, a, b;\r\n    double x, y;\r\n    while (scanf("%d",&n) == 1) {\r\n        pc = pr = pt = 0;\r\n        while (n--) {\r\n            scanf("%s",str);\r\n            switch (str[0]) {\r\n                case ''C'' :\r\n                    scanf("%lf %lf %lf",&c[pc].x,&c[pc].y,&c[pc].r);\r\n                    pc++;\r\n                    break;\r\n                case ''R'' :\r\n                    scanf("%lf %lf %lf %lf",&r[pr].x1,&r[pr].y1,&r[pr].x2,&r[pr].y2);\r\n                    pr++;\r\n                    break;\r\n                case ''T'' :\r\n                    scanf("%lf %lf %lf %lf %lf %lf",&t[pt].x1,&t[pt].y1,\r\n                                                    &t[pt].x2,&t[pt].y2,\r\n                                                    &t[pt].x3,&t[pt].y3);\r\n                    t[pt].area = cal_area(t[pt].x1,t[pt].y1,t[pt].x2,t[pt].y2,\r\n                                          t[pt].x3,t[pt].y3);\r\n                    pt++;\r\n                    break;   \r\n            }        \r\n        }\r\n        \r\n        scanf("%d",&m);\r\n        while (m--) {\r\n            a = b = 0;\r\n            for (i = 0; i < 3; ++i) {\r\n                scanf("%lf %lf",&x,&y);\r\n                a += check_c(x, y);\r\n                a += check_r(x, y);\r\n                a += check_t(x, y);\r\n            }\r\n            for (i = 0; i < 3; ++i) {\r\n                scanf("%lf %lf",&x,&y);\r\n                b += check_c(x, y);\r\n                b += check_r(x, y);\r\n                b += check_t(x, y);\r\n            }\r\n            if (a > b)      printf("Bob\\n");\r\n            else if (a < b) printf("Hannah\\n");\r\n            else            printf("Tied\\n");\r\n        }\r\n    }\r\n    return 0;\r\n}', '', 234, 368640, 1, 1, '2010-12-06 22:25:42', '0001-01-01 00:00:00'),
(1018, 6, 393, 0, '#include <stdio.h>\r\n#define N 105\r\nchar map[N][N];\r\nchar dir[4][2] = { {-1,0},{1,0},{0,-1},{0,1}};\r\nint  n, m;\r\n\r\nchar check(int x, int y) \r\n{\r\n     if (x < 0 || x >= n || y < 0 || y >= m) \r\n           return 0;\r\n     else  return 1;\r\n} \r\n\r\nvoid dfs(int x, int y) \r\n{\r\n     int i, nx, ny;\r\n     map[x][y] = ''.'';\r\n     for (i = 0; i < 4; ++i) {\r\n         nx = x + dir[i][0];\r\n         ny = y + dir[i][1];\r\n         if (map[nx][ny] == ''#'' && check(nx, ny))\r\n             dfs(nx, ny);\r\n     }\r\n}\r\n\r\nint main()\r\n{\r\n    int T, res, i, j;\r\n    scanf("%d",&T);\r\n    while (T--) {\r\n        scanf("%d %d",&n,&m);\r\n        for (i = 0; i < n; ++i) \r\n             scanf("%s",map[i]);\r\n\r\n        res = 0;\r\n        for (i = 0; i < n; ++i) {\r\n            for (j = 0; j < m; ++j) {\r\n                if (map[i][j] == ''#'') {\r\n                    dfs(i, j);\r\n                    ++res;\r\n                }\r\n            }\r\n        }\r\n        printf("%d\\n",res);\r\n    }    \r\n    return 0;\r\n}\r\n', '', 15, 704512, 1, 1, '2010-12-06 23:35:49', '0001-01-01 00:00:00'),
(1019, 1, 402, 0, '#include<stdio.h>\r\n#include<string.h>\r\n\r\nint main()\r\n{\r\n    int n,c[2001],i,p,q,t,j,k;\r\n    char a[2001],b[2001];\r\n    scanf("%d",&n);\r\n    for(i = 1;i <= n;i ++)\r\n    {\r\n        scanf("%s%s",a,b);\r\n        //printf("%s %s\\n",a,b);\r\n        p = strlen(a); q = strlen(b);\r\n        //printf("%d %d\\n",p,q);\r\n        if(p >= q)\r\n        {\r\n            for(j = p-1;j >= p-q;j --)\r\n            {\r\n                if(j == p-1)\r\n                {\r\n                    c[j] = (a[j]-''0''+b[j-p+q]-''0'')%10;\r\n                    t = (a[j]-''0''+b[j-p+q]-''0'')/10;\r\n                    //printf("%d %d\\n",c[j],t);\r\n                }\r\n                else\r\n                {\r\n                    c[j] = (t+a[j]-''0''+b[j-p+q]-''0'')%10;\r\n                    t = (t+a[j]-''0''+b[j-p+q]-''0'')/10;\r\n                }\r\n            }\r\n            if(p == q)\r\n            {\r\n                if(t == 1)\r\n                {\r\n                    printf("Case %d:\\n",i);\r\n                    printf("%s + %s = 1",a,b);\r\n                    for(k = 0;k <= p-1;k ++)\r\n                        printf("%d",c[k]);\r\n                    printf("\\n");\r\n                }\r\n                else\r\n                {\r\n                    printf("Case %d:\\n",i);\r\n                    printf("%s + %s = ",a,b);\r\n                    for(k = 0;k <= p-1;k ++)\r\n                        printf("%d",c[k]);\r\n                    printf("\\n");    \r\n                }\r\n            }\r\n            else\r\n            {\r\n                for(j = p-q-1;j >= 0;j --)\r\n                {\r\n                    c[j] = (a[j]-''0''+t)%10;\r\n                    t = (a[j]-''0''+t)/10;\r\n                }\r\n                if(t == 1)\r\n                {\r\n                    printf("Case %d:\\n",i);\r\n                    printf("%s + %s = 1",a,b);\r\n                    for(k = 0;k <= p-1;k ++)\r\n                        printf("%d",c[k]);\r\n                    printf("\\n");\r\n                }\r\n                else\r\n                {\r\n                    printf("Case %d:\\n",i);\r\n                    printf("%s + %s = ",a,b);\r\n                    for(k = 0;k <= p-1;k ++)\r\n                        printf("%d",c[k]);\r\n                    printf("\\n");\r\n                }\r\n            }\r\n        }\r\n        else\r\n        {\r\n            for(j = q-1;j >= q-p;j --)\r\n            {\r\n                if(j == q-1)\r\n                {\r\n                    c[j] = (b[j]-''0''+a[j-q+p]-''0'')%10;\r\n                    t = (b[j]-''0''+a[j-q+p]-''0'')/10;\r\n                    //printf("%d %d\\n",c[j],t);\r\n                }\r\n                else\r\n                {\r\n                    c[j] = (t+b[j]-''0''+a[j-q+p]-''0'')%10;\r\n                    t = (t+b[j]-''0''+a[j-q+p]-''0'')/10;\r\n                }\r\n            }\r\n            for(j = q-p-1;j >= 0;j --)\r\n            {\r\n                c[j] = (b[j]-''0''+t)%10;\r\n                t = (b[j]-''0''+t)/10;\r\n            }\r\n            if(t == 1)\r\n            {\r\n                printf("Case %d:\\n",i);\r\n                printf("%s + %s = 1",a,b);\r\n                for(k = 0;k <= q-1;k ++)\r\n                    printf("%d",c[k]);\r\n                printf("\\n");\r\n            }\r\n            else\r\n            {\r\n                printf("Case %d:\\n",i);\r\n                printf("%s + %s = ",a,b);\r\n                for(k = 0;k <= q-1;k ++)\r\n                    printf("%d",c[k]);\r\n                printf("\\n");\r\n            }\r\n        }\r\n        if(i < n) printf("\\n");\r\n    }\r\n    return 0;\r\n}\r\n', '', 46, 262144, 1, 2, '2010-12-08 22:21:38', '0001-01-01 00:00:00'),
(1020, 1, 403, 0, '#include<iostream>\r\nusing namespace std;\r\n#define M 10000000000\r\nunsigned long long a[20000];\r\nint main()\r\n{\r\n int N,i,j;\r\n unsigned long long pre;\r\n while(cin>>N)\r\n {\r\n  a[0]=1;a[1]=1;\r\n  if(N==0||N==1)\r\n  {\r\n   cout<<1<<endl;\r\n   continue;\r\n  }\r\n  for(i=2;i<=N;i++)\r\n  {\r\n   pre=0;\r\n   for(j=1;j<=a[0];j++)\r\n   {\r\n    a[j]*=i;\r\n    a[j]+=pre;\r\n    pre=a[j]/M;\r\n    a[j]%=M;\r\n   }\r\n   while(pre)\r\n   {\r\n    a[j]=pre%M;\r\n    a[0]=j;\r\n    pre/=M;\r\n    j++;\r\n   }\r\n  }\r\n  cout<<a[a[0]];\r\n  for(i=a[0]-1;i>0;i--)\r\n  {\r\n   if(a[i]<10) cout<<"000000000";\r\n   else if(a[i]<100) cout<<"00000000";\r\n   else if(a[i]<1000) cout<<"0000000";\r\n   else if(a[i]<10000) cout<<"000000";\r\n   else if(a[i]<100000) cout<<"00000";\r\n   else if(a[i]<1000000) cout<<"0000";\r\n   else if(a[i]<10000000) cout<<"000";\r\n   else if(a[i]<100000000) cout<<"00";\r\n   else if(a[i]<1000000000) cout<<"0";\r\n   cout<<a[i];\r\n  }\r\n  cout<<endl;\r\n }\r\n return 0;\r\n}', '', 873, 524288, 1, 2, '2010-12-09 01:47:04', '0001-01-01 00:00:00'),
(1021, 11, 338, 3, '#include<stdio.h>\r\n#include<string.h>\r\nint main()\r\n{\r\n   int i,size,k,temp,shuzu[1000],count;\r\n   int kmin,kmax;\r\n   while(EOF != scanf("%d%d",&size,&k))\r\n   {\r\n   memset(shuzu,0,1000*sizeof(int));\r\n   for(i = 0 ; i != size ; i++)\r\n   {\r\n    scanf("%d",&temp);\r\n    shuzu[temp] +=1;\r\n   }\r\n   count = 0;\r\n   i = 0;\r\n   while(count<k+1)\r\n   {\r\n    ++i;\r\n    count += shuzu[i];\r\n   }    \r\n   kmin = i;\r\n count = 0;\r\n   i = 1000;\r\n   while(count<k+1)\r\n   {\r\n    --i;\r\n    count += shuzu[i];\r\n   }    \r\n   kmax = i;\r\n   printf("%d\\n",kmax - kmin);\r\n   }\r\n   return 0;\r\n}\r\n', '', 358, 258048, 4, 1, '2010-12-09 08:15:54', '0001-01-01 00:00:00'),
(1022, 11, 338, 3, '#include<stdio.h>\r\n#include<string.h>\r\nint main()\r\n{\r\n   int i,size,k,temp,shuzu[1000],count;\r\n   int kmin,kmax;\r\n   while(EOF != scanf("%d%d",&size,&k))\r\n   {\r\n   memset(shuzu,0,1000*sizeof(int));\r\n   for(i = 0 ; i != size ; i++)\r\n   {\r\n    scanf("%d",&temp);\r\n    shuzu[temp] +=1;\r\n   }\r\n   count = 0;\r\n   i = 0;\r\n   while(count<k+1)\r\n   {\r\n    ++i;\r\n    count += shuzu[i];\r\n   }    \r\n   kmin = i;\r\n   count = 0;\r\n   i = 1000;\r\n   while(count<k+1)\r\n   {\r\n    --i;\r\n    count += shuzu[i];\r\n   }    \r\n   kmax = i;\r\n   printf("%d\\n",kmax - kmin);\r\n   }\r\n   return 0;\r\n}\r\n', '', 374, 258048, 4, 1, '2010-12-09 08:20:47', '0001-01-01 00:00:00'),
(1023, 17, 379, 7, '#include<stdio.h>\r\n#include<stdlib.h>\r\n#define MAXNODE 1405\r\n#define MAXCOST 256\r\nint cost[MAXNODE][MAXNODE];\r\nint s[MAXNODE];\r\nint dist[MAXNODE];\r\nint node[MAXNODE];\r\nint sum;\r\nvoid dijsktra(int v0,int N);\r\nvoid print(int v0,int N);\r\nmain()\r\n{       int i,j;\r\n        int v0;\r\n        int N ,P,C;\r\n        int A,B,long1;\r\n        while(scanf("%d%d%d",&N,&P,&C)!=EOF)\r\n       { \r\n         sum=0;\r\n         for(i=1;i<=P;i++)\r\n            scanf("%d",&node[i]);\r\n         for(i=1;i<=N;i++)\r\n         {       \r\n                for(j=1;j<=N;j++)\r\n                {      \r\n                        cost[i][j]=MAXCOST;\r\n                        \r\n                        if(i==j)\r\n                        cost[i][j]=0;\r\n                }\r\n        }\r\n        for(i=1;i<=C;i++)\r\n        {  \r\n             scanf("%d%d%d",&A,&B,&long1);\r\n             cost[A][B]=long1;\r\n             cost[A][B]=long1;\r\n         }\r\n        \r\n         for(i=1;i<=P;i++)\r\n         {\r\n            printf("input the start node:");\r\n            scanf("%d",&v0);\r\n            dijsktra(v0,N);\r\n            print(v0,N);\r\n        }\r\n        }\r\n        return 0;\r\n}\r\nvoid dijsktra(int v,int N)\r\n{       int i,j;\r\n        int u,mindis;\r\n        int dis;\r\n        for(i=1;i<=N;i++)\r\n        {\r\n                dist[i]=cost[v][i];\r\n                s[i]=0;\r\n        }\r\n        s[v]=1;\r\n        for(i=1;i<=N;i++)\r\n        {       mindis=MAXCOST;\r\n                for(j=1;j<=N;j++)\r\n                {\r\n                        if(dist[j]<mindis&&s[j]==0)\r\n                        {     \r\n                                mindis=dist[j];\r\n                                u=j;\r\n                        }\r\n\r\n                }\r\n                s[u]=1;\r\n                for(j=1;j<=N;j++)\r\n                {       if(s[j]==0)\r\n                        {     \r\n                                dis=dist[u]+cost[u][j];\r\n                                dist[j]=dist[j]<dis?dist[j]:dis;\r\n                        }\r\n                }\r\n        }\r\n}\r\nvoid print(int v,int N)\r\n{       int i,j;\r\n        printf("the result is:\\n");\r\n        for(i=1;i<=N;i++)\r\n        {       if(i!=v)\r\n  {\r\n    printf("V%d-->V%d:",v,i);\r\n    if(dist[i]==MAXCOST)\r\n    printf("no path!\\n");\r\n    else{\r\n    printf("%d\\n",dist[i]);\r\n    sum+=dist[i];\r\n   }\r\n   }\r\n   else\r\n    continue;\r\n}\r\nprintf("%d",sum);\r\n}\r\n', '', 0, 8179712, 7, 1, '2010-12-09 08:22:18', '0001-01-01 00:00:00'),
(1024, 6, 402, 8, '#include <stdio.h>\r\n#include <string.h>\r\n#define N 1005\r\nchar str_a[N], str_b[N], str_c[N];\r\nint  a[N], b[N];\r\n\r\nvoid cal()\r\n{\r\n	int i, j, car;\r\n	memset(a, 0, N*sizeof(int));\r\n	memset(b, 0, N*sizeof(int));\r\n	a[0] = strlen(str_a);\r\n	b[0] = strlen(str_b);\r\n\r\n	for (i = a[0] - 1, j = 0; i >= 0; --i)\r\n		a[++j] = str_a[i] - ''0''; \r\n	for (i = b[0] - 1, j = 0; i >= 0; --i)\r\n		b[++j] = str_b[i] - ''0'';\r\n	a[0] = a[0] > b[0] ? a[0] : b[0];\r\n\r\n	i = 1, car = 0;\r\n	while (i <= a[0]) {\r\n		a[i] += ( b[i] + car);\r\n		car = a[i] / 10;\r\n		a[i] %= 10;\r\n		++i;\r\n	}\r\n	\r\n	while (car) {\r\n		a[i] += car;\r\n		car = a[i] / 10;\r\n		a[i] %= 10;\r\n		++i;\r\n	}\r\n	a[0] = i - 1;\r\n	\r\n	j = 0, i = a[0];\r\n	while (i >= 1)\r\n		str_c[j++] = a[i--] + ''0'';\r\n	str_c[j] = ''\\0'';\r\n}\r\n\r\nint main()\r\n{\r\n	int T, i;\r\n	scanf("%d",&T);\r\n	for (i = 1; i <= T; ++i) {\r\n	    scanf("%s %s",str_a,str_b);\r\n		cal();\r\n		printf("Case %d:\\n",i);\r\n		printf("%s + %s = %s\\n",str_a,str_b,str_c);\r\n		if (i != T) printf("\\n");\r\n	}\r\n	return 0;\r\n}\r\n', '', 0, 270336, 1, 1, '2010-12-09 08:26:32', '0001-01-01 00:00:00'),
(1025, 11, 338, 3, '#include<stdio.h>\r\n#include<string.h>\r\nint main()\r\n{\r\n   int i,size,k,temp,shuzu[1000],count;\r\n   int kmin,kmax;\r\n   while(EOF != scanf("%d%d",&size,&k))\r\n   {\r\n   memset(shuzu,0,1000*sizeof(int));\r\n   for(i = 0 ; i != size ; i++)\r\n   {\r\n    scanf("%d",&temp);\r\n    shuzu[temp] +=1;\r\n   }\r\n   count = 0;\r\n   i = 0;\r\n   if(count+=shuzu[0]>k)\r\n   kmin = 0;\r\n   else while(count<k+1)\r\n   {\r\n    ++i;\r\n    count += shuzu[i];\r\n   }    \r\n   kmin = i;\r\n   count = 0;\r\n   i = 1000;\r\n   while(count<k+1)\r\n   {\r\n    --i;\r\n    count += shuzu[i];\r\n   }    \r\n   kmax = i;\r\n   printf("%d\\n",kmax - kmin);\r\n   }\r\n   return 0;\r\n}\r\n', '', 358, 258048, 4, 1, '2010-12-09 08:32:37', '0001-01-01 00:00:00'),
(1026, 6, 402, 8, '#include <stdio.h>\r\n#include <string.h>\r\n#define N 1005\r\nchar str_a[N], str_b[N], str_c[N];\r\nint  a[N], b[N];\r\n\r\nvoid cal()\r\n{\r\n	int i, j, car;\r\n	memset(a, 0, N*sizeof(int));\r\n	memset(b, 0, N*sizeof(int));\r\n	a[0] = strlen(str_a);\r\n	b[0] = strlen(str_b);\r\n\r\n	for (i = a[0] - 1, j = 0; i >= 0; --i)\r\n		a[++j] = str_a[i] - ''0''; \r\n	for (i = b[0] - 1, j = 0; i >= 0; --i)\r\n		b[++j] = str_b[i] - ''0'';\r\n	a[0] = a[0] > b[0] ? a[0] : b[0];\r\n\r\n	i = 1, car = 0;\r\n	while (i <= a[0]) {\r\n		a[i] += ( b[i] + car);\r\n		car = a[i] / 10;\r\n		a[i] %= 10;\r\n		++i;\r\n	}\r\n	\r\n	while (car) {\r\n		a[i] = car%10;\r\n		car /= 10;\r\n		++i;\r\n	}\r\n	a[0] = i - 1;\r\n	\r\n	j = 0, i = a[0];\r\n	while (i >= 1)\r\n		str_c[j++] = a[i--] + ''0'';\r\n	str_c[j] = ''\\0'';\r\n}\r\n\r\nint main()\r\n{\r\n	int T, i;\r\n	scanf("%d",&T);\r\n	for (i = 1; i <= T; ++i) {\r\n	    scanf("%s %s",str_a,str_b);\r\n		cal();\r\n		printf("Case %d:\\n",i);\r\n		printf("%s + %s = %s\\n",str_a,str_b,str_c);\r\n		if (i != T) printf("\\n");\r\n	}\r\n	return 0;\r\n}\r\n', '', 15, 270336, 1, 1, '2010-12-09 08:42:14', '0001-01-01 00:00:00'),
(1027, 11, 338, 3, '#include<stdio.h>\r\n#include<string.h>\r\nint main()\r\n{\r\n   int i,size,k,temp,shuzu[1000],count;\r\n   int kmin,kmax;\r\n   while(EOF != scanf("%d%d",&size,&k))\r\n   {\r\n   memset(shuzu,0,1000*sizeof(int));\r\n   for(i = 0 ; i != size ; i++)\r\n   {\r\n    scanf("%d",&temp);\r\n    shuzu[temp] +=1;\r\n   }\r\n   count = 0;\r\n   i = 0;\r\n   count += shuzu[0];\r\n   if(count>k)\r\n   kmin = 0;\r\n   else while(count<k+1)\r\n   {\r\n    ++i;\r\n    count += shuzu[i];\r\n   }    \r\n   kmin = i;\r\n   count = 0;\r\n   i = 1000;\r\n   while(count<k+1)\r\n   {\r\n    --i;\r\n    count += shuzu[i];\r\n   }    \r\n   kmax = i;\r\n   printf("%d\\n",kmax - kmin);\r\n   }\r\n   return 0;\r\n}\r\n', '', 358, 262144, 1, 1, '2010-12-09 08:42:57', '0001-01-01 00:00:00'),
(1028, 6, 402, 8, '#include<stdio.h>\r\n#include<string.h>\r\n#include<memory.h>\r\n#define N 1001\r\nint c[N];\r\nchar a[N],b[N];\r\nint main()\r\n{\r\n    int i,j,n,k;\r\n    int t,carry,count=0;\r\n    scanf("%d",&n);\r\n    while(n--)\r\n    {\r\n        scanf("%s%s",a,b);\r\n        i=strlen(a);j=strlen(b);\r\n        memset(c,0,N*sizeof(int));\r\n        t=0;carry=0;k=0;\r\n        i--;j--;\r\n        while(i!=-1||j!=-1)\r\n        { \r\n            t=(i>=0?a[i]-''0'':0)+(j>=0?b[j]-''0'':0)+carry;\r\n            carry=t/10;\r\n            c[k++]=t%10;\r\n            if(i>=0) i--;\r\n            if(j>=0) j--;\r\n        }\r\n        while(carry)\r\n        {\r\n            c[k++]=carry%10;\r\n            carry/=10;\r\n        }\r\n        printf("Case %d:\\n%s + %s = ",++count,a,b);\r\n        for(i=k-1;i>=0;i--)\r\n            printf("%d",c[i]);\r\n        printf("\\n");\r\n        if(n!=0) printf("\\n");\r\n    }\r\n    return 0;\r\n}\r\n', '', 46, 266240, 1, 1, '2010-12-09 08:44:00', '0001-01-01 00:00:00'),
(1029, 11, 336, 2, '#include <stdio.h>\r\n#include <iostream>\r\n#include <vector>\r\n#include <algorithm>\r\n#include <iterator>\r\n#define POW(c) (1<<(c))\r\n#define MASK(c) (((unsigned long)-1) / (POW(POW(c)) + 1))\r\n#define ROUND(n, c) (((n) & MASK(c)) + ((n) >> POW(c) & MASK(c)))\r\nusing namespace std;\r\nint bit_count(unsigned int n)\r\n{\r\nn = ROUND(n, 0);\r\nn = ROUND(n, 1);\r\nn = ROUND(n, 2);\r\nn = ROUND(n, 3);\r\nn = ROUND(n, 4);\r\nreturn n;\r\n}\r\nbool compare(int a,int b)\r\n{\r\n   if(bit_count(a)==bit_count(b))\r\n    return a<b;\r\n   else \r\n    return bit_count(a)<bit_count(b);\r\n}\r\nint main()\r\n{\r\n int num,size,i=0;\r\n vector<int> temp;\r\n while(1 == scanf("%d",&size))\r\n {\r\n  i = 0;\r\n  temp.clear();\r\n   while(i != size)\r\n   {\r\n  scanf("%d",&num);\r\n  temp.push_back(num);\r\n  i++;\r\n   }\r\n  sort(temp.begin(),temp.end(),compare);\r\n  for(vector<int>::iterator iter = temp.begin();\r\n      iter != temp.end();iter++)\r\n   printf("%d ",*iter);\r\n   printf("\\n");\r\n }\r\n return 0;\r\n}\r\n', 'Main.c:2:20: fatal error: iostream: No such file or directory\r\ncompilation terminated.\r\n', 0, 0, 2, 1, '2010-12-09 08:45:32', '0001-01-01 00:00:00'),
(1030, 11, 336, 2, '#include <stdio.h>\r\n#include <iostream>\r\n#include <vector>\r\n#include <algorithm>\r\n#include <iterator>\r\n#define POW(c) (1<<(c))\r\n#define MASK(c) (((unsigned long)-1) / (POW(POW(c)) + 1))\r\n#define ROUND(n, c) (((n) & MASK(c)) + ((n) >> POW(c) & MASK(c)))\r\nusing namespace std;\r\nint bit_count(unsigned int n)\r\n{\r\nn = ROUND(n, 0);\r\nn = ROUND(n, 1);\r\nn = ROUND(n, 2);\r\nn = ROUND(n, 3);\r\nn = ROUND(n, 4);\r\nreturn n;\r\n}\r\nbool compare(int a,int b)\r\n{\r\n   if(bit_count(a)==bit_count(b))\r\n    return a<b;\r\n   else \r\n    return bit_count(a)<bit_count(b);\r\n}\r\nint main()\r\n{\r\n int num,size,i=0;\r\n vector<int> temp;\r\n while(1 == scanf("%d",&size))\r\n {\r\n  i = 0;\r\n  temp.clear();\r\n   while(i != size)\r\n   {\r\n  scanf("%d",&num);\r\n  temp.push_back(num);\r\n  i++;\r\n   }\r\n  sort(temp.begin(),temp.end(),compare);\r\n  for(vector<int>::iterator iter = temp.begin();\r\n      iter != temp.end();iter++)\r\n   printf("%d ",*iter);\r\n   printf("\\n");\r\n }\r\n return 0;\r\n}\r\n', '', 31, 622592, 3, 2, '2010-12-09 08:45:50', '0001-01-01 00:00:00'),
(1031, 11, 336, 2, '#include <stdio.h>\r\n#include <iostream>\r\n#include <vector>\r\n#include <algorithm>\r\n#include <iterator>\r\n#define POW(c) (1<<(c))\r\n#define MASK(c) (((unsigned long)-1) / (POW(POW(c)) + 1))\r\n#define ROUND(n, c) (((n) & MASK(c)) + ((n) >> POW(c) & MASK(c)))\r\nusing namespace std;\r\nint bit_count(unsigned int n)\r\n{\r\nn = ROUND(n, 0);\r\nn = ROUND(n, 1);\r\nn = ROUND(n, 2);\r\nn = ROUND(n, 3);\r\nn = ROUND(n, 4);\r\nreturn n;\r\n}\r\nbool compare(int a,int b)\r\n{\r\n   if(bit_count(a)==bit_count(b))\r\n    return a<b;\r\n   else \r\n    return bit_count(a)<bit_count(b);\r\n}\r\nint main()\r\n{\r\n int num,size,i=0;\r\n vector<int> temp;\r\n while(1 == scanf("%d",&size))\r\n {\r\n  i = 0;\r\n  temp.clear();\r\n   while(i != size)\r\n   {\r\n  scanf("%d",&num);\r\n  temp.push_back(num);\r\n  i++;\r\n   }\r\n  sort(temp.begin(),temp.end(),compare);\r\n  for(vector<int>::iterator iter = temp.begin();\r\n      iter != temp.end();iter++)\r\n   printf("%d ",*iter);\r\n   printf("\\b\\n");\r\n }\r\n return 0;\r\n}\r\n', '', 31, 622592, 4, 2, '2010-12-09 08:48:35', '0001-01-01 00:00:00'),
(1032, 11, 336, 2, '#include <stdio.h>\r\n#include <iostream>\r\n#include <vector>\r\n#include <algorithm>\r\n#include <iterator>\r\n#define POW(c) (1<<(c))\r\n#define MASK(c) (((unsigned long)-1) / (POW(POW(c)) + 1))\r\n#define ROUND(n, c) (((n) & MASK(c)) + ((n) >> POW(c) & MASK(c)))\r\nusing namespace std;\r\nint bit_count(unsigned int n)\r\n{\r\nn = ROUND(n, 0);\r\nn = ROUND(n, 1);\r\nn = ROUND(n, 2);\r\nn = ROUND(n, 3);\r\nn = ROUND(n, 4);\r\nreturn n;\r\n}\r\nbool compare(int a,int b)\r\n{\r\n   if(bit_count(a)==bit_count(b))\r\n    return a<b;\r\n   else \r\n    return bit_count(a)<bit_count(b);\r\n}\r\nint main()\r\n{\r\n int num,size,i=0;\r\n vector<int> temp;\r\n while(1 == scanf("%d",&size))\r\n {\r\n  i = 0;\r\n  temp.clear();\r\n   while(i != size)\r\n   {\r\n  scanf("%d",&num);\r\n  temp.push_back(num);\r\n  i++;\r\n   }\r\n  sort(temp.begin(),temp.end(),compare);\r\n  for(vector<int>::iterator iter = temp.begin();\r\n      iter != temp.end();iter++)\r\n      if(iter != temp.end()-1){\r\n   printf("%d ",*iter);\r\n   }\r\n   else{\r\n   printf("%d ",*iter);\r\n   printf("\\n");}\r\n }\r\n return 0;\r\n}\r\n', '', 31, 622592, 3, 2, '2010-12-09 08:52:15', '0001-01-01 00:00:00'),
(1033, 23, 402, 8, '#include<stdio.h>\r\n#include<string.h>\r\nint main(){\r\n	char a[20][1000],b[20][1000],x,y;\r\n	char d[20][1001];\r\n	int n,a_length,b_length,val,tag;\r\n	int i,j,k;\r\n	\r\n	scanf("%d",&n);\r\n	for(i=0;i<n;++i){\r\n		scanf("%s %s",a[i],b[i]);\r\n		a_length=strlen(a[i])-1;\r\n		b_length=strlen(b[i])-1;\r\n		\r\n		a_length>=b_length?k=a_length+2:k=b_length+2;\r\n		d[i][k--]=''\\0'';\r\n		while(a_length>=0||b_length>=0){\r\n			if(a_length<0) x=''0''; else x=a[i][a_length--];\r\n			if(b_length<0) y=''0''; else y=b[i][b_length--];\r\n			\r\n			val=x-''0''+(y-''0'');\r\n			if(1==tag) ++val;\r\n			if(val>9){\r\n				val=val%10;\r\n				tag=1;\r\n			}\r\n			else tag=0;\r\n			d[i][k--]=val+''0'';\r\n		}\r\n		if(1==tag) d[i][k]=1+''0'';\r\n		else d[i][k]=''0'';\r\n	}\r\n	\r\n	for(i=0;i<n;++i){\r\n		printf("Case%d:\\n",i+1);\r\n		printf("%s + %s= %s\\n\\n",a[i],b[i],d[i]);\r\n	}\r\n	return 0;\r\n}', '', 0, 274432, 7, 2, '2010-12-09 08:54:52', '0001-01-01 00:00:00'),
(1034, 11, 336, 2, '#include <stdio.h>\r\n#include <iostream>\r\n#include <vector>\r\n#include <algorithm>\r\n#include <iterator>\r\n#define POW(c) (1<<(c))\r\n#define MASK(c) (((unsigned long)-1) / (POW(POW(c)) + 1))\r\n#define ROUND(n, c) (((n) & MASK(c)) + ((n) >> POW(c) & MASK(c)))\r\nusing namespace std;\r\nint bit_count(unsigned int n)\r\n{\r\nn = ROUND(n, 0);\r\nn = ROUND(n, 1);\r\nn = ROUND(n, 2);\r\nn = ROUND(n, 3);\r\nn = ROUND(n, 4);\r\nreturn n;\r\n}\r\nbool compare(int a,int b)\r\n{\r\n   if(bit_count(a)==bit_count(b))\r\n    return a<b;\r\n   else \r\n    return bit_count(a)<bit_count(b);\r\n}\r\nint main()\r\n{\r\n int num,size,i=0;\r\n vector<int> temp;\r\n while(1 == scanf("%d",&size))\r\n {\r\n  i = 0;\r\n  temp.clear();\r\n   while(i != size)\r\n   {\r\n  scanf("%d",&num);\r\n  temp.push_back(num);\r\n  i++;\r\n   }\r\n  sort(temp.begin(),temp.end(),compare);\r\n  for(vector<int>::iterator iter = temp.begin();\r\n      iter != temp.end();iter++)\r\n      if(iter != temp.end()-1){\r\n   printf("%d ",*iter);\r\n   }\r\n   else{\r\n   printf("%d",*iter);\r\n   printf("\\n");}\r\n }\r\n return 0;\r\n}\r\n', '', 46, 622592, 3, 2, '2010-12-09 08:56:11', '0001-01-01 00:00:00');
INSERT INTO `tbl_submitions` (`id`, `user_id`, `problem_id`, `exercise_id`, `source`, `result`, `used_time`, `used_memory`, `status`, `compiler_id`, `created`, `modified`) VALUES
(1035, 11, 344, 4, '#include<string>\r\n#include<iostream>\r\n#include<map>\r\n\r\n\r\nusing std::string;using std::map;\r\nusing std::cin;using std::cout;\r\nusing std::pair;using std::endl;\r\n\r\nint main()\r\n{\r\n int i,size;\r\n string temp;\r\n map<string,int> line;\r\n    pair<map<string, int>::iterator, bool> Insert_Pair;\r\n\r\n scanf("%d",&size);\r\n for(i=0;i != size;i++)\r\n {\r\n  cin >>temp;\r\n  Insert_Pair = line.insert(map<string,int>::value_type (temp,i));\r\n        if(Insert_Pair.second == false)\r\n        break;\r\n }\r\n    map<string, int>::iterator  iter;\r\n    /*for(iter = line.begin(); iter != line.end(); iter++)\r\n   {\r\n cout<<iter->first<<"   "<<iter->second<< endl;\r\n    }*/\r\n cout << i-line[temp];\r\n\r\n return 0;\r\n}\r\n', 'Main.cpp: In function ''int main()'':\r\nMain.cpp:17:18: error: ''scanf'' was not declared in this scope\r\n', 0, 0, 2, 2, '2010-12-09 08:59:12', '0001-01-01 00:00:00'),
(1036, 17, 379, 7, '#include<stdio.h>\r\n#include<stdlib.h>\r\n#define MAXNODE 1405\r\n#define MAXCOST 99999\r\nint cost[MAXNODE][MAXNODE];\r\nint s[MAXNODE];\r\nint dist[MAXNODE];\r\nint node[MAXNODE];\r\nint count[MAXNODE];\r\nvoid dijsktra(int v0,int N);\r\nint print(int v0,int N,int a[],int p);\r\nmain()\r\n{       int i,j;\r\n        int v0;\r\n        int N ,P,C;\r\n        int A,B,long1;\r\n        int min=99999;\r\n        int ret;\r\n        while(scanf("%d%d%d",&P,&N,&C)!=EOF)\r\n       { \r\n       \r\n         for(i=1;i<=P;i++)\r\n            scanf("%d",&node[i]);\r\n         for(i=1;i<=N;i++)\r\n         {       \r\n                for(j=1;j<=N;j++)\r\n                {      \r\n                        cost[i][j]=MAXCOST;\r\n                        \r\n                        if(i==j)\r\n                        cost[i][j]=0;\r\n                }\r\n        }\r\n        for(i=1;i<=C;i++)\r\n        {  \r\n             scanf("%d%d%d",&A,&B,&long1);\r\n             cost[A][B]=long1;\r\n             cost[B][A]=long1;\r\n         }\r\n         \r\n         for(i=1;i<=P;i++)\r\n         {  \r\n            dijsktra(node[i],N);\r\n            ret=print(node[i],N,node,P);\r\n            if(min>=ret)\r\n             min = ret;\r\n         }\r\n         printf("%d\\n",min);\r\n        }\r\n        return 0;\r\n}\r\nvoid dijsktra(int v,int N)\r\n{       int i,j;\r\n        int u,mindis;\r\n        int dis;\r\n        for(i=1;i<=N;i++)\r\n        {\r\n                dist[i]=cost[v][i];\r\n                s[i]=0;\r\n        }\r\n        s[v]=1;\r\n        for(i=1;i<=N;i++)\r\n        {       mindis=MAXCOST;\r\n                for(j=1;j<=N;j++)\r\n                {\r\n                        if(dist[j]<mindis&&s[j]==0)\r\n                        {     \r\n                                mindis=dist[j];\r\n                                u=j;\r\n                        }\r\n\r\n                }\r\n                s[u]=1;\r\n                for(j=1;j<=N;j++)\r\n                {       if(s[j]==0)\r\n                        {     \r\n                                dis=dist[u]+cost[u][j];\r\n                                dist[j]=dist[j]<dis?dist[j]:dis;\r\n                        }\r\n                }\r\n        }\r\n}\r\nint print(int v,int N,int *a,int P)\r\n{       \r\n        int i,j;\r\n        int sum;\r\n        sum=0;\r\n    \r\n        for(i=1;i<=N;i++)\r\n        { \r\n          if(i!=v)\r\n        {\r\n        \r\n         if(dist[i]==MAXCOST)\r\n       \r\n         for(j=1;j<=P;j++)\r\n         {\r\n           if(i==a[j]){\r\n           \r\n            sum+=dist[i];}\r\n           }\r\n        }\r\n       else\r\n          continue;\r\n         }\r\n    \r\n       return sum;\r\n}\r\n', '', 0, 8187904, 4, 1, '2010-12-09 08:59:56', '0001-01-01 00:00:00'),
(1037, 6, 402, 8, '#include <stdio.h>\r\n#include <string.h>\r\n#define N 2005\r\nchar str_a[N], str_b[N], str_c[N];\r\nint  a[N], b[N];\r\n\r\nvoid cal()\r\n{\r\n	int i, j, car;\r\n	memset(a, 0, N*sizeof(int));\r\n	memset(b, 0, N*sizeof(int));\r\n	a[0] = strlen(str_a);\r\n	b[0] = strlen(str_b);\r\n\r\n	for (i = a[0] - 1, j = 0; i >= 0; --i)\r\n		a[++j] = str_a[i] - ''0''; \r\n	for (i = b[0] - 1, j = 0; i >= 0; --i)\r\n		b[++j] = str_b[i] - ''0'';\r\n	a[0] = a[0] > b[0] ? a[0] : b[0];\r\n\r\n	i = 1, car = 0;\r\n	while (i <= a[0]) {\r\n		a[i] += ( b[i] + car);\r\n		car = a[i] / 10;\r\n		a[i] %= 10;\r\n		++i;\r\n	}\r\n	\r\n	while (car) {\r\n		a[i] = car%10;\r\n		car /= 10;\r\n		++i;\r\n	}\r\n	a[0] = i - 1;\r\n	\r\n	j = 0, i = a[0];\r\n	while (i >= 1)\r\n		str_c[j++] = a[i--] + ''0'';\r\n	str_c[j] = ''\\0'';\r\n}\r\n\r\nint main()\r\n{\r\n	//freopen("3.txt","r",stdin);\r\n	//freopen("4.txt","w",stdout);\r\n	int T, i, t;\r\n	scanf("%d",&T);\r\n	for (i = 1; i <= T; ++i) {\r\n	    scanf("%s %s",str_a,str_b);\r\n		cal();\r\n		printf("Case %d:\\n",i);\r\n		printf("%s + %s = %s\\n",str_a,str_b,str_c);\r\n		if (i != T) printf("\\n");\r\n	}\r\n	return 0;\r\n}\r\n', '', 15, 282624, 1, 1, '2010-12-09 09:02:56', '0001-01-01 00:00:00'),
(1038, 6, 402, 0, 'import java.math.BigInteger;\r\nimport java.util.Scanner;\r\n\r\npublic class Main {\r\n public static void main(String[] args){\r\n  Scanner cin=new Scanner(System.in);\r\n  int ln=cin.nextInt();\r\n  BigInteger a=null;\r\n  BigInteger b=null;\r\n  for(int j=1;j<=ln;j++){\r\n   a=cin.nextBigInteger();\r\n   b=cin.nextBigInteger(); \r\n   System.out.println("Case "+j+":");\r\n      System.out.println(a + " + " + b + " = " + a.add(b));  \r\n      if(j<ln)\r\n       System.out.println();\r\n  }\r\n }\r\n}\r\n', '', 30, 33554432, 6, 4, '2010-12-09 09:07:04', '0001-01-01 00:00:00'),
(1039, 6, 403, 8, '#include <stdio.h>\r\n#include <string.h>\r\n#define N 20000\r\nint  a[N];\r\n\r\nvoid cal(int v)\r\n{\r\n	int i, car;\r\n	for (i = 1; i <= a[0]; ++i) \r\n		a[i] *= v;\r\n	\r\n	i = 1, car = 0;\r\n	while (i <= a[0]) {\r\n		a[i] += car;\r\n		car = a[i] / 10;\r\n		a[i] %= 10;\r\n		++i;\r\n	}\r\n	\r\n	while (car) {\r\n		a[i] = car%10;\r\n		car /= 10;\r\n		++i;\r\n	}\r\n	a[0] = i - 1;\r\n}\r\n\r\nint main()\r\n{\r\n	int n, i;\r\n	while (scanf("%d",&n) == 1) {\r\n		a[0] = a[1] = 1;\r\n		for (i = 1; i <= n; ++i)\r\n			cal(i);\r\n		for (i = a[0]; i >= 1; --i)\r\n			printf("%d",a[i]);\r\n		printf("\\n");\r\n\r\n	}\r\n	return 0;\r\n}\r\n', '', 888, 339968, 7, 1, '2010-12-09 09:17:01', '0001-01-01 00:00:00'),
(1040, 21, 402, 8, '#include <iostream>\r\n\r\n#include <string>\r\n\r\n#include <stack>\r\n\r\nusing namespace std;\r\n\r\nstring Add(string Str1, string Str2)\r\n\r\n{\r\n\r\n // 操作数1\r\n\r\n stack<int>S1;\r\n\r\n // 操作数2\r\n\r\n stack<int>S2;\r\n\r\n // 结果\r\n\r\n stack<int>S3;\r\n\r\n int i, r, last = 0;\r\n\r\n for(i=0; i<Str1.size(); i++)\r\n\r\n  S1.push(Str1[i]-''0'');\r\n\r\n for(i=0; i<Str2.size(); i++)\r\n\r\n  S2.push(Str2[i]-''0'');\r\n\r\n while(!S1.empty() && !S2.empty())\r\n\r\n {\r\n\r\n  r = S1.top() + S2.top() +last;\r\n\r\n  S3.push(r%10);\r\n\r\n  last = r/10;\r\n\r\n  S1.pop();\r\n\r\n  S2.pop();\r\n\r\n }\r\n\r\n if(!S1.empty())\r\n\r\n {\r\n\r\n  while(!S1.empty())\r\n\r\n  {\r\n\r\n   r = S1.top() + last;\r\n\r\n   S3.push(r%10);\r\n\r\n   last = r/10;\r\n\r\n   S1.pop();\r\n\r\n  }\r\n\r\n }\r\n\r\n else if(!S2.empty())\r\n\r\n {\r\n\r\n  while(!S2.empty())\r\n\r\n  {\r\n\r\n   r = S2.top() + last;\r\n\r\n   S3.push(r%10);\r\n\r\n   last = r/10;\r\n\r\n   S2.pop();\r\n\r\n  }\r\n\r\n }\r\n\r\n if(last != 0)\r\n\r\n  S3.push(last);\r\n\r\n string result;\r\n\r\n while(!S3.empty())\r\n\r\n {\r\n\r\n  result += S3.top() + ''0'';\r\n\r\n  S3.pop();\r\n\r\n }\r\n\r\n return result;\r\n\r\n}\r\n\r\nstring Sub(string Str1, string Str2)\r\n\r\n{\r\n\r\n // 操作数1\r\n\r\n stack<int>S1;\r\n\r\n // 操作数2\r\n\r\n stack<int>S2;\r\n\r\n // 结果\r\n\r\n stack<int>S3;\r\n\r\n int i, r, last = 0;\r\n\r\n for(i=0; i<Str1.size(); i++)\r\n\r\n  S1.push(Str1[i]-''0'');\r\n\r\n for(i=0; i<Str2.size(); i++)\r\n\r\n  S2.push(Str2[i]-''0'');\r\n\r\n while(!S1.empty() && !S2.empty())\r\n\r\n {\r\n	 if(last){r=S1.top()-S2.top()-last+10;}\r\n	 \r\n	 else r=S1.top()-S2.top();\r\n\r\n		S3.push(r);\r\n\r\n		S1.top()<S2.top()?last=1:last=0;\r\n\r\n		S1.pop();\r\n\r\n		S2.pop();\r\n\r\n }\r\n\r\n if(!S1.empty())\r\n\r\n {\r\n\r\n  while(!S1.empty())\r\n\r\n  {\r\n\r\n   r = S1.top() - last;\r\n\r\n   S3.push(r);\r\n\r\n   last = 0;\r\n\r\n   S1.pop();\r\n\r\n  }\r\n\r\n }\r\n\r\n string result;\r\n\r\n while(!S3.empty())\r\n\r\n {\r\n	while(S3.top()==0)S3.pop();\r\n  result += S3.top() + ''0'';\r\n\r\n  S3.pop();\r\n\r\n }\r\n\r\n return result;\r\n\r\n}\r\n\r\n\r\nint main(int argc, char* argv[])\r\n\r\n{\r\n\r\n int i, N;\r\n\r\n cin>>N;\r\n\r\n string a, b;\r\n\r\n\r\n string* answer = new string[N];\r\n\r\n for(i=0; i<N; i++)\r\n\r\n {\r\n\r\n  cin>>a>>b;\r\n\r\n  if(a[0]==''-''&&b[0]==''-''){\r\n     a.erase(0,1);\r\n	 b.erase(0,1);\r\n	 answer[i] = Add(a, b);\r\n	 answer[i].insert(0,''-'');\r\n  }\r\n  else if(a[0]==''-''){\r\n\r\n	a.erase(0,1);\r\n\r\n	bool flag;\r\n\r\n	if(a.length()>b.length()){flag=true;}\r\n\r\n	else if(a.length()==b.length()){a[0]>b[0]?flag=true:flag=false;}\r\n\r\n	else flag=false;\r\n\r\n	answer[i] = Sub(flag?a:b,flag?b:a);\r\n\r\n	if(flag)answer[i].insert(0,''-'');\r\n\r\n  }\r\n\r\n  else if(b[0]==''-''){\r\n	\r\n	b.erase(0,1);	\r\n	\r\n	bool flag;\r\n\r\n	if(a.length()>b.length()){flag=true;}\r\n\r\n	else if(a.length()==b.length()){a[0]>b[0]?flag=true:flag=false;}\r\n\r\n	else flag=false;\r\n\r\n	answer[i] = Sub(flag?a:b,flag?b:a);\r\n\r\n	if(flag)answer[i].insert(0,''-'');\r\n  }\r\n  else 	 answer[i] = Add(a, b);\r\n\r\n }\r\n\r\n for(i=0; i<N; i++)\r\n\r\n {\r\n\r\n  cout<<answer[i]<<endl;\r\n\r\n }\r\n\r\n delete[] answer;\r\n\r\n return 0;\r\n\r\n}\r\n', 'Main.cpp: In function ''int main(int, char**)'':\r\nMain.cpp:214:25: error: invalid conversion from ''char'' to ''const char*''\r\nMain.cpp:214:25: error:   initializing argument 2 of ''std::basic_string<_CharT, _Traits, _Alloc>& std::basic_string<_CharT, _Traits, _Alloc>::insert(std::basic_string<_CharT, _Traits, _Alloc>::size_type, const _CharT*) [with _CharT = char, _Traits = std::char_traits<char>, _Alloc = std::allocator<char>, std::basic_string<_CharT, _Traits, _Alloc> = std::basic_string<char>, std:', 0, 0, 2, 2, '2010-12-09 09:18:17', '0001-01-01 00:00:00'),
(1041, 6, 403, 8, '#include <stdio.h>\r\n#define N 100000\r\nint  a[N];\r\n\r\nvoid cal(int v)\r\n{\r\n	int i, car;\r\n	for (i = 1; i <= a[0]; ++i) \r\n		a[i] *= v;\r\n	\r\n	i = 1, car = 0;\r\n	while (i <= a[0]) {\r\n		a[i] += car;\r\n		car = a[i] / 10;\r\n		a[i] %= 10;\r\n		++i;\r\n	}\r\n	\r\n	while (car) {\r\n		a[i] = car%10;\r\n		car /= 10;\r\n		++i;\r\n	}\r\n	a[0] = i - 1;\r\n}\r\n\r\nint main()\r\n{\r\n	int n, i;\r\n	while (scanf("%d",&n) == 1) {\r\n		a[0] = a[1] = 1;\r\n		for (i = 1; i <= n; ++i)\r\n			cal(i);\r\n		for (i = a[0]; i >= 1; --i)\r\n			printf("%d",a[i]);\r\n		printf("\\n");\r\n\r\n	}\r\n	return 0;\r\n}\r\n', '', 1500, 659456, 5, 1, '2010-12-09 09:18:41', '0001-01-01 00:00:00'),
(1042, 11, 344, 4, '#include<string>\r\n#include<iostream>\r\n#include<map>\r\n\r\n\r\nusing std::string;using std::map;\r\nusing std::cin;using std::cout;\r\nusing std::pair;using std::endl;\r\n\r\nint main()\r\n{\r\n int i,size;\r\n string temp;\r\n map<string,int> line;\r\n pair<map<string, int>::iterator, bool> Insert_Pair;\r\n\r\n while(scanf("%d",&size)!=EOF)\r\n {\r\n   line.clear();\r\n   //Insert_Pair.earse(mapStudent.begin(), mapStudent.end());\r\n for(i=0;i != size;i++)\r\n {\r\n  cin >>temp;\r\n  Insert_Pair = line.insert(map<string,int>::value_type (temp,i));\r\n        if(Insert_Pair.second == false)\r\n        break;\r\n }\r\n if(i == size) cout << 0 << endl;\r\n else cout << i-line[temp] << endl;\r\n}\r\n return 0;\r\n}\r\n', 'Main.cpp: In function ''int main()'':\r\nMain.cpp:17:24: error: ''scanf'' was not declared in this scope\r\nMain.cpp:17:27: error: ''EOF'' was not declared in this scope\r\n', 0, 0, 2, 2, '2010-12-09 09:20:33', '0001-01-01 00:00:00'),
(1043, 6, 403, 8, '#include <stdio.h>\r\n#define N 100000\r\nint  a[N];\r\n\r\nvoid cal(int v)\r\n{\r\n	int i, car = 0;\r\n	for (i = 1; i <= a[0]; ++i) {\r\n		a[i] *= v;\r\n		a[i] += car;\r\n		car = a[i] / 10;\r\n		a[i] %= 10;\r\n	}\r\n	\r\n	while (car) {\r\n		a[i] = car%10;\r\n		car /= 10;\r\n		++i;\r\n	}\r\n	a[0] = i - 1;\r\n}\r\n\r\nint main()\r\n{\r\n	int n, i;\r\n	while (scanf("%d",&n) == 1) {\r\n		a[0] = a[1] = 1;\r\n		for (i = 1; i <= n; ++i)\r\n			cal(i);\r\n		for (i = a[0]; i >= 1; --i)\r\n			printf("%d",a[i]);\r\n		printf("\\n");\r\n\r\n	}\r\n	return 0;\r\n}\r\n', '', 1500, 659456, 5, 1, '2010-12-09 09:21:01', '0001-01-01 00:00:00'),
(1044, 6, 403, 8, '#include <stdio.h>\r\n#define N 100000\r\nint  a[N];\r\n\r\nvoid cal(int v)\r\n{\r\n	int i, car = 0;\r\n	for (i = 1; i <= a[0]; ++i) {\r\n		a[i] *= v;\r\n		a[i] += car;\r\n		car = a[i] / 10;\r\n		a[i] %= 10;\r\n	}\r\n	\r\n	while (car) {\r\n		a[i] = car%10;\r\n		car /= 10;\r\n		++i;\r\n	}\r\n	a[0] = i - 1;\r\n}\r\n\r\nint main()\r\n{\r\n	int n, i;\r\n	while (scanf("%d",&n) != EOF) {\r\n		a[0] = a[1] = 1;\r\n		for (i = 2; i <= n; ++i)\r\n			cal(i);\r\n		for (i = a[0]; i >= 1; --i)\r\n			printf("%d",a[i]);\r\n		printf("\\n");\r\n\r\n	}\r\n	return 0;\r\n}\r\n', '', 1500, 659456, 5, 1, '2010-12-09 09:22:09', '0001-01-01 00:00:00'),
(1045, 20, 402, 8, '#include<stdio.h>\r\n#include<string.h>\r\nchar str1[2000],str2[2000];\r\nint  num1[2000],num2[2000];\r\nint main()\r\n{\r\n    int n,l=1,m=1;\r\n    scanf("%d",&n);\r\n    while(n--)\r\n    {\r\n        memset(num1,0,sizeof(num1));\r\n        memset(num2,0,sizeof(num2));\r\n        scanf("%s%s",str1,str2);\r\n        int len1=strlen(str1);\r\n        int len2=strlen(str2);\r\n        int i,j=0;\r\n        for(i=len1-1;i>=0;i--)\r\n        num1[j++]=str1[i]-''0'';\r\n        j=0;\r\n        for(i=len2-1;i>=0;i--)\r\n        num2[j++]=str2[i]-''0'';\r\n        for(i=0;i<2000;i++)\r\n        {\r\n            num2[i]=num2[i]+num1[i];\r\n            if(num2[i]>=10)\r\n            { num2[i]=num2[i]-10;\r\n              num2[i+1]++;\r\n            }\r\n        }\r\n        if(m==1) m=2;\r\n        else printf("\\n");\r\n        printf("Case %d:\\n",l++);\r\n        printf("%s + %s = ",str1,str2);\r\n        bool bStartOutput=false;\r\n        for(i=1999;i>=0;i--)\r\n        {\r\n            if(num2[i]||bStartOutput)\r\n            {printf("%d",num2[i]);\r\n             bStartOutput=true;\r\n            }\r\n        }\r\n        if(!bStartOutput) printf("0");\r\n        printf("\\n");\r\n    }\r\n    return 0;\r\n}\r\n', 'Main.c: In function ''main'':\r\nMain.c:34:9: error: ''bool'' undeclared (first use in this function)\r\nMain.c:34:9: note: each undeclared identifier is reported only once for each function it appears in\r\nMain.c:34:14: error: expected '';'' before ''bStartOutput''\r\nMain.c:37:25: error: ''bStartOutput'' undeclared (first use in this function)\r\nMain.c:39:27: error: ''true'' undeclared (first use in this function)\r\n', 0, 0, 2, 1, '2010-12-09 09:23:58', '0001-01-01 00:00:00'),
(1046, 6, 403, 8, '#include<iostream>\r\n#include<cmath>\r\nusing namespace std;\r\n\r\nint re[7200];\r\nvoid bigplus(int n)\r\n{\r\n    int i,flag=0;\r\n    for(i=1;i<=re[0];i++)\r\n    {\r\n        re[i]=re[i]*n+flag;\r\n        if(re[i]>99999){\r\n            flag=re[i]/100000;\r\n            re[i]%=100000;\r\n        }\r\n        else flag=0;\r\n    }\r\n    if(flag){re[i]=flag;re[0]++;}\r\n}\r\n\r\nint main()\r\n{\r\n    int n,i;\r\n    while(scanf("%d",&n)!=EOF){\r\n        memset(re,0,sizeof(re));\r\n        re[0]=1;re[1]=1;\r\n        for(i=2;i<=n;i++)\r\n            bigplus(i);\r\n        printf("%d",re[re[0]]);\r\n        for(i=re[0]-1;i>=1;i--)\r\n            printf("%05d",re[i]);\r\n        printf("\\n");\r\n    }\r\n    return 0;\r\n}\r\n', 'Main.cpp: In function ''int main()'':\r\nMain.cpp:24:24: error: ''scanf'' was not declared in this scope\r\nMain.cpp:24:27: error: ''EOF'' was not declared in this scope\r\nMain.cpp:25:31: error: ''memset'' was not declared in this scope\r\nMain.cpp:29:30: error: ''printf'' was not declared in this scope\r\n', 0, 0, 2, 2, '2010-12-09 09:27:24', '0001-01-01 00:00:00'),
(1047, 21, 402, 8, '#include <iostream>\r\n\r\n#include <string>\r\n\r\n#include <stack>\r\n\r\nusing namespace std;\r\n\r\nstring Add(string Str1, string Str2)\r\n\r\n{\r\n\r\n // 操作数1\r\n\r\n stack<int>S1;\r\n\r\n // 操作数2\r\n\r\n stack<int>S2;\r\n\r\n // 结果\r\n\r\n stack<int>S3;\r\n\r\n int i, r, last = 0;\r\n\r\n for(i=0; i<Str1.size(); i++)\r\n\r\n  S1.push(Str1[i]-''0'');\r\n\r\n for(i=0; i<Str2.size(); i++)\r\n\r\n  S2.push(Str2[i]-''0'');\r\n\r\n while(!S1.empty() && !S2.empty())\r\n\r\n {\r\n\r\n  r = S1.top() + S2.top() +last;\r\n\r\n  S3.push(r%10);\r\n\r\n  last = r/10;\r\n\r\n  S1.pop();\r\n\r\n  S2.pop();\r\n\r\n }\r\n\r\n if(!S1.empty())\r\n\r\n {\r\n\r\n  while(!S1.empty())\r\n\r\n  {\r\n\r\n   r = S1.top() + last;\r\n\r\n   S3.push(r%10);\r\n\r\n   last = r/10;\r\n\r\n   S1.pop();\r\n\r\n  }\r\n\r\n }\r\n\r\n else if(!S2.empty())\r\n\r\n {\r\n\r\n  while(!S2.empty())\r\n\r\n  {\r\n\r\n   r = S2.top() + last;\r\n\r\n   S3.push(r%10);\r\n\r\n   last = r/10;\r\n\r\n   S2.pop();\r\n\r\n  }\r\n\r\n }\r\n\r\n if(last != 0)\r\n\r\n  S3.push(last);\r\n\r\n string result;\r\n\r\n while(!S3.empty())\r\n\r\n {\r\n\r\n  result += S3.top() + ''0'';\r\n\r\n  S3.pop();\r\n\r\n }\r\n\r\n return result;\r\n\r\n}\r\n\r\nstring Sub(string Str1, string Str2)\r\n\r\n{\r\n\r\n // 操作数1\r\n\r\n stack<int>S1;\r\n\r\n // 操作数2\r\n\r\n stack<int>S2;\r\n\r\n // 结果\r\n\r\n stack<int>S3;\r\n\r\n int i, r, last = 0;\r\n\r\n for(i=0; i<Str1.size(); i++)\r\n\r\n  S1.push(Str1[i]-''0'');\r\n\r\n for(i=0; i<Str2.size(); i++)\r\n\r\n  S2.push(Str2[i]-''0'');\r\n\r\n while(!S1.empty() && !S2.empty())\r\n\r\n {\r\n	 if(last){r=S1.top()-S2.top()-last+10;}\r\n	 \r\n	 else r=S1.top()-S2.top();\r\n\r\n		S3.push(r);\r\n\r\n		S1.top()<S2.top()?last=1:last=0;\r\n\r\n		S1.pop();\r\n\r\n		S2.pop();\r\n\r\n }\r\n\r\n if(!S1.empty())\r\n\r\n {\r\n\r\n  while(!S1.empty())\r\n\r\n  {\r\n\r\n   r = S1.top() - last;\r\n\r\n   S3.push(r);\r\n\r\n   last = 0;\r\n\r\n   S1.pop();\r\n\r\n  }\r\n\r\n }\r\n\r\n string result;\r\n\r\n while(!S3.empty())\r\n\r\n {\r\n	while(S3.top()==0)S3.pop();\r\n  result += S3.top() + ''0'';\r\n\r\n  S3.pop();\r\n\r\n }\r\n\r\n return result;\r\n\r\n}\r\n\r\n\r\nint main()\r\n\r\n{\r\n\r\n int i, N;\r\n\r\n cin>>N;\r\n\r\n string a, b;\r\n\r\n\r\n string answer;\r\n\r\n for(i=0; i<N; i++)\r\n\r\n {\r\n\r\n  cin>>a>>b;\r\n\r\n  cout<<"CASE "<<i+1<<":"<<endl;\r\n  cout<<a<<" + "<<b<<" = ";\r\n\r\n  if(a[0]==''-''&&b[0]==''-''){\r\n     a.erase(0,1);\r\n	 b.erase(0,1);\r\n	 answer = Add(a, b);\r\n	 answer.insert(0,''-'');\r\n  }\r\n  else if(a[0]==''-''){\r\n\r\n	a.erase(0,1);\r\n\r\n	bool flag;\r\n\r\n	if(a.length()>b.length()){flag=true;}\r\n\r\n	else if(a.length()==b.length()){a[0]>b[0]?flag=true:flag=false;}\r\n\r\n	else flag=false;\r\n\r\n	answer = Sub(flag?a:b,flag?b:a);\r\n\r\n	if(flag)answer.insert(0,''-'');\r\n\r\n  }\r\n\r\n  else if(b[0]==''-''){\r\n	\r\n	b.erase(0,1);	\r\n	\r\n	bool flag;\r\n\r\n	if(a.length()>b.length()){flag=true;}\r\n\r\n	else if(a.length()==b.length()){a[0]>b[0]?flag=true:flag=false;}\r\n\r\n	else flag=false;\r\n\r\n	answer = Sub(flag?a:b,flag?b:a);\r\n\r\n	if(flag)answer.insert(0,''-'');\r\n  }\r\n  else 	 answer = Add(a, b);\r\n\r\n  cout<<answer<<endl<<endl;\r\n\r\n }\r\n return 0;\r\n\r\n}\r\n', 'Main.cpp: In function ''int main()'':\r\nMain.cpp:217:22: error: invalid conversion from ''char'' to ''const char*''\r\nMain.cpp:217:22: error:   initializing argument 2 of ''std::basic_string<_CharT, _Traits, _Alloc>& std::basic_string<_CharT, _Traits, _Alloc>::insert(std::basic_string<_CharT, _Traits, _Alloc>::size_type, const _CharT*) [with _CharT = char, _Traits = std::char_traits<char>, _Alloc = std::allocator<char>, std::basic_string<_CharT, _Traits, _Alloc> = std::basic_string<char>, std::basic_stri', 0, 0, 2, 2, '2010-12-09 09:27:53', '0001-01-01 00:00:00'),
(1048, 20, 402, 8, '#include<stdio.h>\r\n#include<string.h>\r\n#define true 0x0001\r\n#define false 0x0000\r\nchar str1[2000],str2[2000];\r\nint  num1[2000],num2[2000];\r\nint main()\r\n{\r\n    int n,l=1,m=1;\r\n    scanf("%d",&n);\r\n    while(n--)\r\n    {\r\n        memset(num1,0,sizeof(num1));\r\n        memset(num2,0,sizeof(num2));\r\n        scanf("%s%s",str1,str2);\r\n        int len1=strlen(str1);\r\n        int len2=strlen(str2);\r\n        int i,j=0;\r\n        for(i=len1-1;i>=0;i--)\r\n        num1[j++]=str1[i]-''0'';\r\n        j=0;\r\n        for(i=len2-1;i>=0;i--)\r\n        num2[j++]=str2[i]-''0'';\r\n        for(i=0;i<2000;i++)\r\n        {\r\n            num2[i]=num2[i]+num1[i];\r\n            if(num2[i]>=10)\r\n            { num2[i]=num2[i]-10;\r\n              num2[i+1]++;\r\n            }\r\n        }\r\n        if(m==1) m=2;\r\n        else printf("\\n");\r\n        printf("Case %d:\\n",l++);\r\n        printf("%s + %s = ",str1,str2);\r\n        bool bStartOutput=false;\r\n        for(i=1999;i>=0;i--)\r\n        {\r\n            if(num2[i]||bStartOutput)\r\n            {printf("%d",num2[i]);\r\n             bStartOutput=true;\r\n            }\r\n        }\r\n        if(!bStartOutput) printf("0");\r\n        printf("\\n");\r\n    }\r\n    return 0;\r\n}\r\n', 'Main.c: In function ''main'':\r\nMain.c:36:9: error: ''bool'' undeclared (first use in this function)\r\nMain.c:36:9: note: each undeclared identifier is reported only once for each function it appears in\r\nMain.c:36:14: error: expected '';'' before ''bStartOutput''\r\nMain.c:39:25: error: ''bStartOutput'' undeclared (first use in this function)\r\n', 0, 0, 2, 1, '2010-12-09 09:28:34', '0001-01-01 00:00:00'),
(1049, 6, 403, 8, '#include <iostream>\r\n#include <cmath>\r\n#include <cstdio>\r\nusing namespace std;\r\n\r\nint re[7200];\r\nvoid bigplus(int n)\r\n{\r\n    int i,flag=0;\r\n    for(i=1;i<=re[0];i++)\r\n    {\r\n        re[i]=re[i]*n+flag;\r\n        if(re[i]>99999){\r\n            flag=re[i]/100000;\r\n            re[i]%=100000;\r\n        }\r\n        else flag=0;\r\n    }\r\n    if(flag){re[i]=flag;re[0]++;}\r\n}\r\n\r\nint main()\r\n{\r\n    int n,i;\r\n    while(scanf("%d",&n)!=EOF){\r\n        memset(re,0,sizeof(re));\r\n        re[0]=1;re[1]=1;\r\n        for(i=2;i<=n;i++)\r\n            bigplus(i);\r\n        printf("%d",re[re[0]]);\r\n        for(i=re[0]-1;i>=1;i--)\r\n            printf("%05d",re[i]);\r\n        printf("\\n");\r\n    }\r\n    return 0;\r\n}\r\n', 'Main.cpp: In function ''int main()'':\r\nMain.cpp:26:31: error: ''memset'' was not declared in this scope\r\n', 0, 0, 2, 2, '2010-12-09 09:28:51', '0001-01-01 00:00:00'),
(1050, 20, 402, 8, '#include<stdio.h>\r\n#include<string.h>\r\n#define true 0x0001\r\n#define false 0x0000\r\nchar str1[2000],str2[2000];\r\nint  num1[2000],num2[2000];\r\nint main()\r\n{\r\n    int n,l=1,m=1;\r\n    scanf("%d",&n);\r\n    while(n--)\r\n    {\r\n        memset(num1,0,sizeof(num1));\r\n        memset(num2,0,sizeof(num2));\r\n        scanf("%s%s",str1,str2);\r\n        int len1=strlen(str1);\r\n        int len2=strlen(str2);\r\n        int i,j=0;\r\n        for(i=len1-1;i>=0;i--)\r\n        num1[j++]=str1[i]-''0'';\r\n        j=0;\r\n        for(i=len2-1;i>=0;i--)\r\n        num2[j++]=str2[i]-''0'';\r\n        for(i=0;i<2000;i++)\r\n        {\r\n            num2[i]=num2[i]+num1[i];\r\n            if(num2[i]>=10)\r\n            { num2[i]=num2[i]-10;\r\n              num2[i+1]++;\r\n            }\r\n        }\r\n        if(m==1) m=2;\r\n        else printf("\\n");\r\n        printf("Case %d:\\n",l++);\r\n        printf("%s + %s = ",str1,str2);\r\n        bool bStartOutput=false;\r\n        for(i=1999;i>=0;i--)\r\n        {\r\n            if(num2[i]||bStartOutput)\r\n            {printf("%d",num2[i]);\r\n             bStartOutput=true;\r\n            }\r\n        }\r\n        if(!bStartOutput) printf("0");\r\n        printf("\\n");\r\n    }\r\n    return 0;\r\n}\r\n', '', 46, 278528, 1, 2, '2010-12-09 09:28:55', '0001-01-01 00:00:00'),
(1051, 23, 402, 8, '#include<stdio.h>\r\n#include<string.h>\r\nint main(){\r\n	char a[20][1000],b[20][1000],x,y;\r\n	char d[20][1001];\r\n	int n,a_length,b_length,val,tag;\r\n	int i,j,k;\r\n	\r\n	scanf("%d",&n);\r\n	for(i=0;i<n;++i){\r\n		scanf("%s %s",a[i],b[i]);\r\n		a_length=strlen(a[i])-1;\r\n		b_length=strlen(b[i])-1;\r\n		\r\n		a_length>=b_length?k=a_length+2:k=b_length+2;\r\n		d[i][k--]=''\\0'';\r\n		while(a_length>=0||b_length>=0){\r\n			if(a_length<0) x=''0''; else x=a[i][a_length--];\r\n			if(b_length<0) y=''0''; else y=b[i][b_length--];\r\n			\r\n			val=x-''0''+(y-''0'');\r\n			if(1==tag) ++val;\r\n			if(val>9){\r\n				val=val%10;\r\n				tag=1;\r\n			}\r\n			else tag=0;\r\n			d[i][k--]=val+''0'';\r\n		}\r\n		if(1==tag) d[i][k]=1+''0'';\r\n		else d[i][k]=''0'';\r\n	}\r\n	char *p;\r\n	for(i=0;i<n;++i){\r\n		printf("Case%d:\\n",i+1);\r\n		if(''0''==d[i][0]){\r\n			p=&d[i][1];\r\n			printf("%s + %s = %s\\n\\n",a[i],b[i],p);\r\n		}\r\n		else printf("%s + %s = %s\\n\\n",a[i],b[i],d[i]);\r\n	}\r\n	return 0;\r\n}', '', 0, 274432, 7, 2, '2010-12-09 09:29:12', '0001-01-01 00:00:00'),
(1052, 6, 403, 8, '#include <iostream>\r\n#include <cmath>\r\n#include <cstdio>\r\n#include <string.h>\r\nusing namespace std;\r\n\r\nint re[7200];\r\nvoid bigplus(int n)\r\n{\r\n    int i,flag=0;\r\n    for(i=1;i<=re[0];i++)\r\n    {\r\n        re[i]=re[i]*n+flag;\r\n        if(re[i]>99999){\r\n            flag=re[i]/100000;\r\n            re[i]%=100000;\r\n        }\r\n        else flag=0;\r\n    }\r\n    if(flag){re[i]=flag;re[0]++;}\r\n}\r\n\r\nint main()\r\n{\r\n    int n,i;\r\n    while(scanf("%d",&n)!=EOF){\r\n        memset(re,0,sizeof(re));\r\n        re[0]=1;re[1]=1;\r\n        for(i=2;i<=n;i++)\r\n            bigplus(i);\r\n        printf("%d",re[re[0]]);\r\n        for(i=re[0]-1;i>=1;i--)\r\n            printf("%05d",re[i]);\r\n        printf("\\n");\r\n    }\r\n    return 0;\r\n}\r\n', '', 530, 397312, 1, 2, '2010-12-09 09:29:37', '0001-01-01 00:00:00'),
(1053, 23, 402, 8, '#include<stdio.h>\r\n#include<string.h>\r\nint main(){\r\n	char a[20][1000],b[20][1000],x,y;\r\n	char d[20][1001];\r\n	int n,a_length,b_length,val,tag;\r\n	int i,j,k;\r\n	\r\n	scanf("%d",&n);\r\n	for(i=0;i<n;++i){\r\n		scanf("%s %s",a[i],b[i]);\r\n		a_length=strlen(a[i])-1;\r\n		b_length=strlen(b[i])-1;\r\n		\r\n		a_length>=b_length?k=a_length+2:k=b_length+2;\r\n		d[i][k--]=''\\0'';\r\n		while(a_length>=0||b_length>=0){\r\n			if(a_length<0) x=''0''; else x=a[i][a_length--];\r\n			if(b_length<0) y=''0''; else y=b[i][b_length--];\r\n			\r\n			val=x-''0''+(y-''0'');\r\n			if(1==tag) ++val;\r\n			if(val>9){\r\n				val=val%10;\r\n				tag=1;\r\n			}\r\n			else tag=0;\r\n			d[i][k--]=val+''0'';\r\n		}\r\n		if(1==tag) d[i][k]=1+''0'';\r\n		else d[i][k]=''0'';\r\n	}\r\n	char *p;\r\n	for(i=0;i<n;++i){\r\n		printf("Case%d:\\n",i+1);\r\n		if(''0''==d[i][0]){\r\n			p=&d[i][1];\r\n			printf("%s + %s = %s\\n\\n",a[i],b[i],p);\r\n		}\r\n		else printf("%s + %s = %s\\n\\n",a[i],b[i],d[i]);\r\n	}\r\n	return 0;\r\n}', '', 0, 274432, 7, 2, '2010-12-09 09:31:52', '0001-01-01 00:00:00'),
(1054, 17, 379, 7, '#include<stdio.h>\r\n#include<stdlib.h>\r\n#define MAXNODE 1405\r\n#define MAXCOST 99999\r\nint cost[MAXNODE][MAXNODE];\r\nint s[MAXNODE];\r\nint dist[MAXNODE];\r\nint node[MAXNODE];\r\nvoid dijsktra(int v0,int N);\r\nint print(int v0,int N,int a[],int p);\r\nmain()\r\n{       int i,j;\r\n        int v0;\r\n        int N ,P,C;\r\n        int A,B,long1;\r\n        int min=99999;\r\n        int ret;\r\n        int count[801]={1};\r\n        while(scanf("%d%d%d",&P,&N,&C)!=EOF)\r\n       { \r\n       \r\n         for(i=1;i<=P;i++)\r\n          {   \r\n              scanf("%d",&node[i]);\r\n              count[i]=1;\r\n              for(j=1;j<i;j++)\r\n              if(node[i]==node[j])\r\n                count[i]++;\r\n          }\r\n         \r\n         for(i=1;i<=N;i++)\r\n         {       \r\n                for(j=1;j<=N;j++)\r\n                {      \r\n                        cost[i][j]=MAXCOST;\r\n                        \r\n                        if(i==j)\r\n                        cost[i][j]=0;\r\n                }\r\n        }\r\n        for(i=1;i<=C;i++)\r\n        {  \r\n             scanf("%d%d%d",&A,&B,&long1);\r\n             cost[A][B]=long1;\r\n             cost[B][A]=long1;\r\n         }\r\n         \r\n         for(i=1;i<=P;i++)\r\n         {  \r\n            dijsktra(node[i],N);\r\n            ret=print(node[i],N,node,P);\r\n            if(min>=ret)\r\n             min = ret;\r\n         }\r\n         for(i=1;i<=P;i++)\r\n         {\r\n             min=min*count[i];\r\n         }\r\n         printf("%d\\n",min);\r\n        }\r\n        return 0;\r\n}\r\nvoid dijsktra(int v,int N)\r\n{       int i,j;\r\n        int u,mindis;\r\n        int dis;\r\n        for(i=1;i<=N;i++)\r\n        {\r\n                dist[i]=cost[v][i];\r\n                s[i]=0;\r\n        }\r\n        s[v]=1;\r\n        for(i=1;i<=N;i++)\r\n        {       mindis=MAXCOST;\r\n                for(j=1;j<=N;j++)\r\n                {\r\n                        if(dist[j]<mindis&&s[j]==0)\r\n                        {     \r\n                                mindis=dist[j];\r\n                                u=j;\r\n                        }\r\n\r\n                }\r\n                s[u]=1;\r\n                for(j=1;j<=N;j++)\r\n                {       if(s[j]==0)\r\n                        {     \r\n                                dis=dist[u]+cost[u][j];\r\n                                dist[j]=dist[j]<dis?dist[j]:dis;\r\n                        }\r\n                }\r\n        }\r\n}\r\nint print(int v,int N,int *a,int P)\r\n{       \r\n        int i,j;\r\n        int sum;\r\n        sum=0; \r\n        for(i=1;i<=N;i++)\r\n        { \r\n          if(i!=v)\r\n        {      \r\n         for(j=1;j<=P;j++)\r\n         {\r\n           if(i==a[j]){\r\n            sum+=dist[i];}\r\n           }\r\n        }\r\n       else\r\n          continue;\r\n         }\r\n    \r\n       return sum;\r\n}\r\n', '', 0, 8183808, 4, 1, '2010-12-09 09:31:54', '0001-01-01 00:00:00'),
(1055, 11, 344, 4, '#include<string>\r\n#include<iostream>\r\n#include<map>\r\n\r\n\r\nusing std::string;using std::map;\r\nusing std::cin;using std::cout;\r\nusing std::pair;using std::endl;\r\n\r\nint main()\r\n{\r\n int i,size;\r\n string temp;\r\n map<string,int> line;\r\n pair<map<string, int>::iterator, bool> Insert_Pair;\r\n\r\n while(cin>>size)\r\n {\r\n   line.clear();\r\n   //Insert_Pair.earse(mapStudent.begin(), mapStudent.end());\r\n for(i=0;i != size;i++)\r\n {\r\n  cin >>temp;\r\n  Insert_Pair = line.insert(map<string,int>::value_type (temp,i));\r\n        if(Insert_Pair.second == false)\r\n        break;\r\n }\r\n if(i == size) cout << 0 << endl;\r\n else cout << i-line[temp] << endl;\r\n}\r\n return 0;\r\n}\r\n', '', 62, 1134592, 1, 2, '2010-12-09 09:32:26', '0001-01-01 00:00:00'),
(1056, 21, 402, 8, '#include <iostream>\r\n\r\n#include <string>\r\n\r\n#include <stack>\r\n\r\nusing namespace std;\r\n\r\nstring Add(string Str1, string Str2)\r\n\r\n{\r\n\r\n // 操作数1\r\n\r\n stack<int>S1;\r\n\r\n // 操作数2\r\n\r\n stack<int>S2;\r\n\r\n // 结果\r\n\r\n stack<int>S3;\r\n\r\n int i, r, last = 0;\r\n\r\n for(i=0; i<Str1.size(); i++)\r\n\r\n  S1.push(Str1[i]-''0'');\r\n\r\n for(i=0; i<Str2.size(); i++)\r\n\r\n  S2.push(Str2[i]-''0'');\r\n\r\n while(!S1.empty() && !S2.empty())\r\n\r\n {\r\n\r\n  r = S1.top() + S2.top() +last;\r\n\r\n  S3.push(r%10);\r\n\r\n  last = r/10;\r\n\r\n  S1.pop();\r\n\r\n  S2.pop();\r\n\r\n }\r\n\r\n if(!S1.empty())\r\n\r\n {\r\n\r\n  while(!S1.empty())\r\n\r\n  {\r\n\r\n   r = S1.top() + last;\r\n\r\n   S3.push(r%10);\r\n\r\n   last = r/10;\r\n\r\n   S1.pop();\r\n\r\n  }\r\n\r\n }\r\n\r\n else if(!S2.empty())\r\n\r\n {\r\n\r\n  while(!S2.empty())\r\n\r\n  {\r\n\r\n   r = S2.top() + last;\r\n\r\n   S3.push(r%10);\r\n\r\n   last = r/10;\r\n\r\n   S2.pop();\r\n\r\n  }\r\n\r\n }\r\n\r\n if(last != 0)\r\n\r\n  S3.push(last);\r\n\r\n string result;\r\n\r\n while(!S3.empty())\r\n\r\n {\r\n\r\n  result += S3.top() + ''0'';\r\n\r\n  S3.pop();\r\n\r\n }\r\n\r\n return result;\r\n\r\n}\r\n\r\n\r\n\r\nint main()\r\n\r\n{\r\n\r\n int i, N;\r\n\r\n cin>>N;\r\n\r\n string a, b;\r\n\r\n\r\n string answer;\r\n\r\n for(i=0; i<N; i++)\r\n\r\n {\r\n\r\n  cin>>a>>b;\r\n\r\n  cout<<"CASE "<<i+1<<":"<<endl;\r\n  cout<<a<<" + "<<b<<" = ";\r\n\r\n answer = Add(a, b);\r\n\r\n  cout<<answer<<endl<<endl;\r\n\r\n }\r\n return 0;\r\n\r\n}\r\n', '', 93, 512000, 4, 2, '2010-12-09 09:32:45', '0001-01-01 00:00:00'),
(1057, 23, 402, 8, '#include<stdio.h>\r\n#include<string.h>\r\nint main(){\r\n	char a[20][3000],b[20][3000],x,y;\r\n	char d[20][3001];\r\n	int n,a_length,b_length,val,tag;\r\n	int i,j,k;\r\n	\r\n	scanf("%d",&n);\r\n	for(i=0;i<n;++i){\r\n		scanf("%s %s",a[i],b[i]);\r\n		a_length=strlen(a[i])-1;\r\n		b_length=strlen(b[i])-1;\r\n		\r\n		a_length>=b_length?k=a_length+2:k=b_length+2;\r\n		d[i][k--]=''\\0'';\r\n		while(a_length>=0||b_length>=0){\r\n			if(a_length<0) x=''0''; else x=a[i][a_length--];\r\n			if(b_length<0) y=''0''; else y=b[i][b_length--];\r\n			\r\n			val=x-''0''+(y-''0'');\r\n			if(1==tag) ++val;\r\n			if(val>9){\r\n				val=val%10;\r\n				tag=1;\r\n			}\r\n			else tag=0;\r\n			d[i][k--]=val+''0'';\r\n		}\r\n		if(1==tag) d[i][k]=1+''0'';\r\n		else d[i][k]=''0'';\r\n	}\r\n	char *p;\r\n	for(i=0;i<n;++i){\r\n		printf("Case%d:\\n",i+1);\r\n		if(''0''==d[i][0]){\r\n			p=&d[i][1];\r\n			printf("%s + %s = %s\\n\\n",a[i],b[i],p);\r\n		}\r\n		else printf("%s + %s = %s\\n\\n",a[i],b[i],d[i]);\r\n	}\r\n	return 0;\r\n}', 'Main.c: In function ''main'':\r\nMain.c:15:3: error: lvalue required as left operand of assignment\r\n', 0, 0, 2, 1, '2010-12-09 09:35:55', '0001-01-01 00:00:00'),
(1058, 23, 402, 8, '#include<stdio.h>\r\n#include<string.h>\r\nint main(){\r\n	char a[20][3000],b[20][3000],x,y;\r\n	char d[20][3001];\r\n	int n,a_length,b_length,val,tag;\r\n	int i,j,k;\r\n	\r\n	scanf("%d",&n);\r\n	for(i=0;i<n;++i){\r\n		scanf("%s %s",a[i],b[i]);\r\n		a_length=strlen(a[i])-1;\r\n		b_length=strlen(b[i])-1;\r\n		\r\n		a_length>=b_length?k=a_length+2:k=b_length+2;\r\n		d[i][k--]=''\\0'';\r\n		while(a_length>=0||b_length>=0){\r\n			if(a_length<0) x=''0''; else x=a[i][a_length--];\r\n			if(b_length<0) y=''0''; else y=b[i][b_length--];\r\n			\r\n			val=x-''0''+(y-''0'');\r\n			if(1==tag) ++val;\r\n			if(val>9){\r\n				val=val%10;\r\n				tag=1;\r\n			}\r\n			else tag=0;\r\n			d[i][k--]=val+''0'';\r\n		}\r\n		if(1==tag) d[i][k]=1+''0'';\r\n		else d[i][k]=''0'';\r\n	}\r\n	char *p;\r\n	for(i=0;i<n;++i){\r\n		printf("Case%d:\\n",i+1);\r\n		if(''0''==d[i][0]){\r\n			p=&d[i][1];\r\n			printf("%s + %s = %s\\n\\n",a[i],b[i],p);\r\n		}\r\n		else printf("%s + %s = %s\\n\\n",a[i],b[i],d[i]);\r\n	}\r\n	return 0;\r\n}', '', 0, 393216, 7, 2, '2010-12-09 09:36:24', '0001-01-01 00:00:00'),
(1059, 11, 336, 2, '#include <stdio.h>\r\n#include <iostream>\r\n#include <vector>\r\n#include <algorithm>\r\n#include <iterator>\r\n#define POW(c) (1<<(c))\r\n#define MASK(c) (((unsigned long)-1) / (POW(POW(c)) + 1))\r\n#define ROUND(n, c) (((n) & MASK(c)) + ((n) >> POW(c) & MASK(c)))\r\nusing namespace std;\r\nint bit_count(unsigned int n)\r\n{\r\nn = ROUND(n, 0);\r\nn = ROUND(n, 1);\r\nn = ROUND(n, 2);\r\nn = ROUND(n, 3);\r\nn = ROUND(n, 4);\r\nreturn n;\r\n}\r\nbool compare(int a,int b)\r\n{\r\n   if(bit_count(a)==bit_count(b))\r\n    return a<b;\r\n   else \r\n    return bit_count(a)<bit_count(b);\r\n}\r\nint main()\r\n{\r\n int num,size,i=0;\r\n vector<int> temp;\r\n while(1 == scanf("%d",&size))\r\n {\r\n  i = 0;\r\n  temp.clear();\r\n   while(i != size)\r\n   {\r\n  scanf("%d",&num);\r\n  temp.push_back(num);\r\n  i++;\r\n   }\r\n  sort(temp.begin(),temp.end(),compare);\r\n  for(vector<int>::iterator iter = temp.begin();\r\n      iter != temp.end();iter++)\r\n   if(iter !=temp.end()-1)\r\n   printf("%d ",*iter);\r\n   else\r\n   printf("%d",*iter);\r\n   printf("\\n");\r\n }\r\n return 0;\r\n}\r\n', '', 170, 888832, 1, 2, '2010-12-09 09:37:37', '0001-01-01 00:00:00'),
(1060, 17, 379, 7, '#include<stdio.h>\r\n#include<stdlib.h>\r\n#define MAXNODE 1405\r\n#define MAXCOST 99999\r\nint cost[MAXNODE][MAXNODE];\r\nint s[MAXNODE];\r\nint dist[MAXNODE];\r\nint node[MAXNODE];\r\nvoid dijsktra(int v0,int N);\r\nint print(int v0,int N,int a[],int p);\r\nmain()\r\n{       int i,j;\r\n        int v0;\r\n        int N ,P,C;\r\n        int A,B,long1;\r\n        int min=99999;\r\n        int ret;\r\n        int index;\r\n        int count[801]={1};\r\n        while(scanf("%d%d%d",&P,&N,&C)!=EOF)\r\n       { \r\n       \r\n         for(i=1;i<=P;i++)\r\n          {   \r\n              scanf("%d",&node[i]);\r\n              count[i]=1;\r\n              for(j=1;j<i;j++)\r\n              if(node[i]==node[j])\r\n                count[i]++;\r\n          }\r\n         \r\n         for(i=1;i<=N;i++)\r\n         {       \r\n                for(j=1;j<=N;j++)\r\n                {      \r\n                        cost[i][j]=MAXCOST;\r\n                        \r\n                        if(i==j)\r\n                        cost[i][j]=0;\r\n                }\r\n        }\r\n        for(i=1;i<=C;i++)\r\n        {  \r\n             scanf("%d%d%d",&A,&B,&long1);\r\n             cost[A][B]=long1;\r\n             cost[B][A]=long1;\r\n         }\r\n         \r\n         for(i=1;i<=P;i++)\r\n         {  \r\n            dijsktra(node[i],N);\r\n            ret=print(node[i],N,node,P);\r\n            if(min>=ret)\r\n             min = ret;\r\n            index=i;\r\n         }\r\n         for(i=1;i<=P;i++)\r\n         {   \r\n             if(count[i]>1)\r\n               min=min+cost[i][index];\r\n             else continue;\r\n         }\r\n         \r\n         printf("%d\\n",min);\r\n        }\r\n        return 0;\r\n}\r\nvoid dijsktra(int v,int N)\r\n{       int i,j;\r\n        int u,mindis;\r\n        int dis;\r\n        for(i=1;i<=N;i++)\r\n        {\r\n                dist[i]=cost[v][i];\r\n                s[i]=0;\r\n        }\r\n        s[v]=1;\r\n        for(i=1;i<=N;i++)\r\n        {       mindis=MAXCOST;\r\n                for(j=1;j<=N;j++)\r\n                {\r\n                        if(dist[j]<mindis&&s[j]==0)\r\n                        {     \r\n                                mindis=dist[j];\r\n                                u=j;\r\n                        }\r\n\r\n                }\r\n                s[u]=1;\r\n                for(j=1;j<=N;j++)\r\n                {       if(s[j]==0)\r\n                        {     \r\n                                dis=dist[u]+cost[u][j];\r\n                                dist[j]=dist[j]<dis?dist[j]:dis;\r\n                        }\r\n                }\r\n        }\r\n}\r\nint print(int v,int N,int *a,int P)\r\n{       \r\n        int i,j;\r\n        int sum;\r\n        sum=0; \r\n        for(i=1;i<=N;i++)\r\n        { \r\n          if(i!=v)\r\n        {      \r\n         for(j=1;j<=P;j++)\r\n         {\r\n           if(i==a[j]){\r\n            sum+=dist[i];}\r\n           }\r\n        }\r\n       else\r\n          continue;\r\n         }\r\n    \r\n       return sum;\r\n}\r\n', '', 0, 8183808, 4, 1, '2010-12-09 09:42:16', '0001-01-01 00:00:00'),
(1061, 21, 402, 8, '#include <iostream>\r\n\r\n#include <string>\r\n\r\n#include <stack>\r\n\r\nusing namespace std;\r\n\r\nstring Add(string Str1, string Str2)\r\n\r\n{\r\n\r\n // 操作数1\r\n\r\n stack<int>S1;\r\n\r\n // 操作数2\r\n\r\n stack<int>S2;\r\n\r\n // 结果\r\n\r\n stack<int>S3;\r\n\r\n int i, r, last = 0;\r\n\r\n for(i=0; i<Str1.size(); i++)\r\n\r\n  S1.push(Str1[i]-''0'');\r\n\r\n for(i=0; i<Str2.size(); i++)\r\n\r\n  S2.push(Str2[i]-''0'');\r\n\r\n while(!S1.empty() && !S2.empty())\r\n\r\n {\r\n\r\n  r = S1.top() + S2.top() +last;\r\n\r\n  S3.push(r%10);\r\n\r\n  last = r/10;\r\n\r\n  S1.pop();\r\n\r\n  S2.pop();\r\n\r\n }\r\n\r\n if(!S1.empty())\r\n\r\n {\r\n\r\n  while(!S1.empty())\r\n\r\n  {\r\n\r\n   r = S1.top() + last;\r\n\r\n   S3.push(r%10);\r\n\r\n   last = r/10;\r\n\r\n   S1.pop();\r\n\r\n  }\r\n\r\n }\r\n\r\n else if(!S2.empty())\r\n\r\n {\r\n\r\n  while(!S2.empty())\r\n\r\n  {\r\n\r\n   r = S2.top() + last;\r\n\r\n   S3.push(r%10);\r\n\r\n   last = r/10;\r\n\r\n   S2.pop();\r\n\r\n  }\r\n\r\n }\r\n\r\n if(last != 0)\r\n\r\n  S3.push(last);\r\n\r\n string result;\r\n\r\n while(!S3.empty())\r\n\r\n {\r\n\r\n  result += S3.top() + ''0'';\r\n\r\n  S3.pop();\r\n\r\n }\r\n\r\n return result;\r\n\r\n}\r\n\r\nstring Sub(string Str1, string Str2)\r\n\r\n{\r\n\r\n // 操作数1\r\n\r\n stack<int>S1;\r\n\r\n // 操作数2\r\n\r\n stack<int>S2;\r\n\r\n // 结果\r\n\r\n stack<int>S3;\r\n\r\n int i, r, last = 0;\r\n\r\n for(i=0; i<Str1.size(); i++)\r\n\r\n  S1.push(Str1[i]-''0'');\r\n\r\n for(i=0; i<Str2.size(); i++)\r\n\r\n  S2.push(Str2[i]-''0'');\r\n\r\n while(!S1.empty() && !S2.empty())\r\n\r\n {\r\n	 if(last){r=S1.top()-S2.top()-last+10;}\r\n	 \r\n	 else r=S1.top()-S2.top();\r\n\r\n		S3.push(r);\r\n\r\n		S1.top()<S2.top()?last=1:last=0;\r\n\r\n		S1.pop();\r\n\r\n		S2.pop();\r\n\r\n }\r\n\r\n if(!S1.empty())\r\n\r\n {\r\n\r\n  while(!S1.empty())\r\n\r\n  {\r\n\r\n   r = S1.top() - last;\r\n\r\n   S3.push(r);\r\n\r\n   last = 0;\r\n\r\n   S1.pop();\r\n\r\n  }\r\n\r\n }\r\n\r\n string result;\r\n\r\n while(!S3.empty())\r\n\r\n {\r\n	while(S3.top()==0)S3.pop();\r\n  result += S3.top() + ''0'';\r\n\r\n  S3.pop();\r\n\r\n }\r\n\r\n return result;\r\n\r\n}\r\n\r\n\r\nint main()\r\n\r\n{\r\n\r\n int i, N;\r\n\r\n cin>>N;\r\n\r\n string a, b;\r\n\r\n//const char *l="-";\r\n string answer;\r\n\r\n for(i=0; i<N; i++)\r\n\r\n {\r\n\r\n  cin>>a>>b;\r\n\r\n  cout<<"CASE "<<i+1<<":"<<endl;\r\n  cout<<a<<" + "<<b<<" = ";\r\n\r\n  if(a[0]==''-''&&b[0]==''-''){\r\n     a.erase(0,1);\r\n	 b.erase(0,1);\r\n	 answer = Add(a, b);\r\n	 answer.insert(0,"-");\r\n  }\r\n  else if(a[0]==''-''){\r\n\r\n	a.erase(0,1);\r\n\r\n	bool flag;\r\n\r\n	if(a.length()>b.length()){flag=true;}\r\n\r\n	else if(a.length()==b.length()){a[0]>b[0]?flag=true:flag=false;}\r\n\r\n	else flag=false;\r\n\r\n	answer = Sub(flag?a:b,flag?b:a);\r\n\r\n	if(flag)answer.insert(0,"-");\r\n\r\n  }\r\n\r\n  else if(b[0]==''-''){\r\n	\r\n	b.erase(0,1);	\r\n	\r\n	bool flag;\r\n\r\n	if(a.length()>b.length()){flag=true;}\r\n\r\n	else if(a.length()==b.length()){a[0]>b[0]?flag=true:flag=false;}\r\n\r\n	else flag=false;\r\n\r\n	answer = Sub(flag?a:b,flag?b:a);\r\n\r\n	if(flag)answer.insert(0,"-");\r\n  }\r\n  else 	 answer = Add(a, b);\r\n\r\n  cout<<answer<<endl<<endl;\r\n\r\n }\r\n return 0;\r\n\r\n}\r\n', '', 93, 507904, 4, 2, '2010-12-09 09:44:13', '0001-01-01 00:00:00'),
(1062, 20, 403, 8, '#include<stdio.h>\r\n#include<string.h>\r\n#define true 0x0001\r\n#define false 0x0000\r\n#define MAX 3000\r\nint a[MAX];\r\nint main()\r\n{\r\n    int n,i,j;\r\n    scanf("%d",&n);\r\n    memset(a,0,sizeof(a));\r\n    a[0]=1;\r\n    for(i=1;i<=n;i++)\r\n    {\r\n        int c=0;\r\n        for(j=0;j<MAX;j++)\r\n        {\r\n            int s=a[j]*i+c;\r\n            a[j]=s%10;\r\n            c=s/10;\r\n        }\r\n    }\r\n   bool flag=false;\r\n   for(i=MAX-1;i>=0;i--)\r\n   {\r\n       if(flag||a[i])\r\n       {\r\n           flag=true;\r\n           printf("%d",a[i]);\r\n       }\r\n   }\r\n   if(!flag)\r\n   {\r\n       printf("0");\r\n   }\r\n   printf("\\n");\r\n   return 0;\r\n}', 'Main.c: In function ''main'':\r\nMain.c:23:4: error: ''bool'' undeclared (first use in this function)\r\nMain.c:23:4: note: each undeclared identifier is reported only once for each function it appears in\r\nMain.c:23:9: error: expected '';'' before ''flag''\r\nMain.c:26:11: error: ''flag'' undeclared (first use in this function)\r\n', 0, 0, 2, 1, '2010-12-09 09:44:23', '0001-01-01 00:00:00'),
(1063, 20, 403, 8, '#include<stdio.h>\r\n#include<string.h>\r\n#define true 0x0001\r\n#define false 0x0000\r\n#define MAX 3000\r\nint a[MAX];\r\nint main()\r\n{\r\n    int n,i,j;\r\n    scanf("%d",&n);\r\n    memset(a,0,sizeof(a));\r\n    a[0]=1;\r\n    for(i=1;i<=n;i++)\r\n    {\r\n        int c=0;\r\n        for(j=0;j<MAX;j++)\r\n        {\r\n            int s=a[j]*i+c;\r\n            a[j]=s%10;\r\n            c=s/10;\r\n        }\r\n    }\r\n   bool flag=false;\r\n   for(i=MAX-1;i>=0;i--)\r\n   {\r\n       if(flag||a[i])\r\n       {\r\n           flag=true;\r\n           printf("%d",a[i]);\r\n       }\r\n   }\r\n   if(!flag)\r\n   {\r\n       printf("0");\r\n   }\r\n   printf("\\n");\r\n   return 0;\r\n}', '', 15, 266240, 4, 2, '2010-12-09 09:44:45', '0001-01-01 00:00:00'),
(1064, 23, 402, 8, '#include<stdio.h>\r\n#include<string.h>\r\nmain()\r\n{\r\n  char a[20][1000],b[20][1000],x,y;\r\n  char  d[20][2000],c[20][2000];\r\n  int n,i,j,k,l,m,tag,z,t;\r\n  scanf("%d",&n);\r\n  for(i=0;i<n;i++)\r\n     {\r\n         scanf("%s %s",a[i],b[i]);\r\n         l=strlen(a[i])-1;\r\n         m=strlen(b[i])-1;\r\n         tag=0;k=0;\r\n         while(l>=0||m>=0)\r\n            {\r\n               if(l<0) x=''0'';else x=a[i][l];\r\n               if(m<0) y=''0'';else y=b[i][m];\r\n               z=x-''0''+y-''0'';\r\n               if(tag==1)\r\n                 z+=1;\r\n               if(z>9)\r\n                 {\r\n                  tag=1;\r\n                  z=z%10;\r\n                 } \r\n                 else\r\n                   tag=0;\r\n               d[i][k++]=z+''0''; \r\n               l--;m--; \r\n            }\r\n         if(tag==1)\r\n           d[i][k]=1+''0''; \r\n           else k--;\r\n           t=k;j=0;\r\n        while(t>=0)\r\n            {\r\n              c[i][j]=d[i][t];\r\n              t--;j++; \r\n            }\r\n           \r\n     }\r\n   for(i=0;i<n;i++)\r\n      {\r\n        printf("Case %d:\\n",i+1);\r\n        printf("%s + %s = %s\\n",a[i],b[i],c[i]);\r\n        if(i<n-1)\r\n          printf("\\n"); \r\n      }    \r\n}\r\n', '', 0, 335872, 7, 2, '2010-12-09 09:48:13', '0001-01-01 00:00:00'),
(1065, 20, 403, 8, '#include<stdio.h>\r\n#include<string.h>\r\n#define true 0x0001\r\n#define false 0x0000\r\n#define MAX 3000\r\nint a[MAX];\r\nint main()\r\n{\r\n	int k;\r\n    scanf("%d",&k);\r\n    while(k--)\r\n    {\r\n		int n,i,j;\r\n		scanf("%d",&n);\r\n		memset(a,0,sizeof(a));\r\n		a[0]=1;\r\n		for(i=1;i<=n;i++)\r\n		{\r\n		    int c=0;\r\n		    for(j=0;j<MAX;j++)\r\n			{\r\n			    int s=a[j]*i+c;\r\n			    a[j]=s%10;\r\n			    c=s/10;\r\n			}\r\n		}\r\n		bool flag=false;\r\n		for(i=MAX-1;i>=0;i--)\r\n		{\r\n			if(flag||a[i])\r\n			{\r\n				flag=true;\r\n			printf("%d",a[i]);\r\n			}\r\n		}\r\n		if(!flag)\r\n		{\r\n			printf("0");\r\n		}\r\n		printf("\\n");\r\n	}\r\n	return 0;\r\n}', '', 436, 270336, 4, 2, '2010-12-09 09:48:52', '0001-01-01 00:00:00'),
(1066, 30, 402, 8, '#include <iostream>\r\n#include <vector>\r\n\r\nusing namespace std;\r\n\r\nint main(){\r\n    int n,m;\r\n    cin>>n;\r\n    getchar();\r\n    m=n;\r\n    while(m--){\r\n        char ch;\r\n        vector<int> a,b,c;\r\n        while(cin.get(ch)&&ch!='' '')\r\n            a.push_back(int(ch-48));\r\n        \r\n        while(cin.get(ch)&&ch!=''\\n'')\r\n            b.push_back(int(ch-48));\r\n        cout<<"Case "<<n-m<<":"<<endl;\r\n        for(int i=0;i!=a.size();i++)\r\n            cout<<a[i];\r\n        cout<<'' ''<<''+''<<'' '';\r\n        for(int i=0;i!=b.size();i++)\r\n            cout<<b[i];\r\n        cout<<'' ''<<''=''<<'' '';\r\n        if(a.size()<b.size())\r\n            c=a,a=b,b=c;\r\n        int i=a.size(),j=b.size();\r\n        for(;j>1;j--){\r\n            a[i-2]+=(a[i-1]+b[j-1])/10;\r\n            a[i-1]=(a[i-1]+b[j-1])%10;\r\n            i--;\r\n        }\r\n        if(i==j)\r\n            if(a[0]+b[0]>=10){\r\n                a[0]=(a[0]+b[0])%10;\r\n                a.insert(a.begin(),1,1);\r\n            }\r\n            else\r\n                a[0]=a[0]+b[0];\r\n        else{\r\n            a[i-2]+=(a[i-1]+b[j-1])/10;\r\n            a[i-1]=(a[i-1]+b[j-1])%10;\r\n            i--;\r\n        }\r\n        while(a[i-1]>=10){\r\n            if(i-2>=0){\r\n                a[i-2]+=a[i-1]/10;\r\n                a[i-1]%=10;\r\n            }\r\n            else{\r\n                a[i-1]%=10;\r\n                a.insert(a.begin(),1,1);\r\n            }\r\n        }\r\n        for(i=0;i!=a.size();i++)\r\n            cout<<a[i];\r\n        cout<<endl;\r\n        if(m>0)\r\n            cout<<endl;\r\n    }\r\n    return 0;\r\n}', 'Main.cpp: In function ''int main()'':\r\nMain.cpp:9:13: error: ''getchar'' was not declared in this scope\r\n', 0, 0, 2, 2, '2010-12-09 10:37:02', '0001-01-01 00:00:00');
INSERT INTO `tbl_submitions` (`id`, `user_id`, `problem_id`, `exercise_id`, `source`, `result`, `used_time`, `used_memory`, `status`, `compiler_id`, `created`, `modified`) VALUES
(1067, 30, 402, 8, '#include <iostream>\r\n#include <vector>\r\n\r\nusing namespace std;\r\n\r\nint main(){\r\n    int n,m;\r\n    cin>>n;\r\n    getchar();\r\n    m=n;\r\n    while(m--){\r\n        char ch;\r\n        vector<int> a,b,c;\r\n        while(cin.get(ch)&&ch!='' '')\r\n            a.push_back(int(ch-48));\r\n        \r\n        while(cin.get(ch)&&ch!=''\\n'')\r\n            b.push_back(int(ch-48));\r\n        cout<<"Case "<<n-m<<":"<<endl;\r\n        for(int i1=0;i1!=a.size();i1++)\r\n            cout<<a[i1];\r\n        cout<<'' ''<<''+''<<'' '';\r\n        for(int i2=0;i2!=b.size();i2++)\r\n            cout<<b[i2];\r\n        cout<<'' ''<<''=''<<'' '';\r\n        if(a.size()<b.size())\r\n            c=a,a=b,b=c;\r\n        int i=a.size(),j=b.size();\r\n        for(;j>1;j--){\r\n            a[i-2]+=(a[i-1]+b[j-1])/10;\r\n            a[i-1]=(a[i-1]+b[j-1])%10;\r\n            i--;\r\n        }\r\n        if(i==j)\r\n            if(a[0]+b[0]>=10){\r\n                a[0]=(a[0]+b[0])%10;\r\n                a.insert(a.begin(),1,1);\r\n            }\r\n            else\r\n                a[0]=a[0]+b[0];\r\n        else{\r\n            a[i-2]+=(a[i-1]+b[j-1])/10;\r\n            a[i-1]=(a[i-1]+b[j-1])%10;\r\n            i--;\r\n        }\r\n        while(a[i-1]>=10){\r\n            if(i-2>=0){\r\n                a[i-2]+=a[i-1]/10;\r\n                a[i-1]%=10;\r\n            }\r\n            else{\r\n                a[i-1]%=10;\r\n                a.insert(a.begin(),1,1);\r\n            }\r\n        }\r\n        for(i=0;i!=a.size();i++)\r\n            cout<<a[i];\r\n        cout<<endl;\r\n        if(m>0)\r\n            cout<<endl;\r\n    }\r\n    return 0;\r\n}', 'Main.cpp: In function ''int main()'':\r\nMain.cpp:9:13: error: ''getchar'' was not declared in this scope\r\n', 0, 0, 2, 2, '2010-12-09 10:53:56', '0001-01-01 00:00:00'),
(1068, 30, 402, 8, '#include <iostream>\r\n#include <vector>\r\n#include <ctype.h>\r\n#include <conin.h>\r\n\r\nusing namespace std;\r\n\r\nint main(){\r\n    int n,m;\r\n    cin>>n;\r\n    getchar();\r\n    m=n;\r\n    while(m--){\r\n        char ch;\r\n        vector<int> a,b,c;\r\n        while(cin.get(ch)&&ch!='' '')\r\n            a.push_back(int(ch-48));\r\n        \r\n        while(cin.get(ch)&&ch!=''\\n'')\r\n            b.push_back(int(ch-48));\r\n        cout<<"Case "<<n-m<<":"<<endl;\r\n        for(int i1=0;i1!=a.size();i1++)\r\n            cout<<a[i1];\r\n        cout<<'' ''<<''+''<<'' '';\r\n        for(int i2=0;i2!=b.size();i2++)\r\n            cout<<b[i2];\r\n        cout<<'' ''<<''=''<<'' '';\r\n        if(a.size()<b.size())\r\n            c=a,a=b,b=c;\r\n        int i=a.size(),j=b.size();\r\n        for(;j>1;j--){\r\n            a[i-2]+=(a[i-1]+b[j-1])/10;\r\n            a[i-1]=(a[i-1]+b[j-1])%10;\r\n            i--;\r\n        }\r\n        if(i==j)\r\n            if(a[0]+b[0]>=10){\r\n                a[0]=(a[0]+b[0])%10;\r\n                a.insert(a.begin(),1,1);\r\n            }\r\n            else\r\n                a[0]=a[0]+b[0];\r\n        else{\r\n            a[i-2]+=(a[i-1]+b[j-1])/10;\r\n            a[i-1]=(a[i-1]+b[j-1])%10;\r\n            i--;\r\n        }\r\n        while(a[i-1]>=10){\r\n            if(i-2>=0){\r\n                a[i-2]+=a[i-1]/10;\r\n                a[i-1]%=10;\r\n            }\r\n            else{\r\n                a[i-1]%=10;\r\n                a.insert(a.begin(),1,1);\r\n            }\r\n        }\r\n        for(i=0;i!=a.size();i++)\r\n            cout<<a[i];\r\n        cout<<endl;\r\n        if(m>0)\r\n            cout<<endl;\r\n    }\r\n    return 0;\r\n}', 'Main.cpp:4:19: fatal error: conin.h: No such file or directory\r\ncompilation terminated.\r\n', 0, 0, 2, 2, '2010-12-09 11:13:27', '0001-01-01 00:00:00'),
(1069, 30, 402, 8, '#include <iostream>\r\n#include <vector>\r\n#include <ctype.h>\r\n\r\nusing namespace std;\r\n\r\nint main(){\r\n    int n,m;\r\n    cin>>n;\r\n    getchar();\r\n    m=n;\r\n    while(m--){\r\n        char ch;\r\n        vector<int> a,b,c;\r\n        while(cin.get(ch)&&ch!='' '')\r\n            a.push_back(int(ch-48));\r\n        \r\n        while(cin.get(ch)&&ch!=''\\n'')\r\n            b.push_back(int(ch-48));\r\n        cout<<"Case "<<n-m<<":"<<endl;\r\n        for(int i1=0;i1!=a.size();i1++)\r\n            cout<<a[i1];\r\n        cout<<'' ''<<''+''<<'' '';\r\n        for(int i2=0;i2!=b.size();i2++)\r\n            cout<<b[i2];\r\n        cout<<'' ''<<''=''<<'' '';\r\n        if(a.size()<b.size())\r\n            c=a,a=b,b=c;\r\n        int i=a.size(),j=b.size();\r\n        for(;j>1;j--){\r\n            a[i-2]+=(a[i-1]+b[j-1])/10;\r\n            a[i-1]=(a[i-1]+b[j-1])%10;\r\n            i--;\r\n        }\r\n        if(i==j)\r\n            if(a[0]+b[0]>=10){\r\n                a[0]=(a[0]+b[0])%10;\r\n                a.insert(a.begin(),1,1);\r\n            }\r\n            else\r\n                a[0]=a[0]+b[0];\r\n        else{\r\n            a[i-2]+=(a[i-1]+b[j-1])/10;\r\n            a[i-1]=(a[i-1]+b[j-1])%10;\r\n            i--;\r\n        }\r\n        while(a[i-1]>=10){\r\n            if(i-2>=0){\r\n                a[i-2]+=a[i-1]/10;\r\n                a[i-1]%=10;\r\n            }\r\n            else{\r\n                a[i-1]%=10;\r\n                a.insert(a.begin(),1,1);\r\n            }\r\n        }\r\n        for(i=0;i!=a.size();i++)\r\n            cout<<a[i];\r\n        cout<<endl;\r\n        if(m>0)\r\n            cout<<endl;\r\n    }\r\n    return 0;\r\n}', 'Main.cpp: In function ''int main()'':\r\nMain.cpp:10:13: error: ''getchar'' was not declared in this scope\r\n', 0, 0, 2, 2, '2010-12-09 11:14:00', '0001-01-01 00:00:00'),
(1070, 30, 402, 8, '#include <iostream>\r\n#include <vector>\r\n#include <ctype.h>\r\n\r\nusing namespace std;\r\n\r\nint main(){\r\n    int n,m;\r\n    cin>>n;\r\n	char ch;\r\n	cin.get(ch);\r\n    m=n;\r\n    while(m--){\r\n        vector<int> a,b,c;\r\n        while(cin.get(ch)&&ch!='' '')\r\n            a.push_back(int(ch-48));\r\n        \r\n        while(cin.get(ch)&&ch!=''\\n'')\r\n            b.push_back(int(ch-48));\r\n        cout<<"Case "<<n-m<<":"<<endl;\r\n        for(int i1=0;i1!=a.size();i1++)\r\n            cout<<a[i1];\r\n        cout<<'' ''<<''+''<<'' '';\r\n        for(int i2=0;i2!=b.size();i2++)\r\n            cout<<b[i2];\r\n        cout<<'' ''<<''=''<<'' '';\r\n        if(a.size()<b.size())\r\n            c=a,a=b,b=c;\r\n        int i=a.size(),j=b.size();\r\n        for(;j>1;j--){\r\n            a[i-2]+=(a[i-1]+b[j-1])/10;\r\n            a[i-1]=(a[i-1]+b[j-1])%10;\r\n            i--;\r\n        }\r\n        if(i==j)\r\n            if(a[0]+b[0]>=10){\r\n                a[0]=(a[0]+b[0])%10;\r\n                a.insert(a.begin(),1,1);\r\n            }\r\n            else\r\n                a[0]=a[0]+b[0];\r\n        else{\r\n            a[i-2]+=(a[i-1]+b[j-1])/10;\r\n            a[i-1]=(a[i-1]+b[j-1])%10;\r\n            i--;\r\n        }\r\n        while(a[i-1]>=10){\r\n            if(i-2>=0){\r\n                a[i-2]+=a[i-1]/10;\r\n                a[i-1]%=10;\r\n            }\r\n            else{\r\n                a[i-1]%=10;\r\n                a.insert(a.begin(),1,1);\r\n            }\r\n        }\r\n        for(i=0;i!=a.size();i++)\r\n            cout<<a[i];\r\n        cout<<endl;\r\n        if(m>0)\r\n            cout<<endl;\r\n    }\r\n    return 0;\r\n}', '', 140, 368640, 7, 2, '2010-12-09 11:23:07', '0001-01-01 00:00:00'),
(1071, 17, 402, 8, '#include<stdio.h>\r\n#include<string.h>\r\n#define MAX 2001\r\nint max(int a,int b)\r\n{\r\n    return a>b?a:b;\r\n}\r\nint main()\r\n{\r\n    int i,j;\r\n    char a[MAX];\r\n    char sum[MAX];\r\n    char b[MAX];\r\n    int a_copy[MAX];\r\n    int n;\r\n    int count,len_a,len_b,length,len1,len2;\r\n    scanf("%d",&n);\r\n    for(j=1;j<=n;j++)\r\n    {\r\n           scanf("%s%s",a,b);\r\n           len_a=strlen(a);\r\n           len_b=strlen(b);\r\n           len1=len_a;\r\n           len2=len_b;\r\n           if(len_a>len_b)\r\n           {   for(i=len_a-1;i>=0;i--)\r\n                sum[i]=a[i]-''0'';\r\n               for(i=len_b-1;i>=0;i--)\r\n               {\r\n                       sum[len_a-1] += b[i]-''0'';\r\n                       len_a--;\r\n               }\r\n               for(i=len1;i>0;i--)\r\n               {\r\n                       sum[i-1] += (sum[i])/10;\r\n                       sum[i]=(sum[i])%10;\r\n               \r\n               }\r\n               printf("Case %d:\\n",j);\r\n               printf("%s+%s=",a,b);\r\n               for(i=0;i<len1;i++)\r\n                  printf("%d",sum[i]);\r\n               printf("\\n");\r\n               \r\n            }\r\n            else \r\n            {     for(i=len_b-1;i>=0;i--)\r\n                       sum[i]=b[i]-''0'';\r\n                 for(i=len_a-1;i>=0;i--)\r\n                 {\r\n                       sum[len_b-1] += a[i]-''0'';\r\n                       len_b--;\r\n                 }\r\n                 for(i=len2;i>0;i--)\r\n                 {\r\n                       sum[i-1] += (sum[i])/10;\r\n                       sum[i]=(sum[i])%10;\r\n                 }\r\n                 printf("Case %d:\\n",j);\r\n                 printf("%s+%s=",a,b);\r\n                 for(i=0;i<len2;i++)\r\n                   printf("%d",sum[i]);\r\n                   \r\n                 printf("\\n");\r\n            \r\n            }\r\n            if(j!=n)\r\n              printf("\\n");\r\n            }\r\n            return 0;\r\n     }\r\n                   \r\n                        \r\n               \r\n                \r\n', '', 31, 258048, 4, 1, '2010-12-13 10:26:20', '0001-01-01 00:00:00'),
(1072, 17, 402, 8, '#include<stdio.h>\r\n#include<string.h>\r\n#define MAX 2001\r\nint max(int a,int b)\r\n{\r\n    return a>b?a:b;\r\n}\r\nint main()\r\n{\r\n    int i,j;\r\n    char a[MAX];\r\n    char sum[MAX];\r\n    char b[MAX];\r\n    int a_copy[MAX];\r\n    int n;\r\n    int count,len_a,len_b,length,len1,len2;\r\n    scanf("%d",&n);\r\n    for(j=1;j<=n;j++)\r\n    {\r\n           scanf("%s%s",a,b);\r\n           len_a=strlen(a);\r\n           len_b=strlen(b);\r\n           len1=len_a;\r\n           len2=len_b;\r\n           if(len_a>len_b)\r\n           {   for(i=len_a-1;i>=0;i--)\r\n                sum[i]=a[i]-''0'';\r\n               for(i=len_b-1;i>=0;i--)\r\n               {\r\n                       sum[len_a-1] += b[i]-''0'';\r\n                       len_a--;\r\n               }\r\n               for(i=len1;i>0;i--)\r\n               {\r\n                       sum[i-1] += (sum[i])/10;\r\n                       sum[i]=(sum[i])%10;\r\n               \r\n               }\r\n               printf("Case %d:\\n",j);\r\n               printf("%s + %s = ",a,b);\r\n               for(i=0;i<len1;i++)\r\n                  printf("%d",sum[i]);\r\n               printf("\\n");\r\n               \r\n            }\r\n            else \r\n            {     for(i=len_b-1;i>=0;i--)\r\n                       sum[i]=b[i]-''0'';\r\n                 for(i=len_a-1;i>=0;i--)\r\n                 {\r\n                       sum[len_b-1] += a[i]-''0'';\r\n                       len_b--;\r\n                 }\r\n                 for(i=len2;i>0;i--)\r\n                 {\r\n                       sum[i-1] += (sum[i])/10;\r\n                       sum[i]=(sum[i])%10;\r\n                 }\r\n                 printf("Case %d:\\n",j);\r\n                 printf("%s + %s = ",a,b);\r\n                 for(i=0;i<len2;i++)\r\n                   printf("%d",sum[i]);\r\n                   \r\n                 printf("\\n");\r\n            \r\n            }\r\n            if(j!=n)\r\n              printf("\\n");\r\n            }\r\n         \r\n            return 0;\r\n     }\r\n                   \r\n                        \r\n               \r\n                \r\n', '', 46, 262144, 4, 1, '2010-12-13 10:30:36', '0001-01-01 00:00:00'),
(1073, 17, 402, 8, '#include<stdio.h>\r\n#include<string.h>\r\n#define MAX 2001\r\nint main()\r\n{\r\n    int i,j;\r\n    char a[MAX];\r\n    char sum[MAX];\r\n    char b[MAX];\r\n    int a_copy[MAX];\r\n    int n;\r\n    int count,len_a,len_b,length,len1,len2;\r\n    scanf("%d",&n);\r\n    for(j=1;j<=n;j++)\r\n    {\r\n           scanf("%s%s",a,b);\r\n           len_a=strlen(a);\r\n           len_b=strlen(b);\r\n           len1=len_a;\r\n           len2=len_b;\r\n           if(len_a>len_b)\r\n           {   for(i=len_a-1;i>=0;i--)\r\n                sum[i]=a[i]-''0'';\r\n               for(i=len_b-1;i>=0;i--)\r\n               {\r\n                       sum[len_a-1] += b[i]-''0'';\r\n                       len_a--;\r\n               }\r\n               for(i=len1-1;i>0;i--)\r\n               {\r\n                       sum[i-1] += (sum[i])/10;\r\n                       sum[i]=(sum[i])%10;\r\n               \r\n               }\r\n               printf("Case %d:\\n",j);\r\n               printf("%s + %s = ",a,b);\r\n               for(i=0;i<len1;i++)\r\n                  printf("%d",sum[i]);\r\n               printf("\\n");\r\n               \r\n            }\r\n            else \r\n            {     for(i=len_b-1;i>=0;i--)\r\n                       sum[i]=b[i]-''0'';\r\n                 for(i=len_a-1;i>=0;i--)\r\n                 {\r\n                       sum[len_b-1] += a[i]-''0'';\r\n                       len_b--;\r\n                 }\r\n                 for(i=len2-1;i>0;i--)\r\n                 {\r\n                       sum[i-1] += (sum[i])/10;\r\n                       sum[i]=(sum[i])%10;\r\n                 }\r\n                 printf("Case %d:\\n",j);\r\n                 printf("%s + %s = ",a,b);\r\n                 for(i=0;i<len2;i++)\r\n                   printf("%d",sum[i]);\r\n                   \r\n                 printf("\\n");\r\n            \r\n            }\r\n            if(j!=n)\r\n              printf("\\n");\r\n            }\r\n         \r\n            return 0;\r\n     }\r\n                   \r\n                        \r\n               \r\n                \r\n', '', 46, 262144, 1, 1, '2010-12-13 10:33:29', '0001-01-01 00:00:00'),
(1074, 17, 403, 8, '#include<stdio.h>\r\nint main()\r\n{ \r\n int n;\r\n int i,j,temp; \r\n int carry;\r\n int digit;\r\n  int a[100001]={0};\r\n a[0]=1;\r\n while(scanf("%d",&n)!=EOF)  \r\n { \r\n  a[1]=1;\r\n   digit=1;\r\n\r\n  for(i=2;i<=n;i++)  \r\n  { \r\n   for(carry=0,j=1;j<=digit;j++)  \r\n   { \r\n    temp=a[j]*i+carry; \r\n    a[j]=temp%10;  \r\n    carry=temp/10;  \r\n   } \r\n  \r\n   while(carry) \r\n   { \r\n    a[++digit]=carry%10; \r\n    carry=carry/10;\r\n   }   \r\n  } \r\n  for(i=digit;i>0;i--)  \r\n  { \r\n   printf("%d",a[i]); \r\n  } \r\n  printf("\\n");\r\n } \r\n return 0;  \r\n}\r\n', '', 1500, 622592, 5, 1, '2010-12-13 12:49:45', '0001-01-01 00:00:00'),
(1075, 17, 403, 8, '#include<stdio.h>\r\n#define MAX 100001\r\nint main()\r\n{\r\n    int n;\r\n    int i,j;\r\n    int a[MAX]={0};\r\n    int temp,carry,digit;\r\n    a[0]=1;\r\n    while(scanf("%d",&n)!=0)\r\n    {\r\n        a[1] = 1;\r\n        digit = 1;\r\n        for(i = 2;i<=n;i++)\r\n        {\r\n           for(carry = 0,j=1;j<=digit;j++)\r\n           {\r\n               temp = a[j]*i + carry;\r\n               a[j] = temp%10;\r\n               carry = temp/10;\r\n           }\r\n           while(carry)\r\n           {\r\n                       a[++digit]=carry%10;\r\n                       carry = carry /10;\r\n           }\r\n         }\r\n         for(i=digit;i>0;i--)\r\n           printf("%d",a[i]);\r\n         printf("\\n");\r\n        }\r\n         return 0;\r\n}\r\n               \r\n', '', 1500, 622592, 5, 1, '2010-12-13 12:51:34', '0001-01-01 00:00:00'),
(1076, 17, 403, 8, '#include<stdio.h>\r\nint main()\r\n{ \r\n int n;\r\n int i,j,temp; \r\n int carry;\r\n int digit;\r\n int a[100001]={0};\r\n a[0]=1;\r\n while(scanf("%d",&n)!=EOF)  \r\n { \r\n   a[1]=1;\r\n   digit=1;\r\n   for(i=2;i<=n;i++)  \r\n   { \r\n      for(carry=0,j=1;j<=digit;j++)  \r\n      { \r\n          temp=a[j]*i+carry; \r\n          a[j]=temp%10;  \r\n          carry=temp/10;  \r\n      } \r\n      while(carry) \r\n      { \r\n        a[++digit]=carry%10; \r\n        carry=carry/10;\r\n      }   \r\n   } \r\n   for(i=digit;i>0;i--)  \r\n   { \r\n      printf("%d",a[i]); \r\n   } \r\n   printf("\\n");\r\n } \r\n return 0;  \r\n}\r\n', '', 1500, 622592, 5, 1, '2010-12-13 12:54:53', '0001-01-01 00:00:00'),
(1077, 17, 403, 8, '#include<stdio.h>\r\nint main()\r\n{ \r\n int n;\r\n int i,j,temp; \r\n int carry;\r\n int digit;\r\n int a[100001]={0};\r\n a[0]=1;\r\n while(scanf("%d",&n)!=EOF)  \r\n { \r\n   a[1]=1;\r\n   digit=1;\r\n   for(i=2;i<=n;i++)  \r\n   { \r\n      for(carry=0,j=1;j<=digit;j++)  \r\n      { \r\n          temp=a[j]*i+carry; \r\n          a[j]=temp%100;  \r\n          carry=temp/100;  \r\n      } \r\n   \r\n      while(carry) \r\n      { \r\n        a[++digit]=carry%100; \r\n        carry=carry/100;\r\n      }   \r\n   } \r\n   printf("%d",a[digit]);\r\n   for(i=digit-1;i>0;i--)  \r\n   { \r\n      printf("%02d",a[i]); \r\n   } \r\n  printf("\\n");\r\n } \r\n return 0;  \r\n}\r\n', '', 873, 626688, 1, 1, '2010-12-13 13:38:44', '0001-01-01 00:00:00'),
(1078, 17, 379, 7, '#include<stdio.h>\r\n#include<stdlib.h>\r\n#define MAXNODE 1405\r\n#define MAXCOST 99999\r\nint cost[MAXNODE][MAXNODE];\r\nint s[MAXNODE];\r\nint dist[MAXNODE];\r\nint node[MAXNODE];\r\nvoid dijsktra(int v0,int N);\r\nint print(int v0,int N,int a[],int p);\r\nmain()\r\n{       int i,j;\r\n        int v0;\r\n        int N ,P,C;\r\n        int A,B,long1;\r\n        int min=99999;\r\n        int ret;\r\n        int index;\r\n        int count[801]={1};\r\n        while(scanf("%d%d%d",&P,&N,&C)!=EOF)\r\n       { \r\n       \r\n         for(i=1;i<=P;i++)\r\n          {   \r\n              scanf("%d",&node[i]);\r\n              count[i]=1;\r\n              for(j=1;j<i;j++)\r\n              if(node[i]==node[j])\r\n                count[i]++;\r\n          }\r\n         \r\n         for(i=1;i<=N;i++)\r\n         {       \r\n                for(j=1;j<=N;j++)\r\n                {      \r\n                        cost[i][j]=MAXCOST;\r\n                        if(i==j)\r\n                        cost[i][j]=0;\r\n                }\r\n        }\r\n        for(i=1;i<=C;i++)\r\n        {  \r\n             scanf("%d%d%d",&A,&B,&long1);\r\n             cost[A][B]=long1;\r\n             cost[B][A]=long1;\r\n         }\r\n         \r\n         for(i=1;i<=P;i++)\r\n         {  \r\n            dijsktra(node[i],N);\r\n            ret=print(node[i],N,node,P);\r\n            printf("%d\\n",ret);\r\n            if(min>=ret)\r\n             min = ret;\r\n            index=i;\r\n         }\r\n         printf("%d\\n",min);\r\n         for(i=1;i<=P;i++)\r\n         {   \r\n             if(count[i]>1){\r\n               min=min+cost[i][index]*(count[i]-1);\r\n               }\r\n             else continue;\r\n         }  \r\n         printf("%d\\n",min);\r\n        }\r\n        return 0;\r\n}\r\nvoid dijsktra(int v,int N)\r\n{       int i,j;\r\n        int u,mindis;\r\n        int dis;\r\n        for(i=1;i<=N;i++)\r\n        {\r\n                dist[i]=cost[v][i];\r\n                s[i]=0;\r\n        }\r\n        s[v]=1;\r\n        for(i=1;i<=N;i++)\r\n        {       mindis=MAXCOST;\r\n                for(j=1;j<=N;j++)\r\n                {\r\n                        if(dist[j]<mindis&&s[j]==0)\r\n                        {     \r\n                                mindis=dist[j];\r\n                                u=j;\r\n                        }\r\n\r\n                }\r\n                s[u]=1;\r\n                for(j=1;j<=N;j++)\r\n                {       if(s[j]==0)\r\n                        {     \r\n                                dis=dist[u]+cost[u][j];\r\n                                dist[j]=dist[j]<dis?dist[j]:dis;\r\n                        }\r\n                }\r\n        }\r\n}\r\n\r\nint print(int v,int N,int *a,int P)\r\n{       \r\n        int i,j;\r\n        int sum;\r\n        sum=0; \r\n        for(i=1;i<=N;i++)\r\n        { \r\n          if(i!=v)\r\n        {      \r\n         for(j=1;j<=P;j++)\r\n         {\r\n           if(i==a[j]){\r\n            sum+=dist[i];}\r\n           }\r\n        }\r\n       else\r\n          continue;\r\n         }\r\n    \r\n       return sum;\r\n}\r\n', '', 0, 8187904, 4, 1, '2010-12-13 21:07:34', '0001-01-01 00:00:00'),
(1079, 17, 379, 7, '#include<stdio.h>\r\n#include<stdlib.h>\r\n#define MAXNODE 1405\r\n#define MAXCOST 99999\r\nint cost[MAXNODE][MAXNODE];\r\nint s[MAXNODE];\r\nint dist[MAXNODE];\r\nint node[MAXNODE];\r\nvoid dijsktra(int v0,int N);\r\nint print(int v0,int N,int a[],int p);\r\nmain()\r\n{       int i,j;\r\n        int v0;\r\n        int N ,P,C;\r\n        int A,B,long1;\r\n        int min=99999;\r\n        int ret;\r\n        int index;\r\n        int count[801]={1};\r\n        while(scanf("%d%d%d",&P,&N,&C)!=EOF)\r\n       { \r\n       \r\n         for(i=1;i<=P;i++)\r\n          {   \r\n              scanf("%d",&node[i]);\r\n              count[i]=1;\r\n              for(j=1;j<i;j++)\r\n              if(node[i]==node[j])\r\n                count[i]++;\r\n          }\r\n         \r\n         for(i=1;i<=N;i++)\r\n         {       \r\n                for(j=1;j<=N;j++)\r\n                {      \r\n                        cost[i][j]=MAXCOST;\r\n                        if(i==j)\r\n                        cost[i][j]=0;\r\n                }\r\n        }\r\n        for(i=1;i<=C;i++)\r\n        {  \r\n             scanf("%d%d%d",&A,&B,&long1);\r\n             cost[A][B]=long1;\r\n             cost[B][A]=long1;\r\n         }\r\n         \r\n         for(i=1;i<=P;i++)\r\n         {  \r\n            dijsktra(node[i],N);\r\n            ret=print(node[i],N,node,P);\r\n            printf("%d\\n",ret);\r\n            if(min>=ret)\r\n             min = ret;\r\n            index=i;\r\n         }\r\n         printf("%d\\n",min);\r\n         for(i=1;i<=P;i++)\r\n         {   \r\n             if(count[i]>1){\r\n               min=min+cost[i][index]*(count[i]-1);\r\n               }\r\n             else continue;\r\n         }  \r\n         printf("%d\\n",min);\r\n        }\r\n        return 0;\r\n}\r\nvoid dijsktra(int v,int N)\r\n{       int i,j;\r\n        int u,mindis;\r\n        int dis;\r\n        for(i=1;i<=N;i++)\r\n        {\r\n                dist[i]=cost[v][i];\r\n                s[i]=0;\r\n        }\r\n        s[v]=1;\r\n        for(i=1;i<=N;i++)\r\n        {       mindis=MAXCOST;\r\n                for(j=1;j<=N;j++)\r\n                {\r\n                        if(dist[j]<mindis&&s[j]==0)\r\n                        {     \r\n                                mindis=dist[j];\r\n                                u=j;\r\n                        }\r\n\r\n                }\r\n                s[u]=1;\r\n                for(j=1;j<=N;j++)\r\n                {       if(s[j]==0)\r\n                        {     \r\n                                dis=dist[u]+cost[u][j];\r\n                                dist[j]=dist[j]<dis?dist[j]:dis;\r\n                        }\r\n                }\r\n        }\r\n}\r\n\r\nint print(int v,int N,int *a,int P)\r\n{       \r\n        int i,j;\r\n        int sum;\r\n        sum=0; \r\n        for(i=1;i<=N;i++)\r\n        { \r\n          if(i!=v)\r\n        {      \r\n         for(j=1;j<=P;j++)\r\n         {\r\n           if(i==a[j]){\r\n            sum+=dist[i];}\r\n           }\r\n        }\r\n       else\r\n          continue;\r\n         }\r\n    \r\n       return sum;\r\n}\r\n', '', 0, 8179712, 4, 1, '2010-12-13 21:56:07', '0001-01-01 00:00:00'),
(1080, 1, 404, 0, '#include "stdio.h"\r\n#include "stdlib.h"\r\n#include "string.h"\r\n\r\n#include "math.h"\r\n#include "time.h"\r\n\r\nint a[4][4],b[4][4];\r\n\r\nint main()\r\n{\r\n	int n=500;\r\n/*\r\n	if(true)\r\n	{\r\n		srand(time(NULL));\r\n		FILE * fpin=fopen("c:/ti.txt","w");\r\n		fprintf(fpin,"%d\\n",n);\r\n		for(int i=0;i<n;i++)\r\n		{\r\n			for(int k=0;k<4;k++)\r\n			{\r\n				fprintf(fpin,"%d",rand()%2011);\r\n				for(int j=1;j<4;j++)\r\n				{\r\n					fprintf(fpin," %d",rand()%2011);\r\n				}\r\n				fprintf(fpin,"\\n");\r\n			}\r\n			fprintf(fpin,"\\n");\r\n		}\r\n\r\n		fclose(fpin);\r\n	}\r\n	freopen("c:/ti.txt","r",stdin);\r\n	freopen("c:/to.txt","w",stdout);\r\n*/\r\n	int *p=a[0],*pend=p+16;\r\n	scanf("%d",&n);\r\n	while(n--)\r\n	{\r\n		for(p=a[0],pend=p+16;p!=pend;p++)\r\n		{\r\n			scanf("%d",p);\r\n		}\r\n		for(int i=0;i<2011;i++)\r\n		{\r\n			memcpy(b,a,sizeof(int)*16);\r\n			a[0][0]=(b[0][0]*b[0][0]+b[0][1]*b[1][0]+b[0][2]*b[2][0]+b[0][3]*b[3][0])%2011;\r\n			a[0][1]=(b[0][0]*b[0][1]+b[0][1]*b[1][1]+b[0][2]*b[2][1]+b[0][3]*b[3][1])%2011;\r\n			a[0][2]=(b[0][0]*b[0][2]+b[0][1]*b[1][2]+b[0][2]*b[2][2]+b[0][3]*b[3][2])%2011;\r\n			a[0][3]=(b[0][0]*b[0][3]+b[0][1]*b[1][3]+b[0][2]*b[2][3]+b[0][3]*b[3][3])%2011;\r\n\r\n			a[1][0]=(b[1][0]*b[0][0]+b[1][1]*b[1][0]+b[1][2]*b[2][0]+b[1][3]*b[3][0])%2011;\r\n			a[1][1]=(b[1][0]*b[0][1]+b[1][1]*b[1][1]+b[1][2]*b[2][1]+b[1][3]*b[3][1])%2011;\r\n			a[1][2]=(b[1][0]*b[0][2]+b[1][1]*b[1][2]+b[1][2]*b[2][2]+b[1][3]*b[3][2])%2011;\r\n			a[1][3]=(b[1][0]*b[0][3]+b[1][1]*b[1][3]+b[1][2]*b[2][3]+b[1][3]*b[3][3])%2011;\r\n\r\n			a[2][0]=(b[2][0]*b[0][0]+b[2][1]*b[1][0]+b[2][2]*b[2][0]+b[2][3]*b[3][0])%2011;\r\n			a[2][1]=(b[2][0]*b[0][1]+b[2][1]*b[1][1]+b[2][2]*b[2][1]+b[2][3]*b[3][1])%2011;\r\n			a[2][2]=(b[2][0]*b[0][2]+b[2][1]*b[1][2]+b[2][2]*b[2][2]+b[2][3]*b[3][2])%2011;\r\n			a[2][3]=(b[2][0]*b[0][3]+b[2][1]*b[1][3]+b[2][2]*b[2][3]+b[2][3]*b[3][3])%2011;\r\n\r\n			a[3][0]=(b[3][0]*b[0][0]+b[3][1]*b[1][0]+b[3][2]*b[2][0]+b[3][3]*b[3][0])%2011;\r\n			a[3][1]=(b[3][0]*b[0][1]+b[3][1]*b[1][1]+b[3][2]*b[2][1]+b[3][3]*b[3][1])%2011;\r\n			a[3][2]=(b[3][0]*b[0][2]+b[3][1]*b[1][2]+b[3][2]*b[2][2]+b[3][3]*b[3][2])%2011;\r\n			a[3][3]=(b[3][0]*b[0][3]+b[3][1]*b[1][3]+b[3][2]*b[2][3]+b[3][3]*b[3][3])%2011;\r\n		}\r\n		for(int k=0;k<4;k++)\r\n		{\r\n			printf("%d",a[k][0]);\r\n			for(int j=1;j<4;j++)\r\n			{\r\n				printf(" %d",a[k][j]);\r\n			}\r\n			printf("\\n");\r\n		}\r\n		printf("\\n");\r\n	}\r\n	\r\n\r\n	return 0;\r\n}', '', 78, 253952, 4, 2, '2010-12-23 01:00:59', '0001-01-01 00:00:00'),
(1104, 14, 402, 8, '#include<stdio.h>\r\n#include<string.h>\r\n\r\nchar num1[2005];\r\nchar num2[2005];\r\n\r\nchar tempSum[2005];\r\n\r\n\r\nint main()\r\n{\r\n	int n,i;\r\n\r\n	char *max,*min;\r\n	\r\n\r\n	int lennum1,lennum2;\r\n	scanf("%d",&n);\r\n\r\n	for(i = 0;i<n;++i)\r\n	{\r\n		int j=0,k=0,maxlen,minlen,temp,carry =0;\r\n		char total[2005]={''\\0''};\r\n		scanf("%s",num1);\r\n		scanf("%s",num2);\r\n\r\n		lennum1 = strlen(num1);\r\n		lennum2 = strlen(num2);\r\n		max = ( lennum1 >= lennum2 ) ? num1 :num2;\r\n		\r\n		strcpy(tempSum,max);\r\n		min = ( lennum1 < lennum2 ) ? num1 :num2;\r\n		maxlen = strlen(tempSum);\r\n		minlen = strlen(min);\r\n		\r\n		for(j=maxlen -1,k= minlen -1;j>= 0;--j,--k)\r\n		{\r\n			if( k< 0)\r\n				break;\r\n			temp = ( (tempSum[j] - ''0'' ) + (min[k] -''0'')  + carry) ;\r\n			if(temp>=10) \r\n				carry = 1;\r\n			else \r\n				carry =0;\r\n			tempSum[j]= temp % 10 + ''0'';\r\n			\r\n		}\r\n\r\n\r\n		if(1== carry)\r\n		{\r\n			if(j<0)\r\n				strcpy( total,strcat( strcat(total,"1"),tempSum) );\r\n			else \r\n			{\r\n				for(;j>=0;--j)\r\n				{\r\n						temp = ( (tempSum[j] - ''0'' )   + carry) ;\r\n						if(temp>=10) carry =1;\r\n						else\r\n							carry =0;\r\n\r\n						tempSum[j]= temp % 10 + ''0'';\r\n				}\r\n\r\n				if( 1== carry)\r\n					strcpy(total,strcat(strcat(total,"1"),tempSum));\r\n				else\r\n					strcpy(total,tempSum);\r\n			}\r\n\r\n		}else\r\n			strcpy( total,tempSum);\r\n\r\n		\r\n		printf("Case %d:\\n",i+1);\r\n		printf("%s + %s = %s\\n",max,min,total);\r\n		if(i!=n-1)\r\n			printf("\\n");\r\n	}\r\n	\r\n	return 0;\r\n}', '', 15, 262144, 4, 1, '2010-12-23 19:24:06', '0001-01-01 00:00:00'),
(1081, 14, 379, 7, '#include<stdio.h>\r\n#include<limits.h>\r\n\r\n#define FALSE 0\r\n#define TRUE 1\r\nint graphicWeight[801][801];\r\n\r\n\r\nint hasCow(int v,int * table,int num)\r\n{\r\n	int i=0;\r\n	for(;i<num;++i)\r\n		if(table[i] == (v+1) )\r\n			return TRUE;\r\n	return FALSE;\r\n}\r\n\r\n\r\nint shortestPath_dij( int cow[], int cowNum,int vertexNum,int sourceVertex )\r\n{\r\n	int v,i,w,min;\r\n	int shortestSum=0;\r\n	int spTable[801];\r\n\r\n    int final[801];\r\n    \r\n	for(v=0;v<vertexNum;++v)\r\n	{\r\n		final[v]=FALSE; spTable[v]= graphicWeight[ sourceVertex ][v];\r\n	}\r\n\r\n	spTable[sourceVertex]=0; final[sourceVertex]=TRUE;\r\n\r\n	  for(i=0;i<vertexNum; ++i)\r\n	  {\r\n		 min= INT_MAX;\r\n		 for(w=0;w<vertexNum;++w)\r\n			if(!final[w])\r\n			   if(spTable[w]<min) {v=w; min = spTable[w];}\r\n		 final[v] = TRUE;\r\n\r\n		 if( hasCow(v,cow,cowNum) && min < INT_MAX)\r\n			 shortestSum += min;\r\n		 for(w=0;w<vertexNum;++w)\r\n		 if( !final[w] && graphicWeight[v][w] != INT_MAX && ( min+ graphicWeight[v][w]< spTable[w]) )\r\n		 {\r\n			spTable[w]=min + graphicWeight[v][w];\r\n				\r\n		 }\r\n	  }\r\n\r\n	  return shortestSum;\r\n}\r\n\r\n\r\nint main()\r\n{\r\n	int i,j,v0,v1,weight,minSum=INT_MAX;\r\n	int cowNum,pathNum,farmNum;\r\n	int cow[501];\r\n	\r\n 	\r\n\r\n	while(scanf("%d %d %d",&cowNum,&farmNum,&pathNum) )\r\n	{\r\n\r\n		for(i = 0; i < cowNum; ++ i)   \r\n			scanf("%d",&cow[i]);  \r\n	\r\n		for(i = 0; i < farmNum; ++ i)   \r\n		{\r\n			for(j=0;j<farmNum;++j)\r\n				graphicWeight[i][j]=INT_MAX;\r\n		}\r\n\r\n		for(i = 0; i < pathNum; ++ i) \r\n		{         \r\n			scanf("%d %d %d",&v0,&v1,&weight);  \r\n			graphicWeight[v0-1][v1-1]=weight;\r\n			graphicWeight[v1-1][v0-1]=weight;\r\n		}    \r\n	\r\n		for(i = 0; i < farmNum; ++ i)   \r\n		{\r\n			int shortpath =shortestPath_dij(cow,cowNum,farmNum,i);\r\n			if( shortpath<minSum)\r\n				minSum = shortpath;\r\n\r\n		}\r\n		printf("%d\\n",minSum);\r\n	}\r\n	 \r\n	\r\n	return 0;\r\n}', '', 1000, 2830336, 5, 1, '2010-12-23 08:05:27', '0001-01-01 00:00:00'),
(1082, 14, 381, 7, '#include<stdio.h>\r\n#include<limits.h>\r\n\r\n#define FALSE 0\r\n#define TRUE 1\r\nint graphicWeight[801][801];\r\n\r\n\r\nint hasCow(int v,int * table,int num)\r\n{\r\n	int i=0;\r\n	for(;i<num;++i)\r\n		if(table[i] == (v+1) )\r\n			return TRUE;\r\n	return FALSE;\r\n}\r\n\r\n\r\nint shortestPath_dij( int cow[], int cowNum,int vertexNum,int sourceVertex )\r\n{\r\n	int v,i,w,min;\r\n	int shortestSum=0;\r\n	int spTable[801];\r\n\r\n    int final[801];\r\n    \r\n	for(v=0;v<vertexNum;++v)\r\n	{\r\n		final[v]=FALSE; spTable[v]= graphicWeight[ sourceVertex ][v];\r\n	}\r\n\r\n	spTable[sourceVertex]=0; final[sourceVertex]=TRUE;\r\n\r\n	  for(i=0;i<vertexNum; ++i)\r\n	  {\r\n		 min= INT_MAX;\r\n		 for(w=0;w<vertexNum;++w)\r\n			if(!final[w])\r\n			   if(spTable[w]<min) {v=w; min = spTable[w];}\r\n		 final[v] = TRUE;\r\n\r\n		 if( hasCow(v,cow,cowNum) && min < INT_MAX)\r\n			 shortestSum += min;\r\n		 for(w=0;w<vertexNum;++w)\r\n		 if( !final[w] && graphicWeight[v][w] != INT_MAX && ( min+ graphicWeight[v][w]< spTable[w]) )\r\n		 {\r\n			spTable[w]=min + graphicWeight[v][w];\r\n				\r\n		 }\r\n	  }\r\n\r\n	  return shortestSum;\r\n}\r\n\r\n\r\nint main()\r\n{\r\n	int i,j,v0,v1,weight,minSum=INT_MAX;\r\n	int cowNum,pathNum,farmNum;\r\n	int cow[501];\r\n	\r\n 	\r\n\r\n	while(scanf("%d %d %d",&cowNum,&farmNum,&pathNum) )\r\n	{\r\n\r\n		for(i = 0; i < cowNum; ++ i)   \r\n			scanf("%d",&cow[i]);  \r\n	\r\n		for(i = 0; i < farmNum; ++ i)   \r\n		{\r\n			for(j=0;j<farmNum;++j)\r\n				graphicWeight[i][j]=INT_MAX;\r\n		}\r\n\r\n		for(i = 0; i < pathNum; ++ i) \r\n		{         \r\n			scanf("%d %d %d",&v0,&v1,&weight);  \r\n			graphicWeight[v0-1][v1-1]=weight;\r\n			graphicWeight[v1-1][v0-1]=weight;\r\n		}    \r\n	\r\n		for(i = 0; i < farmNum; ++ i)   \r\n		{\r\n			int shortpath =shortestPath_dij(cow,cowNum,farmNum,i);\r\n			if( shortpath<minSum)\r\n				minSum = shortpath;\r\n\r\n		}\r\n		printf("%d\\n",minSum);\r\n	}\r\n	 \r\n	\r\n	return 0;\r\n}', '', 1000, 2826240, 5, 1, '2010-12-23 08:08:45', '0001-01-01 00:00:00'),
(1083, 14, 381, 7, '#include<stdio.h>\r\n#include<limits.h>\r\n\r\n#define FALSE 0\r\n#define TRUE 1\r\nint graphicWeight[801][801];\r\n\r\n\r\nint hasCow(int v,int * table,int num)\r\n{\r\n	int i=0;\r\n	for(;i<num;++i)\r\n		if(table[i] == (v+1) )\r\n			return TRUE;\r\n	return FALSE;\r\n}\r\n\r\n\r\nint shortestPath_dij( int cow[], int cowNum,int vertexNum,int sourceVertex )\r\n{\r\n	int v,i,w,min;\r\n	int shortestSum=0;\r\n	int spTable[801];\r\n\r\n    int final[801];\r\n    \r\n	for(v=0;v<vertexNum;++v)\r\n	{\r\n		final[v]=FALSE; spTable[v]= graphicWeight[ sourceVertex ][v];\r\n	}\r\n\r\n	spTable[sourceVertex]=0; final[sourceVertex]=TRUE;\r\n\r\n	  for(i=0;i<vertexNum; ++i)\r\n	  {\r\n		 min= INT_MAX;\r\n		 for(w=0;w<vertexNum;++w)\r\n			if(!final[w])\r\n			   if(spTable[w]<min) {v=w; min = spTable[w];}\r\n		 final[v] = TRUE;\r\n\r\n		 if( hasCow(v,cow,cowNum) && min < INT_MAX)\r\n			 shortestSum += min;\r\n		 for(w=0;w<vertexNum;++w)\r\n		 if( !final[w] && graphicWeight[v][w] != INT_MAX && ( min+ graphicWeight[v][w]< spTable[w]) )\r\n		 {\r\n			spTable[w]=min + graphicWeight[v][w];\r\n				\r\n		 }\r\n	  }\r\n\r\n	  return shortestSum;\r\n}\r\n\r\n\r\nint main()\r\n{\r\n	int i,j,v0,v1,weight,minSum=INT_MAX;\r\n	int cowNum,pathNum,farmNum;\r\n	int cow[501];\r\n	\r\n 	\r\n\r\n	while(scanf("%d %d %d",&cowNum,&farmNum,&pathNum)==3 )\r\n	{\r\n\r\n		for(i = 0; i < cowNum; ++ i)   \r\n			scanf("%d",&cow[i]);  \r\n	\r\n		for(i = 0; i < farmNum; ++ i)   \r\n		{\r\n			for(j=0;j<farmNum;++j)\r\n				graphicWeight[i][j]=INT_MAX;\r\n		}\r\n\r\n		for(i = 0; i < pathNum; ++ i) \r\n		{         \r\n			scanf("%d %d %d",&v0,&v1,&weight);  \r\n			graphicWeight[v0-1][v1-1]=weight;\r\n			graphicWeight[v1-1][v0-1]=weight;\r\n		}    \r\n	\r\n		for(i = 0; i < farmNum; ++ i)   \r\n		{\r\n			int shortpath =shortestPath_dij(cow,cowNum,farmNum,i);\r\n			if( shortpath<minSum)\r\n				minSum = shortpath;\r\n\r\n		}\r\n		printf("%d\\n",minSum);\r\n	}\r\n	 \r\n	\r\n	return 0;\r\n}', '', 0, 2830336, 4, 1, '2010-12-23 08:10:53', '0001-01-01 00:00:00'),
(1084, 14, 379, 7, '#include<stdio.h>\r\n#include<limits.h>\r\n\r\n#define FALSE 0\r\n#define TRUE 1\r\nint graphicWeight[801][801];\r\n\r\n\r\nint hasCow(int v,int * table,int num)\r\n{\r\n	int i=0;\r\n	for(;i<num;++i)\r\n		if(table[i] == (v+1) )\r\n			return TRUE;\r\n	return FALSE;\r\n}\r\n\r\n\r\nint shortestPath_dij( int cow[], int cowNum,int vertexNum,int sourceVertex )\r\n{\r\n	int v,i,w,min;\r\n	int shortestSum=0;\r\n	int spTable[801];\r\n\r\n    int final[801];\r\n    \r\n	for(v=0;v<vertexNum;++v)\r\n	{\r\n		final[v]=FALSE; spTable[v]= graphicWeight[ sourceVertex ][v];\r\n	}\r\n\r\n	spTable[sourceVertex]=0; final[sourceVertex]=TRUE;\r\n\r\n	  for(i=0;i<vertexNum; ++i)\r\n	  {\r\n		 min= INT_MAX;\r\n		 for(w=0;w<vertexNum;++w)\r\n			if(!final[w])\r\n			   if(spTable[w]<min) {v=w; min = spTable[w];}\r\n		 final[v] = TRUE;\r\n\r\n		 if( hasCow(v,cow,cowNum) && min < INT_MAX)\r\n			 shortestSum += min;\r\n		 for(w=0;w<vertexNum;++w)\r\n		 if( !final[w] && graphicWeight[v][w] != INT_MAX && ( min+ graphicWeight[v][w]< spTable[w]) )\r\n		 {\r\n			spTable[w]=min + graphicWeight[v][w];\r\n				\r\n		 }\r\n	  }\r\n\r\n	  return shortestSum;\r\n}\r\n\r\n\r\nint main()\r\n{\r\n	int i,j,v0,v1,weight,minSum=INT_MAX;\r\n	int cowNum,pathNum,farmNum;\r\n	int cow[501];\r\n	\r\n 	\r\n\r\n	while(scanf("%d %d %d",&cowNum,&farmNum,&pathNum)==3 )\r\n	{\r\n\r\n		for(i = 0; i < cowNum; ++ i)   \r\n			scanf("%d",&cow[i]);  \r\n	\r\n		for(i = 0; i < farmNum; ++ i)   \r\n		{\r\n			for(j=0;j<farmNum;++j)\r\n				graphicWeight[i][j]=INT_MAX;\r\n		}\r\n\r\n		for(i = 0; i < pathNum; ++ i) \r\n		{         \r\n			scanf("%d %d %d",&v0,&v1,&weight);  \r\n			graphicWeight[v0-1][v1-1]=weight;\r\n			graphicWeight[v1-1][v0-1]=weight;\r\n		}    \r\n	\r\n		for(i = 0; i < farmNum; ++ i)   \r\n		{\r\n			int shortpath =shortestPath_dij(cow,cowNum,farmNum,i);\r\n			if( shortpath<minSum)\r\n				minSum = shortpath;\r\n\r\n		}\r\n		printf("%d\\n",minSum);\r\n	}\r\n	 \r\n	\r\n	return 0;\r\n}', '', 15, 2830336, 4, 1, '2010-12-23 08:11:33', '0001-01-01 00:00:00'),
(1085, 14, 381, 7, '#include <iostream>\r\n#include <vector>\r\n\r\n#define M 100001\r\n\r\nusing namespace std;\r\n\r\nvector<int> AdjList[M];\r\nint VertexNum, ArcNum, EdgeNum;\r\nint indegree[M], step[M];\r\nint Edge[M][2];\r\n\r\nbool TopologicalSort()\r\n{\r\n	memset(step, 0, sizeof(step));\r\n    int i, vertex, front=1, rear=1, count = 0;\r\n    int queue[M];\r\n\r\n    for (i = 1; i <= VertexNum; i++)\r\n	{\r\n        if (indegree[i] == 0)\r\n            queue[rear++] = i;\r\n\r\n	}\r\n    while (front < rear )\r\n    {\r\n        vertex = queue[front++];\r\n\r\n        step[vertex] = ++count;\r\n\r\n		int temp;\r\n		for (vector<int>::size_type i= 0; i < AdjList[ vertex ].size(); i++)\r\n        {\r\n            temp = AdjList[vertex][i];\r\n            if ( --indegree[temp] == 0)\r\n                queue[rear++] = temp;\r\n        }\r\n    }\r\n\r\n	if(count<VertexNum)\r\n		return false;\r\n	else \r\n		return true;\r\n}\r\n\r\nint main()\r\n{\r\n    int i,  head, tail, temp;\r\n\r\n    while ( cin >> VertexNum >> ArcNum >> EdgeNum )\r\n    {\r\n        memset(indegree, 0, sizeof(indegree));\r\n\r\n        for (i = 0; i < ArcNum; i++)\r\n        {\r\n            cin>>head>>tail;\r\n\r\n            AdjList[head].push_back(tail);\r\n            indegree[tail]++;\r\n        }\r\n\r\n		for (i = 0; i < EdgeNum; i++)\r\n		{\r\n			cin>>Edge[i][0]>>Edge[i][1];\r\n		}\r\n	            \r\n\r\n        \r\n        if( TopologicalSort() )\r\n		{\r\n			for (i = 0; i < EdgeNum; i++)\r\n			{\r\n				     \r\n				if (step[ Edge[i][0] ] > step[ Edge[i][1] ] )\r\n				{\r\n					temp = Edge[i][0];\r\n					Edge[i][0] = Edge[i][1];\r\n					Edge[i][1] = temp;\r\n				}\r\n				cout<< Edge[i][0]<<'' ''<<Edge[i][1]<<endl;\r\n				\r\n			}\r\n		}\r\n		else\r\n		{\r\n			printf("-1\\n");\r\n		}\r\n\r\n	}\r\n}\r\n \r\n\r\n', 'Main.cpp: In function ''bool TopologicalSort()'':\r\nMain.cpp:15:30: error: ''memset'' was not declared in this scope\r\nMain.cpp: In function ''int main()'':\r\nMain.cpp:52:45: error: ''memset'' was not declared in this scope\r\nMain.cpp:86:17: error: ''printf'' was not declared in this scope\r\n', 0, 0, 2, 2, '2010-12-23 08:12:39', '0001-01-01 00:00:00'),
(1086, 14, 381, 7, '#include <iostream>\r\n#include <vector>\r\n#include <memory.h>\r\n\r\n#define M 100001\r\n\r\nusing namespace std;\r\n\r\nvector<int> AdjList[M];\r\nint VertexNum, ArcNum, EdgeNum;\r\nint indegree[M], step[M];\r\nint Edge[M][2];\r\n\r\nbool TopologicalSort()\r\n{\r\n	memset(step, 0, sizeof(step));\r\n    int i, vertex, front=1, rear=1, count = 0;\r\n    int queue[M];\r\n\r\n    for (i = 1; i <= VertexNum; i++)\r\n	{\r\n        if (indegree[i] == 0)\r\n            queue[rear++] = i;\r\n\r\n	}\r\n    while (front < rear )\r\n    {\r\n        vertex = queue[front++];\r\n\r\n        step[vertex] = ++count;\r\n\r\n		int temp;\r\n		for (vector<int>::size_type i= 0; i < AdjList[ vertex ].size(); i++)\r\n        {\r\n            temp = AdjList[vertex][i];\r\n            if ( --indegree[temp] == 0)\r\n                queue[rear++] = temp;\r\n        }\r\n    }\r\n\r\n	if(count<VertexNum)\r\n		return false;\r\n	else \r\n		return true;\r\n}\r\n\r\nint main()\r\n{\r\n    int i,  head, tail, temp;\r\n\r\n    while ( cin >> VertexNum >> ArcNum >> EdgeNum )\r\n    {\r\n        memset(indegree, 0, sizeof(indegree));\r\n\r\n        for (i = 0; i < ArcNum; i++)\r\n        {\r\n            cin>>head>>tail;\r\n\r\n            AdjList[head].push_back(tail);\r\n            indegree[tail]++;\r\n        }\r\n\r\n		for (i = 0; i < EdgeNum; i++)\r\n		{\r\n			cin>>Edge[i][0]>>Edge[i][1];\r\n		}\r\n	            \r\n\r\n        \r\n        if( TopologicalSort() )\r\n		{\r\n			for (i = 0; i < EdgeNum; i++)\r\n			{\r\n				     \r\n				if (step[ Edge[i][0] ] > step[ Edge[i][1] ] )\r\n				{\r\n					temp = Edge[i][0];\r\n					Edge[i][0] = Edge[i][1];\r\n					Edge[i][1] = temp;\r\n				}\r\n				cout<< Edge[i][0]<<'' ''<<Edge[i][1]<<endl;\r\n				\r\n			}\r\n		}\r\n		else\r\n		{\r\n			cout<<("-1\\n");\r\n		}\r\n\r\n	}\r\n}\r\n \r\n\r\n', 'Main.c:1:20: fatal error: iostream: No such file or directory\r\ncompilation terminated.\r\n', 0, 0, 2, 1, '2010-12-23 08:15:30', '0001-01-01 00:00:00'),
(1087, 14, 381, 7, '#include <iostream.h>\r\n#include <vector>\r\n#include <memory.h>\r\n\r\n#define M 100001\r\n\r\nusing namespace std;\r\n\r\nvector<int> AdjList[M];\r\nint VertexNum, ArcNum, EdgeNum;\r\nint indegree[M], step[M];\r\nint Edge[M][2];\r\n\r\nbool TopologicalSort()\r\n{\r\n	memset(step, 0, sizeof(step));\r\n    int i, vertex, front=1, rear=1, count = 0;\r\n    int queue[M];\r\n\r\n    for (i = 1; i <= VertexNum; i++)\r\n	{\r\n        if (indegree[i] == 0)\r\n            queue[rear++] = i;\r\n\r\n	}\r\n    while (front < rear )\r\n    {\r\n        vertex = queue[front++];\r\n\r\n        step[vertex] = ++count;\r\n\r\n		int temp;\r\n		for (vector<int>::size_type i= 0; i < AdjList[ vertex ].size(); i++)\r\n        {\r\n            temp = AdjList[vertex][i];\r\n            if ( --indegree[temp] == 0)\r\n                queue[rear++] = temp;\r\n        }\r\n    }\r\n\r\n	if(count<VertexNum)\r\n		return false;\r\n	else \r\n		return true;\r\n}\r\n\r\nint main()\r\n{\r\n    int i,  head, tail, temp;\r\n\r\n    while ( cin >> VertexNum >> ArcNum >> EdgeNum )\r\n    {\r\n        memset(indegree, 0, sizeof(indegree));\r\n\r\n        for (i = 0; i < ArcNum; i++)\r\n        {\r\n            cin>>head>>tail;\r\n\r\n            AdjList[head].push_back(tail);\r\n            indegree[tail]++;\r\n        }\r\n\r\n		for (i = 0; i < EdgeNum; i++)\r\n		{\r\n			cin>>Edge[i][0]>>Edge[i][1];\r\n		}\r\n	            \r\n\r\n        \r\n        if( TopologicalSort() )\r\n		{\r\n			for (i = 0; i < EdgeNum; i++)\r\n			{\r\n				     \r\n				if (step[ Edge[i][0] ] > step[ Edge[i][1] ] )\r\n				{\r\n					temp = Edge[i][0];\r\n					Edge[i][0] = Edge[i][1];\r\n					Edge[i][1] = temp;\r\n				}\r\n				cout<< Edge[i][0]<<'' ''<<Edge[i][1]<<endl;\r\n				\r\n			}\r\n		}\r\n		else\r\n		{\r\n			cout<<("-1\\n");\r\n		}\r\n\r\n	}\r\n}\r\n \r\n\r\n', 'Main.c:1:22: fatal error: iostream.h: No such file or directory\r\ncompilation terminated.\r\n', 0, 0, 2, 1, '2010-12-23 08:16:02', '0001-01-01 00:00:00'),
(1088, 14, 381, 7, '#include <iostream>\r\n#include <vector>\r\n#include <memory.h>\r\n\r\n\r\n#define M 100001\r\n\r\nusing namespace std;\r\n\r\nvector<int> AdjList[M];\r\nint VertexNum, ArcNum, EdgeNum;\r\nint indegree[M], step[M];\r\nint Edge[M][2];\r\n\r\nbool TopologicalSort()\r\n{\r\n	memset(step, 0, sizeof(step));\r\n    int i, vertex, front=1, rear=1, count = 0;\r\n    int queue[M];\r\n\r\n    for (i = 1; i <= VertexNum; i++)\r\n	{\r\n        if (indegree[i] == 0)\r\n            queue[rear++] = i;\r\n\r\n	}\r\n    while (front < rear )\r\n    {\r\n        vertex = queue[front++];\r\n\r\n        step[vertex] = ++count;\r\n\r\n		int temp;\r\n		for (vector<int>::size_type i= 0; i < AdjList[ vertex ].size(); i++)\r\n        {\r\n            temp = AdjList[vertex][i];\r\n            if ( --indegree[temp] == 0)\r\n                queue[rear++] = temp;\r\n        }\r\n    }\r\n\r\n	if(count<VertexNum)\r\n		return false;\r\n	else \r\n		return true;\r\n}\r\n\r\nint main()\r\n{\r\n    int i,  head, tail, temp;\r\n\r\n    while ( cin >> VertexNum >> ArcNum >> EdgeNum )\r\n    {\r\n        memset(indegree, 0, sizeof(indegree));\r\n\r\n        for (i = 0; i < ArcNum; i++)\r\n        {\r\n            cin>>head>>tail;\r\n\r\n            AdjList[head].push_back(tail);\r\n            indegree[tail]++;\r\n        }\r\n\r\n		for (i = 0; i < EdgeNum; i++)\r\n		{\r\n			cin>>Edge[i][0]>>Edge[i][1];\r\n		}\r\n	            \r\n\r\n        \r\n        if( TopologicalSort() )\r\n		{\r\n			for (i = 0; i < EdgeNum; i++)\r\n			{\r\n				     \r\n				if (step[ Edge[i][0] ] > step[ Edge[i][1] ] )\r\n				{\r\n					temp = Edge[i][0];\r\n					Edge[i][0] = Edge[i][1];\r\n					Edge[i][1] = temp;\r\n				}\r\n				cout<< Edge[i][0]<<'' ''<<Edge[i][1]<<endl;\r\n				\r\n			}\r\n		}\r\n		else\r\n		{\r\n			cout<<("-1\\n");\r\n		}\r\n\r\n	}\r\n}\r\n \r\n\r\n', '', 0, 3538944, 4, 2, '2010-12-23 08:17:54', '0001-01-01 00:00:00'),
(1089, 11, 402, 8, '// test8.cpp : Defines the entry point for the console application.\r\n#include<iostream>       \r\n#include<string>       \r\nusing namespace std;       \r\nint r[10000000];        \r\nint main()       \r\n{       \r\n    string a,b;       \r\n    int carry=0,lena,lenb,i=0,j=0,t;       \r\n    cin>>a>>b;       \r\n    lena=a.length();       \r\n    lenb=b.length();       \r\n    while(1)       \r\n    {       \r\n        t=a[--lena]+b[--lenb]+carry-96;       \r\n        if(lena==-1||lenb==-1)       \r\n            break;       \r\n        if(t>=10)       \r\n            carry=1;       \r\n        else      \r\n            carry=0;       \r\n        r[j]=t%10;         \r\n        ++j;       \r\n               \r\n    }         \r\n    if(lena==-1&&lenb!=-1)       \r\n    {       \r\n        for(i=lenb;i>=0;--i)       \r\n        {       \r\n            t=b[i]+carry-48;       \r\n            if(t>=10)       \r\n                carry=1;       \r\n            else      \r\n                carry=0;       \r\n            r[j]=t%10;       \r\n            ++j;       \r\n        }//for       \r\n    }//if       \r\n    else if(lena!=-1&&lenb==-1)       \r\n    {       \r\n        for(i=lena;i>=0;--i)       \r\n        {       \r\n            t=a[i]+carry-48;       \r\n            if(t>=10)       \r\n                carry=1;       \r\n            else      \r\n                carry=0;       \r\n            r[j]=t%10;       \r\n            ++j;       \r\n        }//for       \r\n    }//else if      \r\n    if(carry!=0)    \r\n        cout<<carry;    \r\n    for(i=j-1;i>=0;--i)       \r\n        cout<<r[i];       \r\n        cout<<endl;       \r\n    return 0;       \r\n}  \r\n', '', 0, 33554432, 6, 2, '2010-12-23 08:37:48', '0001-01-01 00:00:00'),
(1090, 11, 402, 8, '#include<iostream>       \r\n#include<string>       \r\nusing namespace std;       \r\nint r[100000];        \r\nint main()       \r\n{       \r\n    string a,b;       \r\n    int carry=0,lena,lenb,i=0,j=0,t;       \r\n    cin>>a>>b;       \r\n    lena=a.length();       \r\n    lenb=b.length();       \r\n    while(1)       \r\n    {       \r\n        t=a[--lena]+b[--lenb]+carry-96;       \r\n        if(lena==-1||lenb==-1)       \r\n            break;       \r\n        if(t>=10)       \r\n            carry=1;       \r\n        else      \r\n            carry=0;       \r\n        r[j]=t%10;         \r\n        ++j;       \r\n               \r\n    }         \r\n    if(lena==-1&&lenb!=-1)       \r\n    {       \r\n        for(i=lenb;i>=0;--i)       \r\n        {       \r\n            t=b[i]+carry-48;       \r\n            if(t>=10)       \r\n                carry=1;       \r\n            else      \r\n                carry=0;       \r\n            r[j]=t%10;       \r\n            ++j;       \r\n        }//for       \r\n    }//if       \r\n    else if(lena!=-1&&lenb==-1)       \r\n    {       \r\n        for(i=lena;i>=0;--i)       \r\n        {       \r\n            t=a[i]+carry-48;       \r\n            if(t>=10)       \r\n                carry=1;       \r\n            else      \r\n                carry=0;       \r\n            r[j]=t%10;       \r\n            ++j;       \r\n        }//for       \r\n    }//else if      \r\n    if(carry!=0)    \r\n        cout<<carry;    \r\n    for(i=j-1;i>=0;--i)       \r\n        cout<<r[i];       \r\n        cout<<endl;       \r\n    return 0;       \r\n}  \r\n', 'Main.c:1:26: fatal error: iostream: No such file or directory\r\ncompilation terminated.\r\n', 0, 0, 2, 1, '2010-12-23 08:44:24', '0001-01-01 00:00:00'),
(1091, 11, 402, 8, '#include<iostream>       \r\n#include<string>       \r\nusing namespace std;       \r\nint r[100000];        \r\nint main()       \r\n{       \r\n    string a,b;       \r\n    int carry=0,lena,lenb,i=0,j=0,t;       \r\n    cin>>a>>b;       \r\n    lena=a.length();       \r\n    lenb=b.length();       \r\n    while(1)       \r\n    {       \r\n        t=a[--lena]+b[--lenb]+carry-96;       \r\n        if(lena==-1||lenb==-1)       \r\n            break;       \r\n        if(t>=10)       \r\n            carry=1;       \r\n        else      \r\n            carry=0;       \r\n        r[j]=t%10;         \r\n        ++j;       \r\n               \r\n    }         \r\n    if(lena==-1&&lenb!=-1)       \r\n    {       \r\n        for(i=lenb;i>=0;--i)       \r\n        {       \r\n            t=b[i]+carry-48;       \r\n            if(t>=10)       \r\n                carry=1;       \r\n            else      \r\n                carry=0;       \r\n            r[j]=t%10;       \r\n            ++j;       \r\n        }//for       \r\n    }//if       \r\n    else if(lena!=-1&&lenb==-1)       \r\n    {       \r\n        for(i=lena;i>=0;--i)       \r\n        {       \r\n            t=a[i]+carry-48;       \r\n            if(t>=10)       \r\n                carry=1;       \r\n            else      \r\n                carry=0;       \r\n            r[j]=t%10;       \r\n            ++j;       \r\n        }//for       \r\n    }//else if      \r\n    if(carry!=0)    \r\n        cout<<carry;    \r\n    for(i=j-1;i>=0;--i)       \r\n        cout<<r[i];       \r\n        cout<<endl;       \r\n    return 0;       \r\n}  \r\n', '', 0, 770048, 4, 2, '2010-12-23 08:51:20', '0001-01-01 00:00:00');
INSERT INTO `tbl_submitions` (`id`, `user_id`, `problem_id`, `exercise_id`, `source`, `result`, `used_time`, `used_memory`, `status`, `compiler_id`, `created`, `modified`) VALUES
(1092, 11, 402, 8, '#include<iostream>       \r\n#include<string>       \r\nusing namespace std;       \r\nint r[10000000];        \r\nint main()       \r\n{       \r\n    string a,b;       \r\n    int carry=0,lena,lenb,i=0,j=0,t;       \r\n    cin>>a>>b;       \r\n    lena=a.length();       \r\n    lenb=b.length();       \r\n    while(1)       \r\n    {       \r\n        t=a[--lena]+b[--lenb]+carry-96;       \r\n        if(lena==-1||lenb==-1)       \r\n            break;       \r\n        if(t>=10)       \r\n            carry=1;       \r\n        else      \r\n            carry=0;       \r\n        r[j]=t%10;         \r\n        ++j;       \r\n               \r\n    }         \r\n    if(lena==-1&&lenb!=-1)       \r\n    {       \r\n        for(i=lenb;i>=0;--i)       \r\n        {       \r\n            t=b[i]+carry-48;       \r\n            if(t>=10)       \r\n                carry=1;       \r\n            else      \r\n                carry=0;       \r\n            r[j]=t%10;       \r\n            ++j;       \r\n        }//for       \r\n    }//if       \r\n    else if(lena!=-1&&lenb==-1)       \r\n    {       \r\n        for(i=lena;i>=0;--i)       \r\n        {       \r\n            t=a[i]+carry-48;       \r\n            if(t>=10)       \r\n                carry=1;       \r\n            else      \r\n                carry=0;       \r\n            r[j]=t%10;       \r\n            ++j;       \r\n        }//for       \r\n    }//else if      \r\n    if(carry!=0)    \r\n        cout<<carry;    \r\n    for(i=j-1;i>=0;--i)       \r\n        cout<<r[i];       \r\n        cout<<endl;       \r\n    return 0;       \r\n}  \r\n', '', 0, 33554432, 6, 2, '2010-12-23 08:56:41', '0001-01-01 00:00:00'),
(1093, 11, 402, 8, '#include<iostream>       \r\n#include<string>       \r\nusing namespace std;       \r\nint r[10000000];        \r\nint main()       \r\n{       \r\n    string a,b;       \r\n    int carry=0,lena,lenb,i=0,j=0,t;       \r\n    cin>>a>>b;       \r\n    lena=a.length();       \r\n    lenb=b.length();       \r\n    while(1)       \r\n    {       \r\n        t=a[--lena]+b[--lenb]+carry-96;       \r\n        if(lena==-1||lenb==-1)       \r\n            break;       \r\n        if(t>=10)       \r\n            carry=1;       \r\n        else      \r\n            carry=0;       \r\n        r[j]=t%10;         \r\n        ++j;       \r\n               \r\n    }         \r\n    if(lena==-1&&lenb!=-1)       \r\n    {       \r\n        for(i=lenb;i>=0;--i)       \r\n        {       \r\n            t=b[i]+carry-48;       \r\n            if(t>=10)       \r\n                carry=1;       \r\n            else      \r\n                carry=0;       \r\n            r[j]=t%10;       \r\n            ++j;       \r\n        }//for       \r\n    }//if       \r\n    else if(lena!=-1&&lenb==-1)       \r\n    {       \r\n        for(i=lena;i>=0;--i)       \r\n        {       \r\n            t=a[i]+carry-48;       \r\n            if(t>=10)       \r\n                carry=1;       \r\n            else      \r\n                carry=0;       \r\n            r[j]=t%10;       \r\n            ++j;       \r\n        }//for       \r\n    }//else if      \r\n    if(carry!=0)    \r\n        cout<<carry;    \r\n    for(i=j-1;i>=0;--i)       \r\n        cout<<r[i];       \r\n        cout<<endl;       \r\n    return 0;       \r\n}  \r\n', '', 0, 0, 2, 3, '2010-12-23 08:58:27', '0001-01-01 00:00:00'),
(1094, 23, 335, 2, '#include<iostream>\r\n#include<bitset>\r\n\r\nusing namespace std;\r\nint main(){\r\n	int i,j;\r\n	cin>>i>>j;\r\n	i=i^j;\r\n	j=0;\r\n	while(i){\r\n		i&=(i-1);\r\n		++j;\r\n	}\r\n	cout<<j<<endl;\r\n	system("pause");\r\n}', 'Main.cpp: In function ''int main()'':\r\nMain.cpp:15:16: error: ''system'' was not declared in this scope\r\n', 0, 0, 2, 2, '2010-12-23 08:59:33', '0001-01-01 00:00:00'),
(1095, 11, 402, 8, '#include<iostream>       \r\n#include<string>       \r\nusing namespace std;       \r\nint r[2000];        \r\nint main()       \r\n{       \r\n    string a,b;       \r\n    int carry=0,lena,lenb,i=0,j=0,t;       \r\n    cin>>a>>b;       \r\n    lena=a.length();       \r\n    lenb=b.length();       \r\n    while(1)       \r\n    {       \r\n        t=a[--lena]+b[--lenb]+carry-96;       \r\n        if(lena==-1||lenb==-1)       \r\n            break;       \r\n        if(t>=10)       \r\n            carry=1;       \r\n        else      \r\n            carry=0;       \r\n        r[j]=t%10;         \r\n        ++j;       \r\n               \r\n    }         \r\n    if(lena==-1&&lenb!=-1)       \r\n    {       \r\n        for(i=lenb;i>=0;--i)       \r\n        {       \r\n            t=b[i]+carry-48;       \r\n            if(t>=10)       \r\n                carry=1;       \r\n            else      \r\n                carry=0;       \r\n            r[j]=t%10;       \r\n            ++j;       \r\n        }//for       \r\n    }//if       \r\n    else if(lena!=-1&&lenb==-1)       \r\n    {       \r\n        for(i=lena;i>=0;--i)       \r\n        {       \r\n            t=a[i]+carry-48;       \r\n            if(t>=10)       \r\n                carry=1;       \r\n            else      \r\n                carry=0;       \r\n            r[j]=t%10;       \r\n            ++j;       \r\n        }//for       \r\n    }//else if      \r\n    if(carry!=0)    \r\n        cout<<carry;    \r\n    for(i=j-1;i>=0;--i)       \r\n        cout<<r[i];       \r\n        cout<<endl;       \r\n    return 0;       \r\n}  \r\n', '', 0, 372736, 4, 2, '2010-12-23 09:01:45', '0001-01-01 00:00:00'),
(1096, 16, 374, 5, '#include<stdio.h>\r\nint main(){\r\n int n;\r\n scanf("%d",&n);\r\n int out[1000][3];\r\n for(int i=0;i!=n;++i){\r\n  int count,sum1,sum2,bg,end;\r\n  scanf("%d",&count);\r\n  int num[20000]; \r\n  for(int m=0;m!=count;++m)\r\n   scanf("%d",&num[m]); \r\n  sum1=sum2=num[0];\r\n  bg=1; end=1;\r\n  for(int a=1;a!=count;++a){   \r\n   if(sum2>0){\r\n	   sum2+=num[a];\r\n	   if(sum2<num[a])\r\n		   bg=a+1; \r\n	   else if(sum2>=sum1){\r\n		   sum1=sum2;\r\n		   end=a+1;\r\n	   }  \r\n   }\r\n   else {	   \r\n	   if(num[a]>=0){\r\n		   sum2=num[a];\r\n		   bg =a+1;\r\n		   if(sum2>=sum1){\r\n			   sum1=sum2;\r\n			   end=a+1;\r\n		   } \r\n	   }\r\n   }\r\n  }\r\n  out[i][0]=sum1;\r\n  out[i][1]=bg;  out[i][2]=end;\r\n }\r\n for(int ou=0;ou!=n;++ou)\r\n  printf("Case %d:\\n%d  %d  %d\\n\\n",ou+1,out[ou][0],out[ou][1],out[ou][2]);\r\n return 0;\r\n}\r\n \r\n', '', 15, 311296, 4, 2, '2010-12-23 09:12:36', '0001-01-01 00:00:00'),
(1097, 23, 335, 2, '#include<stdio.h>\r\n#include<bitset>\r\nint num[50];\r\nint main(){\r\n	int i,j,k=0;\r\n\r\n	while(scanf("%d %d",&i,&j)!=EOF){\r\n		i=i^j; \r\n		while(i){\r\n			i&=(i-1);\r\n			++num[k];\r\n		}\r\n		++k;\r\n	}\r\n	i=0;\r\n	while(i<k){\r\n		printf("%d \\n",num[i]);\r\n		++i;\r\n	}\r\n    \r\n	return 0;\r\n}', '', 0, 262144, 3, 2, '2010-12-23 09:16:55', '0001-01-01 00:00:00'),
(1098, 16, 374, 5, '#include<stdio.h>\r\nint main(){\r\n int n;\r\n scanf("%d",&n);\r\n int out[1000][3];\r\n for(int i=0;i!=n;++i){\r\n  int count,sum1,sum2,bg,end;\r\n  scanf("%d",&count);\r\n  int num[20000]; \r\n  for(int m=0;m!=count;++m)\r\n   scanf("%d",&num[m]); \r\n  sum1=sum2=num[0];\r\n  bg=1; end=1;\r\n  for(int a=1;a!=count;++a){   \r\n   if(sum2>=0){\r\n	   sum2+=num[a];\r\n	   if(sum2<num[a])\r\n		   bg=a+1; \r\n	   else if(sum2>=sum1){\r\n		   sum1=sum2;\r\n		   end=a+1;\r\n	   }  \r\n   }\r\n   else {	   \r\n	   if(num[a]>=0){\r\n		   sum2=num[a];\r\n		   bg =a+1;\r\n		   if(sum2>=sum1){\r\n			   sum1=sum2;\r\n			   end=a+1;\r\n		   } \r\n	   }\r\n   }\r\n  }\r\n  out[i][0]=sum1;\r\n  out[i][1]=bg;  out[i][2]=end;\r\n }\r\n for(int ou=0;ou!=n;++ou)\r\n  printf("Case %d:\\n%d  %d  %d\\n\\n",ou+1,out[ou][0],out[ou][1],out[ou][2]);\r\n return 0;\r\n}\r\n \r\n', '', 15, 315392, 4, 2, '2010-12-23 09:18:43', '0001-01-01 00:00:00'),
(1099, 23, 335, 2, '#include<stdio.h>\r\n#include<bitset>\r\nint num[50];\r\nint main(){\r\n	int i,j,k=0;\r\n\r\n	while(scanf("%d %d",&i,&j)!=EOF){\r\n		i=i^j; \r\n		while(i){\r\n			i&=(i-1);\r\n			++num[k];\r\n		}\r\n		++k;\r\n	}\r\n	i=0;\r\n	while(i<k){\r\n		printf("%d\\n",num[i]);\r\n		++i;\r\n	}\r\n    \r\n	return 0;\r\n}', '', 0, 262144, 7, 2, '2010-12-23 09:19:29', '0001-01-01 00:00:00'),
(1100, 23, 335, 2, '#include<stdio.h>\r\n#include<bitset>\r\nint num[1000];\r\nint main(){\r\n	int i,j,k=0;\r\n\r\n	while(scanf("%d %d",&i,&j)!=EOF){\r\n		i=i^j; \r\n		while(i){\r\n			i&=(i-1);\r\n			++num[k];\r\n		}\r\n		++k;\r\n	}\r\n	i=0;\r\n	while(i<k){\r\n		printf("%d\\n",num[i]);\r\n		++i;\r\n	}\r\n    \r\n	return 0;\r\n}', '', 0, 266240, 7, 2, '2010-12-23 09:21:21', '0001-01-01 00:00:00'),
(1101, 16, 374, 5, '#include<stdio.h>\r\nint main(){\r\n int n;\r\n scanf("%d",&n);\r\n int out[1000][3];\r\n for(int i=0;i!=n;++i){\r\n  int count,sum1,sum2,bg,end;\r\n  scanf("%d",&count);\r\n  int num[20001]; \r\n  for(int m=0;m!=count;++m)\r\n   scanf("%d",&num[m]); \r\n  sum1=sum2=num[0];\r\n  bg=1; end=1;\r\n  for(int a=1;a!=count;++a){   \r\n   if(sum2>=0){\r\n	   sum2+=num[a];\r\n	   if(sum2<num[a])\r\n		   bg=a+1; \r\n	   else if(sum2>=sum1){\r\n		   sum1=sum2;\r\n		   end=a+1;\r\n	   }  \r\n   }\r\n   else {	   \r\n	   if(num[a]>=0){\r\n		   sum2=num[a];\r\n		   bg =a+1;\r\n		   if(sum2>=sum1){\r\n			   sum1=sum2;\r\n			   end=a+1;\r\n		   } \r\n	   }\r\n   }\r\n  }\r\n  out[i][0]=sum1;\r\n  out[i][1]=bg;  out[i][2]=end;\r\n }\r\n for(int ou=0;ou!=n-1;++ou)\r\n  printf("Case %d:\\n%d  %d  %d\\n\\n",ou+1,out[ou][0],out[ou][1],out[ou][2]);\r\n printf("Case %d:\\n%d  %d  %d\\n",ou+1,out[n-1][0],out[n-1][1],out[n-1][2]);\r\n return 0;\r\n}\r\n \r\n', 'Main.cpp: In function ''int main()'':\r\nMain.cpp:40:34: error: name lookup of ''ou'' changed for ISO ''for'' scoping\r\nMain.cpp:40:34: note: (if you use ''-fpermissive'' G++ will accept your code)\r\n', 0, 0, 2, 2, '2010-12-23 09:32:03', '0001-01-01 00:00:00'),
(1102, 16, 374, 5, '#include<stdio.h>\r\nint main(){\r\n int n;\r\n scanf("%d",&n);\r\n //int out[1000][3];\r\n for(int i=0;i!=n;++i){\r\n  int count,sum1,sum2,bg,end;\r\n  scanf("%d",&count);\r\n  int num[20001]; \r\n  for(int m=0;m!=count;++m)\r\n   scanf("%d",&num[m]); \r\n  sum1=sum2=num[0];\r\n  bg=1; end=1;\r\n  for(int a=1;a!=count;++a){   \r\n   if(sum2>=0){\r\n	   sum2+=num[a];\r\n	   if(sum2<num[a])\r\n		   bg=a+1; \r\n	   else if(sum2>=sum1){\r\n		   sum1=sum2;\r\n		   end=a+1;\r\n	   }  \r\n   }\r\n   else {	   \r\n	   if(num[a]>=0){\r\n		   sum2=num[a];\r\n		   bg =a+1;\r\n		   if(sum2>=sum1){\r\n			   sum1=sum2;\r\n			   end=a+1;\r\n		   } \r\n	   }\r\n   }\r\n  }\r\n  printf("Case %d:\\n%d  %d  %d\\n\\n",i+1,sum1,bg,end);\r\n // out[i][0]=sum1;\r\n  //out[i][1]=bg;  out[i][2]=end;\r\n }\r\n/* for(int ou=0;ou!=n-1;++ou)\r\n  printf("Case %d:\\n%d  %d  %d\\n\\n",ou+1,out[ou][0],out[ou][1],out[ou][2]);\r\n printf("Case %d:\\n%d  %d  %d\\n",ou+1,out[n-1][0],out[n-1][1],out[n-1][2]);\r\n */return 0;\r\n}\r\n \r\n', '', 15, 299008, 4, 2, '2010-12-23 09:38:44', '0001-01-01 00:00:00'),
(1103, 16, 374, 5, '#include<stdio.h>\r\nint main(){\r\n int n;\r\n scanf("%d",&n);\r\n //int out[1000][3];\r\n for(int i=0;i!=n;++i){\r\n  int count,sum1,sum2,bg,end;\r\n  scanf("%d",&count);\r\n  int num[20001]; \r\n  for(int m=0;m!=count;++m)\r\n   scanf("%d",&num[m]); \r\n  sum1=sum2=num[0];\r\n  bg=1; end=1;\r\n  for(int a=1;a!=count;++a){   \r\n   if(sum2>=0){\r\n	   sum2+=num[a];\r\n	   if(sum2<num[a])\r\n		   bg=a+1; \r\n	   else if(sum2>=sum1){\r\n		   sum1=sum2;\r\n		   end=a+1;\r\n	   }  \r\n   }\r\n   else {	   \r\n	   if(num[a]>=0){\r\n		   sum2=num[a];\r\n		   bg =a+1;\r\n		   if(sum2>=sum1){\r\n			   sum1=sum2;\r\n			   end=a+1;\r\n		   } \r\n	   }\r\n   }\r\n  }\r\n  if(i<n-1)\r\n	  printf("Case %d:\\n%d  %d  %d\\n\\n",i+1,sum1,bg,end);\r\n  else\r\n	  printf("Case %d:\\n%d  %d  %d\\n",i+1,sum1,bg,end);\r\n\r\n // out[i][0]=sum1;\r\n  //out[i][1]=bg;  out[i][2]=end;\r\n }\r\n/* for(int ou=0;ou!=n-1;++ou)\r\n  printf("Case %d:\\n%d  %d  %d\\n\\n",ou+1,out[ou][0],out[ou][1],out[ou][2]);\r\n printf("Case %d:\\n%d  %d  %d\\n",ou+1,out[n-1][0],out[n-1][1],out[n-1][2]);\r\n */return 0;\r\n}\r\n \r\n', 'Main.c: In function ''main'':\r\nMain.c:6:2: error: ''for'' loop initial declarations are only allowed in C99 mode\r\nMain.c:6:2: note: use option -std=c99 or -std=gnu99 to compile your code\r\nMain.c:10:3: error: ''for'' loop initial declarations are only allowed in C99 mode\r\nMain.c:14:3: error: ''for'' loop initial declarations are only allowed in C99 mode\r\n', 0, 0, 2, 1, '2010-12-23 09:42:58', '0001-01-01 00:00:00'),
(1105, 14, 402, 8, '#include<stdio.h>\r\n#include<string.h>\r\n\r\nchar num1[2005];\r\nchar num2[2005];\r\n\r\nchar tempSum[2005];\r\n\r\n\r\nint main()\r\n{\r\n	int n,i;\r\n\r\n	char *max,*min,*number1,*number2;\r\n	\r\n\r\n	int lennum1,lennum2;\r\n	scanf("%d",&n);\r\n\r\n	for(i = 0;i<n;++i)\r\n	{\r\n		int j=0,k=0,maxlen,minlen,temp,carry =0;\r\n		char total[2005]={''\\0''};\r\n		scanf("%s",num1);\r\n		scanf("%s",num2);\r\n\r\n		number1= num1;\r\n		number2=num2;\r\n\r\n		lennum1 = strlen(num1);\r\n		lennum2 = strlen(num2);\r\n		max = ( lennum1 >= lennum2 ) ? num1 :num2;\r\n		\r\n		strcpy(tempSum,max);\r\n		min = ( lennum1 < lennum2 ) ? num1 :num2;\r\n		maxlen = strlen(tempSum);\r\n		minlen = strlen(min);\r\n		\r\n		for(j=maxlen -1,k= minlen -1;j>= 0;--j,--k)\r\n		{\r\n			if( k< 0)\r\n				break;\r\n			temp = ( (tempSum[j] - ''0'' ) + (min[k] -''0'')  + carry) ;\r\n			if(temp>=10) \r\n				carry = 1;\r\n			else \r\n				carry =0;\r\n			tempSum[j]= temp % 10 + ''0'';\r\n			\r\n		}\r\n\r\n\r\n		if(1== carry)\r\n		{\r\n			if(j<0)\r\n				strcpy( total,strcat( strcat(total,"1"),tempSum) );\r\n			else \r\n			{\r\n				for(;j>=0;--j)\r\n				{\r\n						temp = ( (tempSum[j] - ''0'' )   + carry) ;\r\n						if(temp>=10) carry =1;\r\n						else\r\n							carry =0;\r\n\r\n						tempSum[j]= temp % 10 + ''0'';\r\n				}\r\n\r\n				if( 1== carry)\r\n					strcpy(total,strcat(strcat(total,"1"),tempSum));\r\n				else\r\n					strcpy(total,tempSum);\r\n			}\r\n\r\n		}else\r\n			strcpy( total,tempSum);\r\n\r\n		\r\n		printf("Case %d:\\n",i+1);\r\n		printf("%s + %s = %s\\n",number1,number2,total);\r\n		if(i!=n-1)\r\n			printf("\\n");\r\n	}\r\n	\r\n\r\n	return 0;\r\n}', '', 15, 262144, 1, 1, '2010-12-23 19:34:51', '0001-01-01 00:00:00'),
(1106, 14, 379, 7, '#include<stdio.h>\r\n#include<limits.h>\r\n\r\n#define FALSE 0\r\n#define TRUE 1\r\nint graphicWeight[801][801];\r\n\r\n\r\nint hasCow(int v,int * table,int num)\r\n{\r\n	int i=0;\r\n	for(;i<num;++i)\r\n		if(table[i] == (v+1) )\r\n			return TRUE;\r\n	return FALSE;\r\n}\r\n\r\n\r\nint shortestPath_dij( int cow[], int cowNum,int vertexNum,int sourceVertex )\r\n{\r\n	int v,i,w,min;\r\n	int shortestSum=0;\r\n	int spTable[801];\r\n\r\n    int final[801];\r\n    \r\n	for(v=0;v<vertexNum;++v)\r\n	{\r\n		final[v]=FALSE; spTable[v]= graphicWeight[ sourceVertex ][v];\r\n	}\r\n\r\n	spTable[sourceVertex]=0; final[sourceVertex]=TRUE;\r\n\r\n	  for(i=0;i<vertexNum; ++i)\r\n	  {\r\n		 min= INT_MAX;\r\n		 for(w=0;w<vertexNum;++w)\r\n			if(!final[w])\r\n			   if(spTable[w]<min) {v=w; min = spTable[w];}\r\n		 final[v] = TRUE;\r\n\r\n		 if( hasCow(v,cow,cowNum) && min < INT_MAX)\r\n			 shortestSum += min;\r\n		 for(w=0;w<vertexNum;++w)\r\n		 if( !final[w] && graphicWeight[v][w] != INT_MAX && ( min+ graphicWeight[v][w]< spTable[w]) )\r\n		 {\r\n			spTable[w]=min + graphicWeight[v][w];\r\n				\r\n		 }\r\n	  }\r\n\r\n	  return shortestSum;\r\n}\r\n\r\n\r\nint main()\r\n{\r\n	int i,j,v0,v1,weight,minSum=INT_MAX;\r\n	int cowNum,pathNum,farmNum;\r\n	int cow[501];\r\n	\r\n 	\r\n\r\n	while(scanf("%d %d %d",&cowNum,&farmNum,&pathNum)==3 )\r\n	{\r\n\r\n		for(i = 0; i < cowNum; ++ i)   \r\n			scanf("%d",&cow[i]);  \r\n	\r\n		for(i = 0; i < farmNum; ++ i)   \r\n		{\r\n			for(j=0;j<farmNum;++j)\r\n				graphicWeight[i][j]=INT_MAX;\r\n		}\r\n\r\n		for(i = 0; i < pathNum; ++ i) \r\n		{         \r\n			scanf("%d %d %d",&v0,&v1,&weight);  \r\n			graphicWeight[v0-1][v1-1]=weight;\r\n			graphicWeight[v1-1][v0-1]=weight;\r\n		}    \r\n	\r\n		for(i = 0; i < farmNum; ++ i)   \r\n		{\r\n			int shortpath =shortestPath_dij(cow,cowNum,farmNum,i);\r\n			if( shortpath<minSum)\r\n				minSum = shortpath;\r\n\r\n		}\r\n		printf("%d",minSum);\r\n	}\r\n	 \r\n	\r\n	return 0;\r\n}', '', 0, 2830336, 3, 1, '2010-12-23 20:07:24', '0001-01-01 00:00:00'),
(1107, 14, 379, 7, '#include<stdio.h>\r\n#include<limits.h>\r\n\r\n#define FALSE 0\r\n#define TRUE 1\r\nint graphicWeight[801][801];\r\n\r\n\r\nint hasCow(int v,int * table,int num)\r\n{\r\n	int i=0;\r\n	for(;i<num;++i)\r\n		if(table[i] == (v+1) )\r\n			return TRUE;\r\n	return FALSE;\r\n}\r\n\r\n\r\nint shortestPath_dij( int cow[], int cowNum,int vertexNum,int sourceVertex )\r\n{\r\n	int v,i,w,min;\r\n	int shortestSum=0;\r\n	int spTable[801];\r\n\r\n    int final[801];\r\n    \r\n	for(v=0;v<vertexNum;++v)\r\n	{\r\n		final[v]=FALSE; spTable[v]= graphicWeight[ sourceVertex ][v];\r\n	}\r\n\r\n	spTable[sourceVertex]=0; final[sourceVertex]=TRUE;\r\n\r\n	  for(i=0;i<vertexNum; ++i)\r\n	  {\r\n		 min= INT_MAX;\r\n		 for(w=0;w<vertexNum;++w)\r\n			if(!final[w])\r\n			   if(spTable[w]<min) {v=w; min = spTable[w];}\r\n		 final[v] = TRUE;\r\n\r\n		 if( hasCow(v,cow,cowNum) && min < INT_MAX)\r\n			 shortestSum += min;\r\n		 for(w=0;w<vertexNum;++w)\r\n		 if( !final[w] && graphicWeight[v][w] != INT_MAX && ( min+ graphicWeight[v][w]< spTable[w]) )\r\n		 {\r\n			spTable[w]=min + graphicWeight[v][w];\r\n				\r\n		 }\r\n	  }\r\n\r\n	  return shortestSum;\r\n}\r\n\r\n\r\nint main()\r\n{\r\n	int i,j,v0,v1,weight,minSum=INT_MAX;\r\n	int cowNum,pathNum,farmNum;\r\n	int cow[501];\r\n	\r\n 	\r\n\r\n	while(scanf("%d %d %d",&cowNum,&farmNum,&pathNum)==3 )\r\n	{\r\n\r\n		for(i = 0; i < cowNum; ++ i)   \r\n			scanf("%d",&cow[i]);  \r\n	\r\n		for(i = 0; i < farmNum; ++ i)   \r\n		{\r\n			for(j=0;j<farmNum;++j)\r\n				graphicWeight[i][j]=INT_MAX;\r\n		}\r\n\r\n		for(i = 0; i < pathNum; ++ i) \r\n		{         \r\n			scanf("%d %d %d",&v0,&v1,&weight);  \r\n			graphicWeight[v0-1][v1-1]=weight;\r\n			graphicWeight[v1-1][v0-1]=weight;\r\n		}    \r\n	\r\n		for(i = 0; i < farmNum; ++ i)   \r\n		{\r\n			int shortpath =shortestPath_dij(cow,cowNum,farmNum,i);\r\n			if( shortpath<minSum)\r\n				minSum = shortpath;\r\n\r\n		}\r\n		printf("%d\\n",minSum);\r\n	}\r\n	 \r\n	\r\n	return 0;\r\n}', '', 15, 2830336, 4, 1, '2010-12-23 20:07:48', '0001-01-01 00:00:00'),
(1108, 14, 381, 0, '#include <iostream>\r\n#include <vector>\r\n#include <memory.h>\r\n\r\n#define M 100001\r\n\r\nusing namespace std;\r\n\r\nvector<int> AdjList[M];\r\nint VertexNum, ArcNum, EdgeNum;\r\nint indegree[M], step[M];\r\nint Edge[M][2];\r\n\r\nbool TopologicalSort()\r\n{\r\n	memset(step, 0, sizeof(step));\r\n    int i, vertex, front=1, rear=1, count = 0;\r\n    int queue[M];\r\n\r\n    for (i = 1; i <= VertexNum; i++)\r\n	{\r\n        if (indegree[i] == 0)\r\n            queue[rear++] = i;\r\n\r\n	}\r\n    while (front < rear )\r\n    {\r\n        vertex = queue[front++];\r\n\r\n        step[vertex] = ++count;\r\n\r\n		int temp;\r\n		for (vector<int>::size_type i= 0; i < AdjList[ vertex ].size(); i++)\r\n        {\r\n            temp = AdjList[vertex][i];\r\n            if ( --indegree[temp] == 0)\r\n                queue[rear++] = temp;\r\n        }\r\n    }\r\n\r\n	if(count<VertexNum)\r\n		return false;\r\n	else \r\n		return true;\r\n}\r\n\r\nint main()\r\n{\r\n    int i,  head, tail, temp;\r\n\r\n    while ( cin >> VertexNum >> ArcNum >> EdgeNum )\r\n    {\r\n        memset(indegree, 0, sizeof(indegree));\r\n\r\n        for (i = 0; i < ArcNum; i++)\r\n        {\r\n            cin>>head>>tail;\r\n\r\n            AdjList[head].push_back(tail);\r\n            indegree[tail]++;\r\n        }\r\n\r\n		for (i = 0; i < EdgeNum; i++)\r\n		{\r\n			cin>>Edge[i][0]>>Edge[i][1];\r\n		}\r\n	            \r\n\r\n        \r\n        if( TopologicalSort() )\r\n		{\r\n			for (i = 0; i < EdgeNum; i++)\r\n			{\r\n				     \r\n				if (step[ Edge[i][0] ] > step[ Edge[i][1] ] )\r\n				{\r\n					temp = Edge[i][0];\r\n					Edge[i][0] = Edge[i][1];\r\n					Edge[i][1] = temp;\r\n				}\r\n				cout<< Edge[i][0]<<'' ''<<Edge[i][1]<<endl;\r\n				\r\n			}\r\n		}\r\n		else\r\n		{\r\n			cout<<("-1\\n");\r\n		}\r\n\r\n	}\r\n}\r\n \r\n\r\n\r\n', 'Main.c:1:20: fatal error: iostream: No such file or directory\r\ncompilation terminated.\r\n', 0, 0, 2, 1, '2010-12-23 20:23:54', '0001-01-01 00:00:00'),
(1109, 14, 381, 0, '#include <iostream.h>\r\n#include <vector>\r\n#include <memory.h>\r\n\r\n#define M 100001\r\n\r\nusing namespace std;\r\n\r\nvector<int> AdjList[M];\r\nint VertexNum, ArcNum, EdgeNum;\r\nint indegree[M], step[M];\r\nint Edge[M][2];\r\n\r\nbool TopologicalSort()\r\n{\r\n	memset(step, 0, sizeof(step));\r\n    int i, vertex, front=1, rear=1, count = 0;\r\n    int queue[M];\r\n\r\n    for (i = 1; i <= VertexNum; i++)\r\n	{\r\n        if (indegree[i] == 0)\r\n            queue[rear++] = i;\r\n\r\n	}\r\n    while (front < rear )\r\n    {\r\n        vertex = queue[front++];\r\n\r\n        step[vertex] = ++count;\r\n\r\n		int temp;\r\n		for (vector<int>::size_type i= 0; i < AdjList[ vertex ].size(); i++)\r\n        {\r\n            temp = AdjList[vertex][i];\r\n            if ( --indegree[temp] == 0)\r\n                queue[rear++] = temp;\r\n        }\r\n    }\r\n\r\n	if(count<VertexNum)\r\n		return false;\r\n	else \r\n		return true;\r\n}\r\n\r\nint main()\r\n{\r\n    int i,  head, tail, temp;\r\n\r\n    while ( cin >> VertexNum >> ArcNum >> EdgeNum )\r\n    {\r\n        memset(indegree, 0, sizeof(indegree));\r\n\r\n        for (i = 0; i < ArcNum; i++)\r\n        {\r\n            cin>>head>>tail;\r\n\r\n            AdjList[head].push_back(tail);\r\n            indegree[tail]++;\r\n        }\r\n\r\n		for (i = 0; i < EdgeNum; i++)\r\n		{\r\n			cin>>Edge[i][0]>>Edge[i][1];\r\n		}\r\n	            \r\n\r\n        \r\n        if( TopologicalSort() )\r\n		{\r\n			for (i = 0; i < EdgeNum; i++)\r\n			{\r\n				     \r\n				if (step[ Edge[i][0] ] > step[ Edge[i][1] ] )\r\n				{\r\n					temp = Edge[i][0];\r\n					Edge[i][0] = Edge[i][1];\r\n					Edge[i][1] = temp;\r\n				}\r\n				cout<< Edge[i][0]<<'' ''<<Edge[i][1]<<endl;\r\n				\r\n			}\r\n		}\r\n		else\r\n		{\r\n			cout<<("-1\\n");\r\n		}\r\n\r\n	}\r\n}\r\n \r\n\r\n\r\n', 'Main.cpp:1:22: fatal error: iostream.h: No such file or directory\r\ncompilation terminated.\r\n', 0, 0, 2, 2, '2010-12-23 20:24:24', '0001-01-01 00:00:00'),
(1110, 14, 381, 0, '#include <iostream>\r\n#include <vector>\r\n#include <memory.h>\r\n\r\n#define M 100001\r\n\r\nusing namespace std;\r\n\r\nvector<int> AdjList[M];\r\nint VertexNum, ArcNum, EdgeNum;\r\nint indegree[M], step[M];\r\nint Edge[M][2];\r\n\r\nbool TopologicalSort()\r\n{\r\n	memset(step, 0, sizeof(step));\r\n    int i, vertex, front=1, rear=1, count = 0;\r\n    int queue[M];\r\n\r\n    for (i = 1; i <= VertexNum; i++)\r\n	{\r\n        if (indegree[i] == 0)\r\n            queue[rear++] = i;\r\n\r\n	}\r\n    while (front < rear )\r\n    {\r\n        vertex = queue[front++];\r\n\r\n        step[vertex] = ++count;\r\n\r\n		int temp;\r\n		for (vector<int>::size_type i= 0; i < AdjList[ vertex ].size(); i++)\r\n        {\r\n            temp = AdjList[vertex][i];\r\n            if ( --indegree[temp] == 0)\r\n                queue[rear++] = temp;\r\n        }\r\n    }\r\n\r\n	if(count<VertexNum)\r\n		return false;\r\n	else \r\n		return true;\r\n}\r\n\r\nint main()\r\n{\r\n    int i,  head, tail, temp;\r\n\r\n    while ( cin >> VertexNum >> ArcNum >> EdgeNum )\r\n    {\r\n        memset(indegree, 0, sizeof(indegree));\r\n\r\n        for (i = 0; i < ArcNum; i++)\r\n        {\r\n            cin>>head>>tail;\r\n\r\n            AdjList[head].push_back(tail);\r\n            indegree[tail]++;\r\n        }\r\n\r\n		for (i = 0; i < EdgeNum; i++)\r\n		{\r\n			cin>>Edge[i][0]>>Edge[i][1];\r\n		}\r\n	            \r\n\r\n        \r\n        if( TopologicalSort() )\r\n		{\r\n			for (i = 0; i < EdgeNum; i++)\r\n			{\r\n				     \r\n				if (step[ Edge[i][0] ] > step[ Edge[i][1] ] )\r\n				{\r\n					temp = Edge[i][0];\r\n					Edge[i][0] = Edge[i][1];\r\n					Edge[i][1] = temp;\r\n				}\r\n				cout<< Edge[i][0]<<'' ''<<Edge[i][1]<<endl;\r\n				\r\n			}\r\n		}\r\n		else\r\n		{\r\n			cout<<("-1\\n");\r\n		}\r\n\r\n	}\r\n}\r\n \r\n\r\n\r\n', '', 0, 3538944, 4, 2, '2010-12-23 20:24:40', '0001-01-01 00:00:00'),
(1111, 24, 402, 8, '#include <stdio.h>\r\n#include <string.h>\r\n\r\n#define SIZE 20\r\n\r\nchar s1[SIZE];\r\nchar s2[SIZE];\r\nint an1[SIZE];\r\nint an2[SIZE];\r\n\r\nint main()\r\n{\r\n	int i,j,a1;\r\n	int a;\r\n	int n1,n2;\r\n	scanf("%d",&a);\r\n	for(a1=0;a1<a;a1++)\r\n	{\r\n		scanf("%s",s1);\r\n		scanf("%s",s2);\r\n		memset(an1,0,sizeof(an1));\r\n		memset(an2,0,sizeof(an2));\r\n\r\n		n1=strlen(s1);\r\n		n2=strlen(s2);\r\n\r\n		j=0;\r\n		for(i=n1-1;i>=0;i--)\r\n			an1[j++]=s1[i]-''0'';\r\n\r\n		j=0;\r\n		for(i=n2-1;i>=0;i--)\r\n			an2[j++]=s2[i]-''0'';\r\n\r\n		for(i=0;i<SIZE;i++)\r\n		{\r\n			an1[i]+=an2[i];\r\n			if(an1[i]>=10)\r\n			{\r\n				an1[i]-=10;\r\n				an1[i+1]++;\r\n			}\r\n		}\r\n\r\n		j=SIZE;\r\n		while(!an1[j])\r\n			--j;\r\n		if(j<0)\r\n			printf("0");\r\n		printf("Case %d:",a1+1);\r\n		printf("\\n");\r\n		printf("%s + %s = ",s1,s2);\r\n\r\n		for(i=j;i>=0;--i)\r\n			printf("%d",an1[i]);\r\n		printf("\\n");\r\n\r\n		memset(an1,0,sizeof(an1));\r\n		memset(an2,0,sizeof(an2));\r\n\r\n		memset(s1,0,sizeof(s1));\r\n		memset(s2,0,sizeof(s2));\r\n	}\r\n\r\n	return 0;\r\n}', '', 0, 262144, 4, 1, '2010-12-23 20:58:21', '0001-01-01 00:00:00'),
(1112, 24, 402, 8, '#include <stdio.h>\r\n#include <string.h>\r\n\r\n#define SIZE 2000\r\n\r\nchar s1[SIZE];\r\nchar s2[SIZE];\r\nint an1[SIZE];\r\nint an2[SIZE];\r\n\r\nint main()\r\n{\r\n	int i,j,a1;\r\n	int a;\r\n	int n1,n2;\r\n	scanf("%d",&a);\r\n	for(a1=0;a1<a;a1++)\r\n	{\r\n		scanf("%s",s1);\r\n		scanf("%s",s2);\r\n		memset(an1,0,sizeof(an1));\r\n		memset(an2,0,sizeof(an2));\r\n\r\n		n1=strlen(s1);\r\n		n2=strlen(s2);\r\n\r\n		j=0;\r\n		for(i=n1-1;i>=0;i--)\r\n			an1[j++]=s1[i]-''0'';\r\n\r\n		j=0;\r\n		for(i=n2-1;i>=0;i--)\r\n			an2[j++]=s2[i]-''0'';\r\n\r\n		for(i=0;i<SIZE;i++)\r\n		{\r\n			an1[i]+=an2[i];\r\n			if(an1[i]>=10)\r\n			{\r\n				an1[i]-=10;\r\n				an1[i+1]++;\r\n			}\r\n		}\r\n\r\n		j=SIZE-1;\r\n		while(!an1[j])\r\n			--j;\r\n		if(j<0)\r\n			printf("0");\r\n\r\n		printf("Case %d:",a1+1);\r\n		printf("\\n");\r\n		printf("%s + %s = ",s1,s2);\r\n\r\n		for(i=j;i>=0;--i)\r\n			printf("%d",an1[i]);\r\n		printf("\\n");\r\n\r\n		memset(an1,0,sizeof(an1));\r\n		memset(an2,0,sizeof(an2));\r\n\r\n		memset(s1,0,sizeof(s1));\r\n		memset(s2,0,sizeof(s2));\r\n	}\r\n\r\n	return 0;\r\n}', '', 62, 274432, 3, 1, '2010-12-23 21:05:08', '0001-01-01 00:00:00'),
(1113, 24, 402, 8, '#include <stdio.h>\r\n#include <string.h>\r\n\r\n#define SIZE 2000\r\n\r\nchar s1[SIZE];\r\nchar s2[SIZE];\r\nint an1[SIZE];\r\nint an2[SIZE];\r\n\r\nint main()\r\n{\r\n	int i,j,a1;\r\n	int a;\r\n	int n1,n2;\r\n	scanf("%d",&a);\r\n	for(a1=0;a1<a;a1++)\r\n	{\r\n		scanf("%s",s1);\r\n		scanf("%s",s2);\r\n		memset(an1,0,sizeof(an1));\r\n		memset(an2,0,sizeof(an2));\r\n\r\n		n1=strlen(s1);\r\n		n2=strlen(s2);\r\n\r\n		j=0;\r\n		for(i=n1-1;i>=0;i--)\r\n			an1[j++]=s1[i]-''0'';\r\n\r\n		j=0;\r\n		for(i=n2-1;i>=0;i--)\r\n			an2[j++]=s2[i]-''0'';\r\n\r\n		for(i=0;i<SIZE;i++)\r\n		{\r\n			an1[i]+=an2[i];\r\n			if(an1[i]>=10)\r\n			{\r\n				an1[i]-=10;\r\n				an1[i+1]++;\r\n			}\r\n		}\r\n\r\n		j=SIZE-1;\r\n		while(!an1[j])\r\n			--j;\r\n		if(j<0)\r\n			printf("0");\r\n\r\n		printf("Case %d:",a1+1);\r\n		printf("\\n");\r\n		printf("%s + %s = ",s1,s2);\r\n\r\n		for(i=j;i>=0;--i)\r\n			printf("%d",an1[i]);\r\n		printf("\\n");\r\n		printf("\\n");\r\n\r\n		memset(an1,0,sizeof(an1));\r\n		memset(an2,0,sizeof(an2));\r\n\r\n		memset(s1,0,sizeof(s1));\r\n		memset(s2,0,sizeof(s2));\r\n	}\r\n\r\n	return 0;\r\n}', '', 31, 278528, 3, 1, '2010-12-23 21:06:55', '0001-01-01 00:00:00'),
(1114, 24, 402, 8, '#include <stdio.h>\r\n#include <string.h>\r\n\r\n#define SIZE 2000\r\n\r\nchar s1[SIZE];\r\nchar s2[SIZE];\r\nint an1[SIZE];\r\nint an2[SIZE];\r\n\r\nint main()\r\n{\r\n	int i,j,a1;\r\n	int a;\r\n	int n1,n2;\r\n	scanf("%d",&a);\r\n	for(a1=0;a1<a;a1++)\r\n	{\r\n		scanf("%s",s1);\r\n		scanf("%s",s2);\r\n		memset(an1,0,sizeof(an1));\r\n		memset(an2,0,sizeof(an2));\r\n\r\n		n1=strlen(s1);\r\n		n2=strlen(s2);\r\n\r\n		j=0;\r\n		for(i=n1-1;i>=0;i--)\r\n			an1[j++]=s1[i]-''0'';\r\n\r\n		j=0;\r\n		for(i=n2-1;i>=0;i--)\r\n			an2[j++]=s2[i]-''0'';\r\n\r\n		for(i=0;i<SIZE;i++)\r\n		{\r\n			an1[i]+=an2[i];\r\n			if(an1[i]>=10)\r\n			{\r\n				an1[i]-=10;\r\n				an1[i+1]++;\r\n			}\r\n		}\r\n\r\n		j=SIZE-1;\r\n		while(!an1[j])\r\n			--j;\r\n		if(j<0)\r\n			printf("0");\r\n\r\n		printf("Case %d:",a1+1);\r\n		printf("\\n");\r\n		printf("%s + %s = ",s1,s2);\r\n\r\n		for(i=j;i>=0;--i)\r\n			printf("%d",an1[i]);\r\n		printf("\\n");\r\n		if(a1+1!=a)\r\n		printf("\\n");\r\n\r\n		memset(an1,0,sizeof(an1));\r\n		memset(an2,0,sizeof(an2));\r\n\r\n		memset(s1,0,sizeof(s1));\r\n		memset(s2,0,sizeof(s2));\r\n	}\r\n\r\n	return 0;\r\n}', '', 77, 278528, 4, 1, '2010-12-23 21:34:00', '0001-01-01 00:00:00'),
(1115, 24, 402, 8, '#include <stdio.h>\r\n#include <string.h>\r\n#define MAXSIZE 1002\r\n\r\ntypedef struct\r\n{\r\n    //char sign;\r\n    char HighBit;\r\n    char LNum[MAXSIZE];\r\n}LNum;\r\n\r\nvoid LNumInput(LNum &LN)\r\n{\r\n  char ch;\r\n  int i =0;\r\n  scanf("%c",&ch);\r\n  while(ch!='' '' && int(ch)!= 10){\r\n      LN.LNum[i]=ch;\r\n    scanf("%c",&ch);\r\n    \r\n    i++;\r\n  };\r\n  LN.LNum[i]=''\\0'';\r\n}\r\n\r\nvoid LNumOuput(LNum LN)\r\n{\r\n    if(LN.HighBit==''1'')\r\n    {\r\n        printf("1");\r\n    }\r\n    for(int i=0;LN.LNum[i]!=''\\0'';i++)\r\n  {\r\n    printf("%d",int(LN.LNum[i])-48);\r\n  }\r\n}\r\n\r\nvoid AddLNum(LNum LN1,LNum LN2,LNum &LNResult)\r\n{\r\n  LNum Tmp;\r\n \r\n  int NumTmp;\r\n  if (strlen(LN1.LNum)<strlen(LN2.LNum))\r\n  {\r\n    strcpy(Tmp.LNum,LN1.LNum);\r\n    strcpy(LN1.LNum,LN2.LNum);\r\n    strcpy(LN2.LNum,Tmp.LNum);\r\n  }\r\n  \r\n  int longlen = strlen(LN1.LNum) ;\r\n  int shortlen = strlen(LN2.LNum) ;\r\n  int AddictionNum=0;\r\n  int i,j;\r\n  LNResult.LNum[longlen]=''\\0'';\r\n  for(i=longlen-1,j=shortlen-1;i>=0;i--,j--)\r\n  {\r\n    if(j>=0)\r\n    {\r\n      if(int(LN1.LNum[i]) + (int)LN2.LNum[j] + AddictionNum - 96 > 9)\r\n      {\r\n        LNResult.LNum[i] = int(LN1.LNum[i]) + int(LN2.LNum[j]) + AddictionNum  - 58;\r\n        AddictionNum=1;\r\n      }\r\n      else\r\n      {\r\n        LNResult.LNum[i] = int(LN1.LNum[i]) + int(LN2.LNum[j]) + AddictionNum  - 48;\r\n        AddictionNum = 0;\r\n      }\r\n\r\n    }\r\n    else\r\n    {\r\n      if(int(LN1.LNum[i]) + AddictionNum - 48 > 9)\r\n      {\r\n        LNResult.LNum[i] = int(LN1.LNum[i]) + AddictionNum  - 10;\r\n        AddictionNum=1;\r\n      }\r\n      else\r\n      {\r\n        LNResult.LNum[i] = int(LN1.LNum[i]) + AddictionNum;\r\n        AddictionNum = 0;\r\n      }\r\n    }\r\n  }\r\n  if(AddictionNum==1)\r\n  {\r\n    LNResult.HighBit = ''1'';\r\n  }\r\n}\r\n\r\nint main()\r\n{\r\n  LNum LN1,LN2,LNResult;\r\n  \r\n  int n;\r\n  scanf("%d",&n);\r\n  getchar();\r\n    for (int i=1;i<=n;i++)\r\n    {\r\n        LNumInput(LN1);\r\n        LNumInput(LN2);\r\n        AddLNum(LN1,LN2,LNResult);\r\n        printf("Case %d:\\n",i);\r\n        LNumOuput(LN1);\r\n        printf(" + ");\r\n        LNumOuput(LN2);\r\n        printf(" = ");\r\n        LNumOuput(LNResult);\r\n        printf("\\n");\r\n        if(i!=n)\r\n        {\r\n            printf("\\n");\r\n        }\r\n    }\r\n    \r\n} ', '', 202, 258048, 4, 2, '2010-12-23 21:41:44', '0001-01-01 00:00:00'),
(1116, 24, 402, 8, '#include <stdio.h>\r\n#include <string.h>\r\n\r\n#define SIZE 1010\r\n\r\nchar s1[SIZE];\r\nchar s2[SIZE];\r\nint an1[SIZE];\r\nint an2[SIZE];\r\n\r\nint main()\r\n{\r\n	int i,j,a1;\r\n	int a;\r\n	int n1,n2;\r\n	scanf("%d",&a);\r\n	for(a1=0;a1<a;a1++)\r\n	{\r\n		scanf("%s",s1);\r\n		scanf("%s",s2);\r\n		memset(an1,0,sizeof(an1));\r\n		memset(an2,0,sizeof(an2));\r\n\r\n		n1=strlen(s1);\r\n		n2=strlen(s2);\r\n\r\n		j=0;\r\n		for(i=n1-1;i>=0;i--)\r\n			an1[j++]=s1[i]-''0'';\r\n\r\n		j=0;\r\n		for(i=n2-1;i>=0;i--)\r\n			an2[j++]=s2[i]-''0'';\r\n\r\n		for(i=0;i<SIZE;i++)\r\n		{\r\n			an1[i]+=an2[i];\r\n			if(an1[i]>=10)\r\n			{\r\n				an1[i]-=10;\r\n				an1[i+1]++;\r\n			}\r\n		}\r\n\r\n		j=SIZE-1;\r\n		while(!an1[j])\r\n			--j;\r\n		if(j<0)\r\n			printf("0");\r\n\r\n		printf("Case %d:\\n",a1+1);\r\n		printf("%s + %s = ",s1,s2);\r\n\r\n		for(i=j;i>=0;--i)\r\n			printf("%d",an1[i]);\r\n		printf("\\n");\r\n		if(a1+1!=a)\r\n		{\r\n		printf("\\n");\r\n		}\r\n\r\n		memset(an1,0,sizeof(an1));\r\n		memset(an2,0,sizeof(an2));\r\n\r\n		memset(s1,0,sizeof(s1));\r\n		memset(s2,0,sizeof(s2));\r\n	}\r\n\r\n	return 0;\r\n}', '', 62, 270336, 4, 1, '2010-12-23 21:46:00', '0001-01-01 00:00:00'),
(1117, 24, 402, 8, '#include <iostream>\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nvoid add(char a[],char b[],char back[])\r\n{\r\n    int i,j,k,up,x,y,z,l;\r\n    char *c;\r\n    if (strlen(a)>strlen(b)) l=strlen(a)+2; else l=strlen(b)+2;\r\n    c=(char *) malloc(l*sizeof(char));\r\n    i=strlen(a)-1;\r\n    j=strlen(b)-1;\r\n    k=0;up=0;\r\n    while(i>=0||j>=0)\r\n    {\r\n        if(i<0) x=''0''; else x=a[i];\r\n        if(j<0) y=''0''; else y=b[j];\r\n        z=x-''0''+y-''0'';\r\n        if(up) z+=1;\r\n        if(z>9) {up=1;z%=10;} else up=0;\r\n        c[k++]=z+''0'';\r\n        i--;j--;\r\n    }\r\n    if(up) c[k++]=''1'';\r\n    i=0;\r\n    c[k]=''\\0'';\r\n    for(k-=1;k>=0;k--)\r\n        back[i++]=c[k];\r\n    back[i]=''\\0'';\r\n} \r\n\r\nint main()\r\n{\r\n    char a[1000], b[1000], c[1005];\r\n    int n;\r\n    cin >> n;\r\n    int i;\r\n\r\n    for( i = 1; i <= n; i++ )\r\n    {\r\n        cin >> a >> b;\r\n        cout << "Case " << i << ":" << endl;\r\n        char *x = a;\r\n        while( x[0] == ''0'')\r\n        {\r\n            if( x[1] != ''\\0'' )\r\n                x++;\r\n            else\r\n                break;\r\n        }\r\n        cout << x << " + ";\r\n        x = b;\r\n        while( x[0] == ''0'' )\r\n            if( x[1] != ''\\0'' )\r\n                x++;\r\n            else\r\n                break;\r\n        cout << x << " = ";\r\n        add( a, b, c );\r\n\r\n        x = c;\r\n        while( x[0] == ''0'' )\r\n            if( x[1] != ''\\0'' )\r\n                x++;\r\n            else\r\n                break;\r\n        cout << x << endl;\r\n        if( i != n )\r\n            cout << endl;\r\n    }\r\n\r\n    return 0;\r\n}', 'Main.cpp: In function ''void add(char*, char*, char*)'':\r\nMain.cpp:10:17: error: ''strlen'' was not declared in this scope\r\nMain.cpp:11:37: error: ''malloc'' was not declared in this scope\r\nMain.cpp:12:15: error: ''strlen'' was not declared in this scope\r\n', 0, 0, 2, 2, '2010-12-23 21:49:31', '0001-01-01 00:00:00'),
(1118, 24, 374, 5, '#include<iostream>\r\nusing namespace std;\r\n#include <stdio.h>\r\nint n;\r\nint arr[100002];\r\nvoid work(int &max,int &l,int &r)\r\n{\r\n      int i,now,nowl;\r\n      now=max=arr[1];nowl=l=1;r=1;\r\n      for(i=2;i<=n;i++)\r\n      {\r\n            if(now<0)\r\n            {\r\n                  nowl=i;\r\n                  now=arr[i];\r\n            }\r\n            else\r\n            {\r\n                  now+=arr[i];\r\n            }\r\n            if(now>max)\r\n            {\r\n                  max=now;\r\n                  l=nowl;\r\n                  r=i;\r\n            }\r\n      }\r\n}\r\nvoid reader()\r\n{\r\n      scanf("%d",&n);\r\n      for(int i=1;i<=n;i++)\r\n            scanf("%d",arr+i);\r\n}\r\nint main()\r\n{\r\n      int t,i,max,l,r;\r\n      scanf("%d",&t);\r\n      for(i=1;i<=t;i++)\r\n      {\r\n            reader();\r\n            printf("Case %d:\\n",i);\r\n            work(max,l,r);\r\n            printf("%d %d %d\\n",max,l,r);\r\n            if(i<t)\r\n                  printf("\\n");\r\n      }\r\n      return 0;\r\n} ', '', 15, 770048, 1, 2, '2010-12-23 21:52:52', '0001-01-01 00:00:00'),
(1119, 17, 377, 6, '#include<stdio.h>\r\n#include<iostream>\r\nusing namespace std;\r\n#define M 301\r\ntypedef struct point{\r\n        double x1,y1;\r\n        double x2,y2;\r\n}Point;\r\nPoint seg[M];\r\nint cal(Point p0,Point p1)\r\n{   \r\n     double z1,z2;\r\n     if(p0.x1==p0.x2&&p0.y1==p0.y2&&p1.x2==p1.x1&&p1.y2==p1.y1&&p1.x1!=p0.x2)\r\n     return 0;\r\n     z1=(p0.x1-p1.x1)*(p1.y2-p1.y1)-(p0.y1-p1.y1)*(p1.x2-p1.x1);\r\n     z2=(p1.x2-p1.x1)*(p0.y2-p1.y1)-(p1.y2-p1.y1)*(p0.x2-p1.x1);\r\n     if(z1*z2>=0)\r\n       return 1;\r\n     else \r\n     return 0;\r\n}         \r\nint main()\r\n{\r\n    int i,test,j;\r\n    int count;\r\n    while(scanf("%d",&test)&&test!=0)\r\n    {   \r\n        count=0;\r\n        for(i=0;i<test;i++)\r\n          cin>>seg[i].x1>>seg[i].y1>>seg[i].x2>>seg[i].y2;\r\n        for(i=0;i<test;i++)\r\n         for(j=i+1;j<test;j++)\r\n          if(cal(seg[i],seg[j])&&cal(seg[j],seg[i]))\r\n           count++;\r\n        printf("%d\\n",count);\r\n    }\r\n}\r\n', '', 592, 376832, 1, 2, '2010-12-28 12:41:22', '0001-01-01 00:00:00'),
(1120, 20, 336, 2, '#include<stdio.h>\r\nint count(unsigned int n)\r\n{\r\n	int num;\r\n	for(num = 0; n; n >>= 1)\r\n	{\r\n		num += n & 1;\r\n	}\r\n	return num;\r\n}\r\nint main()\r\n{\r\n	int m,n,i,j;\r\n	int a[1000],b[1000];\r\n\r\n	scanf("%d",&n);\r\n\r\n	for(i=0;i<n;i++)\r\n	{\r\n		scanf("%d",&a[i]);\r\n	}\r\n	\r\n	for(j=0;j<n;j++)\r\n	{\r\n		b[j]=count(a[j]);\r\n	}\r\n	\r\n	for(i=0;i<n-1;i++)\r\n	{\r\n		if(b[i]>b[i+1])\r\n        {\r\n			m=a[i];a[i]=a[i+1];a[i+1]=m;\r\n		}\r\n	}\r\n\r\n	for(i=0;i<n;i++)\r\n	{\r\n		printf("%d",a[i]);\r\n	}\r\n	return 0;			\r\n}', '', 0, 253952, 4, 1, '2010-12-28 18:40:50', '0001-01-01 00:00:00'),
(1121, 20, 336, 2, '#include<stdio.h>\r\nint count(unsigned int n)\r\n{\r\n	int num;\r\n	for(num = 0; n; n >>= 1)\r\n	{\r\n		num += n & 1;\r\n	}\r\n	return num;\r\n}\r\nint main()\r\n{\r\n	int m,n,i,j;\r\n	int a[50],b[50];\r\n\r\n	scanf("%d",&n);\r\n\r\n	for(i=0;i<n;i++)\r\n	{\r\n		scanf("%d",&a[i]);\r\n	}\r\n	\r\n	for(j=0;j<n;j++)\r\n	{\r\n		b[j]=count(a[j]);\r\n	}\r\n	\r\n	for(i=0;i<n-1;i++)\r\n	{\r\n		if(b[i]>b[i+1])\r\n        {\r\n			m=a[i];a[i]=a[i+1];a[i+1]=m;\r\n		}\r\n	}\r\n\r\n	for(i=0;i<n;i++)\r\n	{\r\n		printf("%d",a[i]);\r\n	}\r\n	return 0;			\r\n}', '', 0, 258048, 7, 1, '2010-12-28 18:42:37', '0001-01-01 00:00:00'),
(1122, 26, 335, 2, '#include <iostream>\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n	int a,b,c,n = 0;\r\n	cout << "请输入两个整数并以空格隔开\\n" << endl;\r\n    while(cin >> a >> b)\r\n	{\r\n	c = a^b;\r\n	cout << c <<endl;\r\n	while(c/2)\r\n	{\r\n		if(c%2 != 0)\r\n           n++;\r\n		c = c/2;\r\n	}\r\n	cout <<  ++n  << endl;\r\n	n = 0;\r\n	}\r\n	return 0;\r\n}', '', 0, 360448, 4, 2, '2010-12-29 16:02:22', '0001-01-01 00:00:00'),
(1123, 27, 336, 2, '#include<stdio.h>\r\nint countnumber(int n)\r\n{\r\n		int count=0;\r\n		while(n)\r\n		{\r\n			n=n&(n-1);\r\n			count++;\r\n		}\r\n  	return count;\r\n}\r\n\r\nint main()\r\n{\r\n	int n,i,j,b;\r\n	int c[50001],d[50001];\r\n	while(scanf("%d",&n)==1)\r\n	{\r\n		for(i=0;i<n;++i){\r\n			scanf("%d",&c[i]);\r\n		    d[i]=countnumber(c[i]);\r\n		}\r\n		for(i=1;i<n;i++)\r\n		{\r\n			for(j=0;j<n-i;++j)\r\n			{\r\n				if(d[j]>d[j+1]){\r\n				    b=c[j];\r\n				    c[j]=c[j+1];\r\n			    	c[j+1]=b;\r\n					b=d[j];\r\n				    d[j]=d[j+1];\r\n			    	d[j+1]=b;\r\n				}\r\n				if(d[j]==d[j+1]){\r\n					if(c[j]>c[j+1]){\r\n						b=c[j];\r\n				        c[j]=c[j+1];\r\n			        	c[j+1]=b;\r\n				    	b=d[j];\r\n			    	    d[j]=d[j+1];\r\n			        	d[j+1]=b;\r\n					}\r\n				}\r\n\r\n			}\r\n		}\r\n		for(i=0;i<n;i++) printf("%d  ",c[i]);\r\n		printf("\\n");\r\n	}\r\n	return 0;\r\n}\r\n', '', 200, 618496, 5, 1, '2010-12-29 16:12:35', '0001-01-01 00:00:00'),
(1124, 38, 335, 2, '#include <iostream>\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n	int a,b,c,n;\r\n	cout << "请输入两个整数并以空格隔开\\n" << endl;\r\n    while(cin >> a >> b)\r\n	{\r\n	c = a^b;\r\n	for(n = 0;c;c >>= 1)\r\n		n += c&1;\r\n	cout <<  n  << endl;\r\n	n = 0;\r\n	}\r\n	return 0;\r\n}', '', 100, 360448, 5, 2, '2010-12-29 16:21:17', '0001-01-01 00:00:00'),
(1125, 26, 335, 2, '#include <iostream>\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n	int a,b,m,count,c[100],i=0;\r\n	cout << "请输入两个整数并以空格隔开" << endl;\r\n    while(cin >> a >> b)\r\n	{\r\n	c[i] =a^b;\r\n	i ++;\r\n	}\r\n	for(int j =0;j!=i;j++)\r\n	{\r\n		m =c[j];\r\n		for(count = 0;m;m >>= 1)\r\n		count += m&1;\r\n		cout << count << endl;\r\n	}\r\n	return 0;\r\n}', '', 100, 364544, 5, 2, '2010-12-29 16:42:52', '0001-01-01 00:00:00'),
(1126, 26, 335, 2, '#include <stdio.h>\r\n\r\nint main()\r\n{\r\n	int a,b,m,count,c[100],i=0;\r\n	printf( "请输入两个整数并以空格隔开\\n");\r\n    while(scanf("%d\\t%d\\n",&a,&b) == 2) \r\n	{\r\n	c[i] =a^b;\r\n	i ++;\r\n	}\r\n	for(int j =0;j!=i;j++)\r\n	{\r\n		m =c[j];\r\n		for(count = 0;m;m >>= 1)\r\n		count += m&1;\r\n		printf("%d\\n",count);\r\n	}\r\n	return 0;\r\n}', 'Main.c: In function ''main'':\r\nMain.c:12:2: error: ''for'' loop initial declarations are only allowed in C99 mode\r\nMain.c:12:2: note: use option -std=c99 or -std=gnu99 to compile your code\r\n', 0, 0, 2, 1, '2010-12-29 16:50:45', '0001-01-01 00:00:00'),
(1127, 6, 404, 9, '#include <stdio.h>\r\n#include <string.h>\r\n#define Type int \r\n#define MAXN 5\r\nint Mod, Size;\r\nstruct Matrix {\r\n	Type Mat[MAXN][MAXN];\r\n	Matrix() {\r\n		memset(Mat, 0, sizeof(Mat));\r\n	}\r\n	void Init() { \r\n		for (int i = 0; i < Size; ++i) {\r\n			for (int j = 0; j < Size; ++j)\r\n				scanf("%d",&Mat[i][j]);\r\n		}\r\n	}\r\n	void Unit() {\r\n		for (int i = 0; i < Size; ++i) {\r\n			for (int j = 0; j < Size; ++j) \r\n				Mat[i][j] = (i == j);\r\n		}\r\n	}\r\n	void Print() {\r\n		int i, j;\r\n		for (i = 0; i < Size; ++i) {\r\n			for (j = 0; j < (Size - 1) ; ++j)\r\n				printf("%d ",Mat[i][j]);\r\n			printf("%d\\n",Mat[i][j]);\r\n		}\r\n		printf("\\n");\r\n	}\r\n};\r\n\r\n//矩阵相乘\r\nMatrix MMul(Matrix& A,Matrix& B) \r\n{\r\n	Matrix Ans;\r\n	for (int i = 0; i < Size; ++i) {\r\n		for (int x = 0; x < Size; ++x) {\r\n			if (!A.Mat[x][i]) continue;\r\n			for (int y = 0; y < Size; ++y) {\r\n				if (!B.Mat[i][y]) continue;\r\n				Ans.Mat[x][y] += (A.Mat[x][i] * B.Mat[i][y])%Mod;\r\n				if (Ans.Mat[x][y] >= Mod || Ans.Mat[x][y] <= -Mod) {\r\n                    Ans.Mat[x][y] %= Mod;\r\n				}\r\n				Ans.Mat[x][y] %= Mod;\r\n			}\r\n		}\r\n	}\r\n	return Ans;\r\n}\r\n\r\n//矩阵二分求幂\r\nMatrix MPow(Matrix& Mat, int Pow) \r\n{\r\n	Matrix Ans, Tmp(Mat);\r\n	for (Ans.Unit(); Pow ; Pow >>= 1) {\r\n		//printf("22222\\n");\r\n		if ((Pow & 1))\r\n			Ans = MMul(Ans, Tmp);\r\n		Tmp = MMul(Tmp, Tmp);\r\n   }\r\n   return Ans;\r\n}\r\n\r\nint main() \r\n{\r\n   int T;\r\n   Matrix Mat, Tmp;\r\n   Mod = 2011, Size = 4;\r\n   scanf("%d",&T);\r\n   while (T--) {\r\n	   Mat.Init();\r\n	   //printf("111\\n");\r\n	   Mat = MPow(Mat, 2011);\r\n	   Mat.Print();\r\n   }\r\n   return 0;\r\n}', '', 46, 258048, 1, 2, '2010-12-29 23:49:04', '0001-01-01 00:00:00'),
(1128, 6, 404, 9, '#include <stdio.h>\r\n#include <string.h>\r\n#define Type int \r\n#define MAXN 5\r\nint Mod, Size;\r\nstruct Matrix {\r\n	Type Mat[MAXN][MAXN];\r\n	Matrix() {\r\n		memset(Mat, 0, sizeof(Mat));\r\n	}\r\n	void Init() { \r\n		for (int i = 0; i < Size; ++i) {\r\n			for (int j = 0; j < Size; ++j)\r\n				scanf("%d",&Mat[i][j]);\r\n		}\r\n	}\r\n	void Unit() {\r\n		for (int i = 0; i < Size; ++i) {\r\n			for (int j = 0; j < Size; ++j) \r\n				Mat[i][j] = (i == j);\r\n		}\r\n	}\r\n	void Print() {\r\n		int i, j;\r\n		for (i = 0; i < Size; ++i) {\r\n			for (j = 0; j < (Size - 1) ; ++j)\r\n				printf("%d ",Mat[i][j]);\r\n			printf("%d\\n",Mat[i][j]);\r\n		}\r\n		printf("\\n");\r\n	}\r\n};\r\n\r\n//矩阵相乘\r\nMatrix MMul(Matrix& A,Matrix& B) \r\n{\r\n	Matrix Ans;\r\n	for (int i = 0; i < Size; ++i) {\r\n		for (int x = 0; x < Size; ++x) {\r\n			if (!A.Mat[x][i]) continue;\r\n			for (int y = 0; y < Size; ++y) {\r\n				if (!B.Mat[i][y]) continue;\r\n				Ans.Mat[x][y] += (A.Mat[x][i] * B.Mat[i][y])%Mod;\r\n				if (Ans.Mat[x][y] >= Mod || Ans.Mat[x][y] <= -Mod) {\r\n                    Ans.Mat[x][y] %= Mod;\r\n				}\r\n				Ans.Mat[x][y] %= Mod;\r\n			}\r\n		}\r\n	}\r\n	return Ans;\r\n}\r\n\r\n//矩阵二分求幂\r\nMatrix MPow(Matrix& Mat, int Pow) \r\n{\r\n	Matrix Ans, Tmp(Mat);\r\n	for (Ans.Unit(); Pow ; Pow >>= 1) {\r\n		//printf("22222\\n");\r\n		if ((Pow & 1))\r\n			Ans = MMul(Ans, Tmp);\r\n		Tmp = MMul(Tmp, Tmp);\r\n   }\r\n   return Ans;\r\n}\r\n\r\nint main() \r\n{\r\n   int T;\r\n   Matrix Mat, Tmp;\r\n   Mod = 2011, Size = 4;\r\n   scanf("%d",&T);\r\n   while (T--) {\r\n	   Mat.Init();\r\n	   //printf("111\\n");\r\n	   Mat = MPow(Mat, 2011);\r\n	   Mat.Print();\r\n   }\r\n   return 0;\r\n}', '', 46, 258048, 1, 2, '2010-12-29 23:50:23', '0001-01-01 00:00:00'),
(1129, 14, 376, 5, '#include<iostream>\r\n#include<limits.h>\r\n\r\nusing namespace std;\r\n\r\n_int64 num[50001];\r\n\r\nint main()\r\n{\r\n	int i,number;\r\n	\r\n\r\n	while( cin>>number )\r\n	{\r\n		int zeroCount=0,positive=0,negative=0;\r\n		_int64 minPosi = _I64_MAX,minNega = 0,maxNega=_I64_MIN;\r\n		_int64 productive=1;\r\n		\r\n		for(i=0;i<number;i++)\r\n			cin >> num[i];\r\n\r\n		for(i=0;i<number;i++)\r\n		{\r\n			if( 0 == num[i] )\r\n				zeroCount++;\r\n			else if(num[i]<0 )\r\n			{\r\n				negative++;\r\n				if(num[i] > maxNega )\r\n					maxNega = num[i];\r\n\r\n				if(num[i] < minNega)\r\n					minNega = num[i];\r\n			}\r\n			else\r\n			{\r\n				positive++;\r\n				if( num[i] < minPosi )\r\n					minPosi = num[i];\r\n			}\r\n		}\r\n\r\n\r\n		if( zeroCount != 0)\r\n		{\r\n			if(1==zeroCount && 0 == negative % 2)\r\n			{\r\n				for(i=0;i<number;i++)\r\n					if( 0 != num[i])\r\n						productive *= num[i];\r\n				cout<<productive<<endl;\r\n\r\n			}\r\n			else\r\n				cout<<0<<endl;\r\n\r\n		}\r\n		else if( 1==negative %2 )\r\n		{\r\n			for(i=0;i<number;i++)\r\n				if( maxNega != num[i])\r\n			productive *= num[i];\r\n\r\n			cout<<productive<<endl;\r\n		}\r\n		else \r\n		{\r\n			if( 0 != positive)\r\n			{\r\n				for(i=0;i<number;i++)\r\n					if( minPosi != num[i])\r\n						productive *= num[i];\r\n\r\n				cout<<productive<<endl;\r\n			}\r\n			else\r\n			{\r\n				for(i=0;i<number;i++)\r\n					if( minNega != num[i])\r\n						productive *= num[i];\r\n\r\n				cout<<productive<<endl;\r\n			}\r\n\r\n		}\r\n	}\r\n	return 0;\r\n	\r\n}', '', 0, 0, 2, 2, '2010-12-29 23:50:36', '0001-01-01 00:00:00'),
(1130, 14, 376, 5, '#include<iostream.h>\r\n#include<limits.h>\r\n\r\nusing namespace std;\r\n\r\n_int64 num[50001];\r\n\r\nint main()\r\n{\r\n	int i,number;\r\n	\r\n\r\n	while( cin>>number )\r\n	{\r\n		int zeroCount=0,positive=0,negative=0;\r\n		_int64 minPosi = _I64_MAX,minNega = 0,maxNega=_I64_MIN;\r\n		_int64 productive=1;\r\n		\r\n		for(i=0;i<number;i++)\r\n			cin >> num[i];\r\n\r\n		for(i=0;i<number;i++)\r\n		{\r\n			if( 0 == num[i] )\r\n				zeroCount++;\r\n			else if(num[i]<0 )\r\n			{\r\n				negative++;\r\n				if(num[i] > maxNega )\r\n					maxNega = num[i];\r\n\r\n				if(num[i] < minNega)\r\n					minNega = num[i];\r\n			}\r\n			else\r\n			{\r\n				positive++;\r\n				if( num[i] < minPosi )\r\n					minPosi = num[i];\r\n			}\r\n		}\r\n\r\n\r\n		if( zeroCount != 0)\r\n		{\r\n			if(1==zeroCount && 0 == negative % 2)\r\n			{\r\n				for(i=0;i<number;i++)\r\n					if( 0 != num[i])\r\n						productive *= num[i];\r\n				cout<<productive<<endl;\r\n\r\n			}\r\n			else\r\n				cout<<0<<endl;\r\n\r\n		}\r\n		else if( 1==negative %2 )\r\n		{\r\n			for(i=0;i<number;i++)\r\n				if( maxNega != num[i])\r\n			productive *= num[i];\r\n\r\n			cout<<productive<<endl;\r\n		}\r\n		else \r\n		{\r\n			if( 0 != positive)\r\n			{\r\n				for(i=0;i<number;i++)\r\n					if( minPosi != num[i])\r\n						productive *= num[i];\r\n\r\n				cout<<productive<<endl;\r\n			}\r\n			else\r\n			{\r\n				for(i=0;i<number;i++)\r\n					if( minNega != num[i])\r\n						productive *= num[i];\r\n\r\n				cout<<productive<<endl;\r\n			}\r\n\r\n		}\r\n	}\r\n	return 0;\r\n	\r\n}', '', 0, 0, 2, 2, '2010-12-29 23:51:34', '0001-01-01 00:00:00'),
(1131, 14, 376, 5, '#include<iostream.h>\r\n#include<limits.h>\r\n\r\nusing namespace std;\r\n\r\n_int64 num[50001];\r\n\r\nint main()\r\n{\r\n	int i,number;\r\n	\r\n\r\n	while( cin>>number )\r\n	{\r\n		int zeroCount=0,positive=0,negative=0;\r\n		_int64 minPosi = _I64_MAX,minNega = 0,maxNega=_I64_MIN;\r\n		_int64 productive=1;\r\n		\r\n		for(i=0;i<number;i++)\r\n			cin >> num[i];\r\n\r\n		for(i=0;i<number;i++)\r\n		{\r\n			if( 0 == num[i] )\r\n				zeroCount++;\r\n			else if(num[i]<0 )\r\n			{\r\n				negative++;\r\n				if(num[i] > maxNega )\r\n					maxNega = num[i];\r\n\r\n				if(num[i] < minNega)\r\n					minNega = num[i];\r\n			}\r\n			else\r\n			{\r\n				positive++;\r\n				if( num[i] < minPosi )\r\n					minPosi = num[i];\r\n			}\r\n		}\r\n\r\n\r\n		if( zeroCount != 0)\r\n		{\r\n			if(1==zeroCount && 0 == negative % 2)\r\n			{\r\n				for(i=0;i<number;i++)\r\n					if( 0 != num[i])\r\n						productive *= num[i];\r\n				cout<<productive<<endl;\r\n\r\n			}\r\n			else\r\n				cout<<0<<endl;\r\n\r\n		}\r\n		else if( 1==negative %2 )\r\n		{\r\n			for(i=0;i<number;i++)\r\n				if( maxNega != num[i])\r\n			productive *= num[i];\r\n\r\n			cout<<productive<<endl;\r\n		}\r\n		else \r\n		{\r\n			if( 0 != positive)\r\n			{\r\n				for(i=0;i<number;i++)\r\n					if( minPosi != num[i])\r\n						productive *= num[i];\r\n\r\n				cout<<productive<<endl;\r\n			}\r\n			else\r\n			{\r\n				for(i=0;i<number;i++)\r\n					if( minNega != num[i])\r\n						productive *= num[i];\r\n\r\n				cout<<productive<<endl;\r\n			}\r\n\r\n		}\r\n	}\r\n	return 0;\r\n	\r\n}', '', 0, 0, 2, 2, '2010-12-29 23:53:12', '0001-01-01 00:00:00');
INSERT INTO `tbl_submitions` (`id`, `user_id`, `problem_id`, `exercise_id`, `source`, `result`, `used_time`, `used_memory`, `status`, `compiler_id`, `created`, `modified`) VALUES
(1132, 27, 336, 2, '#include<stdio.h>\r\n//int a[50001],b[50001];\r\n\r\nint countnumber(int n)\r\n{\r\n		int count=0;\r\n		while(n)\r\n		{\r\n			n=n&(n-1);\r\n			count++;\r\n		}\r\n  	return count;\r\n}\r\n\r\nint Partition(int a[],int b[],int low,int high)\r\n{\r\n	int pivotkey=b[low];\r\n	a[0]=a[low];\r\n	b[0]=b[low];\r\n    while(low<high){\r\n		while(low<high && b[high]>=pivotkey) --high;\r\n		a[low]=a[high];\r\n        b[low]=b[high];\r\n		while(low<high && b[low]<=pivotkey) ++low;\r\n		a[high]=a[low];\r\n		b[high]=b[low];\r\n	}\r\n	a[low]=a[0];\r\n	b[low]=b[0];\r\n	return low;\r\n}\r\n\r\nvoid qsort(int a[],int b[],int low,int high)\r\n{\r\n	int pivotloc;\r\n	if(low<high){\r\n		pivotloc=Partition(a,b,low,high);\r\n		qsort(a,b,low,pivotloc-1);\r\n		qsort(a,b,pivotloc+1,high);\r\n	}\r\n}\r\n\r\n\r\nint main()\r\n{\r\n	int n,i,j,k,m,c,first;\r\n	int a[50001],b[50001];\r\n	while(scanf("%d",&n)==1)\r\n	{  \r\n		a[0]=0;\r\n		b[0]=0;\r\n		for(i=1;i<=n;++i){\r\n			scanf("%d",&a[i]);\r\n		    b[i]=countnumber(a[i]);\r\n		}\r\n\r\n		qsort(a,b,1,n);		\r\n        for(i=1;i<=n;++i){	\r\n			m=b[i];\r\n			first=i;\r\n			while(m==b[i+1]) ++i;\r\n			if(first!=i){\r\n				qsort(b,a,first,i);\r\n/*				for(k=1;k<i-first;++k){\r\n	            	for(j=first;j<i;++j){\r\n	            		if(a[j]>a[j+1]){\r\n	            			c=a[j];\r\n	            			a[j]=a[j+1];\r\n	            			a[j+1]=c;\r\n						}\r\n					}\r\n				}\r\n		*/\r\n			}\r\n		}\r\n	\r\n		for(i=1;i<=n;++i) printf("%d  ",a[i]);\r\n		printf("\\n");\r\n	}\r\n	return 0;\r\n}', '', 46, 708608, 3, 1, '2010-12-30 01:30:31', '0001-01-01 00:00:00'),
(1133, 27, 336, 2, '#include<stdio.h>\r\n//int a[50001],b[50001];\r\n\r\nint countnumber(int n)\r\n{\r\n		int count=0;\r\n		while(n)\r\n		{\r\n			n=n&(n-1);\r\n			count++;\r\n		}\r\n  	return count;\r\n}\r\n\r\nint Partition(int a[],int b[],int low,int high)\r\n{\r\n	int pivotkey=b[low];\r\n	a[0]=a[low];\r\n	b[0]=b[low];\r\n    while(low<high){\r\n		while(low<high && b[high]>=pivotkey) --high;\r\n		a[low]=a[high];\r\n        b[low]=b[high];\r\n		while(low<high && b[low]<=pivotkey) ++low;\r\n		a[high]=a[low];\r\n		b[high]=b[low];\r\n	}\r\n	a[low]=a[0];\r\n	b[low]=b[0];\r\n	return low;\r\n}\r\n\r\nvoid qsort(int a[],int b[],int low,int high)\r\n{\r\n	int pivotloc;\r\n	if(low<high){\r\n		pivotloc=Partition(a,b,low,high);\r\n		qsort(a,b,low,pivotloc-1);\r\n		qsort(a,b,pivotloc+1,high);\r\n	}\r\n}\r\n\r\n\r\nint main()\r\n{\r\n//	int n,i,j,k,m,c,first;\r\n	int n,i,m,first;\r\n	int a[50001],b[50001];\r\n	while(scanf("%d",&n)==1)\r\n	{  \r\n		a[0]=0;\r\n		b[0]=0;\r\n		for(i=1;i<=n;++i){\r\n			scanf("%d",&a[i]);\r\n		    b[i]=countnumber(a[i]);\r\n		}\r\n\r\n		qsort(a,b,1,n);		\r\n        for(i=1;i<=n;++i){	\r\n			m=b[i];\r\n			first=i;\r\n			while(m==b[i+1]) ++i;\r\n			if(first!=i){\r\n				qsort(b,a,first,i);\r\n/*				for(k=1;k<i-first;++k){\r\n	            	for(j=first;j<i;++j){\r\n	            		if(a[j]>a[j+1]){\r\n	            			c=a[j];\r\n	            			a[j]=a[j+1];\r\n	            			a[j+1]=c;\r\n						}\r\n					}\r\n				}\r\n		*/\r\n			}\r\n		}\r\n	\r\n		for(i=1;i<=n;++i) printf("%d  ",a[i]);\r\n//		printf("\\n");\r\n	}\r\n	return 0;\r\n}', '', 46, 708608, 3, 1, '2010-12-30 01:35:16', '0001-01-01 00:00:00'),
(1134, 10, 402, 8, '#include<stdio.h>\r\n#include<string.h>\r\n\r\nint main(){\r\n int size_a,size_b,i,asize,bsize,size,k;\r\n char a[2000],b[2000],c[2000],jinwei;\r\n scanf("%d",&size);\r\n for(k=1;k != size+1;k++)\r\n {\r\n	 size_a = size_b= i=0;\r\n	 scanf("%s",a);\r\n	 size_a =strlen(a);\r\n	 asize = size_a-1;\r\n	 \r\n	 scanf("%s",b);\r\n	 size_b =strlen(b);\r\n	 bsize = size_b-1;\r\n	 \r\n	 jinwei=''0'';\r\n	 if(size_a > size_b)\r\n	 {\r\n		  while(i != size_b)\r\n		  {\r\n			   if(a[asize]+b[bsize]+jinwei > 153){\r\n				c[asize] = a[asize]+b[bsize]+jinwei-106;\r\n				jinwei = 49;}\r\n			   else\r\n			   {\r\n				c[asize] = a[asize]+b[bsize]+jinwei-96;\r\n				jinwei = 48;}\r\n				--asize;--bsize;\r\n		   ++i;\r\n		  }\r\n		  while(i != size_a)\r\n		  {\r\n			   if(jinwei == ''1'')\r\n			   {\r\n				c[size_a-i-1] = a[size_a-i-1] +1;\r\n				jinwei = 48;\r\n			   }\r\n			   else\r\n			   c[size_a-i-1] = a[size_a-i-1];\r\n			   ++i;\r\n		  }\r\n		  printf("Case %d\\n",k);\r\n		  for(int i=0;i != size_a;++i)\r\n		  printf("%c",c[i]);\r\n		  printf("\\n");\r\n	 }\r\n	 else if(size_a < size_b)\r\n	 {\r\n		  while(i != size_a)\r\n		  {\r\n			   if(a[asize]+b[bsize]+jinwei > 153){\r\n				c[asize] = a[asize]+b[bsize]+jinwei-106;\r\n				jinwei = 49;}\r\n			   else\r\n			   {\r\n				c[asize] = a[asize]+b[bsize]+jinwei-96;\r\n				jinwei = 48;}\r\n						--asize;--bsize;\r\n			   ++i;\r\n		  }\r\n		  while(i != size_b)\r\n		  {\r\n			   if(jinwei == ''1'')\r\n			   {\r\n				c[size_a-i-1] = b[size_a-i-1] +1;\r\n				jinwei = 48;\r\n			   }\r\n			   else\r\n			   c[size_a-i-1] = b[size_a-i-1];\r\n			   ++i;\r\n		  }\r\n		  printf("Case %d\\n",k);\r\n		  for(int i=0;i != size_b;++i)\r\n		  printf("%c",c[i]);\r\n		  printf("\\n");\r\n	 }else\r\n	 {\r\n		  while(i != size_a)\r\n		  {\r\n			   if(a[asize]+b[bsize]+jinwei > 153){\r\n				c[asize] = a[asize]+b[bsize]+jinwei-106;\r\n				jinwei = 49;}\r\n			   else\r\n			   {\r\n				c[asize] = a[asize]+b[bsize]+jinwei-96;\r\n				jinwei = 48;}\r\n				--asize;--bsize;\r\n			   ++i;\r\n		  }\r\n		  printf("Case %d\\n",k);\r\n		  if(jinwei == ''1'')\r\n		  printf("1");\r\n	      for(int i=0;i != size_b;++i)\r\n	      printf("%c",c[i]);\r\n		  printf("\\n");\r\n	 }\r\n } \r\n return 0;\r\n}', 'Main.c: In function ''main'':\r\nMain.c:46:5: error: ''for'' loop initial declarations are only allowed in C99 mode\r\nMain.c:46:5: note: use option -std=c99 or -std=gnu99 to compile your code\r\nMain.c:76:5: error: ''for'' loop initial declarations are only allowed in C99 mode\r\nMain.c:96:8: error: ''for'' loop initial declarations are only allowed in C99 mode\r\n', 0, 0, 2, 1, '2010-12-30 09:13:19', '0001-01-01 00:00:00'),
(1135, 10, 402, 8, '#include<stdio.h>\r\n#include<string.h>\r\n\r\nint main(){\r\n int size_a,size_b,i,asize,bsize,size,k;\r\n char a[2000],b[2000],c[2000],jinwei;\r\n scanf("%d",&size);\r\n for(k=1;k != size+1;k++)\r\n {\r\n	 size_a = size_b= i=0;\r\n	 scanf("%s",a);\r\n	 size_a =strlen(a);\r\n	 asize = size_a-1;\r\n	 \r\n	 scanf("%s",b);\r\n	 size_b =strlen(b);\r\n	 bsize = size_b-1;\r\n	 \r\n	 jinwei=''0'';\r\n	 if(size_a > size_b)\r\n	 {\r\n		  while(i != size_b)\r\n		  {\r\n			   if(a[asize]+b[bsize]+jinwei > 153){\r\n				c[asize] = a[asize]+b[bsize]+jinwei-106;\r\n				jinwei = 49;}\r\n			   else\r\n			   {\r\n				c[asize] = a[asize]+b[bsize]+jinwei-96;\r\n				jinwei = 48;}\r\n				--asize;--bsize;\r\n		   ++i;\r\n		  }\r\n		  while(i != size_a)\r\n		  {\r\n			   if(jinwei == ''1'')\r\n			   {\r\n				c[size_a-i-1] = a[size_a-i-1] +1;\r\n				jinwei = 48;\r\n			   }\r\n			   else\r\n			   c[size_a-i-1] = a[size_a-i-1];\r\n			   ++i;\r\n		  }\r\n		  printf("Case %d\\n",k);\r\n		  for( i=0;i != size_a;++i)\r\n		  printf("%c",c[i]);\r\n		  printf("\\n");\r\n	 }\r\n	 else if(size_a < size_b)\r\n	 {\r\n		  while(i != size_a)\r\n		  {\r\n			   if(a[asize]+b[bsize]+jinwei > 153){\r\n				c[asize] = a[asize]+b[bsize]+jinwei-106;\r\n				jinwei = 49;}\r\n			   else\r\n			   {\r\n				c[asize] = a[asize]+b[bsize]+jinwei-96;\r\n				jinwei = 48;}\r\n						--asize;--bsize;\r\n			   ++i;\r\n		  }\r\n		  while(i != size_b)\r\n		  {\r\n			   if(jinwei == ''1'')\r\n			   {\r\n				c[size_a-i-1] = b[size_a-i-1] +1;\r\n				jinwei = 48;\r\n			   }\r\n			   else\r\n			   c[size_a-i-1] = b[size_a-i-1];\r\n			   ++i;\r\n		  }\r\n		  printf("Case %d\\n",k);\r\n		  for(i=0;i != size_b;++i)\r\n		  printf("%c",c[i]);\r\n		  printf("\\n");\r\n	 }else\r\n	 {\r\n		  while(i != size_a)\r\n		  {\r\n			   if(a[asize]+b[bsize]+jinwei > 153){\r\n				c[asize] = a[asize]+b[bsize]+jinwei-106;\r\n				jinwei = 49;}\r\n			   else\r\n			   {\r\n				c[asize] = a[asize]+b[bsize]+jinwei-96;\r\n				jinwei = 48;}\r\n				--asize;--bsize;\r\n			   ++i;\r\n		  }\r\n		  printf("Case %d\\n",k);\r\n		  if(jinwei == ''1'')\r\n		  printf("1");\r\n	      for(i=0;i != size_b;++i)\r\n	      printf("%c",c[i]);\r\n		  printf("\\n");\r\n	 }\r\n } \r\n return 0;\r\n}', '', 31, 258048, 4, 1, '2010-12-30 09:16:15', '0001-01-01 00:00:00'),
(1136, 10, 402, 8, '#include<stdio.h>\r\n#include<string.h>\r\n\r\nint main(){\r\n int size_a,size_b,i,asize,bsize,size,k;\r\n char a[2000],b[2000],c[2000],jinwei;\r\n scanf("%d",&size);\r\n for(k=1;k != size+1;k++)\r\n {\r\n	 size_a = size_b= i=0;\r\n	 scanf("%s",a);\r\n	 size_a =strlen(a);\r\n	 asize = size_a-1;\r\n	 \r\n	 scanf("%s",b);\r\n	 size_b =strlen(b);\r\n	 bsize = size_b-1;\r\n	 \r\n	 jinwei=''0'';\r\n	 if(size_a > size_b)\r\n	 {\r\n		  while(i != size_b)\r\n		  {\r\n			   if(a[asize]+b[bsize]+jinwei > 153){\r\n				c[asize] = a[asize]+b[bsize]+jinwei-106;\r\n				jinwei = 49;}\r\n			   else\r\n			   {\r\n				c[asize] = a[asize]+b[bsize]+jinwei-96;\r\n				jinwei = 48;}\r\n				--asize;--bsize;\r\n		        ++i;\r\n		  }\r\n		  while(i != size_a)\r\n		  {\r\n			   if(jinwei == ''1'')\r\n			   {\r\n				c[size_a-i-1] = a[size_a-i-1] +1;\r\n				jinwei = 48;\r\n			   }\r\n			   else\r\n			   c[size_a-i-1] = a[size_a-i-1];\r\n			   ++i;\r\n		  }\r\n		  printf("Case %d\\n",k);\r\n		  for( i=0;i != size_a;++i)\r\n		  printf("%c",c[i]);\r\n		  printf("\\n");\r\n	 }\r\n	 else if(size_a < size_b)\r\n	 {\r\n		  while(i != size_a)\r\n		  {\r\n			   if(a[asize]+b[bsize]+jinwei > 153){\r\n				c[bsize] = a[asize]+b[bsize]+jinwei-106;\r\n				jinwei = 49;}\r\n			   else\r\n			   {\r\n				c[bsize] = a[asize]+b[bsize]+jinwei-96;\r\n				jinwei = 48;}\r\n				--asize;--bsize;\r\n			   ++i;\r\n		  }\r\n		  while(i != size_b)\r\n		  {\r\n			   if(jinwei == ''1'')\r\n			   {\r\n				c[size_b-i-1] = b[size_b-i-1] +1;\r\n				jinwei = 48;\r\n			   }\r\n			   else\r\n			   c[size_b-i-1] = b[size_b-i-1];\r\n			   ++i;\r\n		  }\r\n		  printf("Case %d\\n",k);\r\n		  for(i=0;i != size_b;++i)\r\n		  printf("%c",c[i]);\r\n		  printf("\\n");\r\n	 }else\r\n	 {\r\n		  while(i != size_a)\r\n		  {\r\n			   if(a[asize]+b[bsize]+jinwei > 153){\r\n				c[asize] = a[asize]+b[bsize]+jinwei-106;\r\n				jinwei = 49;}\r\n			   else\r\n			   {\r\n				c[asize] = a[asize]+b[bsize]+jinwei-96;\r\n				jinwei = 48;}\r\n				--asize;--bsize;\r\n			   ++i;\r\n		  }\r\n		  printf("Case %d\\n",k);\r\n		  if(jinwei == ''1'')\r\n		  printf("1");\r\n	      for(i=0;i != size_b;++i)\r\n	      printf("%c",c[i]);\r\n		  printf("\\n");\r\n	 }\r\n } \r\n getchar();\r\n  getchar();\r\n return 0;\r\n}', '', 15, 258048, 4, 1, '2010-12-30 09:22:55', '0001-01-01 00:00:00'),
(1137, 10, 402, 8, '#include<stdio.h>\r\n#include<string.h>\r\n\r\nint main(){\r\n int size_a,size_b,i,asize,bsize,size,k;\r\n char a[2000],b[2000],c[2000],jinwei;\r\n scanf("%d",&size);\r\n for(k=1;k != size+1;k++)\r\n {\r\n	 size_a = size_b= i=0;\r\n	 jinwei = 48;\r\n	 scanf("%s",a);\r\n	 size_a =strlen(a);\r\n	 asize = size_a-1;\r\n	 \r\n	 scanf("%s",b);\r\n	 size_b =strlen(b);\r\n	 bsize = size_b-1;\r\n	 \r\n	 jinwei=''0'';\r\n	 if(size_a > size_b)\r\n	 {\r\n		  while(i != size_b)\r\n		  {\r\n			   if(a[asize]+b[bsize]+jinwei > 153){\r\n				c[asize] = a[asize]+b[bsize]+jinwei-106;\r\n				jinwei = 49;}\r\n			   else\r\n			   {\r\n				c[asize] = a[asize]+b[bsize]+jinwei-96;\r\n				jinwei = 48;}\r\n				--asize;--bsize;\r\n		        ++i;\r\n		  }\r\n		  while(i != size_a)\r\n		  {\r\n			   if(jinwei == ''1'')\r\n			   {\r\n				c[size_a-i-1] = a[size_a-i-1] +1;\r\n				jinwei = 48;\r\n			   }\r\n			   else\r\n			   c[size_a-i-1] = a[size_a-i-1];\r\n			   ++i;\r\n		  }\r\n		  printf("Case %d\\n",k);\r\n		  for( i=0;i != size_a;++i)\r\n		  printf("%c",c[i]);\r\n		  printf("\\n");\r\n	 }\r\n	 else if(size_a < size_b)\r\n	 {\r\n		  while(i != size_a)\r\n		  {\r\n			   if(a[asize]+b[bsize]+jinwei > 153){\r\n				c[bsize] = a[asize]+b[bsize]+jinwei-106;\r\n				jinwei = 49;}\r\n			   else\r\n			   {\r\n				c[bsize] = a[asize]+b[bsize]+jinwei-96;\r\n				jinwei = 48;}\r\n				--asize;--bsize;\r\n			   ++i;\r\n		  }\r\n		  while(i != size_b)\r\n		  {\r\n			   if(jinwei == ''1'')\r\n			   {\r\n				c[size_b-i-1] = b[size_b-i-1] +1;\r\n				jinwei = 48;\r\n			   }\r\n			   else\r\n			   c[size_b-i-1] = b[size_b-i-1];\r\n			   ++i;\r\n		  }\r\n		  printf("Case %d\\n",k);\r\n		  for(i=0;i != size_b;++i)\r\n		  printf("%c",c[i]);\r\n		  printf("\\n");\r\n	 }else\r\n	 {\r\n		  while(i != size_a)\r\n		  {\r\n			   if(a[asize]+b[bsize]+jinwei > 153){\r\n				c[asize] = a[asize]+b[bsize]+jinwei-106;\r\n				jinwei = 49;}\r\n			   else\r\n			   {\r\n				c[asize] = a[asize]+b[bsize]+jinwei-96;\r\n				jinwei = 48;}\r\n				--asize;--bsize;\r\n			   ++i;\r\n		  }\r\n		  printf("Case %d\\n",k);\r\n		  if(jinwei == ''1'')\r\n		  printf("1");\r\n	      for(i=0;i != size_b;++i)\r\n	      printf("%c",c[i]);\r\n		  printf("\\n");\r\n	 }\r\n } \r\n return 0;\r\n}', '', 0, 253952, 4, 1, '2010-12-30 09:24:17', '0001-01-01 00:00:00'),
(1138, 10, 402, 8, '#include<stdio.h>\r\n#include<string.h>\r\n\r\nint main(){\r\n int size_a,size_b,i,asize,bsize,size,k;\r\n char a[2000],b[2000],c[2000],jinwei;\r\n scanf("%d",&size);\r\n for(k=1;k != size+1;k++)\r\n {\r\n	 size_a = size_b= i=0;\r\n	 jinwei = 48;\r\n	 scanf("%s",a);\r\n	 size_a =strlen(a);\r\n	 asize = size_a-1;\r\n	 \r\n	 scanf("%s",b);\r\n	 size_b =strlen(b);\r\n	 bsize = size_b-1;\r\n	 \r\n	 jinwei=''0'';\r\n	 if(size_a > size_b)\r\n	 {\r\n		  while(i != size_b)\r\n		  {\r\n			   if(a[asize]+b[bsize]+jinwei > 153){\r\n				c[asize] = a[asize]+b[bsize]+jinwei-106;\r\n				jinwei = 49;}\r\n			   else\r\n			   {\r\n				c[asize] = a[asize]+b[bsize]+jinwei-96;\r\n				jinwei = 48;}\r\n				--asize;--bsize;\r\n		        ++i;\r\n		  }\r\n		  while(i != size_a)\r\n		  {\r\n			   if(jinwei == ''1'')\r\n			   {\r\n				c[size_a-i-1] = a[size_a-i-1] +1;\r\n				jinwei = 48;\r\n			   }\r\n			   else\r\n			   c[size_a-i-1] = a[size_a-i-1];\r\n			   ++i;\r\n		  }\r\n		  printf("Case %d\\n",k);\r\n		  printf("%s + %s =",a,b);\r\n		  for( i=0;i != size_a;++i)\r\n		  printf("%c",c[i]);\r\n		  printf("\\n");\r\n	 }\r\n	 else if(size_a < size_b)\r\n	 {\r\n		  while(i != size_a)\r\n		  {\r\n			   if(a[asize]+b[bsize]+jinwei > 153){\r\n				c[bsize] = a[asize]+b[bsize]+jinwei-106;\r\n				jinwei = 49;}\r\n			   else\r\n			   {\r\n				c[bsize] = a[asize]+b[bsize]+jinwei-96;\r\n				jinwei = 48;}\r\n				--asize;--bsize;\r\n			   ++i;\r\n		  }\r\n		  while(i != size_b)\r\n		  {\r\n			   if(jinwei == ''1'')\r\n			   {\r\n				c[size_b-i-1] = b[size_b-i-1] +1;\r\n				jinwei = 48;\r\n			   }\r\n			   else\r\n			   c[size_b-i-1] = b[size_b-i-1];\r\n			   ++i;\r\n		  }\r\n		  printf("Case %d\\n",k);\r\n		  printf("%s + %s =",a,b);\r\n		  for(i=0;i != size_b;++i)\r\n		  printf("%c",c[i]);\r\n		  printf("\\n");\r\n	 }else\r\n	 {\r\n		  while(i != size_a)\r\n		  {\r\n			   if(a[asize]+b[bsize]+jinwei > 153){\r\n				c[asize] = a[asize]+b[bsize]+jinwei-106;\r\n				jinwei = 49;}\r\n			   else\r\n			   {\r\n				c[asize] = a[asize]+b[bsize]+jinwei-96;\r\n				jinwei = 48;}\r\n				--asize;--bsize;\r\n			   ++i;\r\n		  }\r\n		  printf("Case %d\\n",k);\r\n		  printf("%s + %s =",a,b);\r\n		  if(jinwei == ''1'')\r\n		  printf("1");\r\n	      for(i=0;i != size_b;++i)\r\n	      printf("%c",c[i]);\r\n		  printf("\\n");\r\n	 }\r\n } \r\n return 0;\r\n}', '', 15, 258048, 4, 1, '2010-12-30 09:28:08', '0001-01-01 00:00:00'),
(1139, 10, 402, 8, '#include<stdio.h>\r\n#include<string.h>\r\n\r\nint main(){\r\n int size_a,size_b,i,asize,bsize,size,k;\r\n char a[2000],b[2000],c[2000],jinwei;\r\n scanf("%d",&size);\r\n for(k=1;k != size+1;k++)\r\n {\r\n	 size_a = size_b= i=0;\r\n	 jinwei = 48;\r\n	 scanf("%s",a);\r\n	 size_a =strlen(a);\r\n	 asize = size_a-1;\r\n	 \r\n	 scanf("%s",b);\r\n	 size_b =strlen(b);\r\n	 bsize = size_b-1;\r\n	 \r\n	 jinwei=''0'';\r\n	 if(size_a > size_b)\r\n	 {\r\n		  while(i != size_b)\r\n		  {\r\n			   if(a[asize]+b[bsize]+jinwei > 153){\r\n				c[asize] = a[asize]+b[bsize]+jinwei-106;\r\n				jinwei = 49;}\r\n			   else\r\n			   {\r\n				c[asize] = a[asize]+b[bsize]+jinwei-96;\r\n				jinwei = 48;}\r\n				--asize;--bsize;\r\n		        ++i;\r\n		  }\r\n		  while(i != size_a)\r\n		  {\r\n			   if(jinwei == ''1'')\r\n			   {\r\n				c[size_a-i-1] = a[size_a-i-1] +1;\r\n				jinwei = 48;\r\n			   }\r\n			   else\r\n			   c[size_a-i-1] = a[size_a-i-1];\r\n			   ++i;\r\n		  }\r\n		  printf("Case %d:\\n",k);\r\n		  printf("%s + %s = ",a,b);\r\n		  for( i=0;i != size_a;++i)\r\n		  printf("%c",c[i]);\r\n		  printf("\\n");\r\n	 }\r\n	 else if(size_a < size_b)\r\n	 {\r\n		  while(i != size_a)\r\n		  {\r\n			   if(a[asize]+b[bsize]+jinwei > 153){\r\n				c[bsize] = a[asize]+b[bsize]+jinwei-106;\r\n				jinwei = 49;}\r\n			   else\r\n			   {\r\n				c[bsize] = a[asize]+b[bsize]+jinwei-96;\r\n				jinwei = 48;}\r\n				--asize;--bsize;\r\n			   ++i;\r\n		  }\r\n		  while(i != size_b)\r\n		  {\r\n			   if(jinwei == ''1'')\r\n			   {\r\n				c[size_b-i-1] = b[size_b-i-1] +1;\r\n				jinwei = 48;\r\n			   }\r\n			   else\r\n			   c[size_b-i-1] = b[size_b-i-1];\r\n			   ++i;\r\n		  }\r\n		  printf("Case %d\\n",k);\r\n		  printf("%s + %s = ",a,b);\r\n		  for(i=0;i != size_b;++i)\r\n		  printf("%c",c[i]);\r\n		  printf("\\n");\r\n	 }else\r\n	 {\r\n		  while(i != size_a)\r\n		  {\r\n			   if(a[asize]+b[bsize]+jinwei > 153){\r\n				c[asize] = a[asize]+b[bsize]+jinwei-106;\r\n				jinwei = 49;}\r\n			   else\r\n			   {\r\n				c[asize] = a[asize]+b[bsize]+jinwei-96;\r\n				jinwei = 48;}\r\n				--asize;--bsize;\r\n			   ++i;\r\n		  }\r\n		  printf("Case %d\\n",k);\r\n		  printf("%s + %s = ",a,b);\r\n		  if(jinwei == ''1'')\r\n		  printf("1");\r\n	      for(i=0;i != size_b;++i)\r\n	      printf("%c",c[i]);\r\n		  printf("\\n");\r\n	 }\r\n } \r\n return 0;\r\n}', '', 31, 258048, 4, 1, '2010-12-30 09:29:31', '0001-01-01 00:00:00'),
(1140, 17, 404, 9, '#include <iostream>\r\n#include<stdio.h>\r\nusing namespace std;\r\nconst int MAXN = 31;\r\nstruct mat_T {\r\n    int matrix[MAXN][MAXN];\r\n};\r\nmat_T mat;\r\nint n, mod;\r\n\r\nmat_T mul(mat_T a, mat_T b) \r\n{\r\n    int i, j, k;\r\n    mat_T c;\r\n    for(i = 0; i < 4; i ++) {\r\n        for(j = 0; j < 4; j ++) {\r\n            c.matrix[i][j] = 0;\r\n            for(k = 0; k < 4; k ++) {\r\n                c.matrix[i][j] += a.matrix[i][k] * b.matrix[k][j];\r\n                c.matrix[i][j] %= 2011;\r\n            }\r\n        }\r\n    }\r\n    return c;\r\n}\r\n \r\nmat_T myPow2(int k)\r\n{   \r\n	mat_T d;\r\n	int i;\r\n	int l,j;\r\n    d = mat;\r\n	for(i=0;i<k-1;i++)\r\n	{\r\n		d = mul(mat,d);\r\n\r\n	}\r\n   return d;\r\n}\r\n\r\n\r\nint main() \r\n{\r\n    int i, j, k;\r\n    scanf("%d", &n);\r\n	while(n--){\r\n    for(i = 0; i < 4; i ++)\r\n        for(j = 0; j < 4; j ++)\r\n		{\r\n			scanf("%d", &mat.matrix[i][j]);\r\n		}\r\n    mat_T mt = myPow2(2011);\r\n    for(i = 0; i < 4; i ++) {\r\n        for(j = 0; j < 3; j ++)\r\n            printf("%d ", mt.matrix[i][j]);\r\n        printf("%d\\n", mt.matrix[i][j]);\r\n    }\r\n	if(n!=0)\r\n		printf("\\n");\r\n	}\r\n    return 0;\r\n}\r\n', '', 300, 368640, 5, 2, '2010-12-30 09:35:13', '0001-01-01 00:00:00'),
(1141, 10, 402, 8, '#include<stdio.h>\r\n#include<string.h>\r\n\r\nint main(){\r\n int size_a,size_b,i,asize,bsize,size,k;\r\n char a[2000],b[2000],c[2000],jinwei;\r\n scanf("%d",&size);\r\n for(k=1;k != size+1;k++)\r\n {\r\n	 size_a = size_b= i=0;\r\n	 jinwei = 48;\r\n	 scanf("%s",a);\r\n	 size_a =strlen(a);\r\n	 asize = size_a-1;\r\n	 \r\n	 scanf("%s",b);\r\n	 size_b =strlen(b);\r\n	 bsize = size_b-1;\r\n	 \r\n	 jinwei=''0'';\r\n	 if(size_a > size_b)\r\n	 {\r\n		  while(i != size_b)\r\n		  {\r\n			   if(a[asize]+b[bsize]+jinwei > 153){\r\n				c[asize] = a[asize]+b[bsize]+jinwei-106;\r\n				jinwei = 49;}\r\n			   else\r\n			   {\r\n				c[asize] = a[asize]+b[bsize]+jinwei-96;\r\n				jinwei = 48;}\r\n				--asize;--bsize;\r\n		        ++i;\r\n		  }\r\n		  while(i != size_a)\r\n		  {\r\n			   if(jinwei == ''1'')\r\n			   {\r\n				   if(b[size_a-i-1] == ''9'')\r\n					   c[size_a-i-1] = ''0'';\r\n				   else\r\n				   {\r\n				       c[size_a-i-1] = b[size_a-i-1] +1;\r\n				       jinwei = 48;\r\n				   }\r\n			   }\r\n			   else\r\n			   c[size_a-i-1] = a[size_a-i-1];\r\n			   ++i;\r\n		  }\r\n		  printf("Case %d:\\n",k);\r\n		  printf("%s + %s = ",a,b);\r\n		  if(jinwei == ''1'')\r\n			  printf("1");\r\n		  for( i=0;i != size_a;++i)\r\n		  printf("%c",c[i]);\r\n		  printf("\\n");\r\n	 }\r\n	 else if(size_a < size_b)\r\n	 {\r\n		  while(i != size_a)\r\n		  {\r\n			   if(a[asize]+b[bsize]+jinwei > 153){\r\n				c[bsize] = a[asize]+b[bsize]+jinwei-106;\r\n				jinwei = 49;}\r\n			   else\r\n			   {\r\n				c[bsize] = a[asize]+b[bsize]+jinwei-96;\r\n				jinwei = 48;}\r\n				--asize;--bsize;\r\n			   ++i;\r\n		  }\r\n		  while(i != size_b)\r\n		  {\r\n			   if(jinwei == ''1'')\r\n			   {\r\n				   if(b[size_b-i-1] == ''9'')\r\n					   c[size_b-i-1] = ''0'';\r\n				   else\r\n				   {\r\n				       c[size_b-i-1] = b[size_b-i-1] +1;\r\n				       jinwei = 48;\r\n				   }\r\n			   }\r\n			   else\r\n			   c[size_b-i-1] = b[size_b-i-1];\r\n			   ++i;\r\n		  }\r\n		  printf("Case %d:\\n",k);\r\n		  printf("%s + %s = ",a,b);\r\n		  if(jinwei == ''1'')\r\n			  printf("1");\r\n		  for(i=0;i != size_b;++i)\r\n		  printf("%c",c[i]);\r\n		  printf("\\n");\r\n	 }else\r\n	 {\r\n		  while(i != size_a)\r\n		  {\r\n			   if(a[asize]+b[bsize]+jinwei > 153){\r\n				c[asize] = a[asize]+b[bsize]+jinwei-106;\r\n				jinwei = 49;}\r\n			   else\r\n			   {\r\n				c[asize] = a[asize]+b[bsize]+jinwei-96;\r\n				jinwei = 48;}\r\n				--asize;--bsize;\r\n			   ++i;\r\n		  }\r\n		  printf("Case %d:\\n",k);\r\n		  printf("%s + %s = ",a,b);\r\n		  if(jinwei == ''1'')\r\n		  printf("1");\r\n	      for(i=0;i != size_b;++i)\r\n	      printf("%c",c[i]);\r\n		  printf("\\n");\r\n	 }\r\n } \r\n return 0;\r\n}', '', 15, 258048, 4, 1, '2010-12-30 09:52:25', '0001-01-01 00:00:00'),
(1142, 17, 404, 9, '#include <iostream>\r\n#include<stdio.h>\r\nusing namespace std;\r\nconst int MAXN = 31;\r\nstruct mat_T {\r\n    int matrix[MAXN][MAXN];\r\n};\r\nmat_T mat;\r\nint n, mod;\r\n\r\nmat_T mul(mat_T a, mat_T b) \r\n{\r\n    int i, j, k;\r\n    mat_T c;\r\n    for(i = 0; i < 4; i ++) {\r\n        for(j = 0; j < 4; j ++) {\r\n            c.matrix[i][j] = 0;\r\n            for(k = 0; k < 4; k ++) {\r\n                c.matrix[i][j] += a.matrix[i][k] * b.matrix[k][j];\r\n                c.matrix[i][j] %= 2011;\r\n            }\r\n        }\r\n    }\r\n    return c;\r\n}\r\nmat_T myPow2(int k) \r\n{   \r\n    if(k == 1){\r\n        return mat;\r\n    }\r\n 	else if(k % 2) {\r\n        return mul(myPow2(k -1), mat);\r\n    }\r\n	else {\r\n        mat_T mt = myPow2(k/2);\r\n        return mul(mt, mt);\r\n    }\r\n}\r\n\r\n\r\nint main() \r\n{\r\n    int i, j, k;\r\n    scanf("%d", &n);\r\n	while(n--){\r\n    for(i = 0; i < 4; i ++)\r\n        for(j = 0; j < 4; j ++)\r\n		{\r\n			scanf("%d", &mat.matrix[i][j]);\r\n		}\r\n    mat_T mt = myPow2(2011);\r\n    for(i = 0; i < 4; i ++) {\r\n        for(j = 0; j < 3; j ++)\r\n            printf("%d ", mt.matrix[i][j]);\r\n        printf("%d\\n", mt.matrix[i][j]);\r\n    }\r\n	if(n!=0)\r\n		printf("\\n");\r\n	}\r\n    return 0;\r\n}\r\n', '', 15, 626688, 3, 2, '2010-12-30 09:54:43', '0001-01-01 00:00:00'),
(1143, 17, 404, 9, '#include <iostream>\r\n#include<stdio.h>\r\nusing namespace std;\r\nconst int MAXN = 31;\r\nstruct mat_T {\r\n    int matrix[MAXN][MAXN];\r\n};\r\nmat_T mat;\r\nint n, mod;\r\n\r\nmat_T mul(mat_T a, mat_T b) \r\n{\r\n    int i, j, k;\r\n    mat_T c;\r\n    for(i = 0; i < 4; i ++) {\r\n        for(j = 0; j < 4; j ++) {\r\n            c.matrix[i][j] = 0;\r\n            for(k = 0; k < 4; k ++) {\r\n                c.matrix[i][j] += a.matrix[i][k] * b.matrix[k][j];\r\n                c.matrix[i][j] %= 2011;\r\n            }\r\n        }\r\n    }\r\n    return c;\r\n}\r\nmat_T myPow2(int k) \r\n{   \r\n    if(k == 1){\r\n        return mat;\r\n    }\r\n 	else if(k % 2) {\r\n        return mul(myPow2(k -1), mat);\r\n    }\r\n	else {\r\n        mat_T mt = myPow2(k/2);\r\n        return mul(mt, mt);\r\n    }\r\n}\r\n\r\n\r\nint main() \r\n{\r\n    int i, j, k;\r\n    scanf("%d", &n);\r\n	while(n--){\r\n    for(i = 0; i < 4; i ++)\r\n        for(j = 0; j < 4; j ++)\r\n		{\r\n			scanf("%d", &mat.matrix[i][j]);\r\n		}\r\n    mat_T mt = myPow2(2011);\r\n    for(i = 0; i < 4; i ++) {\r\n        for(j = 0; j < 3; j ++)\r\n            printf("%d ", mt.matrix[i][j]);\r\n        printf("%d\\n", mt.matrix[i][j]);\r\n    }\r\n\r\n	}\r\n    return 0;\r\n}\r\n', '', 15, 622592, 3, 2, '2010-12-30 09:56:18', '0001-01-01 00:00:00'),
(1144, 27, 336, 2, '#include<stdio.h>\r\n//int a[50001],b[50001];\r\n\r\nint countnumber(int n)\r\n{\r\n		int count=0;\r\n		while(n)\r\n		{\r\n			n=n&(n-1);\r\n			count++;\r\n		}\r\n  	return count;\r\n}\r\n\r\nint Partition(int a[],int b[],int low,int high)\r\n{\r\n	int pivotkey=b[low];\r\n	a[0]=a[low];\r\n	b[0]=b[low];\r\n    while(low<high){\r\n		while(low<high && b[high]>=pivotkey) --high;\r\n		a[low]=a[high];\r\n        b[low]=b[high];\r\n		while(low<high && b[low]<=pivotkey) ++low;\r\n		a[high]=a[low];\r\n		b[high]=b[low];\r\n	}\r\n	a[low]=a[0];\r\n	b[low]=b[0];\r\n	return low;\r\n}\r\n\r\nvoid qsort(int a[],int b[],int low,int high)\r\n{\r\n	int pivotloc;\r\n	if(low<high){\r\n		pivotloc=Partition(a,b,low,high);\r\n		qsort(a,b,low,pivotloc-1);\r\n		qsort(a,b,pivotloc+1,high);\r\n	}\r\n}\r\n\r\n\r\nint main()\r\n{\r\n//	int n,i,j,k,m,c,first;\r\n	int n,i,m,first;\r\n	int a[50001],b[50001];\r\n	while(scanf("%d",&n)==1)\r\n	{  \r\n		a[0]=0;\r\n		b[0]=0;\r\n		for(i=1;i<=n;++i){\r\n			scanf("%d",&a[i]);\r\n		    b[i]=countnumber(a[i]);\r\n		}\r\n\r\n		qsort(a,b,1,n);		\r\n        for(i=1;i<=n;++i){	\r\n			m=b[i];\r\n			first=i;\r\n			while(m==b[i+1]) ++i;\r\n			if(first!=i){\r\n				qsort(b,a,first,i);\r\n/*				for(k=1;k<i-first;++k){\r\n	            	for(j=first;j<i;++j){\r\n	            		if(a[j]>a[j+1]){\r\n	            			c=a[j];\r\n	            			a[j]=a[j+1];\r\n	            			a[j+1]=c;\r\n						}\r\n					}\r\n				}\r\n		*/\r\n			}\r\n		}\r\n	\r\n		for(i=1;i<n;++i) printf("%d  ",a[i]);\r\n		printf("%d",a[i]);\r\n		printf("\\n");\r\n	}\r\n	return 0;\r\n}', '', 46, 712704, 3, 1, '2010-12-30 09:57:34', '0001-01-01 00:00:00'),
(1145, 17, 404, 9, '#include <iostream>\r\n#include<stdio.h>\r\nusing namespace std;\r\nconst int MAXN = 31;\r\nstruct mat_T {\r\n    int matrix[MAXN][MAXN];\r\n};\r\nmat_T mat;\r\nint n, mod;\r\n\r\nmat_T mul(mat_T a, mat_T b) \r\n{\r\n    int i, j, k;\r\n    mat_T c;\r\n    for(i = 0; i < 4; i ++) {\r\n        for(j = 0; j < 4; j ++) {\r\n            c.matrix[i][j] = 0;\r\n            for(k = 0; k < 4; k ++) {\r\n                c.matrix[i][j] += a.matrix[i][k] * b.matrix[k][j];\r\n                c.matrix[i][j] %= 2011;\r\n            }\r\n        }\r\n    }\r\n    return c;\r\n}\r\nmat_T myPow2(int k) \r\n{   \r\n    if(k == 1){\r\n        return mat;\r\n    }\r\n 	else if(k % 2) {\r\n        return mul(myPow2(k -1), mat);\r\n    }\r\n	else {\r\n        mat_T mt = myPow2(k/2);\r\n        return mul(mt, mt);\r\n    }\r\n}\r\n\r\n\r\nint main() \r\n{\r\n    int i, j, k;\r\n    scanf("%d", &n);\r\n	while(n--){\r\n    for(i = 0; i < 4; i ++)\r\n        for(j = 0; j < 4; j ++)\r\n		{\r\n			scanf("%d", &mat.matrix[i][j]);\r\n		}\r\n	printf("\\n");\r\n    mat_T mt = myPow2(2011);\r\n    for(i = 0; i < 4; i ++) {\r\n        for(j = 0; j < 3; j ++)\r\n            printf("%d ", mt.matrix[i][j]);\r\n        printf("%d\\n", mt.matrix[i][j]);\r\n    }\r\n\r\n	}\r\n    return 0;\r\n}\r\n', '', 15, 626688, 3, 2, '2010-12-30 09:57:49', '0001-01-01 00:00:00'),
(1146, 10, 402, 8, '#include<stdio.h>\r\n#include<string.h>\r\n\r\nint main(){\r\n int size_a,size_b,i,asize,bsize,size,k;\r\n char a[2000],b[2000],c[2000],jinwei;\r\n scanf("%d",&size);\r\n for(k=1;k != size+1;k++)\r\n {\r\n	 size_a = size_b= i=0;\r\n	 jinwei = 48;\r\n	 scanf("%s",a);\r\n	 size_a =strlen(a);\r\n	 asize = size_a-1;\r\n	 \r\n	 scanf("%s",b);\r\n	 size_b =strlen(b);\r\n	 bsize = size_b-1;\r\n	 \r\n	 jinwei=''0'';\r\n	 if(size_a > size_b)\r\n	 {\r\n		  while(i != size_b)\r\n		  {\r\n			   if(a[asize]+b[bsize]+jinwei > 153){\r\n				c[asize] = a[asize]+b[bsize]+jinwei-106;\r\n				jinwei = 49;}\r\n			   else\r\n			   {\r\n				c[asize] = a[asize]+b[bsize]+jinwei-96;\r\n				jinwei = 48;}\r\n				--asize;--bsize;\r\n		        ++i;\r\n		  }\r\n		  while(i != size_a)\r\n		  {\r\n			   if(jinwei == ''1'')\r\n			   {\r\n				   if(a[size_a-i-1] == ''9'')\r\n					   c[size_a-i-1] = ''0'';\r\n				   else\r\n				   {\r\n				       c[size_a-i-1] = a[size_a-i-1] +1;\r\n				       jinwei = 48;\r\n				   }\r\n			   }\r\n			   else\r\n			   c[size_a-i-1] = a[size_a-i-1];\r\n			   ++i;\r\n		  }\r\n		  printf("Case %d:\\n",k);\r\n		  printf("%s + %s = ",a,b);\r\n		  if(jinwei == ''1'')\r\n			  printf("1");\r\n		  for( i=0;i != size_a;++i)\r\n		  printf("%c",c[i]);\r\n		  printf("\\n");\r\n	 }\r\n	 else if(size_a < size_b)\r\n	 {\r\n		  while(i != size_a)\r\n		  {\r\n			   if(a[asize]+b[bsize]+jinwei > 153){\r\n				c[bsize] = a[asize]+b[bsize]+jinwei-106;\r\n				jinwei = 49;}\r\n			   else\r\n			   {\r\n				c[bsize] = a[asize]+b[bsize]+jinwei-96;\r\n				jinwei = 48;}\r\n				--asize;--bsize;\r\n			   ++i;\r\n		  }\r\n		  while(i != size_b)\r\n		  {\r\n			   if(jinwei == ''1'')\r\n			   {\r\n				   if(b[size_b-i-1] == ''9'')\r\n					   c[size_b-i-1] = ''0'';\r\n				   else\r\n				   {\r\n				       c[size_b-i-1] = b[size_b-i-1] +1;\r\n				       jinwei = 48;\r\n				   }\r\n			   }\r\n			   else\r\n			   c[size_b-i-1] = b[size_b-i-1];\r\n			   ++i;\r\n		  }\r\n		  printf("Case %d:\\n",k);\r\n		  printf("%s + %s = ",a,b);\r\n		  if(jinwei == ''1'')\r\n			  printf("1");\r\n		  for(i=0;i != size_b;++i)\r\n		  printf("%c",c[i]);\r\n		  printf("\\n");\r\n	 }else\r\n	 {\r\n		  while(i != size_a)\r\n		  {\r\n			   if(a[asize]+b[bsize]+jinwei > 153){\r\n				c[asize] = a[asize]+b[bsize]+jinwei-106;\r\n				jinwei = 49;}\r\n			   else\r\n			   {\r\n				c[asize] = a[asize]+b[bsize]+jinwei-96;\r\n				jinwei = 48;}\r\n				--asize;--bsize;\r\n			   ++i;\r\n		  }\r\n		  printf("Case %d:\\n",k);\r\n		  printf("%s + %s = ",a,b);\r\n		  if(jinwei == ''1'')\r\n		  printf("1");\r\n	      for(i=0;i != size_b;++i)\r\n	      printf("%c",c[i]);\r\n		  printf("\\n");\r\n	 }\r\n } \r\n return 0;\r\n}', '', 31, 253952, 3, 1, '2010-12-30 09:57:54', '0001-01-01 00:00:00'),
(1147, 10, 402, 8, '#include<stdio.h>\r\n#include<string.h>\r\n\r\nint main(){\r\n int size_a,size_b,i,asize,bsize,size,k;\r\n char a[2000],b[2000],c[2000],jinwei;\r\n scanf("%d",&size);\r\n for(k=1;k != size+1;k++)\r\n {\r\n	 size_a = size_b= i=0;\r\n	 jinwei = 48;\r\n	 scanf("%s",a);\r\n	 size_a =strlen(a);\r\n	 asize = size_a-1;\r\n	 \r\n	 scanf("%s",b);\r\n	 size_b =strlen(b);\r\n	 bsize = size_b-1;\r\n	 \r\n	 jinwei=''0'';\r\n	 if(size_a > size_b)\r\n	 {\r\n		  while(i != size_b)\r\n		  {\r\n			   if(a[asize]+b[bsize]+jinwei > 153){\r\n				c[asize] = a[asize]+b[bsize]+jinwei-106;\r\n				jinwei = 49;}\r\n			   else\r\n			   {\r\n				c[asize] = a[asize]+b[bsize]+jinwei-96;\r\n				jinwei = 48;}\r\n				--asize;--bsize;\r\n		        ++i;\r\n		  }\r\n		  while(i != size_a)\r\n		  {\r\n			   if(jinwei == ''1'')\r\n			   {\r\n				   if(a[size_a-i-1] == ''9'')\r\n					   c[size_a-i-1] = ''0'';\r\n				   else\r\n				   {\r\n				       c[size_a-i-1] = a[size_a-i-1] +1;\r\n				       jinwei = 48;\r\n				   }\r\n			   }\r\n			   else\r\n			   c[size_a-i-1] = a[size_a-i-1];\r\n			   ++i;\r\n		  }\r\n		  printf("Case %d:\\n",k);\r\n		  printf("%s + %s = ",a,b);\r\n		  if(jinwei == ''1'')\r\n			  printf("1");\r\n		  for( i=0;i != size_a;++i)\r\n		  printf("%c",c[i]);\r\n		  if(k != size)\r\n		  printf("\\n");\r\n	 }\r\n	 else if(size_a < size_b)\r\n	 {\r\n		  while(i != size_a)\r\n		  {\r\n			   if(a[asize]+b[bsize]+jinwei > 153){\r\n				c[bsize] = a[asize]+b[bsize]+jinwei-106;\r\n				jinwei = 49;}\r\n			   else\r\n			   {\r\n				c[bsize] = a[asize]+b[bsize]+jinwei-96;\r\n				jinwei = 48;}\r\n				--asize;--bsize;\r\n			   ++i;\r\n		  }\r\n		  while(i != size_b)\r\n		  {\r\n			   if(jinwei == ''1'')\r\n			   {\r\n				   if(b[size_b-i-1] == ''9'')\r\n					   c[size_b-i-1] = ''0'';\r\n				   else\r\n				   {\r\n				       c[size_b-i-1] = b[size_b-i-1] +1;\r\n				       jinwei = 48;\r\n				   }\r\n			   }\r\n			   else\r\n			   c[size_b-i-1] = b[size_b-i-1];\r\n			   ++i;\r\n		  }\r\n		  printf("Case %d:\\n",k);\r\n		  printf("%s + %s = ",a,b);\r\n		  if(jinwei == ''1'')\r\n			  printf("1");\r\n		  for(i=0;i != size_b;++i)\r\n		  printf("%c",c[i]);\r\n		  if(k != size)\r\n		  printf("\\n");\r\n	 }else\r\n	 {\r\n		  while(i != size_a)\r\n		  {\r\n			   if(a[asize]+b[bsize]+jinwei > 153){\r\n				c[asize] = a[asize]+b[bsize]+jinwei-106;\r\n				jinwei = 49;}\r\n			   else\r\n			   {\r\n				c[asize] = a[asize]+b[bsize]+jinwei-96;\r\n				jinwei = 48;}\r\n				--asize;--bsize;\r\n			   ++i;\r\n		  }\r\n		  printf("Case %d:\\n",k);\r\n		  printf("%s + %s = ",a,b);\r\n		  if(jinwei == ''1'')\r\n		  printf("1");\r\n	      for(i=0;i != size_b;++i)\r\n	      printf("%c",c[i]);\r\n		  if(k != size)\r\n		  printf("\\n");\r\n	 }\r\n } \r\n return 0;\r\n}', '', 31, 258048, 3, 1, '2010-12-30 09:59:37', '0001-01-01 00:00:00'),
(1148, 17, 404, 9, '#include <iostream>\r\n#include<stdio.h>\r\nusing namespace std;\r\nconst int MAXN = 31;\r\nstruct mat_T {\r\n    int matrix[MAXN][MAXN];\r\n};\r\nmat_T mat;\r\nint n, mod;\r\n\r\nmat_T mul(mat_T a, mat_T b) \r\n{\r\n    int i, j, k;\r\n    mat_T c;\r\n    for(i = 0; i < 4; i ++) {\r\n        for(j = 0; j < 4; j ++) {\r\n            c.matrix[i][j] = 0;\r\n            for(k = 0; k < 4; k ++) {\r\n                c.matrix[i][j] += a.matrix[i][k] * b.matrix[k][j];\r\n                c.matrix[i][j] %= 2011;\r\n            }\r\n        }\r\n    }\r\n    return c;\r\n}\r\nmat_T myPow2(int k) \r\n{   \r\n    if(k == 1){\r\n        return mat;\r\n    }\r\n 	else if(k % 2) {\r\n        return mul(myPow2(k -1), mat);\r\n    }\r\n	else {\r\n        mat_T mt = myPow2(k/2);\r\n        return mul(mt, mt);\r\n    }\r\n}\r\n\r\n\r\nint main() \r\n{\r\n    int i, j, k;\r\n    scanf("%d", &n);\r\n	while(n--){\r\n    for(i = 0; i < 4; i ++)\r\n        for(j = 0; j < 4; j ++)\r\n		{\r\n			scanf("%d", &mat.matrix[i][j]);\r\n		}\r\n	printf("\\n");\r\n    mat_T mt = myPow2(2011);\r\n    for(i = 0; i < 4; i ++) {\r\n        for(j = 0; j < 3; j ++)\r\n            printf("%d ", mt.matrix[i][j]);\r\n        printf("%d\\n", mt.matrix[i][j]);\r\n    }\r\n    if(n!=0)\r\n		printf("\\n");\r\n	}\r\n    return 0;\r\n}\r\n', '', 15, 626688, 3, 2, '2010-12-30 10:01:42', '0001-01-01 00:00:00'),
(1149, 10, 402, 8, '#include<stdio.h>\r\n#include<string.h>\r\n\r\nint main(){\r\n int size_a,size_b,i,asize,bsize,size,k;\r\n char a[2000],b[2000],c[2000],jinwei;\r\n scanf("%d",&size);\r\n for(k=1;k != size+1;k++)\r\n {\r\n	 size_a = size_b= i=0;\r\n	 jinwei = 48;\r\n	 scanf("%s",a);\r\n	 size_a =strlen(a);\r\n	 asize = size_a-1;\r\n	 \r\n	 scanf("%s",b);\r\n	 size_b =strlen(b);\r\n	 bsize = size_b-1;\r\n	 \r\n	 jinwei=''0'';\r\n	 if(size_a > size_b)\r\n	 {\r\n		  while(i != size_b)\r\n		  {\r\n			   if(a[asize]+b[bsize]+jinwei > 153){\r\n				c[asize] = a[asize]+b[bsize]+jinwei-106;\r\n				jinwei = 49;}\r\n			   else\r\n			   {\r\n				c[asize] = a[asize]+b[bsize]+jinwei-96;\r\n				jinwei = 48;}\r\n				--asize;--bsize;\r\n		        ++i;\r\n		  }\r\n		  while(i != size_a)\r\n		  {\r\n			   if(jinwei == ''1'')\r\n			   {\r\n				   if(a[size_a-i-1] == ''9'')\r\n					   c[size_a-i-1] = ''0'';\r\n				   else\r\n				   {\r\n				       c[size_a-i-1] = a[size_a-i-1] +1;\r\n				       jinwei = 48;\r\n				   }\r\n			   }\r\n			   else\r\n			   c[size_a-i-1] = a[size_a-i-1];\r\n			   ++i;\r\n		  }\r\n		  printf("Case %d:\\n",k);\r\n		  printf("%s + %s = ",a,b);\r\n		  if(jinwei == ''1'')\r\n			  printf("1");\r\n		  for( i=0;i != size_a;++i)\r\n		  printf("%c",c[i]);\r\n		  if(k != size)\r\n		  {\r\n		  printf("\\n");\r\n		  printf("\\n");\r\n		  }\r\n	 }\r\n	 else if(size_a < size_b)\r\n	 {\r\n		  while(i != size_a)\r\n		  {\r\n			   if(a[asize]+b[bsize]+jinwei > 153){\r\n				c[bsize] = a[asize]+b[bsize]+jinwei-106;\r\n				jinwei = 49;}\r\n			   else\r\n			   {\r\n				c[bsize] = a[asize]+b[bsize]+jinwei-96;\r\n				jinwei = 48;}\r\n				--asize;--bsize;\r\n			   ++i;\r\n		  }\r\n		  while(i != size_b)\r\n		  {\r\n			   if(jinwei == ''1'')\r\n			   {\r\n				   if(b[size_b-i-1] == ''9'')\r\n					   c[size_b-i-1] = ''0'';\r\n				   else\r\n				   {\r\n				       c[size_b-i-1] = b[size_b-i-1] +1;\r\n				       jinwei = 48;\r\n				   }\r\n			   }\r\n			   else\r\n			   c[size_b-i-1] = b[size_b-i-1];\r\n			   ++i;\r\n		  }\r\n		  printf("Case %d:\\n",k);\r\n		  printf("%s + %s = ",a,b);\r\n		  if(jinwei == ''1'')\r\n			  printf("1");\r\n		  for(i=0;i != size_b;++i)\r\n		  printf("%c",c[i]);\r\n		  if(k != size)\r\n		  {\r\n		  printf("\\n");\r\n		  printf("\\n");\r\n		  }\r\n	 }else\r\n	 {\r\n		  while(i != size_a)\r\n		  {\r\n			   if(a[asize]+b[bsize]+jinwei > 153){\r\n				c[asize] = a[asize]+b[bsize]+jinwei-106;\r\n				jinwei = 49;}\r\n			   else\r\n			   {\r\n				c[asize] = a[asize]+b[bsize]+jinwei-96;\r\n				jinwei = 48;}\r\n				--asize;--bsize;\r\n			   ++i;\r\n		  }\r\n		  printf("Case %d:\\n",k);\r\n		  printf("%s + %s = ",a,b);\r\n		  if(jinwei == ''1'')\r\n		  printf("1");\r\n	      for(i=0;i != size_b;++i)\r\n	      printf("%c",c[i]);\r\n		  if(k != size)\r\n		  {\r\n		  printf("\\n");\r\n		  printf("\\n");\r\n		  }\r\n	 }\r\n } \r\n return 0;\r\n}', '', 31, 258048, 3, 1, '2010-12-30 10:02:04', '0001-01-01 00:00:00'),
(1150, 17, 404, 9, '#include <iostream>\r\n#include<stdio.h>\r\nusing namespace std;\r\nconst int MAXN = 31;\r\nstruct mat_T {\r\n    int matrix[MAXN][MAXN];\r\n};\r\nmat_T mat;\r\nint n, mod;\r\n\r\nmat_T mul(mat_T a, mat_T b) \r\n{\r\n    int i, j, k;\r\n    mat_T c;\r\n    for(i = 0; i < 4; i ++) {\r\n        for(j = 0; j < 4; j ++) {\r\n            c.matrix[i][j] = 0;\r\n            for(k = 0; k < 4; k ++) {\r\n                c.matrix[i][j] += a.matrix[i][k] * b.matrix[k][j];\r\n                c.matrix[i][j] %= 2011;\r\n            }\r\n        }\r\n    }\r\n    return c;\r\n}\r\nmat_T myPow2(int k) \r\n{   \r\n    if(k == 1){\r\n        return mat;\r\n    }\r\n 	else if(k % 2) {\r\n        return mul(myPow2(k -1), mat);\r\n    }\r\n	else {\r\n        mat_T mt = myPow2(k/2);\r\n        return mul(mt, mt);\r\n    }\r\n}\r\n\r\n\r\nint main() \r\n{\r\n    int i, j, k;\r\n    scanf("%d", &n);\r\n	while(n--){\r\n    for(i = 0; i < 4; i ++)\r\n        for(j = 0; j < 4; j ++)\r\n		{\r\n			scanf("%d", &mat.matrix[i][j]);\r\n		}\r\n	printf("\\n");\r\n    mat_T mt = myPow2(2011);\r\n    for(i = 0; i < 4; i ++) {\r\n        for(j = 0; j < 3; j ++)\r\n            printf("%d ", mt.matrix[i][j]);\r\n        printf("%d\\n", mt.matrix[i][j]);\r\n    }\r\n		printf("\\n");\r\n	}\r\n    return 0;\r\n}\r\n', 'Main.c:1:20: fatal error: iostream: No such file or directory\r\ncompilation terminated.\r\n', 0, 0, 2, 1, '2010-12-30 10:05:51', '0001-01-01 00:00:00'),
(1151, 17, 404, 9, '#include <iostream>\r\n#include<stdio.h>\r\nusing namespace std;\r\nconst int MAXN = 31;\r\nstruct mat_T {\r\n    int matrix[MAXN][MAXN];\r\n};\r\nmat_T mat;\r\nint n, mod;\r\n\r\nmat_T mul(mat_T a, mat_T b) \r\n{\r\n    int i, j, k;\r\n    mat_T c;\r\n    for(i = 0; i < 4; i ++) {\r\n        for(j = 0; j < 4; j ++) {\r\n            c.matrix[i][j] = 0;\r\n            for(k = 0; k < 4; k ++) {\r\n                c.matrix[i][j] += a.matrix[i][k] * b.matrix[k][j];\r\n                c.matrix[i][j] %= 2011;\r\n            }\r\n        }\r\n    }\r\n    return c;\r\n}\r\nmat_T myPow2(int k) \r\n{   \r\n    if(k == 1){\r\n        return mat;\r\n    }\r\n 	else if(k % 2) {\r\n        return mul(myPow2(k -1), mat);\r\n    }\r\n	else {\r\n        mat_T mt = myPow2(k/2);\r\n        return mul(mt, mt);\r\n    }\r\n}\r\n\r\n\r\nint main() \r\n{\r\n    int i, j, k;\r\n    scanf("%d", &n);\r\n	while(n--){\r\n    for(i = 0; i < 4; i ++)\r\n        for(j = 0; j < 4; j ++)\r\n		{\r\n			scanf("%d", &mat.matrix[i][j]);\r\n		}\r\n	printf("\\n");\r\n    mat_T mt = myPow2(2011);\r\n    for(i = 0; i < 4; i ++) {\r\n        for(j = 0; j < 3; j ++)\r\n            printf("%d ", mt.matrix[i][j]);\r\n        printf("%d\\n", mt.matrix[i][j]);\r\n    }\r\n		printf("\\n");\r\n	}\r\n    return 0;\r\n}\r\n', '', 15, 626688, 3, 2, '2010-12-30 10:06:00', '0001-01-01 00:00:00'),
(1152, 10, 402, 8, '#include<stdio.h>\r\n#include<string.h>\r\nint main(){\r\n int size_a,size_b,i,asize,bsize,size,k;\r\n char a[2000],b[2000],c[2000],jinwei;\r\n scanf("%d",&size);\r\n for(k=1;k != size+1;k++)\r\n {\r\n  size_a = size_b= i=0;\r\n  jinwei = 48;\r\n  scanf("%s",a);\r\n  size_a =strlen(a);\r\n  asize = size_a-1;\r\n  \r\n  scanf("%s",b);\r\n  size_b =strlen(b);\r\n  bsize = size_b-1;\r\n  \r\n  jinwei=''0'';\r\n  if(size_a > size_b)\r\n  {\r\n    while(i != size_b)\r\n    {\r\n      if(a[asize]+b[bsize]+jinwei > 153){\r\n    c[asize] = a[asize]+b[bsize]+jinwei-106;\r\n    jinwei = 49;}\r\n      else\r\n      {\r\n    c[asize] = a[asize]+b[bsize]+jinwei-96;\r\n    jinwei = 48;}\r\n    --asize;--bsize;\r\n          ++i;\r\n    }\r\n    while(i != size_a)\r\n    {\r\n      if(jinwei == ''1'')\r\n      {\r\n       if(a[size_a-i-1] == ''9'')\r\n        c[size_a-i-1] = ''0'';\r\n       else\r\n       {\r\n           c[size_a-i-1] = a[size_a-i-1] +1;\r\n           jinwei = 48;\r\n       }\r\n      }\r\n      else\r\n      c[size_a-i-1] = a[size_a-i-1];\r\n      ++i;\r\n    }\r\n    printf("Case %d:\\n",k);\r\n    printf("%s + %s = ",a,b);\r\n    if(jinwei == ''1'')\r\n     printf("1");\r\n    for( i=0;i != size_a;++i)\r\n    printf("%c",c[i]);\r\n    if(k != size)\r\n    {\r\n    printf("\\n");\r\n    printf("\\n");\r\n    }\r\n  }\r\n  else if(size_a < size_b)\r\n  {\r\n    while(i != size_a)\r\n    {\r\n      if(a[asize]+b[bsize]+jinwei > 153){\r\n    c[bsize] = a[asize]+b[bsize]+jinwei-106;\r\n    jinwei = 49;}\r\n      else\r\n      {\r\n    c[bsize] = a[asize]+b[bsize]+jinwei-96;\r\n    jinwei = 48;}\r\n    --asize;--bsize;\r\n      ++i;\r\n    }\r\n    while(i != size_b)\r\n    {\r\n      if(jinwei == ''1'')\r\n      {\r\n       if(b[size_b-i-1] == ''9'')\r\n        c[size_b-i-1] = ''0'';\r\n       else\r\n       {\r\n           c[size_b-i-1] = b[size_b-i-1] +1;\r\n           jinwei = 48;\r\n       }\r\n      }\r\n      else\r\n      c[size_b-i-1] = b[size_b-i-1];\r\n      ++i;\r\n    }\r\n    printf("Case %d:\\n",k);\r\n    printf("%s + %s = ",a,b);\r\n    if(jinwei == ''1'')\r\n     printf("1");\r\n    for(i=0;i != size_b;++i)\r\n    printf("%c",c[i]);\r\n    if(k != size)\r\n    {\r\n    printf("\\n");\r\n    printf("\\n");\r\n    }\r\n  }else\r\n  {\r\n    while(i != size_a)\r\n    {\r\n      if(a[asize]+b[bsize]+jinwei > 153){\r\n    c[asize] = a[asize]+b[bsize]+jinwei-106;\r\n    jinwei = 49;}\r\n      else\r\n      {\r\n    c[asize] = a[asize]+b[bsize]+jinwei-96;\r\n    jinwei = 48;}\r\n    --asize;--bsize;\r\n      ++i;\r\n    }\r\n    printf("Case %d:\\n",k);\r\n    printf("%s + %s = ",a,b);\r\n    if(jinwei == ''1'')\r\n    printf("1");\r\n       for(i=0;i != size_b;++i)\r\n       printf("%c",c[i]);\r\n    if(k != size)\r\n    {\r\n    printf("\\n");\r\n    printf("\\n");\r\n    }\r\n  }\r\n } \r\n return 0;\r\n}', '', 15, 253952, 3, 1, '2010-12-30 10:11:55', '0001-01-01 00:00:00'),
(1153, 10, 402, 8, '#include<stdio.h>\r\n#include<string.h>\r\n\r\nint main(){\r\n int size_a,size_b,i,asize,bsize,size,k;\r\n char a[2000],b[2000],c[2000],jinwei;\r\n scanf("%d",&size);\r\n for(k=1;k != size+1;k++)\r\n {\r\n	 size_a = size_b= i=0;\r\n	 jinwei = 48;\r\n	 scanf("%s",a);\r\n	 size_a =strlen(a);\r\n	 asize = size_a-1;\r\n	 \r\n	 scanf("%s",b);\r\n	 size_b =strlen(b);\r\n	 bsize = size_b-1;\r\n	 \r\n	 jinwei=''0'';\r\n	 if(size_a > size_b)\r\n	 {\r\n		  while(i != size_b)\r\n		  {\r\n			   if(a[asize]+b[bsize]+jinwei > 153){\r\n				c[asize] = a[asize]+b[bsize]+jinwei-106;\r\n				jinwei = 49;}\r\n			   else\r\n			   {\r\n				c[asize] = a[asize]+b[bsize]+jinwei-96;\r\n				jinwei = 48;}\r\n				--asize;--bsize;\r\n		        ++i;\r\n		  }\r\n		  while(i != size_a)\r\n		  {\r\n			   if(jinwei == ''1'')\r\n			   {\r\n				   if(a[size_a-i-1] == ''9'')\r\n					   c[size_a-i-1] = ''0'';\r\n				   else\r\n				   {\r\n				       c[size_a-i-1] = a[size_a-i-1] +1;\r\n				       jinwei = 48;\r\n				   }\r\n			   }\r\n			   else\r\n			   c[size_a-i-1] = a[size_a-i-1];\r\n			   ++i;\r\n		  }\r\n		  printf("Case %d:\\n",k);\r\n		  printf("%s + %s = ",a,b);\r\n		  if(jinwei == ''1'')\r\n			  printf("1");\r\n		  for( i=0;i != size_a;++i)\r\n		  printf("%c",c[i]);\r\n		  if(k != size)\r\n		  {\r\n		  printf("\\n");\r\n		  printf("\\n");\r\n		  }\r\n		  else\r\n			  printf("\\n");\r\n	 }\r\n	 else if(size_a < size_b)\r\n	 {\r\n		  while(i != size_a)\r\n		  {\r\n			   if(a[asize]+b[bsize]+jinwei > 153){\r\n				c[bsize] = a[asize]+b[bsize]+jinwei-106;\r\n				jinwei = 49;}\r\n			   else\r\n			   {\r\n				c[bsize] = a[asize]+b[bsize]+jinwei-96;\r\n				jinwei = 48;}\r\n				--asize;--bsize;\r\n			   ++i;\r\n		  }\r\n		  while(i != size_b)\r\n		  {\r\n			   if(jinwei == ''1'')\r\n			   {\r\n				   if(b[size_b-i-1] == ''9'')\r\n					   c[size_b-i-1] = ''0'';\r\n				   else\r\n				   {\r\n				       c[size_b-i-1] = b[size_b-i-1] +1;\r\n				       jinwei = 48;\r\n				   }\r\n			   }\r\n			   else\r\n			   c[size_b-i-1] = b[size_b-i-1];\r\n			   ++i;\r\n		  }\r\n		  printf("Case %d:\\n",k);\r\n		  printf("%s + %s = ",a,b);\r\n		  if(jinwei == ''1'')\r\n			  printf("1");\r\n		  for(i=0;i != size_b;++i)\r\n		  printf("%c",c[i]);\r\n		  if(k != size)\r\n		  {\r\n		  printf("\\n");\r\n		  printf("\\n");\r\n		  }\r\n		  else\r\n			  printf("\\n");\r\n	 }else\r\n	 {\r\n		  while(i != size_a)\r\n		  {\r\n			   if(a[asize]+b[bsize]+jinwei > 153){\r\n				c[asize] = a[asize]+b[bsize]+jinwei-106;\r\n				jinwei = 49;}\r\n			   else\r\n			   {\r\n				c[asize] = a[asize]+b[bsize]+jinwei-96;\r\n				jinwei = 48;}\r\n				--asize;--bsize;\r\n			   ++i;\r\n		  }\r\n		  printf("Case %d:\\n",k);\r\n		  printf("%s + %s = ",a,b);\r\n		  if(jinwei == ''1'')\r\n		  printf("1");\r\n	      for(i=0;i != size_b;++i)\r\n	      printf("%c",c[i]);\r\n		  if(k != size)\r\n		  {\r\n		  printf("\\n");\r\n		  printf("\\n");\r\n		  }\r\n		  else\r\n			  printf("\\n");\r\n	 }\r\n } \r\n return 0;\r\n}', '', 31, 253952, 1, 1, '2010-12-30 10:15:56', '0001-01-01 00:00:00'),
(1154, 17, 404, 9, '#include <iostream>\r\n#include<stdio.h>\r\nusing namespace std;\r\nconst int MAXN = 31;\r\nstruct mat_T {\r\n    int matrix[MAXN][MAXN];\r\n};\r\nmat_T mat;\r\nint n, mod;\r\n\r\nmat_T mul(mat_T a, mat_T b) \r\n{\r\n    int i, j, k;\r\n    mat_T c;\r\n    for(i = 0; i < 4; i ++) {\r\n        for(j = 0; j < 4; j ++) {\r\n            c.matrix[i][j] = 0;\r\n            for(k = 0; k < 4; k ++) {\r\n                c.matrix[i][j] += a.matrix[i][k] * b.matrix[k][j];\r\n                c.matrix[i][j] %= 2011;\r\n            }\r\n        }\r\n    }\r\n    return c;\r\n}\r\nmat_T myPow2(int k) \r\n{   \r\n    if(k == 1){\r\n        return mat;\r\n    }\r\n 	else if(k % 2) {\r\n        return mul(myPow2(k -1), mat);\r\n    }\r\n	else {\r\n        mat_T mt = myPow2(k/2);\r\n        return mul(mt, mt);\r\n    }\r\n}\r\n\r\n\r\nint main() \r\n{\r\n    int i, j, k;\r\n    scanf("%d", &n);\r\n	while(n--){\r\n    for(i = 0; i < 4; i ++)\r\n        for(j = 0; j < 4; j ++)\r\n		{\r\n			scanf("%d", &mat.matrix[i][j]);\r\n		}\r\n    mat_T mt = myPow2(2011);\r\n    for(i = 0; i < 4; i ++) {\r\n        for(j = 0; j < 3; j ++)\r\n            printf("%d ", mt.matrix[i][j]);\r\n        printf("%d\\n", mt.matrix[i][j]);\r\n    }\r\n\r\n    if(n!=0)\r\n		printf("\\n");\r\n	}\r\n    return 0;\r\n}\r\n ', '', 15, 626688, 3, 2, '2010-12-30 10:18:29', '0001-01-01 00:00:00'),
(1155, 17, 404, 9, '#include <iostream>\r\n#include<stdio.h>\r\nusing namespace std;\r\nconst int MAXN = 31;\r\nstruct mat_T {\r\n    int matrix[MAXN][MAXN];\r\n};\r\nmat_T mat;\r\nint n, mod;\r\n\r\nmat_T mul(mat_T a, mat_T b) \r\n{\r\n    int i, j, k;\r\n    mat_T c;\r\n    for(i = 0; i < 4; i ++) {\r\n        for(j = 0; j < 4; j ++) {\r\n            c.matrix[i][j] = 0;\r\n            for(k = 0; k < 4; k ++) {\r\n                c.matrix[i][j] += a.matrix[i][k] * b.matrix[k][j];\r\n                c.matrix[i][j] %= 2011;\r\n            }\r\n        }\r\n    }\r\n    return c;\r\n}\r\nmat_T myPow2(int k) \r\n{   \r\n    if(k == 1){\r\n        return mat;\r\n    }\r\n 	else if(k % 2) {\r\n        return mul(myPow2(k -1), mat);\r\n    }\r\n	else {\r\n        mat_T mt = myPow2(k/2);\r\n        return mul(mt, mt);\r\n    }\r\n}\r\n\r\n\r\nint main() \r\n{\r\n    int i, j, k;\r\n    scanf("%d", &n);\r\n	while(n--){\r\n    for(i = 0; i < 4; i ++)\r\n        for(j = 0; j < 4; j ++)\r\n		{\r\n			scanf("%d", &mat.matrix[i][j]);\r\n		}\r\n    printf("\\n");\r\n    mat_T mt = myPow2(2011);\r\n    for(i = 0; i < 4; i ++) {\r\n        for(j = 0; j < 4; j++)\r\n		{   \r\n			if(j==3)\r\n		      printf("%d",mt.matrix [i][j]);\r\n		    else\r\n			 printf("%d ", mt.matrix[i][j]);\r\n		}\r\n       printf("\\n");\r\n    }\r\n     \r\n  \r\n	}\r\n    return 0;\r\n}\r\n ', '', 15, 622592, 3, 2, '2010-12-30 10:35:39', '0001-01-01 00:00:00');
INSERT INTO `tbl_submitions` (`id`, `user_id`, `problem_id`, `exercise_id`, `source`, `result`, `used_time`, `used_memory`, `status`, `compiler_id`, `created`, `modified`) VALUES
(1156, 17, 404, 9, '#include <iostream>\r\n#include<stdio.h>\r\nusing namespace std;\r\nconst int MAXN = 31;\r\nstruct mat_T {\r\n    int matrix[MAXN][MAXN];\r\n};\r\nmat_T mat;\r\nint n, mod;\r\n\r\nmat_T mul(mat_T a, mat_T b) \r\n{\r\n    int i, j, k;\r\n    mat_T c;\r\n    for(i = 0; i < 4; i ++) {\r\n        for(j = 0; j < 4; j ++) {\r\n            c.matrix[i][j] = 0;\r\n            for(k = 0; k < 4; k ++) {\r\n                c.matrix[i][j] += a.matrix[i][k] * b.matrix[k][j];\r\n                c.matrix[i][j] %= 2011;\r\n            }\r\n        }\r\n    }\r\n    return c;\r\n}\r\nmat_T myPow2(int k) \r\n{   \r\n    if(k == 1){\r\n        return mat;\r\n    }\r\n 	else if(k % 2) {\r\n        return mul(myPow2(k -1), mat);\r\n    }\r\n	else {\r\n        mat_T mt = myPow2(k/2);\r\n        return mul(mt, mt);\r\n    }\r\n}\r\n\r\n\r\nint main() \r\n{\r\n    int i, j, k;\r\n    scanf("%d", &n);\r\n	while(n--){\r\n    for(i = 0; i < 4; i ++)\r\n        for(j = 0; j < 4; j ++)\r\n		{\r\n			scanf("%d", &mat.matrix[i][j]);\r\n		}\r\n    mat_T mt = myPow2(2011);\r\n    for(i = 0; i < 4; i ++) {\r\n        for(j = 0; j < 4; j++)\r\n		{   \r\n			if(j==3)\r\n		      printf("%d",mt.matrix [i][j]);\r\n		    else\r\n			 printf("%d ", mt.matrix[i][j]);\r\n		}\r\n       if(i!=3)\r\n		   printf("\\n");\r\n    }\r\n     if(n!=0)\r\n		 printf("\\n");\r\n  \r\n	}\r\n    return 0;\r\n}\r\n ', '', 15, 626688, 3, 2, '2010-12-30 10:40:10', '0001-01-01 00:00:00'),
(1157, 17, 404, 9, '#include <iostream>\r\n#include<stdio.h>\r\nusing namespace std;\r\nconst int MAXN = 31;\r\nstruct mat_T {\r\n    int matrix[MAXN][MAXN];\r\n};\r\nmat_T mat;\r\nint n, mod;\r\n\r\nmat_T mul(mat_T a, mat_T b) \r\n{\r\n    int i, j, k;\r\n    mat_T c;\r\n    for(i = 0; i < 4; i ++) {\r\n        for(j = 0; j < 4; j ++) {\r\n            c.matrix[i][j] = 0;\r\n            for(k = 0; k < 4; k ++) {\r\n                c.matrix[i][j] += a.matrix[i][k] * b.matrix[k][j];\r\n                c.matrix[i][j] %= 2011;\r\n            }\r\n        }\r\n    }\r\n    return c;\r\n}\r\nmat_T myPow2(int k) \r\n{   \r\n    if(k == 1){\r\n        return mat;\r\n    }\r\n 	else if(k % 2) {\r\n        return mul(myPow2(k -1), mat);\r\n    }\r\n	else {\r\n        mat_T mt = myPow2(k/2);\r\n        return mul(mt, mt);\r\n    }\r\n}\r\n\r\n\r\nint main() \r\n{\r\n    int i, j, k;\r\n    scanf("%d", &n);\r\n	while(n--){\r\n    for(i = 0; i < 4; i ++)\r\n        for(j = 0; j < 4; j ++)\r\n		{\r\n			scanf("%d", &mat.matrix[i][j]);\r\n		}\r\n    mat_T mt = myPow2(2011);\r\n    for(i = 0; i < 4; i ++) {\r\n        for(j = 0; j < 4; j++)\r\n		{   \r\n			if(j==3)\r\n		      printf("%d",mt.matrix [i][j]);\r\n		    else\r\n			 printf("%d ", mt.matrix[i][j]);\r\n		}\r\n		   printf("\\n");\r\n    }\r\n		 printf("\\n");\r\n  \r\n	}\r\n    return 0;\r\n}\r\n ', '', 30, 626688, 1, 2, '2010-12-30 10:43:50', '0001-01-01 00:00:00'),
(1158, 27, 338, 3, '#include<stdio.h>\r\nint main()\r\n{\r\n	int a[1000],i,n,k,num;\r\n	int kmin,kmax,kminnumber,kmaxnumber;	\r\n    while(scanf("%d %d",&n,&k)==2){\r\n  		for(i=0;i<1000;++i)	a[i]=0;\r\n		for(i=0;i<n;++i){\r\n			scanf("%d",&num);\r\n			++a[num];\r\n		}\r\n//		for(i=0;i<10;++i)	printf("%d  ",a[i]);\r\n//		printf("\\n");\r\n		kminnumber=-1;\r\n		kmaxnumber=-1;\r\n		for(i=0;i<1000;++i){\r\n			kminnumber+=a[i];\r\n//			printf("%d\\n",kminnumber);\r\n			if(k<=kminnumber) { kmin=i;  break;}			\r\n		}\r\n//		printf("%d\\n",kmin);\r\n		for(i=999;i>0;--i){\r\n			kmaxnumber+=a[i];\r\n			if(k<=kmaxnumber) { kmax=i;  break;}\r\n		}\r\n//		printf("%d\\n",kmax);\r\n		printf("%d\\n",kmax-kmin);\r\n	}\r\n    return 0;\r\n}', '', 374, 258048, 1, 1, '2010-12-30 11:26:32', '0001-01-01 00:00:00'),
(1159, 10, 404, 9, '#include<stdio.h>\r\n#include<string.h>\r\nint main()\r\n{\r\n    int num,size;\r\n    long int juzhen_0[4][4];\r\n    long int juzhen_1[4][4];\r\n    long int juzhen_2[4][4];\r\n    long int juzhen_3[4][4];\r\n    long int juzhen_4[4][4];\r\n    long int juzhen_5[4][4];\r\n    long int juzhen_6[4][4];\r\n    long int juzhen_7[4][4];\r\n    long int juzhen_8[4][4];\r\n    long int juzhen_9[4][4];\r\n    long int juzhen_10[4][4];\r\n    long int juzhen_ans1[4][4];    \r\n    long int juzhen_ans2[4][4];\r\n	scanf("%d",&size);\r\n for(num=0;num !=size;++num)\r\n {\r\n    memset(juzhen_0,0,16*sizeof(long));     \r\n    memset(juzhen_1,0,16*sizeof(long));  \r\n    memset(juzhen_2,0,16*sizeof(long));  \r\n    memset(juzhen_3,0,16*sizeof(long));  \r\n    memset(juzhen_4,0,16*sizeof(long));  \r\n    memset(juzhen_5,0,16*sizeof(long));  \r\n    memset(juzhen_6,0,16*sizeof(long));  \r\n    memset(juzhen_7,0,16*sizeof(long));  \r\n    memset(juzhen_8,0,16*sizeof(long));  \r\n    memset(juzhen_9,0,16*sizeof(long));   \r\n    memset(juzhen_10,0,16*sizeof(long));  \r\n    memset(juzhen_ans1,0,16*sizeof(long));   \r\n    memset(juzhen_ans2,0,16*sizeof(long));   \r\n    \r\n    int i,j,k;\r\n    for(i=0;i != 4;++i)\r\n       for(j=0;j != 4;++j)\r\n           {\r\n                   scanf("%d",&juzhen_0[i][j]);\r\n           }\r\n    \r\n    for(i=0;i != 4;++i)\r\n       for(j=0;j != 4;++j){\r\n           for(k=0; k != 4;++k)\r\n           {\r\n                   juzhen_1[i][j] += (juzhen_0[i][k]*juzhen_0[k][j]);\r\n           }\r\n           juzhen_1[i][j] =juzhen_1[i][j]%2011;}\r\n    for(i=0;i != 4;++i)\r\n       for(j=0;j != 4;++j){\r\n           for(k=0; k != 4;++k)\r\n           {\r\n                   juzhen_2[i][j] += (juzhen_1[i][k]*juzhen_1[k][j]);\r\n           }\r\n           juzhen_2[i][j] =juzhen_2[i][j]%2011;}\r\n          \r\n    for(i=0;i != 4;++i)\r\n       for(j=0;j != 4;++j){\r\n           for(k=0; k != 4;++k)\r\n           {\r\n                   juzhen_3[i][j] += (juzhen_2[i][k]*juzhen_2[k][j]);\r\n           }\r\n           juzhen_3[i][j] =juzhen_3[i][j]%2011;}\r\n             \r\n    for(i=0;i != 4;++i)\r\n       for(j=0;j != 4;++j){\r\n           for(k=0; k != 4;++k)\r\n           {\r\n                   juzhen_4[i][j] += (juzhen_3[i][k]*juzhen_3[k][j]);\r\n           }\r\n           juzhen_4[i][j] =juzhen_4[i][j]%2011;}\r\n           \r\n    for(i=0;i != 4;++i)\r\n       for(j=0;j != 4;++j){\r\n           for(k=0; k != 4;++k)\r\n           {\r\n                   juzhen_5[i][j] += (juzhen_4[i][k]*juzhen_4[k][j]);\r\n           }\r\n           juzhen_5[i][j] =juzhen_5[i][j]%2011;}\r\n           \r\n    for(i=0;i != 4;++i)\r\n       for(j=0;j != 4;++j){\r\n           for(k=0; k != 4;++k)\r\n           {\r\n                   juzhen_6[i][j] += (juzhen_5[i][k]*juzhen_5[k][j]);\r\n           }\r\n           juzhen_6[i][j] =juzhen_6[i][j]%2011;}\r\n           \r\n    for(i=0;i != 4;++i)\r\n       for(j=0;j != 4;++j){\r\n           for(k=0; k != 4;++k)\r\n           {\r\n                   juzhen_7[i][j] += (juzhen_6[i][k]*juzhen_6[k][j]);\r\n           }\r\n           juzhen_7[i][j] =juzhen_7[i][j]%2011;}\r\n           \r\n    for(i=0;i != 4;++i)\r\n       for(j=0;j != 4;++j){\r\n           for(k=0; k != 4;++k)\r\n           {\r\n                   juzhen_8[i][j] += (juzhen_7[i][k]*juzhen_7[k][j]);\r\n           }\r\n           juzhen_8[i][j] =juzhen_8[i][j]%2011;}\r\n           \r\n    for(i=0;i != 4;++i)\r\n       for(j=0;j != 4;++j){\r\n           for(k=0; k != 4;++k)\r\n           {\r\n                   juzhen_9[i][j] += (juzhen_8[i][k]*juzhen_8[k][j]);\r\n           }\r\n           juzhen_9[i][j] =juzhen_9[i][j]%2011;}\r\n           \r\n    for(i=0;i != 4;++i)\r\n       for(j=0;j != 4;++j){\r\n           for(k=0; k != 4;++k)\r\n           {\r\n                   juzhen_10[i][j] += (juzhen_9[i][k]*juzhen_9[k][j]);\r\n           }\r\n           juzhen_10[i][j] =juzhen_10[i][j]%2011;}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    for(i=0;i != 4;++i)\r\n       for(j=0;j != 4;++j){\r\n           for(k=0; k != 4;++k)\r\n           {\r\n                   juzhen_ans1[i][j] += (juzhen_10[i][k]*juzhen_9[k][j]);\r\n           }\r\n           juzhen_ans1[i][j] =juzhen_ans1[i][j]%2011;}\r\n\r\n    for(i=0;i != 4;++i)\r\n       for(j=0;j != 4;++j){\r\n           for(k=0; k != 4;++k)\r\n           {\r\n                   juzhen_ans2[i][j] += (juzhen_ans1[i][k]*juzhen_8[k][j]);\r\n           }\r\n           juzhen_ans2[i][j] =juzhen_ans2[i][j]%2011;}\r\n    memset(juzhen_ans1,0,16*sizeof(long));   \r\n\r\n    for(i=0;i != 4;++i)\r\n       for(j=0;j != 4;++j){\r\n           for(k=0; k != 4;++k)\r\n           {\r\n                   juzhen_ans1[i][j] += (juzhen_ans2[i][k]*juzhen_7[k][j]);\r\n           }\r\n           juzhen_ans1[i][j] =juzhen_ans1[i][j]%2011;}\r\n    memset(juzhen_ans2,0,16*sizeof(long));  \r\n\r\n    for(i=0;i != 4;++i)\r\n       for(j=0;j != 4;++j){\r\n           for(k=0; k != 4;++k)\r\n           {\r\n                   juzhen_ans2[i][j] += (juzhen_ans1[i][k]*juzhen_6[k][j]);\r\n           }\r\n           juzhen_ans2[i][j] =juzhen_ans2[i][j]%2011;}\r\n    memset(juzhen_ans1,0,16*sizeof(long));   \r\n\r\n    for(i=0;i != 4;++i)\r\n       for(j=0;j != 4;++j){\r\n           for(k=0; k != 4;++k)\r\n           {\r\n                   juzhen_ans1[i][j] += (juzhen_ans2[i][k]*juzhen_4[k][j]);\r\n           }\r\n           juzhen_ans1[i][j] =juzhen_ans1[i][j]%2011;}\r\n    memset(juzhen_ans2,0,16*sizeof(long));  \r\n\r\n    for(i=0;i != 4;++i)\r\n       for(j=0;j != 4;++j){\r\n           for(k=0; k != 4;++k)\r\n           {\r\n                   juzhen_ans2[i][j] += (juzhen_ans1[i][k]*juzhen_3[k][j]);\r\n           }\r\n           juzhen_ans2[i][j] =juzhen_ans2[i][j]%2011;}\r\n    memset(juzhen_ans1,0,16*sizeof(long));   \r\n\r\n    for(i=0;i != 4;++i)\r\n       for(j=0;j != 4;++j){\r\n           for(k=0; k != 4;++k)\r\n           {\r\n                   juzhen_ans1[i][j] += (juzhen_ans2[i][k]*juzhen_1[k][j]);\r\n           }\r\n           juzhen_ans1[i][j] =juzhen_ans1[i][j]%2011;}  \r\n    memset(juzhen_ans2,0,16*sizeof(long));  \r\n\r\n    for(i=0;i != 4;++i)\r\n       for(j=0;j != 4;++j){\r\n           for(k=0; k != 4;++k)\r\n           {\r\n                   juzhen_ans2[i][j] += (juzhen_ans1[i][k]*juzhen_0[k][j]);\r\n           }\r\n           juzhen_ans2[i][j] =juzhen_ans2[i][j]%2011;}\r\n    memset(juzhen_ans1,0,16*sizeof(long));   \r\n           \r\n \r\n    \r\n    for(i=0;i != 4;++i){\r\n       for(j=0;j != 4;++j)\r\n       {\r\n       printf("%ld ",juzhen_ans2[i][j]);\r\n       }\r\n       printf("\\n");\r\n    }\r\n}\r\n                   \r\ngetchar();getchar();\r\nreturn 0;\r\n}//2011 = 2 10 2 9 2 8 2 7 2 6 2 4 2 3 2 1 2 0\r\n', '', 15, 253952, 3, 1, '2010-12-30 11:33:42', '0001-01-01 00:00:00'),
(1160, 10, 404, 9, '#include<stdio.h>\r\n#include<string.h>\r\nint main()\r\n{\r\n    int num,size;\r\n    long int juzhen_0[4][4];\r\n    long int juzhen_1[4][4];\r\n    long int juzhen_2[4][4];\r\n    long int juzhen_3[4][4];\r\n    long int juzhen_4[4][4];\r\n    long int juzhen_5[4][4];\r\n    long int juzhen_6[4][4];\r\n    long int juzhen_7[4][4];\r\n    long int juzhen_8[4][4];\r\n    long int juzhen_9[4][4];\r\n    long int juzhen_10[4][4];\r\n    long int juzhen_ans1[4][4];    \r\n    long int juzhen_ans2[4][4];\r\n	scanf("%d",&size);\r\n for(num=0;num !=size;++num)\r\n {\r\n    memset(juzhen_0,0,16*sizeof(long));     \r\n    memset(juzhen_1,0,16*sizeof(long));  \r\n    memset(juzhen_2,0,16*sizeof(long));  \r\n    memset(juzhen_3,0,16*sizeof(long));  \r\n    memset(juzhen_4,0,16*sizeof(long));  \r\n    memset(juzhen_5,0,16*sizeof(long));  \r\n    memset(juzhen_6,0,16*sizeof(long));  \r\n    memset(juzhen_7,0,16*sizeof(long));  \r\n    memset(juzhen_8,0,16*sizeof(long));  \r\n    memset(juzhen_9,0,16*sizeof(long));   \r\n    memset(juzhen_10,0,16*sizeof(long));  \r\n    memset(juzhen_ans1,0,16*sizeof(long));   \r\n    memset(juzhen_ans2,0,16*sizeof(long));   \r\n    \r\n    int i,j,k;\r\n    for(i=0;i != 4;++i)\r\n       for(j=0;j != 4;++j)\r\n           {\r\n                   scanf("%d",&juzhen_0[i][j]);\r\n           }\r\n    \r\n    for(i=0;i != 4;++i)\r\n       for(j=0;j != 4;++j){\r\n           for(k=0; k != 4;++k)\r\n           {\r\n                   juzhen_1[i][j] += (juzhen_0[i][k]*juzhen_0[k][j]);\r\n           }\r\n           juzhen_1[i][j] =juzhen_1[i][j]%2011;}\r\n    for(i=0;i != 4;++i)\r\n       for(j=0;j != 4;++j){\r\n           for(k=0; k != 4;++k)\r\n           {\r\n                   juzhen_2[i][j] += (juzhen_1[i][k]*juzhen_1[k][j]);\r\n           }\r\n           juzhen_2[i][j] =juzhen_2[i][j]%2011;}\r\n          \r\n    for(i=0;i != 4;++i)\r\n       for(j=0;j != 4;++j){\r\n           for(k=0; k != 4;++k)\r\n           {\r\n                   juzhen_3[i][j] += (juzhen_2[i][k]*juzhen_2[k][j]);\r\n           }\r\n           juzhen_3[i][j] =juzhen_3[i][j]%2011;}\r\n             \r\n    for(i=0;i != 4;++i)\r\n       for(j=0;j != 4;++j){\r\n           for(k=0; k != 4;++k)\r\n           {\r\n                   juzhen_4[i][j] += (juzhen_3[i][k]*juzhen_3[k][j]);\r\n           }\r\n           juzhen_4[i][j] =juzhen_4[i][j]%2011;}\r\n           \r\n    for(i=0;i != 4;++i)\r\n       for(j=0;j != 4;++j){\r\n           for(k=0; k != 4;++k)\r\n           {\r\n                   juzhen_5[i][j] += (juzhen_4[i][k]*juzhen_4[k][j]);\r\n           }\r\n           juzhen_5[i][j] =juzhen_5[i][j]%2011;}\r\n           \r\n    for(i=0;i != 4;++i)\r\n       for(j=0;j != 4;++j){\r\n           for(k=0; k != 4;++k)\r\n           {\r\n                   juzhen_6[i][j] += (juzhen_5[i][k]*juzhen_5[k][j]);\r\n           }\r\n           juzhen_6[i][j] =juzhen_6[i][j]%2011;}\r\n           \r\n    for(i=0;i != 4;++i)\r\n       for(j=0;j != 4;++j){\r\n           for(k=0; k != 4;++k)\r\n           {\r\n                   juzhen_7[i][j] += (juzhen_6[i][k]*juzhen_6[k][j]);\r\n           }\r\n           juzhen_7[i][j] =juzhen_7[i][j]%2011;}\r\n           \r\n    for(i=0;i != 4;++i)\r\n       for(j=0;j != 4;++j){\r\n           for(k=0; k != 4;++k)\r\n           {\r\n                   juzhen_8[i][j] += (juzhen_7[i][k]*juzhen_7[k][j]);\r\n           }\r\n           juzhen_8[i][j] =juzhen_8[i][j]%2011;}\r\n           \r\n    for(i=0;i != 4;++i)\r\n       for(j=0;j != 4;++j){\r\n           for(k=0; k != 4;++k)\r\n           {\r\n                   juzhen_9[i][j] += (juzhen_8[i][k]*juzhen_8[k][j]);\r\n           }\r\n           juzhen_9[i][j] =juzhen_9[i][j]%2011;}\r\n           \r\n    for(i=0;i != 4;++i)\r\n       for(j=0;j != 4;++j){\r\n           for(k=0; k != 4;++k)\r\n           {\r\n                   juzhen_10[i][j] += (juzhen_9[i][k]*juzhen_9[k][j]);\r\n           }\r\n           juzhen_10[i][j] =juzhen_10[i][j]%2011;}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    for(i=0;i != 4;++i)\r\n       for(j=0;j != 4;++j){\r\n           for(k=0; k != 4;++k)\r\n           {\r\n                   juzhen_ans1[i][j] += (juzhen_10[i][k]*juzhen_9[k][j]);\r\n           }\r\n           juzhen_ans1[i][j] =juzhen_ans1[i][j]%2011;}\r\n\r\n    for(i=0;i != 4;++i)\r\n       for(j=0;j != 4;++j){\r\n           for(k=0; k != 4;++k)\r\n           {\r\n                   juzhen_ans2[i][j] += (juzhen_ans1[i][k]*juzhen_8[k][j]);\r\n           }\r\n           juzhen_ans2[i][j] =juzhen_ans2[i][j]%2011;}\r\n    memset(juzhen_ans1,0,16*sizeof(long));   \r\n\r\n    for(i=0;i != 4;++i)\r\n       for(j=0;j != 4;++j){\r\n           for(k=0; k != 4;++k)\r\n           {\r\n                   juzhen_ans1[i][j] += (juzhen_ans2[i][k]*juzhen_7[k][j]);\r\n           }\r\n           juzhen_ans1[i][j] =juzhen_ans1[i][j]%2011;}\r\n    memset(juzhen_ans2,0,16*sizeof(long));  \r\n\r\n    for(i=0;i != 4;++i)\r\n       for(j=0;j != 4;++j){\r\n           for(k=0; k != 4;++k)\r\n           {\r\n                   juzhen_ans2[i][j] += (juzhen_ans1[i][k]*juzhen_6[k][j]);\r\n           }\r\n           juzhen_ans2[i][j] =juzhen_ans2[i][j]%2011;}\r\n    memset(juzhen_ans1,0,16*sizeof(long));   \r\n\r\n    for(i=0;i != 4;++i)\r\n       for(j=0;j != 4;++j){\r\n           for(k=0; k != 4;++k)\r\n           {\r\n                   juzhen_ans1[i][j] += (juzhen_ans2[i][k]*juzhen_4[k][j]);\r\n           }\r\n           juzhen_ans1[i][j] =juzhen_ans1[i][j]%2011;}\r\n    memset(juzhen_ans2,0,16*sizeof(long));  \r\n\r\n    for(i=0;i != 4;++i)\r\n       for(j=0;j != 4;++j){\r\n           for(k=0; k != 4;++k)\r\n           {\r\n                   juzhen_ans2[i][j] += (juzhen_ans1[i][k]*juzhen_3[k][j]);\r\n           }\r\n           juzhen_ans2[i][j] =juzhen_ans2[i][j]%2011;}\r\n    memset(juzhen_ans1,0,16*sizeof(long));   \r\n\r\n    for(i=0;i != 4;++i)\r\n       for(j=0;j != 4;++j){\r\n           for(k=0; k != 4;++k)\r\n           {\r\n                   juzhen_ans1[i][j] += (juzhen_ans2[i][k]*juzhen_1[k][j]);\r\n           }\r\n           juzhen_ans1[i][j] =juzhen_ans1[i][j]%2011;}  \r\n    memset(juzhen_ans2,0,16*sizeof(long));  \r\n\r\n    for(i=0;i != 4;++i)\r\n       for(j=0;j != 4;++j){\r\n           for(k=0; k != 4;++k)\r\n           {\r\n                   juzhen_ans2[i][j] += (juzhen_ans1[i][k]*juzhen_0[k][j]);\r\n           }\r\n           juzhen_ans2[i][j] =juzhen_ans2[i][j]%2011;}\r\n    memset(juzhen_ans1,0,16*sizeof(long));   \r\n           \r\n \r\n    \r\n    for(i=0;i != 4;++i){\r\n       for(j=0;j != 4;++j)\r\n       {\r\n       printf("%ld",juzhen_ans2[i][j]);\r\n	   if(j!=4)\r\n		   printf(" ");\r\n       }\r\n       printf("\\n");\r\n    }\r\n	printf("\\n");\r\n}\r\n                   \r\ngetchar();getchar();\r\nreturn 0;\r\n}//2011 = 2 10 2 9 2 8 2 7 2 6 2 4 2 3 2 1 2 0\r\n', '', 15, 258048, 3, 1, '2010-12-30 11:35:25', '0001-01-01 00:00:00'),
(1161, 10, 404, 9, '#include<stdio.h>\r\n#include<string.h>\r\nint main()\r\n{\r\n    int num,size;\r\n    long int juzhen_0[4][4];\r\n    long int juzhen_1[4][4];\r\n    long int juzhen_2[4][4];\r\n    long int juzhen_3[4][4];\r\n    long int juzhen_4[4][4];\r\n    long int juzhen_5[4][4];\r\n    long int juzhen_6[4][4];\r\n    long int juzhen_7[4][4];\r\n    long int juzhen_8[4][4];\r\n    long int juzhen_9[4][4];\r\n    long int juzhen_10[4][4];\r\n    long int juzhen_ans1[4][4];    \r\n    long int juzhen_ans2[4][4];\r\n	scanf("%d",&size);\r\n for(num=0;num !=size;++num)\r\n {\r\n    memset(juzhen_0,0,16*sizeof(long));     \r\n    memset(juzhen_1,0,16*sizeof(long));  \r\n    memset(juzhen_2,0,16*sizeof(long));  \r\n    memset(juzhen_3,0,16*sizeof(long));  \r\n    memset(juzhen_4,0,16*sizeof(long));  \r\n    memset(juzhen_5,0,16*sizeof(long));  \r\n    memset(juzhen_6,0,16*sizeof(long));  \r\n    memset(juzhen_7,0,16*sizeof(long));  \r\n    memset(juzhen_8,0,16*sizeof(long));  \r\n    memset(juzhen_9,0,16*sizeof(long));   \r\n    memset(juzhen_10,0,16*sizeof(long));  \r\n    memset(juzhen_ans1,0,16*sizeof(long));   \r\n    memset(juzhen_ans2,0,16*sizeof(long));   \r\n    \r\n    int i,j,k;\r\n    for(i=0;i != 4;++i)\r\n       for(j=0;j != 4;++j)\r\n           {\r\n                   scanf("%d",&juzhen_0[i][j]);\r\n           }\r\n    \r\n    for(i=0;i != 4;++i)\r\n       for(j=0;j != 4;++j){\r\n           for(k=0; k != 4;++k)\r\n           {\r\n                   juzhen_1[i][j] += (juzhen_0[i][k]*juzhen_0[k][j]);\r\n           }\r\n           juzhen_1[i][j] =juzhen_1[i][j]%2011;}\r\n    for(i=0;i != 4;++i)\r\n       for(j=0;j != 4;++j){\r\n           for(k=0; k != 4;++k)\r\n           {\r\n                   juzhen_2[i][j] += (juzhen_1[i][k]*juzhen_1[k][j]);\r\n           }\r\n           juzhen_2[i][j] =juzhen_2[i][j]%2011;}\r\n          \r\n    for(i=0;i != 4;++i)\r\n       for(j=0;j != 4;++j){\r\n           for(k=0; k != 4;++k)\r\n           {\r\n                   juzhen_3[i][j] += (juzhen_2[i][k]*juzhen_2[k][j]);\r\n           }\r\n           juzhen_3[i][j] =juzhen_3[i][j]%2011;}\r\n             \r\n    for(i=0;i != 4;++i)\r\n       for(j=0;j != 4;++j){\r\n           for(k=0; k != 4;++k)\r\n           {\r\n                   juzhen_4[i][j] += (juzhen_3[i][k]*juzhen_3[k][j]);\r\n           }\r\n           juzhen_4[i][j] =juzhen_4[i][j]%2011;}\r\n           \r\n    for(i=0;i != 4;++i)\r\n       for(j=0;j != 4;++j){\r\n           for(k=0; k != 4;++k)\r\n           {\r\n                   juzhen_5[i][j] += (juzhen_4[i][k]*juzhen_4[k][j]);\r\n           }\r\n           juzhen_5[i][j] =juzhen_5[i][j]%2011;}\r\n           \r\n    for(i=0;i != 4;++i)\r\n       for(j=0;j != 4;++j){\r\n           for(k=0; k != 4;++k)\r\n           {\r\n                   juzhen_6[i][j] += (juzhen_5[i][k]*juzhen_5[k][j]);\r\n           }\r\n           juzhen_6[i][j] =juzhen_6[i][j]%2011;}\r\n           \r\n    for(i=0;i != 4;++i)\r\n       for(j=0;j != 4;++j){\r\n           for(k=0; k != 4;++k)\r\n           {\r\n                   juzhen_7[i][j] += (juzhen_6[i][k]*juzhen_6[k][j]);\r\n           }\r\n           juzhen_7[i][j] =juzhen_7[i][j]%2011;}\r\n           \r\n    for(i=0;i != 4;++i)\r\n       for(j=0;j != 4;++j){\r\n           for(k=0; k != 4;++k)\r\n           {\r\n                   juzhen_8[i][j] += (juzhen_7[i][k]*juzhen_7[k][j]);\r\n           }\r\n           juzhen_8[i][j] =juzhen_8[i][j]%2011;}\r\n           \r\n    for(i=0;i != 4;++i)\r\n       for(j=0;j != 4;++j){\r\n           for(k=0; k != 4;++k)\r\n           {\r\n                   juzhen_9[i][j] += (juzhen_8[i][k]*juzhen_8[k][j]);\r\n           }\r\n           juzhen_9[i][j] =juzhen_9[i][j]%2011;}\r\n           \r\n    for(i=0;i != 4;++i)\r\n       for(j=0;j != 4;++j){\r\n           for(k=0; k != 4;++k)\r\n           {\r\n                   juzhen_10[i][j] += (juzhen_9[i][k]*juzhen_9[k][j]);\r\n           }\r\n           juzhen_10[i][j] =juzhen_10[i][j]%2011;}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    for(i=0;i != 4;++i)\r\n       for(j=0;j != 4;++j){\r\n           for(k=0; k != 4;++k)\r\n           {\r\n                   juzhen_ans1[i][j] += (juzhen_10[i][k]*juzhen_9[k][j]);\r\n           }\r\n           juzhen_ans1[i][j] =juzhen_ans1[i][j]%2011;}\r\n\r\n    for(i=0;i != 4;++i)\r\n       for(j=0;j != 4;++j){\r\n           for(k=0; k != 4;++k)\r\n           {\r\n                   juzhen_ans2[i][j] += (juzhen_ans1[i][k]*juzhen_8[k][j]);\r\n           }\r\n           juzhen_ans2[i][j] =juzhen_ans2[i][j]%2011;}\r\n    memset(juzhen_ans1,0,16*sizeof(long));   \r\n\r\n    for(i=0;i != 4;++i)\r\n       for(j=0;j != 4;++j){\r\n           for(k=0; k != 4;++k)\r\n           {\r\n                   juzhen_ans1[i][j] += (juzhen_ans2[i][k]*juzhen_7[k][j]);\r\n           }\r\n           juzhen_ans1[i][j] =juzhen_ans1[i][j]%2011;}\r\n    memset(juzhen_ans2,0,16*sizeof(long));  \r\n\r\n    for(i=0;i != 4;++i)\r\n       for(j=0;j != 4;++j){\r\n           for(k=0; k != 4;++k)\r\n           {\r\n                   juzhen_ans2[i][j] += (juzhen_ans1[i][k]*juzhen_6[k][j]);\r\n           }\r\n           juzhen_ans2[i][j] =juzhen_ans2[i][j]%2011;}\r\n    memset(juzhen_ans1,0,16*sizeof(long));   \r\n\r\n    for(i=0;i != 4;++i)\r\n       for(j=0;j != 4;++j){\r\n           for(k=0; k != 4;++k)\r\n           {\r\n                   juzhen_ans1[i][j] += (juzhen_ans2[i][k]*juzhen_4[k][j]);\r\n           }\r\n           juzhen_ans1[i][j] =juzhen_ans1[i][j]%2011;}\r\n    memset(juzhen_ans2,0,16*sizeof(long));  \r\n\r\n    for(i=0;i != 4;++i)\r\n       for(j=0;j != 4;++j){\r\n           for(k=0; k != 4;++k)\r\n           {\r\n                   juzhen_ans2[i][j] += (juzhen_ans1[i][k]*juzhen_3[k][j]);\r\n           }\r\n           juzhen_ans2[i][j] =juzhen_ans2[i][j]%2011;}\r\n    memset(juzhen_ans1,0,16*sizeof(long));   \r\n\r\n    for(i=0;i != 4;++i)\r\n       for(j=0;j != 4;++j){\r\n           for(k=0; k != 4;++k)\r\n           {\r\n                   juzhen_ans1[i][j] += (juzhen_ans2[i][k]*juzhen_1[k][j]);\r\n           }\r\n           juzhen_ans1[i][j] =juzhen_ans1[i][j]%2011;}  \r\n    memset(juzhen_ans2,0,16*sizeof(long));  \r\n\r\n    for(i=0;i != 4;++i)\r\n       for(j=0;j != 4;++j){\r\n           for(k=0; k != 4;++k)\r\n           {\r\n                   juzhen_ans2[i][j] += (juzhen_ans1[i][k]*juzhen_0[k][j]);\r\n           }\r\n           juzhen_ans2[i][j] =juzhen_ans2[i][j]%2011;}\r\n    memset(juzhen_ans1,0,16*sizeof(long));   \r\n           \r\n \r\n    \r\n    for(i=0;i != 4;++i){\r\n       for(j=0;j != 4;++j)\r\n       {\r\n       printf("%ld",juzhen_ans2[i][j]);\r\n	   if(j!=3)\r\n		   printf(" ");\r\n       }\r\n       printf("\\n");\r\n    }\r\n	//if(num != size-1)\r\n	printf("\\n");\r\n}\r\n                   \r\ngetchar();getchar();\r\nreturn 0;\r\n}//2011 = 2 10 2 9 2 8 2 7 2 6 2 4 2 3 2 1 2 0\r\n', '', 30, 258048, 1, 1, '2010-12-30 11:36:49', '0001-01-01 00:00:00'),
(1162, 27, 339, 3, '#include<stdio.h>\r\nint countnumber(int n)\r\n{\r\n		int count=0;\r\n		while(n)\r\n		{\r\n			n=n&(n-1);\r\n			count++;\r\n		}\r\n  	return count;\r\n}\r\n\r\nint Partition(int a[],int low,int high)\r\n{\r\n	int pivotkey=a[low];\r\n	a[0]=a[low];\r\n    while(low<high){\r\n		while(low<high && a[high]>=pivotkey) --high;\r\n		a[low]=a[high];\r\n		while(low<high && a[low]<=pivotkey) ++low;\r\n		a[high]=a[low];\r\n	}\r\n	a[low]=a[0];\r\n	return low;\r\n}\r\n\r\nvoid qsort(int a[],int low,int high)\r\n{\r\n	int pivotloc;\r\n	if(low<high){\r\n		pivotloc=Partition(a,low,high);\r\n		qsort(a,low,pivotloc-1);\r\n		qsort(a,pivotloc+1,high);\r\n	}\r\n}\r\n\r\n\r\nint main()\r\n{\r\n	int a[100000],k[1000],i,n,r,num;	\r\n    while(scanf("%d %d",&n,&r)==2){\r\n		for(i=1;i<=r;++i) scanf("%d",&k[i]);\r\n        for(i=1;i<=n;++i) scanf("%d",&a[i]);\r\n//		for(i=0;i<10;++i)	printf("%d  ",a[i]);\r\n//		printf("\\n");\r\n\r\n        qsort(a,1,n);\r\n //       for(i=1;i<=n;++i) printf("%d\\n",a[i]);\r\n        for(i=1;i<=r;++i) printf("%d\\n",a[n-k[i]]);\r\n	}\r\n    return 0;\r\n}', '', 202, 626688, 1, 1, '2010-12-30 11:58:50', '0001-01-01 00:00:00'),
(1163, 27, 336, 2, '#include<stdio.h>\r\n//int a[50001],b[50001];\r\n\r\nint countnumber(int n)\r\n{\r\n		int count=0;\r\n		while(n)\r\n		{\r\n			n=n&(n-1);\r\n			count++;\r\n		}\r\n  	return count;\r\n}\r\n\r\nint Partition(int a[],int b[],int low,int high)\r\n{\r\n	int pivotkey=b[low];\r\n	a[0]=a[low];\r\n	b[0]=b[low];\r\n    while(low<high){\r\n		while(low<high && b[high]>=pivotkey) --high;\r\n		a[low]=a[high];\r\n        b[low]=b[high];\r\n		while(low<high && b[low]<=pivotkey) ++low;\r\n		a[high]=a[low];\r\n		b[high]=b[low];\r\n	}\r\n	a[low]=a[0];\r\n	b[low]=b[0];\r\n	return low;\r\n}\r\n\r\nvoid qsort(int a[],int b[],int low,int high)\r\n{\r\n	int pivotloc;\r\n	if(low<high){\r\n		pivotloc=Partition(a,b,low,high);\r\n		qsort(a,b,low,pivotloc-1);\r\n		qsort(a,b,pivotloc+1,high);\r\n	}\r\n}\r\n\r\n\r\nint main()\r\n{\r\n//	int n,i,j,k,m,c,first;\r\n	int n,i,m,first;\r\n	int a[50001],b[50001];\r\n	while(scanf("%d",&n)==1)\r\n	{  \r\n		a[0]=0;\r\n		b[0]=0;\r\n		for(i=1;i<=n;++i){\r\n			scanf("%d",&a[i]);\r\n		    b[i]=countnumber(a[i]);\r\n		}\r\n\r\n		qsort(a,b,1,n);		\r\n        for(i=1;i<=n;++i){	\r\n			m=b[i];\r\n			first=i;\r\n			while(m==b[i+1]) ++i;\r\n			if(first!=i){\r\n				qsort(b,a,first,i);\r\n/*				for(k=1;k<i-first;++k){\r\n	            	for(j=first;j<i;++j){\r\n	            		if(a[j]>a[j+1]){\r\n	            			c=a[j];\r\n	            			a[j]=a[j+1];\r\n	            			a[j+1]=c;\r\n						}\r\n					}\r\n				}\r\n		*/\r\n			}\r\n		}\r\n	\r\n		for(i=1;i<n;++i) printf("%d ",a[i]);\r\n		printf("%d",a[i]);\r\n		printf("\\n");\r\n	}\r\n	return 0;\r\n}', '', 46, 712704, 4, 1, '2010-12-30 12:44:43', '0001-01-01 00:00:00'),
(1164, 27, 336, 2, '#include<stdio.h>\r\n//int a[50001],b[50001];\r\n\r\nint countnumber(int n)\r\n{\r\n		int count=0;\r\n		while(n)\r\n		{\r\n			n=n&(n-1);\r\n			count++;\r\n		}\r\n  	return count;\r\n}\r\n\r\nint Partition(int a[],int b[],int low,int high)\r\n{\r\n	int pivotkey=b[low];\r\n	a[0]=a[low];\r\n	b[0]=b[low];\r\n    while(low<high){\r\n		while(low<high && b[high]>=pivotkey) --high;\r\n		a[low]=a[high];\r\n        b[low]=b[high];\r\n		while(low<high && b[low]<=pivotkey) ++low;\r\n		a[high]=a[low];\r\n		b[high]=b[low];\r\n	}\r\n	a[low]=a[0];\r\n	b[low]=b[0];\r\n	return low;\r\n}\r\n\r\nvoid qsort(int a[],int b[],int low,int high)\r\n{\r\n	int pivotloc;\r\n	if(low<high){\r\n		pivotloc=Partition(a,b,low,high);\r\n		qsort(a,b,low,pivotloc-1);\r\n		qsort(a,b,pivotloc+1,high);\r\n	}\r\n}\r\n\r\n\r\nint main()\r\n{\r\n//	int n,i,j,k,m,c,first;\r\n	int n,i,m,first;\r\n	int a[50001],b[50001];\r\n	while(scanf("%d",&n)==1)\r\n	{  \r\n		a[0]=0;\r\n		b[0]=0;\r\n		for(i=1;i<=n;++i){\r\n			scanf("%d",&a[i]);\r\n		    b[i]=countnumber(a[i]);\r\n		}\r\n\r\n		qsort(a,b,1,n);		\r\n        for(i=1;i<=n;++i){	\r\n			m=b[i];\r\n			first=i;\r\n			while(m==b[i+1]) ++i;\r\n			if(first!=i){\r\n				qsort(b,a,first,i);\r\n/*				for(k=1;k<i-first;++k){\r\n	            	for(j=first;j<i;++j){\r\n	            		if(a[j]>a[j+1]){\r\n	            			c=a[j];\r\n	            			a[j]=a[j+1];\r\n	            			a[j+1]=c;\r\n						}\r\n					}\r\n				}\r\n		*/\r\n			}\r\n		}\r\n	\r\n		for(i=1;i<n;++i) printf("%d ",a[i]);\r\n		printf("%d",a[i]);\r\n		printf("\\n");\r\n	}\r\n	return 0;\r\n}', '', 46, 708608, 4, 1, '2010-12-30 12:46:00', '0001-01-01 00:00:00'),
(1165, 27, 336, 2, '#include<stdio.h>\r\n//int a[50001],b[50001];\r\n\r\nint countnumber(int n)\r\n{\r\n		int count=0;\r\n		while(n)\r\n		{\r\n			n=n&(n-1);\r\n			count++;\r\n		}\r\n  	return count;\r\n}\r\n\r\nint Partition(int a[],int b[],int low,int high)\r\n{\r\n	int pivotkey=b[low];\r\n	a[0]=a[low];\r\n	b[0]=b[low];\r\n    while(low<high){\r\n		while(low<high && b[high]>=pivotkey) --high;\r\n		a[low]=a[high];\r\n        b[low]=b[high];\r\n		while(low<high && b[low]<=pivotkey) ++low;\r\n		a[high]=a[low];\r\n		b[high]=b[low];\r\n	}\r\n	a[low]=a[0];\r\n	b[low]=b[0];\r\n	return low;\r\n}\r\n\r\nvoid qsort(int a[],int b[],int low,int high)\r\n{\r\n	int pivotloc;\r\n	if(low<high){\r\n		pivotloc=Partition(a,b,low,high);\r\n		qsort(a,b,low,pivotloc-1);\r\n		qsort(a,b,pivotloc+1,high);\r\n	}\r\n}\r\n\r\n\r\nint main()\r\n{\r\n//	int n,i,j,k,m,c,first;\r\n	int n,i,m,first;\r\n	int a[50002],b[50002];\r\n	while(scanf("%d",&n)==1)\r\n	{  \r\n		a[0]=0;\r\n		b[0]=0;\r\n		for(i=1;i<=n;++i){\r\n			scanf("%d",&a[i]);\r\n		    b[i]=countnumber(a[i]);\r\n		}\r\n\r\n		qsort(a,b,1,n);		\r\n        for(i=1;i<=n;++i){	\r\n			m=b[i];\r\n			first=i;\r\n			while(m==b[i+1]) ++i;\r\n			if(first!=i){\r\n				qsort(b,a,first,i);\r\n/*				for(k=1;k<i-first;++k){\r\n	            	for(j=first;j<i;++j){\r\n	            		if(a[j]>a[j+1]){\r\n	            			c=a[j];\r\n	            			a[j]=a[j+1];\r\n	            			a[j+1]=c;\r\n						}\r\n					}\r\n				}\r\n		*/\r\n			}\r\n		}\r\n	\r\n		for(i=1;i<n;++i) printf("%d ",a[i]);\r\n		printf("%d",a[i]);\r\n		printf("\\n");\r\n	}\r\n	return 0;\r\n}', '', 46, 712704, 4, 1, '2010-12-30 13:04:10', '0001-01-01 00:00:00'),
(1166, 27, 336, 2, '#include<stdio.h>\r\n//int a[50001],b[50001];\r\n\r\nint countnumber(int n)\r\n{\r\n		int count=0;\r\n		while(n)\r\n		{\r\n			n=n&(n-1);\r\n			count++;\r\n		}\r\n  	return count;\r\n}\r\n\r\nint Partition(int a[],int b[],int low,int high)\r\n{\r\n	int pivotkey=b[low];\r\n	a[0]=a[low];\r\n	b[0]=b[low];\r\n    while(low<high){\r\n		while(low<high && b[high]>=pivotkey) --high;\r\n		a[low]=a[high];\r\n        b[low]=b[high];\r\n		while(low<high && b[low]<=pivotkey) ++low;\r\n		a[high]=a[low];\r\n		b[high]=b[low];\r\n	}\r\n	a[low]=a[0];\r\n	b[low]=b[0];\r\n	return low;\r\n}\r\n\r\nvoid qsort(int a[],int b[],int low,int high)\r\n{\r\n	int pivotloc;\r\n	if(low<high){\r\n		pivotloc=Partition(a,b,low,high);\r\n		qsort(a,b,low,pivotloc-1);\r\n		qsort(a,b,pivotloc+1,high);\r\n	}\r\n}\r\n\r\n\r\nint main()\r\n{\r\n//	int n,i,j,k,m,c,first;\r\n	int n,i,m,first;\r\n	int a[50002],b[50002];\r\n	while(scanf("%d",&n)==1)\r\n	{  \r\n	if(n>0){\r\n		a[0]=0;\r\n		b[0]=0;\r\n		for(i=1;i<=n;++i){\r\n			scanf("%d",&a[i]);\r\n		    b[i]=countnumber(a[i]);\r\n		}\r\n\r\n		qsort(a,b,1,n);		\r\n        for(i=1;i<=n;++i){	\r\n			m=b[i];\r\n			first=i;\r\n			while(m==b[i+1]) ++i;\r\n			if(first!=i){\r\n				qsort(b,a,first,i);\r\n/*				for(k=1;k<i-first;++k){\r\n	            	for(j=first;j<i;++j){\r\n	            		if(a[j]>a[j+1]){\r\n	            			c=a[j];\r\n	            			a[j]=a[j+1];\r\n	            			a[j+1]=c;\r\n						}\r\n					}\r\n				}\r\n		*/\r\n			}\r\n		}\r\n	\r\n		for(i=1;i<n;++i) printf("%d ",a[i]);\r\n//		printf("\\n");\r\n//		for(i=1;i<=n;++i) printf("%d ",b[i]);\r\n		printf("%d",a[i]);\r\n		printf("\\n");\r\n	}\r\n	}\r\n	return 0;\r\n}', '', 61, 712704, 3, 1, '2010-12-30 13:36:51', '0001-01-01 00:00:00'),
(1167, 27, 336, 2, '#include<stdio.h>\r\n//int a[50001],b[50001];\r\n\r\nint countnumber(int n)\r\n{\r\n		int count=0;\r\n		while(n)\r\n		{\r\n			n=n&(n-1);\r\n			count++;\r\n		}\r\n  	return count;\r\n}\r\n\r\nint Partition(int a[],int b[],int low,int high)\r\n{\r\n	int pivotkey=b[low];\r\n	a[0]=a[low];\r\n	b[0]=b[low];\r\n    while(low<high){\r\n		while(low<high && b[high]>=pivotkey) --high;\r\n		a[low]=a[high];\r\n        b[low]=b[high];\r\n		while(low<high && b[low]<=pivotkey) ++low;\r\n		a[high]=a[low];\r\n		b[high]=b[low];\r\n	}\r\n	a[low]=a[0];\r\n	b[low]=b[0];\r\n	return low;\r\n}\r\n\r\nvoid qsort(int a[],int b[],int low,int high)\r\n{\r\n	int pivotloc;\r\n	if(low<high){\r\n		pivotloc=Partition(a,b,low,high);\r\n		qsort(a,b,low,pivotloc-1);\r\n		qsort(a,b,pivotloc+1,high);\r\n	}\r\n}\r\n\r\n\r\nint main()\r\n{\r\n//	int n,i,j,k,m,c,first;\r\n	int n,i,m,first;\r\n	int a[50002],b[50002];\r\n	while(scanf("%d",&n)==1)\r\n	{  \r\n	if(n>0){\r\n		a[0]=0;\r\n		b[0]=0;\r\n		for(i=1;i<=n;++i){\r\n			scanf("%d",&a[i]);\r\n		    b[i]=countnumber(a[i]);\r\n		}\r\n\r\n		qsort(a,b,1,n);		\r\n        for(i=1;i<=n;++i){	\r\n			m=b[i];\r\n			first=i;\r\n			while(m==b[i+1]) ++i;\r\n			if(first!=i){\r\n				qsort(b,a,first,i);\r\n/*				for(k=1;k<i-first;++k){\r\n	            	for(j=first;j<i;++j){\r\n	            		if(a[j]>a[j+1]){\r\n	            			c=a[j];\r\n	            			a[j]=a[j+1];\r\n	            			a[j+1]=c;\r\n						}\r\n					}\r\n				}\r\n		*/\r\n			}\r\n		}\r\n	\r\n		for(i=1;i<n;++i) printf("%d ",a[i]);\r\n//		printf("\\n");\r\n//		for(i=1;i<=n;++i) printf("%d ",b[i]);\r\n		printf("%d",a[i]);\r\n	}\r\n		printf("\\n");\r\n	}\r\n	return 0;\r\n}', '', 200, 905216, 5, 1, '2010-12-30 13:39:20', '0001-01-01 00:00:00'),
(1168, 27, 336, 2, '#include<iostream>\r\n#include<vector>\r\n#include<algorithm>\r\nusing namespace std;\r\n#define N 50000\r\nint getBitCount_method1(int n)\r\n{\r\n    int num = 0;\r\n    while(n)\r\n    {\r\n         n &=(n-1);\r\n         num++;\r\n         }\r\n    return num;\r\n}\r\n\r\nint Cmp(const void*a,const void *b)\r\n{\r\nreturn(*(int *)a-*(int *)b);\r\n\r\n}\r\n\r\nvector<int> getSortVec(int a[], int count[], int n)\r\n{\r\nvector<int> rstVec;\r\nvector<int> vecArray[33]; \r\nint i;\r\nint j;\r\nfor ( i = 0; i < n; ++i)\r\n{\r\n   vecArray[count[i]].push_back(a[i]); \r\n}\r\n\r\n\r\nfor ( i = 0; i <= 32; ++i)\r\n{\r\n   for ( j = 0; j < vecArray[i].size(); ++j)\r\n   {\r\n    rstVec.push_back(vecArray[i][j]);\r\n   }\r\n}\r\n\r\nreturn rstVec;\r\n}\r\n\r\nint main()\r\n{\r\n    int n;\r\n    int i;\r\n    int a[N];\r\n    while(scanf("%d",&n)==1)\r\n    {\r\n        for(i=0;i<n;i++)\r\n        scanf("%d",&a[i]);\r\n        qsort(a,n,sizeof(a[0]),Cmp); \r\n        int count[N];\r\n        for ( i = 0; i < n; ++i)\r\n       {\r\n          count[i] = getBitCount_method1(a[i]);\r\n        }\r\n\r\n\r\n       vector<int> rstVec = getSortVec(a, count, n);\r\n\r\n       for ( i = 0; i <rstVec.size(); ++i){ \r\n	     if(i==rstVec.size()-1)\r\n            cout << rstVec[i] ;\r\n         else \r\n        cout << rstVec[i] << " ";\r\n       }\r\n      cout << endl;\r\n/*      int x=rstVec.size();\r\n       for ( i = 0; i <x; ++i){ \r\n	     if(i==x-1)\r\n            cout << count[i] ;\r\n         else \r\n        cout << count[i] << " ";\r\n       }\r\n      cout << endl;\r\n*/   }\r\n   return 0;\r\n}\r\n    ', 'Main.cpp: In function ''int main()'':\r\nMain.cpp:51:24: error: ''scanf'' was not declared in this scope\r\n', 0, 0, 2, 2, '2010-12-30 13:41:28', '0001-01-01 00:00:00'),
(1169, 27, 336, 2, '#include<iostream>\r\n#include<vector>\r\n#include<algorithm>\r\nusing namespace std;\r\n#define N 50000\r\nint getBitCount_method1(int n)\r\n{\r\n    int num = 0;\r\n    while(n)\r\n    {\r\n         n &=(n-1);\r\n         num++;\r\n         }\r\n    return num;\r\n}\r\nint Cmp(const void*a,const void *b)\r\n{\r\nreturn(*(int *)a-*(int *)b);\r\n\r\n}\r\nvector<int> getSortVec(int a[], int count[], int n)\r\n{\r\nvector<int> rstVec;\r\nvector<int> vecArray[33]; \r\nint i;\r\nint j;\r\nfor ( i = 0; i < n; ++i)\r\n{\r\n   vecArray[count[i]].push_back(a[i]); \r\n}\r\n\r\n\r\nfor ( i = 0; i <= 32; ++i)\r\n{\r\n   for ( j = 0; j < vecArray[i].size(); ++j)\r\n   {\r\n    rstVec.push_back(vecArray[i][j]);\r\n   }\r\n}\r\nreturn rstVec;\r\n}\r\nint main()\r\n{\r\n    int n;\r\n    int i;\r\n    int a[N];\r\n    while(scanf("%d",&n)==1)\r\n    {\r\n        for(i=0;i<n;i++)\r\n            scanf("%d",&a[i]);\r\n        qsort(a,n,sizeof(a[0]),Cmp); \r\n        int count[N];\r\n        for ( i = 0; i < n; ++i)\r\n       {\r\n          count[i] = getBitCount_method1(a[i]);\r\n        }\r\n\r\n\r\nvector<int> rstVec = getSortVec(a, count, n);\r\n\r\nfor ( i = 0; i <rstVec.size(); ++i)\r\n{ \r\n	if(i==rstVec.size()-1)\r\n     cout << rstVec[i] ;\r\n   else \r\n    cout << rstVec[i] << " ";\r\n}\r\ncout << endl;\r\n\r\n}\r\nreturn 0;\r\n}', 'Main.cpp: In function ''int main()'':\r\nMain.cpp:47:24: error: ''scanf'' was not declared in this scope\r\n', 0, 0, 2, 2, '2010-12-30 13:42:02', '0001-01-01 00:00:00'),
(1170, 27, 374, 5, '啊啊', 'Main.c:1:1: error: stray ''\\345'' in program\r\nMain.c:1:1: error: stray ''\\225'' in program\r\nMain.c:1:1: error: stray ''\\212'' in program\r\nMain.c:1:1: error: stray ''\\345'' in program\r\nMain.c:1:1: error: stray ''\\225'' in program\r\nMain.c:1:1: error: stray ''\\212'' in program\r\n', 0, 0, 2, 1, '2010-12-30 13:47:19', '0001-01-01 00:00:00'),
(1171, 27, 375, 5, '#include<stdio.h>\r\nint main()\r\n{\r\n	int a[50000];\r\n	int b[50001]={0};\r\n    int i,j,n,k;\r\n    while(scanf("%d",&n)==1){\r\n    	for(i=0;i<n;++i) scanf("%d",&a[i]);\r\n        k=1;\r\n        b[1]=a[0];\r\n        for(i=1;i<n;i++){\r\n        for(j=k;j>=1 && b[j]>a[i];--j);\r\n        b[j+1]=a[i];\r\n        if(j==k) k++;\r\n        }  \r\n		printf("%d",k);  \r\n    }\r\n    \r\n    return 0;\r\n}', '', 202, 618496, 3, 1, '2010-12-30 14:53:41', '0001-01-01 00:00:00'),
(1172, 27, 375, 5, '#include<stdio.h>\r\nint main()\r\n{\r\n	int a[50000];\r\n	int b[50001]={0};\r\n    int i,j,n,k;\r\n    while(scanf("%d",&n)==1){\r\n    	for(i=0;i<n;++i) scanf("%d",&a[i]);\r\n        k=1;\r\n        b[1]=a[0];\r\n        for(i=1;i<n;i++){\r\n        for(j=k;j>=1 && b[j]>a[i];--j);\r\n        b[j+1]=a[i];\r\n        if(j==k) k++;\r\n        }  \r\n		printf("%d\\n",k);  \r\n    }\r\n    \r\n    return 0;\r\n}', '', 187, 618496, 1, 1, '2010-12-30 14:54:46', '0001-01-01 00:00:00'),
(1173, 21, 378, 6, '#include <stdio.h> \r\n#include <math.h> \r\nconst int MAX = 101 ; \r\nstruct point { float x ;float y ; } p[MAX] ; \r\nint main() \r\n{ \r\n	int  n , m , i , sum , t1 , t2 ;\r\n	float f ;\r\n	point t ; \r\n	while ( scanf( "%d" , &n )  ) \r\n	{ \r\n		scanf ( "%d" , &m ) ; \r\n		for ( i = 0 ; i < n ; i ++ ) scanf ( "%f%f" , &p[ i ].x , &p[ i ].y ) ; \r\n		p[ n ] = p[ 0 ]  ; \r\n		while ( m -- ) \r\n		{ \r\n			scanf ( "%f%f" , &t.x , &t.y ); \r\n			for ( i = 0 ; i <= n ; i ++ ) p[ i ].x -= t.x , p[ i ].y -= t.y ;   \r\n			t1 = p[ 0 ].x>=0 ? ( p[ 0 ].y>=0?0:3 ) : ( p[ 0 ].y>=0?1:2 ) ;        \r\n			for ( sum = 0 , i = 1 ; i <= n ; i ++ ) \r\n			{ \r\n				if ( !p[ i ].x && !p[ i ].y ){printf("0\\n"); break ;}             \r\n				f = p[ i ].y * p[i-1].x - p[ i ].x * p[ i-1 ].y ;   \r\n				if ( !f && p[ i-1 ].x*p[ i ].x <= 0 && p[ i-1 ].y*p[i].y <= 0 ){printf("0\\n"); break ;}  \r\n				t2 = p[ i ].x>=0 ? ( p[ i ].y>=0?0:3 ) : ( p[ i ].y>=0?1:2 ) ; \r\n				if ( t2 == ( t1 + 1 ) % 4 ) sum += 1 ;       \r\n				else if ( t2 == ( t1 + 3 ) % 4 ) sum -= 1 ;   \r\n				else if ( t2 == ( t1 + 2 ) % 4 )            \r\n				{                                             \r\n					if ( f > 0 ) sum += 2 ; else sum -= 2 ; \r\n				} \r\n				t1 = t2 ; \r\n			} \r\n			if ( i<=n || sum ) printf( "1\\n" ) ; else printf( "-1\\n" ) ; \r\n			for ( i = 0 ; i <= n ; i ++ ) p[ i ].x += t.x , p[i].y += t.y ; \r\n		} \r\n	} \r\n	return 0; \r\n}', 'Main.c:4:37: error: variably modified ''p'' at file scope\r\nMain.c: In function ''main'':\r\nMain.c:9:2: error: ''point'' undeclared (first use in this function)\r\nMain.c:9:2: note: each undeclared identifier is reported only once for each function it appears in\r\nMain.c:9:8: error: expected '';'' before ''t''\r\nMain.c:17:22: error: ''t'' undeclared (first use in this function)\r\n', 0, 0, 2, 1, '2010-12-30 16:42:56', '0001-01-01 00:00:00'),
(1174, 21, 378, 6, '#include <stdio.h> \r\n#include <math.h> \r\nconst int MAX = 101 ; \r\n\r\nint main() \r\n{ \r\n	struct point { float x ;float y ; } p[MAX] ; \r\n	int  n , m , i , sum , t1 , t2 ;\r\n	float f ;\r\n	point t ; \r\n	while ( scanf( "%d" , &n )  ) \r\n	{ \r\n		scanf ( "%d" , &m ) ; \r\n		for ( i = 0 ; i < n ; i ++ ) scanf ( "%f%f" , &p[ i ].x , &p[ i ].y ) ; \r\n		p[ n ] = p[ 0 ]  ; \r\n		while ( m -- ) \r\n		{ \r\n			scanf ( "%f%f" , &t.x , &t.y ); \r\n			for ( i = 0 ; i <= n ; i ++ ) p[ i ].x -= t.x , p[ i ].y -= t.y ;   \r\n			t1 = p[ 0 ].x>=0 ? ( p[ 0 ].y>=0?0:3 ) : ( p[ 0 ].y>=0?1:2 ) ;        \r\n			for ( sum = 0 , i = 1 ; i <= n ; i ++ ) \r\n			{ \r\n				if ( !p[ i ].x && !p[ i ].y ){printf("0\\n"); break ;}             \r\n				f = p[ i ].y * p[i-1].x - p[ i ].x * p[ i-1 ].y ;   \r\n				if ( !f && p[ i-1 ].x*p[ i ].x <= 0 && p[ i-1 ].y*p[i].y <= 0 ){printf("0\\n"); break ;}  \r\n				t2 = p[ i ].x>=0 ? ( p[ i ].y>=0?0:3 ) : ( p[ i ].y>=0?1:2 ) ; \r\n				if ( t2 == ( t1 + 1 ) % 4 ) sum += 1 ;       \r\n				else if ( t2 == ( t1 + 3 ) % 4 ) sum -= 1 ;   \r\n				else if ( t2 == ( t1 + 2 ) % 4 )            \r\n				{                                             \r\n					if ( f > 0 ) sum += 2 ; else sum -= 2 ; \r\n				} \r\n				t1 = t2 ; \r\n			} \r\n			if ( i<=n || sum ) printf( "1\\n" ) ; else printf( "-1\\n" ) ; \r\n			for ( i = 0 ; i <= n ; i ++ ) p[ i ].x += t.x , p[i].y += t.y ; \r\n		} \r\n	} \r\n	return 0; \r\n}', 'Main.c: In function ''main'':\r\nMain.c:10:2: error: ''point'' undeclared (first use in this function)\r\nMain.c:10:2: note: each undeclared identifier is reported only once for each function it appears in\r\nMain.c:10:8: error: expected '';'' before ''t''\r\nMain.c:18:22: error: ''t'' undeclared (first use in this function)\r\n', 0, 0, 2, 1, '2010-12-30 16:50:43', '0001-01-01 00:00:00'),
(1175, 14, 345, 4, '#include<iostream.h>\r\n#include<string>\r\n#include<map>\r\n\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n	map<string,string> first,second;\r\n\r\n	int num1,num2;\r\n\r\n	while( cin >> num1 )\r\n	{\r\n		bool ISintersect=false;\r\n		string name,firstname;\r\n\r\n		for(int i=0;i<num1;i++)\r\n		{\r\n			cin>>name;\r\n			first[name]=name;\r\n		}\r\n\r\n		cin>>num2;\r\n		for(int i=0;i<num2;i++)\r\n		{\r\n			cin>>name;\r\n			if(first.find( name)!=first.end() && !ISintersect )\r\n			{\r\n				ISintersect = true;\r\n				firstname = name;\r\n			}\r\n		}\r\n\r\n		if( ISintersect )\r\n			cout<<firstname<<'' ''<<firstname<<endl;\r\n		else\r\n			cout<<"none none"<<endl;\r\n\r\n\r\n\r\n	}\r\n	return 0;\r\n}', 'Main.cpp:1:21: fatal error: iostream.h: No such file or directory\r\ncompilation terminated.\r\n', 0, 0, 2, 2, '2010-12-30 16:50:51', '0001-01-01 00:00:00'),
(1176, 14, 345, 4, '#include<iostream>\r\n#include<string>\r\n#include<map>\r\n\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n	map<string,string> first,second;\r\n\r\n	int num1,num2;\r\n\r\n	while( cin >> num1 )\r\n	{\r\n		bool ISintersect=false;\r\n		string name,firstname;\r\n\r\n		for(int i=0;i<num1;i++)\r\n		{\r\n			cin>>name;\r\n			first[name]=name;\r\n		}\r\n\r\n		cin>>num2;\r\n		for(int i=0;i<num2;i++)\r\n		{\r\n			cin>>name;\r\n			if(first.find( name)!=first.end() && !ISintersect )\r\n			{\r\n				ISintersect = true;\r\n				firstname = name;\r\n			}\r\n		}\r\n\r\n		if( ISintersect )\r\n			cout<<firstname<<'' ''<<firstname<<endl;\r\n		else\r\n			cout<<"none none"<<endl;\r\n\r\n\r\n\r\n	}\r\n	return 0;\r\n}', '', 0, 368640, 4, 2, '2010-12-30 16:51:12', '0001-01-01 00:00:00'),
(1177, 14, 376, 5, '#include<iostream>\r\n#include<limits.h>\r\n\r\nusing namespace std;\r\n\r\n_int64 num[50001];\r\n\r\nint main()\r\n{\r\n	int i,number;\r\n	\r\n\r\n	while( cin>>number )\r\n	{\r\n		int zeroCount=0,positive=0,negative=0;\r\n		_int64 minPosi = _I64_MAX,minNega = 0,maxNega=_I64_MIN;\r\n		_int64 productive=1;\r\n		\r\n		for(i=0;i<number;i++)\r\n			cin >> num[i];\r\n\r\n		for(i=0;i<number;i++)\r\n		{\r\n			if( 0 == num[i] )\r\n				zeroCount++;\r\n			else if(num[i]<0 )\r\n			{\r\n				negative++;\r\n				if(num[i] > maxNega )\r\n					maxNega = num[i];\r\n\r\n				if(num[i] < minNega)\r\n					minNega = num[i];\r\n			}\r\n			else\r\n			{\r\n				positive++;\r\n				if( num[i] < minPosi )\r\n					minPosi = num[i];\r\n			}\r\n		}\r\n\r\n\r\n		if( zeroCount != 0)\r\n		{\r\n			if(1==zeroCount && 0 == negative % 2)\r\n			{\r\n				for(i=0;i<number;i++)\r\n					if( 0 != num[i])\r\n						productive *= num[i];\r\n				cout<<productive<<endl;\r\n\r\n			}\r\n			else\r\n				cout<<0<<endl;\r\n\r\n		}\r\n		else if( 1==negative %2 )\r\n		{\r\n			for(i=0;i<number;i++)\r\n				if( maxNega != num[i])\r\n			productive *= num[i];\r\n\r\n			cout<<productive<<endl;\r\n		}\r\n		else \r\n		{\r\n			if( 0 != positive)\r\n			{\r\n				for(i=0;i<number;i++)\r\n					if( minPosi != num[i])\r\n						productive *= num[i];\r\n\r\n				cout<<productive<<endl;\r\n			}\r\n			else\r\n			{\r\n				for(i=0;i<number;i++)\r\n					if( minNega != num[i])\r\n						productive *= num[i];\r\n\r\n				cout<<productive<<endl;\r\n			}\r\n\r\n		}\r\n	}\r\n	return 0;\r\n	\r\n}', 'Main.cpp:6:1: error: ''_int64'' does not name a type\r\nMain.cpp: In function ''int main()'':\r\nMain.cpp:16:3: error: ''_int64'' was not declared in this scope\r\nMain.cpp:16:10: error: expected '';'' before ''minPosi''\r\nMain.cpp:17:10: error: expected '';'' before ''productive''\r\nMain.cpp:20:11: error: ''num'' was not declared in this scope\r\nMain.cpp:24:13: error: ''num'' was not declared in this scope\r\nMain.cpp:29:17: error: ''maxNega'' was not declared in this scope\r\nMain.cpp:32:17: error: ''minNega'' was not declared ', 0, 0, 2, 2, '2010-12-30 16:52:27', '0001-01-01 00:00:00'),
(1178, 14, 376, 5, '#include<iostream>\r\n#include<limits.h>\r\n\r\nusing namespace std;\r\n\r\nlong long num[50001];\r\n\r\nint main()\r\n{\r\n	int i,number;\r\n	\r\n\r\n	while( cin>>number )\r\n	{\r\n		int zeroCount=0,positive=0,negative=0;\r\n		long long minPosi = _I64_MAX,minNega = 0,maxNega=_I64_MIN;\r\n		long long productive=1;\r\n		\r\n		for(i=0;i<number;i++)\r\n			cin >> num[i];\r\n\r\n		for(i=0;i<number;i++)\r\n		{\r\n			if( 0 == num[i] )\r\n				zeroCount++;\r\n			else if(num[i]<0 )\r\n			{\r\n				negative++;\r\n				if(num[i] > maxNega )\r\n					maxNega = num[i];\r\n\r\n				if(num[i] < minNega)\r\n					minNega = num[i];\r\n			}\r\n			else\r\n			{\r\n				positive++;\r\n				if( num[i] < minPosi )\r\n					minPosi = num[i];\r\n			}\r\n		}\r\n\r\n\r\n		if( zeroCount != 0)\r\n		{\r\n			if(1==zeroCount && 0 == negative % 2)\r\n			{\r\n				for(i=0;i<number;i++)\r\n					if( 0 != num[i])\r\n						productive *= num[i];\r\n				cout<<productive<<endl;\r\n\r\n			}\r\n			else\r\n				cout<<0<<endl;\r\n\r\n		}\r\n		else if( 1==negative %2 )\r\n		{\r\n			for(i=0;i<number;i++)\r\n				if( maxNega != num[i])\r\n			productive *= num[i];\r\n\r\n			cout<<productive<<endl;\r\n		}\r\n		else \r\n		{\r\n			if( 0 != positive)\r\n			{\r\n				for(i=0;i<number;i++)\r\n					if( minPosi != num[i])\r\n						productive *= num[i];\r\n\r\n				cout<<productive<<endl;\r\n			}\r\n			else\r\n			{\r\n				for(i=0;i<number;i++)\r\n					if( minNega != num[i])\r\n						productive *= num[i];\r\n\r\n				cout<<productive<<endl;\r\n			}\r\n\r\n		}\r\n	}\r\n	return 0;\r\n	\r\n}', '', 200, 765952, 5, 2, '2010-12-30 16:53:40', '0001-01-01 00:00:00'),
(1179, 14, 376, 5, '#include<iostream>\r\n#include<limits.h>\r\n\r\nusing namespace std;\r\n\r\nlong long num[50001];\r\n\r\nint main()\r\n{\r\n	int i,number;\r\n	\r\n\r\n	while( cin>>number != EOF )\r\n	{\r\n		int zeroCount=0,positive=0,negative=0;\r\n		long long minPosi = LLONG_MAX,minNega = 0,maxNega=LLONG_MIN;\r\n		long long productive=1;\r\n		\r\n		for(i=0;i<number;i++)\r\n			cin >> num[i];\r\n\r\n		for(i=0;i<number;i++)\r\n		{\r\n			if( 0 == num[i] )\r\n				zeroCount++;\r\n			else if(num[i]<0 )\r\n			{\r\n				negative++;\r\n				if(num[i] > maxNega )\r\n					maxNega = num[i];\r\n\r\n				if(num[i] < minNega)\r\n					minNega = num[i];\r\n			}\r\n			else\r\n			{\r\n				positive++;\r\n				if( num[i] < minPosi )\r\n					minPosi = num[i];\r\n			}\r\n		}\r\n\r\n\r\n		if( zeroCount != 0)\r\n		{\r\n			if(1==zeroCount && 0 == negative % 2)\r\n			{\r\n				for(i=0;i<number;i++)\r\n					if( 0 != num[i])\r\n						productive *= num[i];\r\n				cout<<productive<<endl;\r\n\r\n			}\r\n			else\r\n				cout<<0<<endl;\r\n\r\n		}\r\n		else if( 1==negative %2 )\r\n		{\r\n			for(i=0;i<number;i++)\r\n				if( maxNega != num[i])\r\n			productive *= num[i];\r\n\r\n			cout<<productive<<endl;\r\n		}\r\n		else \r\n		{\r\n			if( 0 != positive)\r\n			{\r\n				for(i=0;i<number;i++)\r\n					if( minPosi != num[i])\r\n						productive *= num[i];\r\n\r\n				cout<<productive<<endl;\r\n			}\r\n			else\r\n			{\r\n				for(i=0;i<number;i++)\r\n					if( minNega != num[i])\r\n						productive *= num[i];\r\n\r\n				cout<<productive<<endl;\r\n			}\r\n\r\n		}\r\n	}\r\n	return 0;\r\n	\r\n}', 'Main.cpp: In function ''int main()'':\r\nMain.cpp:13:24: error: ''EOF'' was not declared in this scope\r\n', 0, 0, 2, 2, '2010-12-30 16:56:01', '0001-01-01 00:00:00');
INSERT INTO `tbl_submitions` (`id`, `user_id`, `problem_id`, `exercise_id`, `source`, `result`, `used_time`, `used_memory`, `status`, `compiler_id`, `created`, `modified`) VALUES
(1180, 14, 376, 5, '#include<iostream>\r\n#include<limits.h>\r\n#include<stdlib.h>\r\n\r\nusing namespace std;\r\n\r\nlong long num[50001];\r\n\r\nint main()\r\n{\r\n	int i,number;\r\n	\r\n\r\n	while( cin>>number != EOF )\r\n	{\r\n		int zeroCount=0,positive=0,negative=0;\r\n		long long minPosi = LLONG_MAX,minNega = 0,maxNega=LLONG_MIN;\r\n		long long productive=1;\r\n		\r\n		for(i=0;i<number;i++)\r\n			cin >> num[i];\r\n\r\n		for(i=0;i<number;i++)\r\n		{\r\n			if( 0 == num[i] )\r\n				zeroCount++;\r\n			else if(num[i]<0 )\r\n			{\r\n				negative++;\r\n				if(num[i] > maxNega )\r\n					maxNega = num[i];\r\n\r\n				if(num[i] < minNega)\r\n					minNega = num[i];\r\n			}\r\n			else\r\n			{\r\n				positive++;\r\n				if( num[i] < minPosi )\r\n					minPosi = num[i];\r\n			}\r\n		}\r\n\r\n\r\n		if( zeroCount != 0)\r\n		{\r\n			if(1==zeroCount && 0 == negative % 2)\r\n			{\r\n				for(i=0;i<number;i++)\r\n					if( 0 != num[i])\r\n						productive *= num[i];\r\n				cout<<productive<<endl;\r\n\r\n			}\r\n			else\r\n				cout<<0<<endl;\r\n\r\n		}\r\n		else if( 1==negative %2 )\r\n		{\r\n			for(i=0;i<number;i++)\r\n				if( maxNega != num[i])\r\n			productive *= num[i];\r\n\r\n			cout<<productive<<endl;\r\n		}\r\n		else \r\n		{\r\n			if( 0 != positive)\r\n			{\r\n				for(i=0;i<number;i++)\r\n					if( minPosi != num[i])\r\n						productive *= num[i];\r\n\r\n				cout<<productive<<endl;\r\n			}\r\n			else\r\n			{\r\n				for(i=0;i<number;i++)\r\n					if( minNega != num[i])\r\n						productive *= num[i];\r\n\r\n				cout<<productive<<endl;\r\n			}\r\n\r\n		}\r\n	}\r\n	return 0;\r\n	\r\n}', 'Main.cpp: In function ''int main()'':\r\nMain.cpp:14:24: error: ''EOF'' was not declared in this scope\r\n', 0, 0, 2, 2, '2010-12-30 16:57:12', '0001-01-01 00:00:00'),
(1181, 14, 376, 5, '#include<iostream>\r\n#include<limits.h>\r\n\r\nusing namespace std;\r\n\r\nlong long num[50001];\r\n\r\nint main()\r\n{\r\n	int i,number;\r\n	\r\n\r\n	while( cin>>number )\r\n	{\r\n		int zeroCount=0,positive=0,negative=0;\r\n		long long minPosi = LLONG_MAX,minNega = 0,maxNega=LLONG_MIN;\r\n		long long productive=1;\r\n		\r\n		for(i=0;i<number;i++)\r\n			cin >> num[i];\r\n\r\n		for(i=0;i<number;i++)\r\n		{\r\n			if( 0 == num[i] )\r\n				zeroCount++;\r\n			else if(num[i]<0 )\r\n			{\r\n				negative++;\r\n				if(num[i] > maxNega )\r\n					maxNega = num[i];\r\n\r\n				if(num[i] < minNega)\r\n					minNega = num[i];\r\n			}\r\n			else\r\n			{\r\n				positive++;\r\n				if( num[i] < minPosi )\r\n					minPosi = num[i];\r\n			}\r\n		}\r\n\r\n\r\n		if( zeroCount != 0)\r\n		{\r\n			if(1==zeroCount && 0 == negative % 2)\r\n			{\r\n				for(i=0;i<number;i++)\r\n					if( 0 != num[i])\r\n						productive *= num[i];\r\n				cout<<productive<<endl;\r\n\r\n			}\r\n			else\r\n				cout<<0<<endl;\r\n\r\n		}\r\n		else if( 1==negative %2 )\r\n		{\r\n			for(i=0;i<number;i++)\r\n				if( maxNega != num[i])\r\n			productive *= num[i];\r\n\r\n			cout<<productive<<endl;\r\n		}\r\n		else \r\n		{\r\n			if( 0 != positive)\r\n			{\r\n				for(i=0;i<number;i++)\r\n					if( minPosi != num[i])\r\n						productive *= num[i];\r\n\r\n				cout<<productive<<endl;\r\n			}\r\n			else\r\n			{\r\n				for(i=0;i<number;i++)\r\n					if( minNega != num[i])\r\n						productive *= num[i];\r\n\r\n				cout<<productive<<endl;\r\n			}\r\n\r\n		}\r\n	}\r\n	return 0;\r\n	\r\n}', '', 200, 765952, 5, 2, '2010-12-30 17:04:58', '0001-01-01 00:00:00'),
(1182, 14, 376, 5, '#include<stdio.h>\r\n#include<limits.h>\r\n\r\n\r\nlong long num[50001];\r\n\r\nint main()\r\n{\r\n	int i,number;\r\n	\r\n\r\n	while( scanf("%d",&number) != -1 )\r\n	{\r\n		int zeroCount=0,positive=0,negative=0;\r\n		long long minPosi = _I64_MAX,minNega = 0,maxNega=_I64_MIN;\r\n		long long productive=1;\r\n		\r\n		for(i=0;i<number;i++)\r\n			scanf("%lld",&num[i] );\r\n\r\n		for(i=0;i<number;i++)\r\n		{\r\n			if( 0 == num[i] )\r\n				zeroCount++;\r\n			else if(num[i]<0 )\r\n			{\r\n				negative++;\r\n				if(num[i] > maxNega )\r\n					maxNega = num[i];\r\n\r\n				if(num[i] < minNega)\r\n					minNega = num[i];\r\n			}\r\n			else\r\n			{\r\n				positive++;\r\n				if( num[i] < minPosi )\r\n					minPosi = num[i];\r\n			}\r\n		}\r\n\r\n\r\n		if( zeroCount != 0)\r\n		{\r\n			if(1==zeroCount && 0 == negative % 2)\r\n			{\r\n				for(i=0;i<number;i++)\r\n					if( 0 != num[i])\r\n						productive *= num[i];\r\n				printf("%lld\\n",productive);\r\n\r\n			}\r\n			else\r\n				printf("0\\n");\r\n\r\n		}\r\n		else if( 1==negative %2 )\r\n		{\r\n			for(i=0;i<number;i++)\r\n				if( maxNega != num[i])\r\n			productive *= num[i];\r\n\r\n			printf("%lld\\n",productive);\r\n		}\r\n		else \r\n		{\r\n			if( 0 != positive)\r\n			{\r\n				for(i=0;i<number;i++)\r\n					if( minPosi != num[i])\r\n						productive *= num[i];\r\n\r\n				printf("%lld\\n",productive);\r\n			}\r\n			else\r\n			{\r\n				for(i=0;i<number;i++)\r\n					if( minNega != num[i])\r\n						productive *= num[i];\r\n\r\n				printf("%lld\\n",productive);\r\n			}\r\n\r\n		}\r\n	}\r\n	return 0;\r\n	\r\n}', '', 78, 655360, 4, 1, '2010-12-30 17:16:40', '0001-01-01 00:00:00'),
(1183, 14, 376, 5, '#include<stdio.h>\r\n#include<limits.h>\r\n\r\n\r\n_int64 num[50001];\r\n\r\nint main()\r\n{\r\n	int i,number;\r\n	\r\n\r\n	while( scanf("%d",&number) != -1 )\r\n	{\r\n		int zeroCount=0,positive=0,negative=0;\r\n		_int64 minPosi = _I64_MAX,minNega = 0,maxNega=_I64_MIN;\r\n		_int64 productive=1;\r\n		\r\n		for(i=0;i<number;i++)\r\n			scanf("%I64d",&num[i] );\r\n\r\n		for(i=0;i<number;i++)\r\n		{\r\n			if( 0 == num[i] )\r\n				zeroCount++;\r\n			else if(num[i]<0 )\r\n			{\r\n				negative++;\r\n				if(num[i] > maxNega )\r\n					maxNega = num[i];\r\n\r\n				if(num[i] < minNega)\r\n					minNega = num[i];\r\n			}\r\n			else\r\n			{\r\n				positive++;\r\n				if( num[i] < minPosi )\r\n					minPosi = num[i];\r\n			}\r\n		}\r\n\r\n\r\n		if( zeroCount != 0)\r\n		{\r\n			if(1==zeroCount && 0 == negative % 2)\r\n			{\r\n				for(i=0;i<number;i++)\r\n					if( 0 != num[i])\r\n						productive *= num[i];\r\n				printf("%I64d\\n",productive);\r\n\r\n			}\r\n			else\r\n				printf("0\\n");\r\n\r\n		}\r\n		else if( 1==negative %2 )\r\n		{\r\n			for(i=0;i<number;i++)\r\n				if( maxNega != num[i])\r\n			productive *= num[i];\r\n\r\n			printf("%I64d\\n",productive);\r\n		}\r\n		else \r\n		{\r\n			if( 0 != positive)\r\n			{\r\n				for(i=0;i<number;i++)\r\n					if( minPosi != num[i])\r\n						productive *= num[i];\r\n\r\n				printf("%I64d\\n",productive);\r\n			}\r\n			else\r\n			{\r\n				for(i=0;i<number;i++)\r\n					if( minNega != num[i])\r\n						productive *= num[i];\r\n\r\n				printf("%I64d\\n",productive);\r\n			}\r\n\r\n		}\r\n	}\r\n	return 0;\r\n	\r\n}', 'Main.c:5:8: error: expected ''='', '','', '';'', ''asm'' or ''__attribute__'' before ''num''\r\nMain.c: In function ''main'':\r\nMain.c:15:3: error: ''_int64'' undeclared (first use in this function)\r\nMain.c:15:3: note: each undeclared identifier is reported only once for each function it appears in\r\nMain.c:15:10: error: expected '';'' before ''minPosi''\r\nMain.c:16:10: error: expected '';'' before ''productive''\r\nMain.c:19:19: error: ''num'' undeclared (first use in this function)\r\nMain.c:28:17: error: ''maxNega'' undeclared (', 0, 0, 2, 1, '2010-12-30 17:26:19', '0001-01-01 00:00:00'),
(1184, 14, 376, 5, '#include<stdio.h>\r\n#include<limits.h>\r\n\r\n\r\n__int64 num[50001];\r\n\r\nint main()\r\n{\r\n	int i,number;\r\n	\r\n\r\n	while( scanf("%d",&number) != -1 )\r\n	{\r\n		int zeroCount=0,positive=0,negative=0;\r\n		__int64 minPosi = _I64_MAX,minNega = 0,maxNega=_I64_MIN;\r\n		__int64 productive=1;\r\n		\r\n		for(i=0;i<number;i++)\r\n			scanf("%I64d",&num[i] );\r\n\r\n		for(i=0;i<number;i++)\r\n		{\r\n			if( 0 == num[i] )\r\n				zeroCount++;\r\n			else if(num[i]<0 )\r\n			{\r\n				negative++;\r\n				if(num[i] > maxNega )\r\n					maxNega = num[i];\r\n\r\n				if(num[i] < minNega)\r\n					minNega = num[i];\r\n			}\r\n			else\r\n			{\r\n				positive++;\r\n				if( num[i] < minPosi )\r\n					minPosi = num[i];\r\n			}\r\n		}\r\n\r\n\r\n		if( zeroCount != 0)\r\n		{\r\n			if(1==zeroCount && 0 == negative % 2)\r\n			{\r\n				for(i=0;i<number;i++)\r\n					if( 0 != num[i])\r\n						productive *= num[i];\r\n				printf("%I64d\\n",productive);\r\n\r\n			}\r\n			else\r\n				printf("0\\n");\r\n\r\n		}\r\n		else if( 1==negative %2 )\r\n		{\r\n			for(i=0;i<number;i++)\r\n				if( maxNega != num[i])\r\n			productive *= num[i];\r\n\r\n			printf("%I64d\\n",productive);\r\n		}\r\n		else \r\n		{\r\n			if( 0 != positive)\r\n			{\r\n				for(i=0;i<number;i++)\r\n					if( minPosi != num[i])\r\n						productive *= num[i];\r\n\r\n				printf("%I64d\\n",productive);\r\n			}\r\n			else\r\n			{\r\n				for(i=0;i<number;i++)\r\n					if( minNega != num[i])\r\n						productive *= num[i];\r\n\r\n				printf("%I64d\\n",productive);\r\n			}\r\n\r\n		}\r\n	}\r\n	return 0;\r\n	\r\n}', '', 78, 655360, 4, 1, '2010-12-30 17:28:04', '0001-01-01 00:00:00'),
(1185, 14, 376, 5, '#include<stdio.h>\r\n#include<limits.h>\r\n\r\n\r\n__int64 num[50001];\r\n\r\nint main()\r\n{\r\n	int i,number;\r\n	\r\n\r\n	while( scanf("%d",&number) != -1 )\r\n	{\r\n		int zeroCount=0,positive=0,negative=0;\r\n		int count =0;\r\n		\r\n		__int64 minPosi = _I64_MAX,minNega = 0,maxNega=_I64_MIN;\r\n		__int64 productive=1;\r\n		\r\n		for(i=0;i<number;i++)\r\n			scanf("%I64d",&num[i] );\r\n\r\n		for(i=0;i<number;i++)\r\n		{\r\n			if( 0 == num[i] )\r\n				zeroCount++;\r\n			else if(num[i]<0 )\r\n			{\r\n				negative++;\r\n				if(num[i] > maxNega )\r\n					maxNega = num[i];\r\n\r\n				if(num[i] < minNega)\r\n					minNega = num[i];\r\n			}\r\n			else\r\n			{\r\n				positive++;\r\n				if( num[i] < minPosi )\r\n					minPosi = num[i];\r\n			}\r\n		}\r\n\r\n\r\n		if( zeroCount != 0)\r\n		{\r\n			if(1==zeroCount && 0 == negative % 2)\r\n			{\r\n				for(i=0;i<number;i++)\r\n					if( 0 != num[i])\r\n						productive *= num[i];\r\n				printf("%I64d\\n",productive);\r\n\r\n			}\r\n			else\r\n				printf("0\\n");\r\n\r\n		}\r\n		else if( 1==negative %2 )\r\n		{\r\n			for(i=0;i<number;i++)\r\n			{\r\n				if( maxNega == num[i] && !count)\r\n					{\r\n						count =1;\r\n						continue;\r\n					}\r\n					productive *= num[i];\r\n			}\r\n\r\n			printf("%I64d\\n",productive);\r\n		}\r\n		else \r\n		{\r\n			if( 0 != positive)\r\n			{\r\n				for(i=0;i<number;i++)\r\n				{\r\n					if( minPosi == num[i] && !count)\r\n					{\r\n						count =1;\r\n						continue;\r\n					}\r\n						productive *= num[i];\r\n				}\r\n\r\n				printf("%I64d\\n",productive);\r\n			}\r\n			else\r\n			{\r\n				for(i=0;i<number;i++)\r\n				{\r\n					if( minNega == num[i] && !count)\r\n					{\r\n						count =1;\r\n						continue;\r\n					}\r\n					productive *= num[i];\r\n				}\r\n				printf("%I64d\\n",productive);\r\n			}\r\n\r\n		}\r\n	}\r\n	return 0;\r\n	\r\n}', '', 78, 651264, 1, 1, '2010-12-30 17:54:55', '0001-01-01 00:00:00'),
(1186, 27, 336, 2, '#include<iostream>\r\n#include<vector>\r\n#include<algorithm>\r\nusing namespace std;\r\n#define N 50000\r\nint getBitCount_method1(int n)\r\n{\r\n    int num = 0;\r\n    while(n)\r\n    {\r\n         n &=(n-1);\r\n         num++;\r\n         }\r\n    return num;\r\n}\r\nint Cmp(const void*a,const void *b)\r\n{\r\nreturn(*(int *)a-*(int *)b);\r\n\r\n}\r\nvector<int> getSortVec(int a[], int count[], int n)\r\n{\r\nvector<int> rstVec;\r\nvector<int> vecArray[33]; \r\nint i;\r\nint j;\r\nfor ( i = 0; i < n; ++i)\r\n{\r\n   vecArray[count[i]].push_back(a[i]); \r\n}\r\n\r\n\r\nfor ( i = 0; i <= 32; ++i)\r\n{\r\n   for ( j = 0; j < vecArray[i].size(); ++j)\r\n   {\r\n    rstVec.push_back(vecArray[i][j]);\r\n   }\r\n}\r\nreturn rstVec;\r\n}\r\nint main()\r\n{\r\n    int n;\r\n    int i;\r\n    int a[N];\r\n    while(scanf("%d",&n)==1)\r\n    {\r\n        for(i=0;i<n;i++)\r\n            scanf("%d",&a[i]);\r\n        qsort(a,n,sizeof(a[0]),Cmp); \r\n        int count[N];\r\n        for ( i = 0; i < n; ++i)\r\n       {\r\n          count[i] = getBitCount_method1(a[i]);\r\n        }\r\n\r\n\r\nvector<int> rstVec = getSortVec(a, count, n);\r\n\r\nfor ( i = 0; i <rstVec.size(); ++i)\r\n{ \r\n	if(i==rstVec.size()-1)\r\n     cout << rstVec[i] ;\r\n   else \r\n    cout << rstVec[i] << " ";\r\n}\r\ncout << endl;\r\n\r\n}\r\nreturn 0;\r\n}\r\n', 'Main.cpp: In function ''int main()'':\r\nMain.cpp:47:24: error: ''scanf'' was not declared in this scope\r\n', 0, 0, 2, 2, '2010-12-30 19:16:20', '0001-01-01 00:00:00'),
(1187, 27, 336, 2, '#include<iostream>\r\n#include<vector>\r\n#include<algorithm>\r\n#include<stdio.h>\r\nusing namespace std;\r\n#define N 50000\r\nint getBitCount_method1(int n)\r\n{\r\n    int num = 0;\r\n    while(n)\r\n    {\r\n         n &=(n-1);\r\n         num++;\r\n         }\r\n    return num;\r\n}\r\nint Cmp(const void*a,const void *b)\r\n{\r\nreturn(*(int *)a-*(int *)b);\r\n\r\n}\r\nvector<int> getSortVec(int a[], int count[], int n)\r\n{\r\nvector<int> rstVec;\r\nvector<int> vecArray[33]; \r\nint i;\r\nint j;\r\nfor ( i = 0; i < n; ++i)\r\n{\r\n   vecArray[count[i]].push_back(a[i]); \r\n}\r\n\r\n\r\nfor ( i = 0; i <= 32; ++i)\r\n{\r\n   for ( j = 0; j < vecArray[i].size(); ++j)\r\n   {\r\n    rstVec.push_back(vecArray[i][j]);\r\n   }\r\n}\r\nreturn rstVec;\r\n}\r\nint main()\r\n{\r\n    int n;\r\n    int i;\r\n    int a[N];\r\n    while(scanf("%d",&n)==1)\r\n    {\r\n        for(i=0;i<n;i++)\r\n            scanf("%d",&a[i]);\r\n        qsort(a,n,sizeof(a[0]),Cmp); \r\n        int count[N];\r\n        for ( i = 0; i < n; ++i)\r\n       {\r\n          count[i] = getBitCount_method1(a[i]);\r\n        }\r\n\r\n\r\nvector<int> rstVec = getSortVec(a, count, n);\r\n\r\nfor ( i = 0; i <rstVec.size(); ++i)\r\n{ \r\n	if(i==rstVec.size()-1)\r\n     cout << rstVec[i] ;\r\n   else \r\n    cout << rstVec[i] << " ";\r\n}\r\ncout << endl;\r\n\r\n}\r\nreturn 0;\r\n}\r\n', '', 108, 1728512, 1, 2, '2010-12-30 19:18:45', '0001-01-01 00:00:00'),
(1188, 27, 336, 2, '#include<stdio.h>\r\n//int a[50001],b[50001];\r\n\r\nint countnumber(int n)\r\n{\r\n		int count=0;\r\n		while(n)\r\n		{\r\n			n=n&(n-1);\r\n			count++;\r\n		}\r\n  	return count;\r\n}\r\n\r\nint Partition(int a[],int b[],int low,int high)\r\n{\r\n	int pivotkey=b[low];\r\n	a[0]=a[low];\r\n	b[0]=b[low];\r\n    while(low<high){\r\n		while(low<high && b[high]>=pivotkey) --high;\r\n		a[low]=a[high];\r\n        b[low]=b[high];\r\n		while(low<high && b[low]<=pivotkey) ++low;\r\n		a[high]=a[low];\r\n		b[high]=b[low];\r\n	}\r\n	a[low]=a[0];\r\n	b[low]=b[0];\r\n	return low;\r\n}\r\n\r\nvoid qsort(int a[],int b[],int low,int high)\r\n{\r\n	int pivotloc;\r\n	if(low<high){\r\n		pivotloc=Partition(a,b,low,high);\r\n		qsort(a,b,low,pivotloc-1);\r\n		qsort(a,b,pivotloc+1,high);\r\n	}\r\n}\r\n\r\n\r\nint main()\r\n{\r\n//	int n,i,j,k,m,c,first;\r\n	int n,i,m,first;\r\n	int a[50002],b[50002];\r\n	while(scanf("%d",&n)==1)\r\n	{  \r\n	if(n>0){\r\n		a[0]=0;\r\n		b[0]=0;\r\n		for(i=1;i<=n;++i){\r\n			scanf("%d",&a[i]);\r\n		    b[i]=countnumber(a[i]);\r\n		}\r\n\r\n		qsort(a,b,1,n);		\r\n        for(i=1;i<=n;++i){	\r\n			m=b[i];\r\n			first=i;\r\n			while(m==b[i+1]) ++i;\r\n			if(first!=i){\r\n				qsort(b,a,first,i);\r\n/*				for(k=1;k<i-first;++k){\r\n	            	for(j=first;j<i;++j){\r\n	            		if(a[j]>a[j+1]){\r\n	            			c=a[j];\r\n	            			a[j]=a[j+1];\r\n	            			a[j+1]=c;\r\n						}\r\n					}\r\n				}\r\n		*/\r\n			}\r\n		}\r\n	\r\n		for(i=1;i<n;++i) printf("%d ",a[i]);\r\n		printf("%d",a[i]);\r\n	}\r\n		printf("\\n");\r\n	}\r\n	return 0;\r\n}\r\n', '', 200, 905216, 5, 1, '2010-12-30 19:19:24', '0001-01-01 00:00:00'),
(1189, 27, 336, 2, '#include<stdio.h>\r\n//int a[50001],b[50001];\r\n\r\n#define POW(c) (1<<(c))\r\n#define MASK(c) (((unsigned long)-1) / (POW(POW(c)) + 1))\r\n#define ROUND(n, c) (((n) & MASK(c)) + ((n) >> POW(c) & MASK(c)))\r\n\r\nint bit_count(int n)\r\n{\r\nn = ROUND(n, 0);\r\nn = ROUND(n, 1);\r\nn = ROUND(n, 2);\r\nn = ROUND(n, 3);\r\nn = ROUND(n, 4);\r\nreturn n;\r\n}\r\n/*\r\nint countnumber(int n)\r\n{\r\n		int count=0;\r\n		while(n)\r\n		{\r\n			n=n&(n-1);\r\n			count++;\r\n		}\r\n  	return count;\r\n}\r\n*/\r\nint Partition(int a[],int b[],int low,int high)\r\n{\r\n	int pivotkey=b[low];\r\n	a[0]=a[low];\r\n	b[0]=b[low];\r\n    while(low<high){\r\n		while(low<high && b[high]>=pivotkey) --high;\r\n		a[low]=a[high];\r\n        b[low]=b[high];\r\n		while(low<high && b[low]<=pivotkey) ++low;\r\n		a[high]=a[low];\r\n		b[high]=b[low];\r\n	}\r\n	a[low]=a[0];\r\n	b[low]=b[0];\r\n	return low;\r\n}\r\n\r\nvoid qsort(int a[],int b[],int low,int high)\r\n{\r\n	int pivotloc;\r\n	if(low<high){\r\n		pivotloc=Partition(a,b,low,high);\r\n		qsort(a,b,low,pivotloc-1);\r\n		qsort(a,b,pivotloc+1,high);\r\n	}\r\n}\r\n\r\n\r\nint main()\r\n{\r\n//	int n,i,j,k,m,c,first;\r\n	int n,i,m,first;\r\n	int a[50002],b[50002];\r\n	while(scanf("%d",&n)==1)\r\n	{  \r\n	if(n>0){\r\n		a[0]=0;\r\n		b[0]=0;\r\n		for(i=1;i<=n;++i){\r\n			scanf("%d",&a[i]);\r\n		    //b[i]=countnumber(a[i]);\r\n			b[i]=bit_count(a[i]);\r\n		}\r\n\r\n		qsort(a,b,1,n);		\r\n        for(i=1;i<=n;++i){	\r\n			m=b[i];\r\n			first=i;\r\n			while(m==b[i+1]) ++i;\r\n			if(first!=i){\r\n				qsort(b,a,first,i);\r\n/*				for(k=1;k<i-first;++k){\r\n	            	for(j=first;j<i;++j){\r\n	            		if(a[j]>a[j+1]){\r\n	            			c=a[j];\r\n	            			a[j]=a[j+1];\r\n	            			a[j+1]=c;\r\n						}\r\n					}\r\n				}\r\n		*/\r\n			}\r\n		}\r\n	\r\n		for(i=1;i<n;++i) printf("%d ",a[i]);\r\n		printf("%d",a[i]);\r\n	}\r\n		printf("\\n");\r\n	}\r\n	return 0;\r\n}\r\n', '', 200, 905216, 5, 1, '2010-12-30 19:30:45', '0001-01-01 00:00:00'),
(1190, 27, 336, 2, '#include<iostream>\r\n#include<vector>\r\n#include<algorithm>\r\n#include<stdio.h>\r\nusing namespace std;\r\n#define N 50000\r\nint getBitCount_method1(int n)\r\n{\r\n    int num = 0;\r\n    while(n)\r\n    {\r\n         n &=(n-1);\r\n         num++;\r\n         }\r\n    return num;\r\n}\r\n\r\nint Cmp(const void*a,const void *b)\r\n{\r\n    return(*(int *)a-*(int *)b);\r\n} \r\n\r\nvector<int> getSortVec(int a[], int count[], int n)\r\n{\r\n  vector<int> rstVec;\r\n  vector<int> vecArray[33]; \r\n  int i;\r\n  int j;\r\n  for ( i = 0; i < n; ++i)\r\n  {\r\n     vecArray[count[i]].push_back(a[i]); \r\n  }\r\n\r\n\r\nfor ( i = 0; i <= 32; ++i)\r\n{\r\n   for ( j = 0; j < vecArray[i].size(); ++j)\r\n   {\r\n    rstVec.push_back(vecArray[i][j]);\r\n   }\r\n}\r\nreturn rstVec;\r\n}\r\nint main()\r\n{\r\n    int n;\r\n    int i;\r\n    int a[N];\r\n    while(scanf("%d",&n)==1)\r\n    {\r\n        for(i=0;i<n;i++)\r\n            scanf("%d",&a[i]);\r\n        qsort(a,n,sizeof(a[0]),Cmp); \r\n        int count[N];\r\n        for ( i = 0; i < n; ++i)\r\n       {\r\n          count[i] = getBitCount_method1(a[i]);\r\n        }\r\n\r\n\r\nvector<int> rstVec = getSortVec(a, count, n);\r\n\r\nfor ( i = 0; i <rstVec.size(); ++i)\r\n{ \r\n	if(i==rstVec.size()-1)\r\n     cout << rstVec[i] ;\r\n   else \r\n    cout << rstVec[i] << " ";\r\n}\r\ncout << endl;\r\n\r\n}\r\nreturn 0;\r\n}\r\n', '', 76, 1728512, 1, 2, '2010-12-30 19:42:56', '0001-01-01 00:00:00'),
(1191, 27, 376, 5, '       #include<stdio.h>\r\nint main()\r\n{\r\n	long long array[50000],mul[50000],a[50000],b[50000];\r\n	long long max;\r\n	int n,i,count;\r\n //    int x=0;\r\n	while(scanf("%d",&n)==1){\r\n		count=0;\r\n		for(i=0;i<n;++i){\r\n		    scanf("%I64d",&array[i]);\r\n            if(array[i]==0) ++count;\r\n		}\r\n		if(n>1){\r\n	   	  if(count>1)  printf("0");\r\n          else{					\r\n			a[0]=array[0];\r\n			for(i=1;i<n-1;++i)  a[i]=a[i-1]*array[i];\r\n//			printf("%d&\\n",x++);\r\n			b[n-1]=array[n-1];\r\n	//		printf("%d&&\\n",x++);\r\n			for(i=n-2;i>0;--i)  b[i]=b[i+1]*array[i];\r\n			\r\n	//		printf("%d***\\n",x++);\r\n			\r\n			mul[0]=b[1];\r\n			for(i=1;i<n-1;++i) mul[i]=a[i-1]*b[i+1];\r\n			mul[n-1]=a[n-2];\r\n			\r\n	//		printf("%d\\n",x++);\r\n			\r\n			max=mul[0];\r\n			for(i=1;i<n;++i){\r\n				if(max<mul[i])  max=mul[i];\r\n			}\r\n			printf("%I64d",max);		\r\n		 }\r\n	  	 printf("\\n");\r\n		}\r\n	}\r\n	return 0;\r\n}\r\n', '', 78, 1810432, 1, 1, '2010-12-30 19:50:40', '0001-01-01 00:00:00'),
(1192, 14, 345, 4, '#include<iostream>\r\n#include<string>\r\n#include<map>\r\n#include<cmath>\r\n\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n	int num1,num2;\r\n\r\n	while( cin >> num1 )\r\n	{\r\n		bool loop=false,intersect=true;\r\n		string name,firstnode,commonnode;\r\n		map<string,int> firstQueue;\r\n\r\n		for(int i=0;i<num1;i++)\r\n		{\r\n			cin>>name;\r\n			if(firstQueue.find(name) != firstQueue.end())\r\n			{\r\n				loop = true;\r\n				firstnode=name;\r\n			}else\r\n				firstQueue[name]=i;\r\n		}\r\n\r\n		cin>>num2;\r\n		for(int i=0;i<num2;i++)\r\n\r\n		{\r\n			cin>>name;\r\n			if(firstQueue.find( name)!=firstQueue.end() && intersect )\r\n			{\r\n					if( !loop)\r\n						commonnode = name;\r\n					else\r\n					{\r\n						if( firstQueue[name] > firstQueue[  firstnode])\r\n							commonnode = firstnode;\r\n						else\r\n							commonnode = name;\r\n					}\r\n\r\n					intersect = false;\r\n			}\r\n		}\r\n\r\n		\r\n			if( !intersect )\r\n				cout<<commonnode<<'' ''<<commonnode<<endl;\r\n			else\r\n				cout<<"none none"<<endl;\r\n\r\n		\r\n\r\n	}\r\n	return 0;\r\n}', '', 0, 368640, 4, 2, '2010-12-30 20:36:27', '0001-01-01 00:00:00'),
(1193, 11, 402, 8, '#include<iostream>       \r\n#include<string>       \r\n  \r\nusing namespace std;       \r\nint r[2000];        \r\nint main()       \r\n{       \r\n    string a,b;       \r\n    int carry,lena,lenb,i,j,tmp,k,times,size;\r\n	cin >> size;\r\n	for(times = 0;times !=size;++times)\r\n	{\r\n	carry=i=j=0;\r\n	for(k=0;k != 2000;k++)\r\n		r[k] = 0;\r\n    cin>>a>>b;       \r\n    lena=a.length();\r\n    lenb=b.length();  \r\n    while(1)       \r\n    {       \r\n		--lena;--lenb;\r\n		if(lena==-1||lenb==-1)       \r\n         break;     \r\n        tmp=a[lena]+b[lenb]+carry-96;           \r\n        if(tmp>=10)       \r\n            carry=1;       \r\n        else      \r\n            carry=0;       \r\n        r[j]=tmp%10;         \r\n        ++j;       \r\n               \r\n    }         \r\n    if(lena==-1&&lenb!=-1)       \r\n    {       \r\n        for(i=lenb;i>=0;--i)       \r\n        {       \r\n            tmp=b[i]+carry-48;       \r\n            if(tmp>=10)       \r\n                carry=1;       \r\n            else      \r\n                carry=0;       \r\n            r[j]=tmp%10;       \r\n            ++j;       \r\n        }//for       \r\n    }//if       \r\n    else if(lena!=-1&&lenb==-1)       \r\n    {       \r\n        for(i=lena;i>=0;--i)       \r\n        {       \r\n            tmp=a[i]+carry-48;       \r\n            if(tmp>=10)       \r\n                carry=1;       \r\n            else      \r\n                carry=0;       \r\n            r[j]=tmp%10;       \r\n            ++j;       \r\n        }//for       \r\n    }//else if  \r\n	cout << "Case " << times+1 <<":" <<endl;\r\n	cout << a << " + " << b << "= ";\r\n    if(carry!=0)    \r\n        cout<<carry;    \r\n    for(i=j-1;i>=0;--i)       \r\n        cout<<r[i];       \r\n        cout<<endl;\r\n		cout<<endl; \r\n	}\r\n    return 0;       \r\n}  \r\n', '', 78, 368640, 3, 2, '2010-12-30 20:36:59', '0001-01-01 00:00:00'),
(1194, 11, 402, 8, '#include<iostream>       \r\n#include<string>       \r\n  \r\nusing namespace std;       \r\nint r[2000];        \r\nint main()       \r\n{       \r\n    string a,b;       \r\n    int carry,lena,lenb,i,j,tmp,k,times,size;\r\n	cin >> size;\r\n	for(times = 0;times !=size;++times)\r\n	{\r\n	carry=i=j=0;\r\n	for(k=0;k != 2000;k++)\r\n		r[k] = 0;\r\n    cin>>a>>b;       \r\n    lena=a.length();\r\n    lenb=b.length();  \r\n    while(1)       \r\n    {       \r\n		--lena;--lenb;\r\n		if(lena==-1||lenb==-1)       \r\n         break;     \r\n        tmp=a[lena]+b[lenb]+carry-96;           \r\n        if(tmp>=10)       \r\n            carry=1;       \r\n        else      \r\n            carry=0;       \r\n        r[j]=tmp%10;         \r\n        ++j;       \r\n               \r\n    }         \r\n    if(lena==-1&&lenb!=-1)       \r\n    {       \r\n        for(i=lenb;i>=0;--i)       \r\n        {       \r\n            tmp=b[i]+carry-48;       \r\n            if(tmp>=10)       \r\n                carry=1;       \r\n            else      \r\n                carry=0;       \r\n            r[j]=tmp%10;       \r\n            ++j;       \r\n        }//for       \r\n    }//if       \r\n    else if(lena!=-1&&lenb==-1)       \r\n    {       \r\n        for(i=lena;i>=0;--i)       \r\n        {       \r\n            tmp=a[i]+carry-48;       \r\n            if(tmp>=10)       \r\n                carry=1;       \r\n            else      \r\n                carry=0;       \r\n            r[j]=tmp%10;       \r\n            ++j;       \r\n        }//for       \r\n    }//else if  \r\n	cout << "Case " << times+1 <<":" <<endl;\r\n	cout << a << " + " << b << "= ";\r\n    if(carry!=0)    \r\n        cout<<carry;    \r\n    for(i=j-1;i>=0;--i)       \r\n        cout<<r[i];       \r\n        cout<<endl;\r\n	if(times+1 !=size)\r\n		cout<<endl; \r\n	}\r\n    return 0;       \r\n}  \r\n', '', 78, 372736, 3, 2, '2010-12-30 20:38:53', '0001-01-01 00:00:00'),
(1195, 11, 402, 8, '#include<iostream>       \r\n#include<string>       \r\n  \r\nusing namespace std;       \r\nint r[2000];        \r\nint main()       \r\n{       \r\n    string a,b;       \r\n    int carry,lena,lenb,i,j,tmp,k,times,size;\r\n	cin >> size;\r\n	for(times = 0;times !=size;++times)\r\n	{\r\n	carry=i=j=0;\r\n	for(k=0;k != 2000;k++)\r\n		r[k] = 0;\r\n    cin>>a>>b;       \r\n    lena=a.length();\r\n    lenb=b.length();  \r\n    while(1)       \r\n    {       \r\n		--lena;--lenb;\r\n		if(lena==-1||lenb==-1)       \r\n         break;     \r\n        tmp=a[lena]+b[lenb]+carry-96;           \r\n        if(tmp>=10)       \r\n            carry=1;       \r\n        else      \r\n            carry=0;       \r\n        r[j]=tmp%10;         \r\n        ++j;       \r\n               \r\n    }         \r\n    if(lena==-1&&lenb!=-1)       \r\n    {       \r\n        for(i=lenb;i>=0;--i)       \r\n        {       \r\n            tmp=b[i]+carry-48;       \r\n            if(tmp>=10)       \r\n                carry=1;       \r\n            else      \r\n                carry=0;       \r\n            r[j]=tmp%10;       \r\n            ++j;       \r\n        }//for       \r\n    }//if       \r\n    else if(lena!=-1&&lenb==-1)       \r\n    {       \r\n        for(i=lena;i>=0;--i)       \r\n        {       \r\n            tmp=a[i]+carry-48;       \r\n            if(tmp>=10)       \r\n                carry=1;       \r\n            else      \r\n                carry=0;       \r\n            r[j]=tmp%10;       \r\n            ++j;       \r\n        }//for       \r\n    }//else if  \r\n	cout << "Case " << times+1 <<":" <<endl;\r\n	cout << a << " + " << b << " = ";\r\n    if(carry!=0)    \r\n        cout<<carry;    \r\n    for(i=j-1;i>=0;--i)       \r\n        cout<<r[i];       \r\n        cout<<endl;\r\n	if(times+1 !=size)\r\n		cout<<endl; \r\n	}\r\n    return 0;       \r\n}  \r\n', '', 62, 372736, 1, 2, '2010-12-30 20:40:22', '0001-01-01 00:00:00'),
(1196, 10, 374, 5, 'asdfsdf', 'Main.c:1:1: error: expected ''='', '','', '';'', ''asm'' or ''__attribute__'' at end of input\r\n', 0, 0, 2, 1, '2010-12-30 20:45:09', '0001-01-01 00:00:00'),
(1197, 14, 345, 4, '#include<iostream>\r\n#include<string>\r\n#include<map>\r\n#include<cmath>\r\n\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n	int num1,num2;\r\n\r\n	while( cin >> num1 )\r\n	{\r\n		bool loop=false,intersect=true;\r\n		string name,firstnode,node1,node2;\r\n		map<string,int> firstQueue;\r\n\r\n		for(int i=0;i<num1;i++)\r\n		{\r\n			cin>>name;\r\n			if(firstQueue.find(name) != firstQueue.end())\r\n			{\r\n				loop = true;\r\n				firstnode=name;\r\n			}else\r\n				firstQueue[name]=i;\r\n		}\r\n\r\n		cin>>num2;\r\n		for(int i=0;i<num2;i++)\r\n\r\n		{\r\n			cin>>name;\r\n			if(firstQueue.find( name)!=firstQueue.end() && intersect )\r\n			{\r\n					if( !loop)\r\n						node1 = node2 = name;\r\n					else\r\n					{\r\n						if( firstQueue[name] > firstQueue[  firstnode])\r\n						{\r\n							node1 = firstnode;\r\n							node2 = name;\r\n						}\r\n						else\r\n							node1 = node2 = name;\r\n					}\r\n\r\n					intersect = false;\r\n			}\r\n		}\r\n\r\n		\r\n			if( !intersect )\r\n				cout<<node1<<'' ''<<node2<<endl;\r\n			else\r\n				cout<<"none none"<<endl;\r\n\r\n		\r\n\r\n	}\r\n	return 0;\r\n}', '', 31, 544768, 1, 2, '2010-12-30 20:49:02', '0001-01-01 00:00:00'),
(1198, 27, 402, 8, '#include<stdio.h>\r\n#include<string>\r\n#include<iostream>\r\nint main()\r\n{\r\n	int sum[2001],a[2000],b[2000];\r\n	int T,i,k;\r\n	int n,n1,n2,c;\r\n	string s;\r\n	scanf("%d",&T);\r\n	for(k=0;k<T;++k){\r\n	   cin>>s;\r\n	   n1=s.length();\r\n	   for(i=n1-1;i>=0;--i)  a[i]=s[n1-i-1]-48;\r\n 	   cin>>s;\r\n	   n2=s.length();\r\n	   for(i=n2-1;i>=0;--i)  b[i]=s[n2-i-1]-48;\r\n	   \r\n	   c=0;\r\n	   if(n1<n2){\r\n           n=n2;	\r\n    	   for(i=0;i<n1;++i){\r\n    	       sum[i]=a[i]+b[i]+c;\r\n    	       if(sum[i]>9){\r\n    	           sum[i]=sum[i]-10;\r\n                   c=1;\r\n               }\r\n           }\r\n           for(;i<n2;++i){\r\n                sum[i]=b[i]+c;\r\n                if(sum[i]>9){\r\n    	           sum[i]=sum[i]-10;\r\n                   c=1;\r\n               }else c=0;\r\n           }\r\n           if(c==1) { sum[i]=1; ++n; }\r\n       }\r\n       else{\r\n               n=n1;\r\n               for(i=0;i<n2;++i){\r\n    	       sum[i]=a[i]+b[i]+c;\r\n    	       if(sum[i]>9){\r\n    	           sum[i]=sum[i]-10;\r\n                   c=1;\r\n               }\r\n           }\r\n           for(;i<n1;++i){\r\n                sum[i]=a[i]+c;\r\n                if(sum[i]>9){\r\n    	           sum[i]=sum[i]-10;\r\n                   c=1;\r\n               }else c=0;\r\n           }\r\n           if(c==1) { sum[i]=1;  ++n; }\r\n       }\r\n       printf("Case %d:\\n",k+1);      	   \r\n\r\n	   for(i=n1-1;i>=0;--i) printf("%d",a[i]);\r\n	   printf("+");\r\n	   for(i=n2-1;i>=0;--i) printf("%d",b[i]);\r\n	   printf("=");\r\n\r\n	   for(i=n-1;i>=0;--i) printf("%d",sum[i]);\r\n	   printf("\\n\\n");\r\n    }\r\n	return 0;\r\n}', 'Main.c:2:17: fatal error: string: No such file or directory\r\ncompilation terminated.\r\n', 0, 0, 2, 1, '2010-12-30 22:35:42', '0001-01-01 00:00:00'),
(1199, 27, 402, 8, '#include<stdio.h>\r\n#include<string>\r\n#include<iostream>\r\nint main()\r\n{\r\n	int sum[2001],a[2000],b[2000];\r\n	int T,i,k;\r\n	int n,n1,n2,c;\r\n	string s;\r\n	scanf("%d",&T);\r\n	for(k=0;k<T;++k){\r\n	   cin>>s;\r\n	   n1=s.length();\r\n	   for(i=n1-1;i>=0;--i)  a[i]=s[n1-i-1]-48;\r\n 	   cin>>s;\r\n	   n2=s.length();\r\n	   for(i=n2-1;i>=0;--i)  b[i]=s[n2-i-1]-48;\r\n	   \r\n	   c=0;\r\n	   if(n1<n2){\r\n           n=n2;	\r\n    	   for(i=0;i<n1;++i){\r\n    	       sum[i]=a[i]+b[i]+c;\r\n    	       if(sum[i]>9){\r\n    	           sum[i]=sum[i]-10;\r\n                   c=1;\r\n               }\r\n           }\r\n           for(;i<n2;++i){\r\n                sum[i]=b[i]+c;\r\n                if(sum[i]>9){\r\n    	           sum[i]=sum[i]-10;\r\n                   c=1;\r\n               }else c=0;\r\n           }\r\n           if(c==1) { sum[i]=1; ++n; }\r\n       }\r\n       else{\r\n               n=n1;\r\n               for(i=0;i<n2;++i){\r\n    	       sum[i]=a[i]+b[i]+c;\r\n    	       if(sum[i]>9){\r\n    	           sum[i]=sum[i]-10;\r\n                   c=1;\r\n               }\r\n           }\r\n           for(;i<n1;++i){\r\n                sum[i]=a[i]+c;\r\n                if(sum[i]>9){\r\n    	           sum[i]=sum[i]-10;\r\n                   c=1;\r\n               }else c=0;\r\n           }\r\n           if(c==1) { sum[i]=1;  ++n; }\r\n       }\r\n       printf("Case %d:\\n",k+1);      	   \r\n\r\n	   for(i=n1-1;i>=0;--i) printf("%d",a[i]);\r\n	   printf("+");\r\n	   for(i=n2-1;i>=0;--i) printf("%d",b[i]);\r\n	   printf("=");\r\n\r\n	   for(i=n-1;i>=0;--i) printf("%d",sum[i]);\r\n	   printf("\\n\\n");\r\n    }\r\n	return 0;\r\n}', 'Main.cpp: In function ''int main()'':\r\nMain.cpp:9:2: error: ''string'' was not declared in this scope\r\nMain.cpp:9:9: error: expected '';'' before ''s''\r\nMain.cpp:12:5: error: ''cin'' was not declared in this scope\r\nMain.cpp:12:10: error: ''s'' was not declared in this scope\r\n', 0, 0, 2, 2, '2010-12-30 22:36:05', '0001-01-01 00:00:00'),
(1200, 27, 402, 8, '#include<stdio.h>\r\n#include<string>\r\n#include<iostream>\r\nint main()\r\n{\r\n	int sum[2001],a[2000],b[2000];\r\n	int T,i,k;\r\n	int n,n1,n2,c;\r\n	string s;\r\n	scanf("%d",&T);\r\n	for(k=0;k<T;++k){\r\n	   cin>>s;\r\n	   n1=s.length();\r\n	   for(i=n1-1;i>=0;--i)  a[i]=s[n1-i-1]-48;\r\n 	   cin>>s;\r\n	   n2=s.length();\r\n	   for(i=n2-1;i>=0;--i)  b[i]=s[n2-i-1]-48;\r\n	   \r\n	   c=0;\r\n	   if(n1<n2){\r\n           n=n2;	\r\n    	   for(i=0;i<n1;++i){\r\n    	       sum[i]=a[i]+b[i]+c;\r\n    	       if(sum[i]>9){\r\n    	           sum[i]=sum[i]-10;\r\n                   c=1;\r\n               }\r\n           }\r\n           for(;i<n2;++i){\r\n                sum[i]=b[i]+c;\r\n                if(sum[i]>9){\r\n    	           sum[i]=sum[i]-10;\r\n                   c=1;\r\n               }else c=0;\r\n           }\r\n           if(c==1) { sum[i]=1; ++n; }\r\n       }\r\n       else{\r\n               n=n1;\r\n               for(i=0;i<n2;++i){\r\n    	       sum[i]=a[i]+b[i]+c;\r\n    	       if(sum[i]>9){\r\n    	           sum[i]=sum[i]-10;\r\n                   c=1;\r\n               }\r\n           }\r\n           for(;i<n1;++i){\r\n                sum[i]=a[i]+c;\r\n                if(sum[i]>9){\r\n    	           sum[i]=sum[i]-10;\r\n                   c=1;\r\n               }else c=0;\r\n           }\r\n           if(c==1) { sum[i]=1;  ++n; }\r\n       }\r\n       printf("Case %d:\\n",k+1);      	   \r\n\r\n	   for(i=n1-1;i>=0;--i) printf("%d",a[i]);\r\n	   printf(" + ");\r\n	   for(i=n2-1;i>=0;--i) printf("%d",b[i]);\r\n	   printf(" = ");\r\n\r\n	   for(i=n-1;i>=0;--i) printf("%d",sum[i]);\r\n	   printf("\\n\\n");\r\n    }\r\n	return 0;\r\n}', 'Main.cpp: In function ''int main()'':\r\nMain.cpp:9:2: error: ''string'' was not declared in this scope\r\nMain.cpp:9:9: error: expected '';'' before ''s''\r\nMain.cpp:12:5: error: ''cin'' was not declared in this scope\r\nMain.cpp:12:10: error: ''s'' was not declared in this scope\r\n', 0, 0, 2, 2, '2010-12-30 22:38:44', '0001-01-01 00:00:00'),
(1201, 27, 402, 8, '#include<stdio.h>\r\n#include<string>\r\n#include<iostream>\r\nusing namespace std;\r\nint main()\r\n{\r\n	int sum[2001],a[2000],b[2000];\r\n	int T,i,k;\r\n	int n,n1,n2,c;\r\n	string s;\r\n	scanf("%d",&T);\r\n	for(k=0;k<T;++k){\r\n	   cin>>s;\r\n	   n1=s.length();\r\n	   for(i=n1-1;i>=0;--i)  a[i]=s[n1-i-1]-48;\r\n 	   cin>>s;\r\n	   n2=s.length();\r\n	   for(i=n2-1;i>=0;--i)  b[i]=s[n2-i-1]-48;\r\n	   \r\n	   c=0;\r\n	   if(n1<n2){\r\n           n=n2;	\r\n    	   for(i=0;i<n1;++i){\r\n    	       sum[i]=a[i]+b[i]+c;\r\n    	       if(sum[i]>9){\r\n    	           sum[i]=sum[i]-10;\r\n                   c=1;\r\n               }\r\n           }\r\n           for(;i<n2;++i){\r\n                sum[i]=b[i]+c;\r\n                if(sum[i]>9){\r\n    	           sum[i]=sum[i]-10;\r\n                   c=1;\r\n               }else c=0;\r\n           }\r\n           if(c==1) { sum[i]=1; ++n; }\r\n       }\r\n       else{\r\n               n=n1;\r\n               for(i=0;i<n2;++i){\r\n    	       sum[i]=a[i]+b[i]+c;\r\n    	       if(sum[i]>9){\r\n    	           sum[i]=sum[i]-10;\r\n                   c=1;\r\n               }\r\n           }\r\n           for(;i<n1;++i){\r\n                sum[i]=a[i]+c;\r\n                if(sum[i]>9){\r\n    	           sum[i]=sum[i]-10;\r\n                   c=1;\r\n               }else c=0;\r\n           }\r\n           if(c==1) { sum[i]=1;  ++n; }\r\n       }\r\n       printf("Case %d:\\n",k+1);      	   \r\n\r\n	   for(i=n1-1;i>=0;--i) printf("%d",a[i]);\r\n	   printf(" + ");\r\n	   for(i=n2-1;i>=0;--i) printf("%d",b[i]);\r\n	   printf(" = ");\r\n\r\n	   for(i=n-1;i>=0;--i) printf("%d",sum[i]);\r\n	   printf("\\n\\n");\r\n    }\r\n	return 0;\r\n}', '', 171, 360448, 4, 2, '2010-12-30 22:51:00', '0001-01-01 00:00:00'),
(1202, 27, 402, 8, '#include<stdio.h>\r\n#include<string>\r\n#include<iostream>\r\nusing namespace std;\r\nint main()\r\n{\r\n	int sum[2001],a[2000],b[2000];\r\n	int T,i,k;\r\n	int n,n1,n2,c;\r\n	string s;\r\n	scanf("%d",&T);\r\n	for(k=0;k<T;++k){\r\n	   cin>>s;\r\n	   n1=s.length();\r\n	   for(i=n1-1;i>=0;--i)  a[i]=s[n1-i-1]-48;\r\n 	   cin>>s;\r\n	   n2=s.length();\r\n	   for(i=n2-1;i>=0;--i)  b[i]=s[n2-i-1]-48;\r\n	   \r\n	   c=0;\r\n	   if(n1<n2){\r\n           n=n2;	\r\n    	   for(i=0;i<n1;++i){\r\n    	       sum[i]=a[i]+b[i]+c;\r\n    	       if(sum[i]>9){\r\n    	           sum[i]=sum[i]-10;\r\n                   c=1;\r\n               }\r\n           }\r\n           for(;i<n2;++i){\r\n                sum[i]=b[i]+c;\r\n                if(sum[i]>9){\r\n    	           sum[i]=sum[i]-10;\r\n                   c=1;\r\n               }else c=0;\r\n           }\r\n           if(c==1) { sum[i]=1; ++n; }\r\n       }\r\n       else{\r\n               n=n1;\r\n               for(i=0;i<n2;++i){\r\n    	       sum[i]=a[i]+b[i]+c;\r\n    	       if(sum[i]>9){\r\n    	           sum[i]=sum[i]-10;\r\n                   c=1;\r\n               }\r\n           }\r\n           for(;i<n1;++i){\r\n                sum[i]=a[i]+c;\r\n                if(sum[i]>9){\r\n    	           sum[i]=sum[i]-10;\r\n                   c=1;\r\n               }else c=0;\r\n           }\r\n           if(c==1) { sum[i]=1;  ++n; }\r\n       }\r\n       printf("Case %d:\\n",k+1);      	   \r\n\r\n	   for(i=n1-1;i>=0;--i) printf("%d",a[i]);\r\n	   printf("+");\r\n	   for(i=n2-1;i>=0;--i) printf("%d",b[i]);\r\n	   printf("=");\r\n\r\n	   for(i=n-1;i>=0;--i) printf("%d",sum[i]);\r\n	   printf("\\n\\n");\r\n    }\r\n	return 0;\r\n}', '', 171, 360448, 4, 2, '2010-12-30 22:51:34', '0001-01-01 00:00:00'),
(1203, 27, 402, 8, '#include<stdio.h>\r\n#include<string>\r\n#include<iostream>\r\nusing namespace std;\r\nint main()\r\n{\r\n	int sum[2001],a[2000],b[2000];\r\n	int T,i,k;\r\n	int n,n1,n2,c;\r\n	string s;\r\n	scanf("%d",&T);\r\n	for(k=0;k<T;++k){\r\n	   cin>>s;\r\n	   n1=s.length();\r\n	   for(i=n1-1;i>=0;--i)  a[i]=s[n1-i-1]-48;\r\n 	   cin>>s;\r\n	   n2=s.length();\r\n	   for(i=n2-1;i>=0;--i)  b[i]=s[n2-i-1]-48;\r\n	   \r\n	   c=0;\r\n	   if(n1<n2){\r\n           n=n2;	\r\n    	   for(i=0;i<n1;++i){\r\n    	       sum[i]=a[i]+b[i]+c;\r\n    	       if(sum[i]>9){\r\n    	           sum[i]=sum[i]-10;\r\n                   c=1;\r\n               }\r\n           }\r\n           for(;i<n2;++i){\r\n                sum[i]=b[i]+c;\r\n                if(sum[i]>9){\r\n    	           sum[i]=sum[i]-10;\r\n                   c=1;\r\n               }else c=0;\r\n           }\r\n           if(c==1) { sum[i]=1; ++n; }\r\n       }\r\n       else{\r\n               n=n1;\r\n               for(i=0;i<n2;++i){\r\n    	       sum[i]=a[i]+b[i]+c;\r\n    	       if(sum[i]>9){\r\n    	           sum[i]=sum[i]-10;\r\n                   c=1;\r\n               }\r\n           }\r\n           for(;i<n1;++i){\r\n                sum[i]=a[i]+c;\r\n                if(sum[i]>9){\r\n    	           sum[i]=sum[i]-10;\r\n                   c=1;\r\n               }else c=0;\r\n           }\r\n           if(c==1) { sum[i]=1;  ++n; }\r\n       }\r\n       printf("Case %d:\\n",k+1);      	   \r\n\r\n	   for(i=n1-1;i>=0;--i) printf("%d",a[i]);\r\n	   printf(" + ");\r\n	   for(i=n2-1;i>=0;--i) printf("%d",b[i]);\r\n	   printf(" = ");\r\n\r\n	   for(i=n-1;i>=0;--i) printf("%d",sum[i]);\r\n	   printf("\\n");\r\n	   if(k<T-1) printf("\\n");\r\n    }\r\n	return 0;\r\n}', '', 171, 364544, 4, 2, '2010-12-30 23:10:08', '0001-01-01 00:00:00'),
(1204, 27, 402, 8, '#include<stdio.h>\r\n#include<string>\r\n#include<iostream>\r\nusing namespace std;\r\nint main()\r\n{\r\n	int sum[2002],a[2001],b[2001];\r\n	int T,i,k;\r\n	int n,n1,n2,c;\r\n	string s;\r\n	scanf("%d",&T);\r\n	for(k=0;k<T;++k){\r\n	   cin>>s;\r\n	   n1=s.length();\r\n	   for(i=n1-1;i>=0;--i)  a[i]=s[n1-i-1]-48;\r\n 	   cin>>s;\r\n	   n2=s.length();\r\n	   for(i=n2-1;i>=0;--i)  b[i]=s[n2-i-1]-48;\r\n	   \r\n	   c=0;\r\n	   if(n1<n2){\r\n           n=n2;	\r\n    	   for(i=0;i<n1;++i){\r\n    	       sum[i]=a[i]+b[i]+c;\r\n    	       if(sum[i]>9){\r\n    	           sum[i]=sum[i]-10;\r\n                   c=1;\r\n               }\r\n           }\r\n           for(;i<n2;++i){\r\n                sum[i]=b[i]+c;\r\n                if(sum[i]>9){\r\n    	           sum[i]=sum[i]-10;\r\n                   c=1;\r\n               }else c=0;\r\n           }\r\n           if(c==1) { sum[i]=1; ++n; }\r\n       }\r\n       else{\r\n               n=n1;\r\n               for(i=0;i<n2;++i){\r\n    	       sum[i]=a[i]+b[i]+c;\r\n    	       if(sum[i]>9){\r\n    	           sum[i]=sum[i]-10;\r\n                   c=1;\r\n               }\r\n           }\r\n           for(;i<n1;++i){\r\n                sum[i]=a[i]+c;\r\n                if(sum[i]>9){\r\n    	           sum[i]=sum[i]-10;\r\n                   c=1;\r\n               }else c=0;\r\n           }\r\n           if(c==1) { sum[i]=1;  ++n; }\r\n       }\r\n       printf("Case %d:\\n",k+1);      	   \r\n\r\n	   for(i=n1-1;i>=0;--i) printf("%d",a[i]);\r\n	   printf(" + ");\r\n	   for(i=n2-1;i>=0;--i) printf("%d",b[i]);\r\n	   printf(" = ");\r\n\r\n	   for(i=n-1;i>=0;--i) printf("%d",sum[i]);\r\n	   printf("\\n");\r\n	   if(k<T-1) printf("\\n");\r\n    }\r\n	return 0;\r\n}', '', 171, 360448, 4, 2, '2010-12-30 23:12:36', '0001-01-01 00:00:00'),
(1205, 27, 402, 8, '#include<stdio.h>\r\n#include<string>\r\n#include<iostream>\r\nusing namespace std;\r\nint main()\r\n{\r\n	int sum[2002],a[2001],b[2001];\r\n	int T,i,k;\r\n	int n,n1,n2,c;\r\n	string s;\r\n	scanf("%d",&T);\r\n	for(k=0;k<T;++k){\r\n	   cin>>s;\r\n	   n1=s.length();\r\n	   for(i=n1-1;i>=0;--i)  a[i]=s[n1-i-1]-48;\r\n 	   cin>>s;\r\n	   n2=s.length();\r\n	   for(i=n2-1;i>=0;--i)  b[i]=s[n2-i-1]-48;\r\n/*	   \r\n	   for(i=n1-1;i>=0;--i) printf("%d",a[i]);\r\n	   printf("\\n");\r\n	   for(i=n1-1;i>=0;--i) printf("%d",b[i]);\r\n	   printf("\\n");\r\n*/	   \r\n	   c=0;\r\n	   if(n1<n2){\r\n           n=n2;	\r\n    	   for(i=0;i<n1;++i){\r\n    	       sum[i]=a[i]+b[i]+c;\r\n    	       if(sum[i]>9){\r\n    	           sum[i]=sum[i]-10;\r\n                   c=1;\r\n               }else c=0;\r\n           }\r\n           for(;i<n2;++i){\r\n                sum[i]=b[i]+c;\r\n                if(sum[i]>9){\r\n    	           sum[i]=sum[i]-10;\r\n                   c=1;\r\n               }else c=0;\r\n           }\r\n           if(c==1) { sum[i]=1; ++n; }\r\n       }\r\n       else{\r\n               n=n1;\r\n               for(i=0;i<n2;++i){\r\n    	       sum[i]=a[i]+b[i]+c;\r\n    	       if(sum[i]>9){\r\n    	           sum[i]=sum[i]-10;\r\n                   c=1;\r\n               }else c=0;\r\n           }\r\n           for(;i<n1;++i){\r\n                sum[i]=a[i]+c;\r\n                if(sum[i]>9){\r\n    	           sum[i]=sum[i]-10;\r\n                   c=1;\r\n               }else c=0;\r\n           }\r\n           if(c==1) { sum[i]=1;  ++n; }\r\n       }\r\n       printf("Case %d:\\n",k+1);      	   \r\n\r\n	   for(i=n1-1;i>=0;--i) printf("%d",a[i]);\r\n	   printf(" + ");\r\n	   for(i=n2-1;i>=0;--i) printf("%d",b[i]);\r\n	   printf(" = ");\r\n\r\n	   for(i=n-1;i>=0;--i) printf("%d",sum[i]);\r\n	   printf("\\n");\r\n	   if(k<T-1) printf("\\n");\r\n    }\r\n	return 0;\r\n}', '', 140, 364544, 4, 2, '2010-12-30 23:46:35', '0001-01-01 00:00:00'),
(1206, 27, 402, 8, '#include<stdio.h>\r\n#include<string>\r\n#include<iostream>\r\nusing namespace std;\r\nint main()\r\n{\r\n	int sum[2002],a[2001],b[2001];\r\n	int T,i,k;\r\n	int n,n1,n2,c;\r\n	string s;\r\n	scanf("%d",&T);\r\n	for(k=0;k<T;++k){\r\n	   cin>>s;\r\n	   n1=s.length();\r\n	   for(i=n1-1;i>=0;--i)  a[i]=s[n1-i-1]-''0'';\r\n 	   cin>>s;\r\n	   n2=s.length();\r\n	   for(i=n2-1;i>=0;--i)  b[i]=s[n2-i-1]-''0'';\r\n	   \r\n	   c=0;\r\n	   if(n1<n2){\r\n           n=n2;	\r\n    	   for(i=0;i<n1;++i){\r\n    	       sum[i]=a[i]+b[i]+c;\r\n    	       if(sum[i]>9){\r\n    	           sum[i]=sum[i]-10;\r\n                   c=1;\r\n               }else c=0;\r\n           }\r\n           for(;i<n2;++i){\r\n                sum[i]=b[i]+c;\r\n                if(sum[i]>9){\r\n    	           sum[i]=sum[i]-10;\r\n                   c=1;\r\n               }else c=0;\r\n           }\r\n           if(c==1) { sum[i]=1; ++n; }\r\n       }\r\n       else{\r\n               n=n1;\r\n               for(i=0;i<n2;++i){\r\n    	       sum[i]=a[i]+b[i]+c;\r\n    	       if(sum[i]>9){\r\n    	           sum[i]=sum[i]-10;\r\n                   c=1;\r\n               }else c=0;\r\n           }\r\n           for(;i<n1;++i){\r\n                sum[i]=a[i]+c;\r\n                if(sum[i]>9){\r\n    	           sum[i]=sum[i]-10;\r\n                   c=1;\r\n               }else c=0;\r\n           }\r\n           if(c==1) { sum[i]=1;  ++n; }\r\n       }\r\n       printf("Case %d:\\n",k+1);      	   \r\n\r\n	   for(i=n1-1;i>=0;--i) printf("%d",a[i]);\r\n	   printf(" + ");\r\n	   for(i=n2-1;i>=0;--i) printf("%d",b[i]);\r\n	   printf(" = ");\r\n\r\n	   for(i=n-1;i>=0;--i) printf("%d",sum[i]);\r\n	   printf("\\n");\r\n	   if(k<T-1) printf("\\n");\r\n    }\r\n	return 0;\r\n}', 'Main.c:2:17: fatal error: string: No such file or directory\r\ncompilation terminated.\r\n', 0, 0, 2, 1, '2010-12-31 00:47:54', '0001-01-01 00:00:00'),
(1207, 27, 402, 8, '#include<stdio.h>\r\n#include<string>\r\n#include<iostream>\r\nusing namespace std;\r\nint main()\r\n{\r\n	int sum[2002],a[2001],b[2001];\r\n	int T,i,k;\r\n	int n,n1,n2,c;\r\n	string s;\r\n	scanf("%d",&T);\r\n	for(k=0;k<T;++k){\r\n	   cin>>s;\r\n	   n1=s.length();\r\n	   for(i=n1-1;i>=0;--i)  a[i]=s[n1-i-1]-''0'';\r\n 	   cin>>s;\r\n	   n2=s.length();\r\n	   for(i=n2-1;i>=0;--i)  b[i]=s[n2-i-1]-''0'';\r\n	   \r\n	   c=0;\r\n	   if(n1<n2){\r\n           n=n2;	\r\n    	   for(i=0;i<n1;++i){\r\n    	       sum[i]=a[i]+b[i]+c;\r\n    	       if(sum[i]>9){\r\n    	           sum[i]=sum[i]-10;\r\n                   c=1;\r\n               }else c=0;\r\n           }\r\n           for(;i<n2;++i){\r\n                sum[i]=b[i]+c;\r\n                if(sum[i]>9){\r\n    	           sum[i]=sum[i]-10;\r\n                   c=1;\r\n               }else c=0;\r\n           }\r\n           if(c==1) { sum[i]=1; ++n; }\r\n       }\r\n       else{\r\n               n=n1;\r\n               for(i=0;i<n2;++i){\r\n    	       sum[i]=a[i]+b[i]+c;\r\n    	       if(sum[i]>9){\r\n    	           sum[i]=sum[i]-10;\r\n                   c=1;\r\n               }else c=0;\r\n           }\r\n           for(;i<n1;++i){\r\n                sum[i]=a[i]+c;\r\n                if(sum[i]>9){\r\n    	           sum[i]=sum[i]-10;\r\n                   c=1;\r\n               }else c=0;\r\n           }\r\n           if(c==1) { sum[i]=1;  ++n; }\r\n       }\r\n       printf("Case %d:\\n",k+1);      	   \r\n\r\n	   for(i=n1-1;i>=0;--i) printf("%d",a[i]);\r\n	   printf(" + ");\r\n	   for(i=n2-1;i>=0;--i) printf("%d",b[i]);\r\n	   printf(" = ");\r\n\r\n	   for(i=n-1;i>=0;--i) printf("%d",sum[i]);\r\n	   printf("\\n");\r\n	   if(k<T-1) printf("\\n");\r\n    }\r\n	return 0;\r\n}', '', 186, 364544, 4, 2, '2010-12-31 00:48:16', '0001-01-01 00:00:00'),
(1208, 27, 402, 8, '#include<stdio.h>\r\n#include<string>\r\n#include<iostream>\r\nusing namespace std;\r\nint main()\r\n{\r\n	int sum[2002],a[2001],b[2001];\r\n	int T,i,k;\r\n	int n,n1,n2,c;\r\n	string s;\r\n	scanf("%d",&T);\r\n	for(k=0;k<T;++k){\r\n	   cin>>s;\r\n	   n1=s.length();\r\n	   for(i=n1-1;i>=0;--i)  a[i]=s[n1-i-1]-''0'';\r\n 	   cin>>s;\r\n	   n2=s.length();\r\n	   for(i=n2-1;i>=0;--i)  b[i]=s[n2-i-1]-''0'';\r\n	   \r\n	   c=0;\r\n	   if(n1<n2){\r\n           n=n2;	\r\n    	   for(i=0;i<n1;++i) sum[i]=a[i]+b[i];\r\n    	   for(;i<n2;++i) sum[i]=b[i];\r\n    	   for(i=0;i<n2-1;++i){\r\n    	   	   sum[i+1]+=(sum[i])/10;\r\n    	   	   sum[i]=sum[i]%10;\r\n    	   }\r\n       }\r\n       else{\r\n           n=n1;	\r\n    	   for(i=0;i<n2;++i) sum[i]=a[i]+b[i];\r\n    	   for(;i<n1;++i) sum[i]=a[i];\r\n    	   for(i=0;i<n1-1;++i){\r\n    	   	   sum[i+1]+=(sum[i])/10;\r\n    	   	   sum[i]=sum[i]%10;\r\n    	   }\r\n       }\r\n       printf("Case %d:\\n",k+1);      	   \r\n\r\n	   for(i=n1-1;i>=0;--i) printf("%d",a[i]);\r\n	   printf(" + ");\r\n	   for(i=n2-1;i>=0;--i) printf("%d",b[i]);\r\n	   printf(" = ");\r\n\r\n	   for(i=n-1;i>=0;--i) printf("%d",sum[i]);\r\n	   printf("\\n");\r\n	   if(k<T-1) printf("\\n");\r\n    }\r\n	return 0;\r\n}', '', 171, 364544, 4, 2, '2010-12-31 01:03:15', '0001-01-01 00:00:00');
INSERT INTO `tbl_submitions` (`id`, `user_id`, `problem_id`, `exercise_id`, `source`, `result`, `used_time`, `used_memory`, `status`, `compiler_id`, `created`, `modified`) VALUES
(1209, 27, 402, 8, '#include<stdio.h>\r\n#include<string>\r\n#include<iostream>\r\nusing namespace std;\r\nint main()\r\n{\r\n	int sum[2002],a[2001],b[2001];\r\n	int T,i,k;\r\n	int n,n1,n2,c;\r\n	string s1,s2;\r\n	scanf("%d",&T);\r\n	for(k=0;k<T;++k){\r\n	   cin>>s1;\r\n	   n1=s1.length();\r\n	   for(i=n1-1;i>=0;--i)  a[i]=s1[n1-i-1]-''0'';\r\n 	   cin>>s2;\r\n	   n2=s2.length();\r\n	   for(i=n2-1;i>=0;--i)  b[i]=s2[n2-i-1]-''0'';\r\n	   \r\n	   c=0;\r\n	   if(n1<n2){\r\n           n=n2;	\r\n    	   for(i=0;i<n1;++i) sum[i]=a[i]+b[i];\r\n    	   for(;i<n2;++i) sum[i]=b[i];\r\n    	   for(i=0;i<n2-1;++i){\r\n    	   	   sum[i+1]+=(sum[i])/10;\r\n    	   	   sum[i]=sum[i]%10;\r\n    	   }\r\n       }\r\n       else{\r\n           n=n1;	\r\n    	   for(i=0;i<n2;++i) sum[i]=a[i]+b[i];\r\n    	   for(;i<n1;++i) sum[i]=a[i];\r\n    	   for(i=0;i<n1-1;++i){\r\n    	   	   sum[i+1]+=(sum[i])/10;\r\n    	   	   sum[i]=sum[i]%10;\r\n    	   }\r\n       }\r\n       printf("Case %d:\\n",k+1);      	   \r\n\r\n//	   for(i=n1-1;i>=0;--i) printf("%d",a[i]);\r\n       cout<<s1;\r\n	   printf(" + ");\r\n//	   for(i=n2-1;i>=0;--i) printf("%d",b[i]);\r\n       cout<<s2;\r\n	   printf(" = ");\r\n\r\n	   for(i=n-1;i>=0;--i) printf("%d",sum[i]);\r\n	   printf("\\n");\r\n	   if(k<T-1) printf("\\n");\r\n    }\r\n	return 0;\r\n}', '', 93, 364544, 1, 2, '2010-12-31 01:09:14', '0001-01-01 00:00:00'),
(1210, 27, 402, 8, '#include<stdio.h>\r\n#include<string>\r\n#include<iostream>\r\nusing namespace std;\r\nint main()\r\n{\r\n	int sum[2002],a[2001],b[2001];\r\n	int T,i,k;\r\n	int n,n1,n2,c;\r\n	string s1,s2;\r\n	scanf("%d",&T);\r\n	for(k=0;k<T;++k){\r\n	   cin>>s1;\r\n	   n1=s1.length();\r\n	   for(i=n1-1;i>=0;--i)  a[i]=s1[n1-i-1]-''0'';\r\n 	   cin>>s2;\r\n	   n2=s2.length();\r\n	   for(i=n2-1;i>=0;--i)  b[i]=s2[n2-i-1]-''0'';\r\n	   \r\n	   c=0;\r\n	   if(n1<n2){\r\n           n=n2;	\r\n    	   for(i=0;i<n1;++i){\r\n    	       sum[i]=a[i]+b[i]+c;\r\n    	       if(sum[i]>9){\r\n    	           sum[i]=sum[i]-10;\r\n                   c=1;\r\n               }else c=0;\r\n           }\r\n           for(;i<n2;++i){\r\n                sum[i]=b[i]+c;\r\n                if(sum[i]>9){\r\n    	           sum[i]=sum[i]-10;\r\n                   c=1;\r\n               }else c=0;\r\n           }\r\n           if(c==1) { sum[i]=1; ++n; }\r\n       }\r\n       else{\r\n               n=n1;\r\n               for(i=0;i<n2;++i){\r\n    	       sum[i]=a[i]+b[i]+c;\r\n    	       if(sum[i]>9){\r\n    	           sum[i]=sum[i]-10;\r\n                   c=1;\r\n               }else c=0;\r\n           }\r\n           for(;i<n1;++i){\r\n                sum[i]=a[i]+c;\r\n                if(sum[i]>9){\r\n    	           sum[i]=sum[i]-10;\r\n                   c=1;\r\n               }else c=0;\r\n           }\r\n           if(c==1) { sum[i]=1;  ++n; }\r\n       }\r\n       printf("Case %d:\\n",k+1);      	   \r\n\r\n//	   for(i=n1-1;i>=0;--i) printf("%d",a[i]);\r\n       cout<<s1;\r\n	   printf(" + ");\r\n//	   for(i=n2-1;i>=0;--i) printf("%d",b[i]);\r\n       cout<<s2;\r\n	   printf(" = ");\r\n\r\n	   for(i=n-1;i>=0;--i) printf("%d",sum[i]);\r\n	   printf("\\n");\r\n	   if(k<T-1) printf("\\n");\r\n    }\r\n	return 0;\r\n}', '', 93, 360448, 1, 2, '2010-12-31 01:11:57', '0001-01-01 00:00:00'),
(1211, 27, 403, 8, '#include<stdio.h>\r\n#include<string.h>\r\n#include<stdlib.h>\r\nint main()\r\n{\r\n	int n,m,i,j;\r\n    int a[10000];\r\n    char str[60000],s[6];\r\n	while(scanf("%d",&n)==1){\r\n		if(n>1){\r\n			m=1;\r\n			a[0]=1;\r\n			strcpy(str,"");\r\n			for(i=2;i<=n;++i){\r\n				for(j=0;j<m;++j){\r\n					a[j]*=i;\r\n				}\r\n				for(j=0;j<m-1;++j){\r\n					a[j+1]+=a[j]/10000;\r\n					a[j]=a[j]%10000;\r\n				}\r\n				if(a[j]>=10000){\r\n					a[j+1]=a[j]/10000;\r\n					a[j]=a[j]%10000;\r\n					++m;\r\n				}\r\n		     }\r\n             for(i=m-1;i>=0;--i){\r\n             	itoa(a[i],s,10);\r\n			    strcat(str,s);\r\n             }\r\n             printf("%s\\n",str);\r\n						\r\n		}else printf("1\\n");\r\n\r\n	}\r\n}', '', 0, 315392, 4, 1, '2010-12-31 03:05:32', '0001-01-01 00:00:00'),
(1212, 27, 403, 8, '#include<stdio.h>\r\n#include<string>\r\n#include<stdlib.h>\r\n#define MAX 5\r\nint main()\r\n{\r\n	int n,m,i,j,s_length;\r\n    int a[10000];\r\n    char num_str[50000],str[MAX],s[MAX];\r\n	while(scanf("%d",&n)==1){\r\n		if(n>1){\r\n			m=1;\r\n			a[0]=1;			\r\n			for(i=2;i<=n;++i){\r\n				for(j=0;j<m;++j){\r\n					a[j]*=i;\r\n				}\r\n				for(j=0;j<m-1;++j){\r\n					a[j+1]+=a[j]/10000;\r\n					a[j]=a[j]%10000;\r\n				}\r\n				if(a[j]>=10000){\r\n					a[j+1]=a[j]/10000;\r\n					a[j]=a[j]%10000;\r\n					++m;\r\n				}\r\n		     }\r\n		     \r\n		     strcpy(num_str,"");\r\n		     \r\n      	     itoa(a[m-1],s,10);\r\n             strcat(num_str,s);           \r\n             for(i=m-2;i>=0;--i){\r\n             	strcpy(str,"");\r\n             	itoa(a[i],s,10);\r\n             	switch( strlen(s) )\r\n             	{\r\n             		case 1:\r\n         		       strcat(str,"000");\r\n         		       strcat(str,s);\r\n         		       break;\r\n      		       case 2:\r\n	                   strcat(str,"00");\r\n	                   strcat(str,s);\r\n	                   break;\r\n                   case 3:\r\n                       strcat(str,"0");\r\n                       strcat(str,s);\r\n                       break;\r\n                   default:\r\n                       strcpy(str,s);\r\n             	}                \r\n			    strcat(num_str,str);\r\n             }\r\n             \r\n             printf("%s\\n",num_str);\r\n						\r\n		}else printf("1\\n");\r\n\r\n	}\r\n}', 'Main.c:2:17: fatal error: string: No such file or directory\r\ncompilation terminated.\r\n', 0, 0, 2, 1, '2010-12-31 03:52:31', '0001-01-01 00:00:00'),
(1213, 27, 403, 8, '#include<stdio.h>\r\n#include<string.h>\r\n#include<stdlib.h>\r\n#define MAX 5\r\nint main()\r\n{\r\n	int n,m,i,j,s_length;\r\n    int a[10000];\r\n    char num_str[50000],str[MAX],s[MAX];\r\n	while(scanf("%d",&n)==1){\r\n		if(n>1){\r\n			m=1;\r\n			a[0]=1;			\r\n			for(i=2;i<=n;++i){\r\n				for(j=0;j<m;++j){\r\n					a[j]*=i;\r\n				}\r\n				for(j=0;j<m-1;++j){\r\n					a[j+1]+=a[j]/10000;\r\n					a[j]=a[j]%10000;\r\n				}\r\n				if(a[j]>=10000){\r\n					a[j+1]=a[j]/10000;\r\n					a[j]=a[j]%10000;\r\n					++m;\r\n				}\r\n		     }\r\n		     \r\n		     strcpy(num_str,"");\r\n		     \r\n      	     itoa(a[m-1],s,10);\r\n             strcat(num_str,s);           \r\n             for(i=m-2;i>=0;--i){\r\n             	strcpy(str,"");\r\n             	itoa(a[i],s,10);\r\n             	switch( strlen(s) )\r\n             	{\r\n             		case 1:\r\n         		       strcat(str,"000");\r\n         		       strcat(str,s);\r\n         		       break;\r\n      		       case 2:\r\n	                   strcat(str,"00");\r\n	                   strcat(str,s);\r\n	                   break;\r\n                   case 3:\r\n                       strcat(str,"0");\r\n                       strcat(str,s);\r\n                       break;\r\n                   default:\r\n                       strcpy(str,s);\r\n             	}                \r\n			    strcat(num_str,str);\r\n             }\r\n             \r\n             printf("%s\\n",num_str);\r\n						\r\n		}else printf("1\\n");\r\n\r\n	}\r\n}', '', 670, 307200, 1, 1, '2010-12-31 03:53:07', '0001-01-01 00:00:00'),
(1214, 21, 339, 3, '#include<stdio.h>\r\n\r\nvoid  sift(int   e[]/*存储结点序列*/,   \r\n           int   n/*序列的结点个数*/,   \r\n           int   s/*对e[s]做渗透，其中e[s]的左右子树是堆*/)   \r\n{   \r\n    int   t,k,j;   \r\n    t=e[s];   \r\n    k=s;   \r\n    j=2*k+1;/*e[k]是e[j]和e[j+1]的父结点*/   \r\n    while(j<n)/*为渗透到页结点*/   \r\n    {   \r\n        if(j<n-1   &&   e[j]>e[j+1])//j<n-1   选出是左子还是右子跟父接点比较\r\n            j++;   /*e[j+1]是e[k]较大的子结点*/   \r\n        if(t>e[j])/*改连续渗透交换为循环传送*/   \r\n        {//               交换每个父接点与子接点，满足大顶堆，同时继续比较子接点\r\n            e[k]=e[j];   \r\n            k=j;   \r\n            j=2*k+1;   \r\n        }   \r\n        else   \r\n            break;/*已是一个堆*/   \r\n    }   \r\n    e[k]=t;   \r\n}   \r\n\r\nvoid   heapsort(int   e[],int   n)   \r\n{   \r\n    int   i,k,t;   \r\n    for(i=n/2-1;i>=0;i--)//  从最后一个非叶子节点开始建堆\r\n        sift(e,n,i);/*建初始堆*/   \r\n    for(k=n-1;k>=1;k--)   \r\n    {   \r\n        t=e[0];/*根结点与堆的末结点交换*/   \r\n        e[0]=e[k];   \r\n        e[k]=t;   \r\n        sift(e,k,0);/*重新建堆*/   \r\n    }   \r\n}   \r\n\r\nint main(){\r\n	int n,k,i;\r\n	int a[10000],d[10000];\r\n		while(scanf("%d %d",&n,&k)==2){\r\n		\r\n		for(i = 0;i < k;i++)scanf("%d",&d[i]);\r\n\r\n		for(i = 0;i < n;i++)scanf("%d",&a[i]);\r\n\r\n		heapsort(a,n);\r\n		for(i = 0;i < k;i++){\r\n			printf("%d\\n",a[d[i]]);\r\n		}\r\n	}\r\n\r\n	\r\n	return 0;\r\n}', '', 0, 299008, 7, 1, '2010-12-31 15:33:43', '0001-01-01 00:00:00'),
(1215, 21, 339, 3, '#include<stdio.h>\r\n\r\nvoid  sift(int   e[]/*存储结点序列*/,   \r\n           int   n/*序列的结点个数*/,   \r\n           int   s/*对e[s]做渗透，其中e[s]的左右子树是堆*/)   \r\n{   \r\n    int   t,k,j;   \r\n    t=e[s];   \r\n    k=s;   \r\n    j=2*k+1;/*e[k]是e[j]和e[j+1]的父结点*/   \r\n    while(j<n)/*为渗透到页结点*/   \r\n    {   \r\n        if(j<n-1   &&   e[j]>e[j+1])//j<n-1   选出是左子还是右子跟父接点比较\r\n            j++;   /*e[j+1]是e[k]较大的子结点*/   \r\n        if(t>e[j])/*改连续渗透交换为循环传送*/   \r\n        {//               交换每个父接点与子接点，满足大顶堆，同时继续比较子接点\r\n            e[k]=e[j];   \r\n            k=j;   \r\n            j=2*k+1;   \r\n        }   \r\n        else   \r\n            break;/*已是一个堆*/   \r\n    }   \r\n    e[k]=t;   \r\n}   \r\n\r\nvoid   heapsort(int   e[],int   n)   \r\n{   \r\n    int   i,k,t;   \r\n    for(i=n/2-1;i>=0;i--)//  从最后一个非叶子节点开始建堆\r\n        sift(e,n,i);/*建初始堆*/   \r\n    for(k=n-1;k>=1;k--)   \r\n    {   \r\n        t=e[0];/*根结点与堆的末结点交换*/   \r\n        e[0]=e[k];   \r\n        e[k]=t;   \r\n        sift(e,k,0);/*重新建堆*/   \r\n    }   \r\n}   \r\n\r\nint main(){\r\n	int n,k,i;\r\n	int a[50000],d[1000];\r\n		while(scanf("%d %d",&n,&k)==2){\r\n		\r\n		for(i = 0;i < k;i++)scanf("%d",&d[i]);\r\n\r\n		for(i = 0;i < n;i++)scanf("%d",&a[i]);\r\n\r\n		heapsort(a,n);\r\n		for(i = 0;i < k;i++){\r\n			printf("%d\\n",a[d[i]]);\r\n		}\r\n	}\r\n\r\n	\r\n	return 0;\r\n}\r\n', '', 78, 548864, 4, 1, '2010-12-31 15:37:28', '0001-01-01 00:00:00'),
(1216, 21, 339, 3, '#include<stdio.h>\r\n\r\nvoid  sift(int   e[]/*存储结点序列*/,   \r\n           int   n/*序列的结点个数*/,   \r\n           int   s/*对e[s]做渗透，其中e[s]的左右子树是堆*/)   \r\n{   \r\n    int   t,k,j;   \r\n    t=e[s];   \r\n    k=s;   \r\n    j=2*k+1;/*e[k]是e[j]和e[j+1]的父结点*/   \r\n    while(j<n)/*为渗透到页结点*/   \r\n    {   \r\n        if(j<n-1   &&   e[j]>e[j+1])//j<n-1   选出是左子还是右子跟父接点比较\r\n            j++;   /*e[j+1]是e[k]较大的子结点*/   \r\n        if(t>e[j])/*改连续渗透交换为循环传送*/   \r\n        {//               交换每个父接点与子接点，满足大顶堆，同时继续比较子接点\r\n            e[k]=e[j];   \r\n            k=j;   \r\n            j=2*k+1;   \r\n        }   \r\n        else   \r\n            break;/*已是一个堆*/   \r\n    }   \r\n    e[k]=t;   \r\n}   \r\n\r\nvoid   heapsort(int   e[],int   n)   \r\n{   \r\n    int   i,k,t;   \r\n    for(i=n/2-1;i>=0;i--)//  从最后一个非叶子节点开始建堆\r\n        sift(e,n,i);/*建初始堆*/   \r\n    for(k=n-1;k>=1;k--)   \r\n    {   \r\n        t=e[0];/*根结点与堆的末结点交换*/   \r\n        e[0]=e[k];   \r\n        e[k]=t;   \r\n        sift(e,k,0);/*重新建堆*/   \r\n    }   \r\n}   \r\n\r\nint main(){\r\n	int n,k,i;\r\n	int a[50000],d[1000];\r\n		while(scanf("%d %d",&n,&k)==2){\r\n		\r\n		for(i = 0;i < k;i++)scanf("%d",&d[i]);\r\n\r\n		for(i = 0;i < n;i++)scanf("%d",&a[i]);\r\n\r\n		heapsort(a,n);\r\n		for(i = 0;i < k;i++){\r\n			printf("%d\\n",a[d[i]]);\r\n		}\r\n		printf("\\n");\r\n	}\r\n\r\n	\r\n	return 0;\r\n}\r\n', '', 46, 544768, 7, 1, '2010-12-31 15:40:05', '0001-01-01 00:00:00'),
(1217, 21, 339, 3, '#include<stdio.h>\r\n\r\nvoid  sift(int   e[]/*存储结点序列*/,   \r\n           int   n/*序列的结点个数*/,   \r\n           int   s/*对e[s]做渗透，其中e[s]的左右子树是堆*/)   \r\n{   \r\n    int   t,k,j;   \r\n    t=e[s];   \r\n    k=s;   \r\n    j=2*k+1;/*e[k]是e[j]和e[j+1]的父结点*/   \r\n    while(j<n)/*为渗透到页结点*/   \r\n    {   \r\n        if(j<n-1   &&   e[j]>e[j+1])//j<n-1   选出是左子还是右子跟父接点比较\r\n            j++;   /*e[j+1]是e[k]较大的子结点*/   \r\n        if(t>e[j])/*改连续渗透交换为循环传送*/   \r\n        {//               交换每个父接点与子接点，满足大顶堆，同时继续比较子接点\r\n            e[k]=e[j];   \r\n            k=j;   \r\n            j=2*k+1;   \r\n        }   \r\n        else   \r\n            break;/*已是一个堆*/   \r\n    }   \r\n    e[k]=t;   \r\n}   \r\n\r\nvoid   heapsort(int   e[],int   n)   \r\n{   \r\n    int   i,k,t;   \r\n    for(i=n/2-1;i>=0;i--)//  从最后一个非叶子节点开始建堆\r\n        sift(e,n,i);/*建初始堆*/   \r\n    for(k=n-1;k>=1;k--)   \r\n    {   \r\n        t=e[0];/*根结点与堆的末结点交换*/   \r\n        e[0]=e[k];   \r\n        e[k]=t;   \r\n        sift(e,k,0);/*重新建堆*/   \r\n    }   \r\n}   \r\n\r\nint main(){\r\n	int n,k,i;\r\n	int a[50000],d[10000];\r\n		while(scanf("%d %d",&n,&k)==2){\r\n		\r\n		for(i = 0;i < k;i++)scanf("%d",&d[i]);\r\n\r\n		for(i = 0;i < n;i++)scanf("%d",&a[i]);\r\n\r\n		heapsort(a,n);\r\n		for(i = 0;i < k;i++){\r\n			printf("%d\\n",a[d[i]]);\r\n		}\r\n		printf("\\n");\r\n	}\r\n\r\n	\r\n	return 0;\r\n}\r\n', '', 31, 458752, 7, 1, '2010-12-31 15:41:42', '0001-01-01 00:00:00'),
(1218, 21, 339, 3, '#include<stdio.h>\r\n\r\nvoid  sift(int   e[]/*存储结点序列*/,   \r\n           int   n/*序列的结点个数*/,   \r\n           int   s/*对e[s]做渗透，其中e[s]的左右子树是堆*/)   \r\n{   \r\n    int   t,k,j;   \r\n    t=e[s];   \r\n    k=s;   \r\n    j=2*k+1;/*e[k]是e[j]和e[j+1]的父结点*/   \r\n    while(j<n)/*为渗透到页结点*/   \r\n    {   \r\n        if(j<n-1   &&   e[j]>e[j+1])//j<n-1   选出是左子还是右子跟父接点比较\r\n            j++;   /*e[j+1]是e[k]较大的子结点*/   \r\n        if(t>e[j])/*改连续渗透交换为循环传送*/   \r\n        {//               交换每个父接点与子接点，满足大顶堆，同时继续比较子接点\r\n            e[k]=e[j];   \r\n            k=j;   \r\n            j=2*k+1;   \r\n        }   \r\n        else   \r\n            break;/*已是一个堆*/   \r\n    }   \r\n    e[k]=t;   \r\n}   \r\n\r\nvoid   heapsort(int   e[],int   n)   \r\n{   \r\n    int   i,k,t;   \r\n    for(i=n/2-1;i>=0;i--)//  从最后一个非叶子节点开始建堆\r\n        sift(e,n,i);/*建初始堆*/   \r\n    for(k=n-1;k>=1;k--)   \r\n    {   \r\n        t=e[0];/*根结点与堆的末结点交换*/   \r\n        e[0]=e[k];   \r\n        e[k]=t;   \r\n        sift(e,k,0);/*重新建堆*/   \r\n    }   \r\n}   \r\n\r\nint main(){\r\n	int n,k,i;\r\n	int a[50000],d[10000];\r\n		while(scanf("%d %d",&n,&k)==2){\r\n		\r\n		for(i = 0;i < k;i++)scanf("%d",&d[i]);\r\n\r\n		for(i = 0;i < n;i++)scanf("%d",&a[i]);\r\n\r\n		heapsort(a,n);\r\n		for(i = 0;i < k;i++){\r\n			printf("%d\\n",a[d[i]]);\r\n		}\r\n	}\r\n\r\n	\r\n	return 0;\r\n}\r\n', '', 31, 458752, 7, 1, '2010-12-31 15:42:39', '0001-01-01 00:00:00'),
(1219, 21, 339, 3, '#include<stdio.h>\r\n\r\nvoid  sift(int   e[]/*存储结点序列*/,   \r\n           int   n/*序列的结点个数*/,   \r\n           int   s/*对e[s]做渗透，其中e[s]的左右子树是堆*/)   \r\n{   \r\n    int   t,k,j;   \r\n    t=e[s];   \r\n    k=s;   \r\n    j=2*k+1;/*e[k]是e[j]和e[j+1]的父结点*/   \r\n    while(j<n)/*为渗透到页结点*/   \r\n    {   \r\n        if(j<n-1   &&   e[j]>e[j+1])//j<n-1   选出是左子还是右子跟父接点比较\r\n            j++;   /*e[j+1]是e[k]较大的子结点*/   \r\n        if(t>e[j])/*改连续渗透交换为循环传送*/   \r\n        {//               交换每个父接点与子接点，满足大顶堆，同时继续比较子接点\r\n            e[k]=e[j];   \r\n            k=j;   \r\n            j=2*k+1;   \r\n        }   \r\n        else   \r\n            break;/*已是一个堆*/   \r\n    }   \r\n    e[k]=t;   \r\n}   \r\n\r\nvoid   heapsort(int   e[],int   n)   \r\n{   \r\n    int   i,k,t;   \r\n    for(i=n/2-1;i>=0;i--)//  从最后一个非叶子节点开始建堆\r\n        sift(e,n,i);/*建初始堆*/   \r\n    for(k=n-1;k>=1;k--)   \r\n    {   \r\n        t=e[0];/*根结点与堆的末结点交换*/   \r\n        e[0]=e[k];   \r\n        e[k]=t;   \r\n        sift(e,k,0);/*重新建堆*/   \r\n    }   \r\n}   \r\n\r\nint main(){\r\n	int n,k,i;\r\n	int a[10001]={0},d[1001]={0};\r\n		while(scanf("%d %d",&n,&k)==2){\r\n		\r\n		for(i = 0;i < k;i++)scanf("%d",&d[i]);\r\n\r\n		for(i = 0;i < n;i++)scanf("%d",&a[i]);\r\n\r\n		heapsort(a,n);\r\n\r\n		for(i = 0;i < k;i++){\r\n			printf("%d\\n",a[d[i]]);\r\n		}\r\n	}\r\n\r\n	\r\n	return 0;\r\n}\r\n', '', 0, 266240, 7, 1, '2010-12-31 15:47:12', '0001-01-01 00:00:00'),
(1220, 21, 339, 3, '#include<stdio.h>\r\n\r\nvoid  sift(int   e[]/*存储结点序列*/,   \r\n           int   n/*序列的结点个数*/,   \r\n           int   s/*对e[s]做渗透，其中e[s]的左右子树是堆*/)   \r\n{   \r\n    int   t,k,j;   \r\n    t=e[s];   \r\n    k=s;   \r\n    j=2*k+1;/*e[k]是e[j]和e[j+1]的父结点*/   \r\n    while(j<n)/*为渗透到页结点*/   \r\n    {   \r\n        if(j<n-1   &&   e[j]>e[j+1])//j<n-1   选出是左子还是右子跟父接点比较\r\n            j++;   /*e[j+1]是e[k]较大的子结点*/   \r\n        if(t>e[j])/*改连续渗透交换为循环传送*/   \r\n        {//               交换每个父接点与子接点，满足大顶堆，同时继续比较子接点\r\n            e[k]=e[j];   \r\n            k=j;   \r\n            j=2*k+1;   \r\n        }   \r\n        else   \r\n            break;/*已是一个堆*/   \r\n    }   \r\n    e[k]=t;   \r\n}   \r\n\r\nvoid   heapsort(int   e[],int   n)   \r\n{   \r\n    int   i,k,t;   \r\n    for(i=n/2-1;i>=0;i--)//  从最后一个非叶子节点开始建堆\r\n        sift(e,n,i);/*建初始堆*/   \r\n    for(k=n-1;k>=1;k--)   \r\n    {   \r\n        t=e[0];/*根结点与堆的末结点交换*/   \r\n        e[0]=e[k];   \r\n        e[k]=t;   \r\n        sift(e,k,0);/*重新建堆*/   \r\n    }   \r\n}   \r\n\r\nint main(){\r\n	int n,k,i;\r\n	int a[50001]={0},d[5001]={0};\r\n		while(scanf("%d %d",&n,&k)==2){\r\n		\r\n		for(i = 0;i < k;i++)scanf("%d",&d[i]);\r\n\r\n		for(i = 0;i < n;i++)scanf("%d",&a[i]);\r\n\r\n		heapsort(a,n);\r\n\r\n		for(i = 0;i < k;i++){\r\n			printf("%d\\n",a[d[i]]);\r\n		}\r\n	}\r\n\r\n	\r\n	return 0;\r\n}\r\n', '', 15, 438272, 7, 1, '2010-12-31 15:47:51', '0001-01-01 00:00:00'),
(1221, 21, 339, 3, '#include<stdio.h>\r\n\r\nvoid  sift(int   e[]/*存储结点序列*/,   \r\n           int   n/*序列的结点个数*/,   \r\n           int   s/*对e[s]做渗透，其中e[s]的左右子树是堆*/)   \r\n{   \r\n    int   t,k,j;   \r\n    t=e[s];   \r\n    k=s;   \r\n    j=2*k+1;/*e[k]是e[j]和e[j+1]的父结点*/   \r\n    while(j<n)/*为渗透到页结点*/   \r\n    {   \r\n        if(j<n-1   &&   e[j]>e[j+1])//j<n-1   选出是左子还是右子跟父接点比较\r\n            j++;   /*e[j+1]是e[k]较大的子结点*/   \r\n        if(t>e[j])/*改连续渗透交换为循环传送*/   \r\n        {//               交换每个父接点与子接点，满足大顶堆，同时继续比较子接点\r\n            e[k]=e[j];   \r\n            k=j;   \r\n            j=2*k+1;   \r\n        }   \r\n        else   \r\n            break;/*已是一个堆*/   \r\n    }   \r\n    e[k]=t;   \r\n}   \r\n\r\nvoid   heapsort(int   e[],int   n)   \r\n{   \r\n    int   i,k,t;   \r\n    for(i=n/2-1;i>=0;i--)//  从最后一个非叶子节点开始建堆\r\n        sift(e,n,i);/*建初始堆*/   \r\n    for(k=n-1;k>=1;k--)   \r\n    {   \r\n        t=e[0];/*根结点与堆的末结点交换*/   \r\n        e[0]=e[k];   \r\n        e[k]=t;   \r\n        sift(e,k,0);/*重新建堆*/   \r\n    }   \r\n}   \r\n\r\nint main(){\r\n	int n,k,i;\r\n	int a[50001]={0},d[50001]={0};\r\n		while(scanf("%d %d",&n,&k)==2){\r\n		\r\n		for(i = 0;i < k;i++)scanf("%d",&d[i]);\r\n\r\n		for(i = 0;i < n;i++)scanf("%d",&a[i]);\r\n\r\n		heapsort(a,n);\r\n\r\n		for(i = 0;i < k;i++){\r\n			printf("%d\\n",a[d[i]]);\r\n		}\r\n	}\r\n\r\n	\r\n	return 0;\r\n}\r\n', '', 109, 618496, 4, 1, '2010-12-31 15:48:30', '0001-01-01 00:00:00'),
(1222, 21, 339, 3, '#include<stdio.h>\r\n\r\nvoid  sift(int   e[]/*存储结点序列*/,   \r\n           int   n/*序列的结点个数*/,   \r\n           int   s/*对e[s]做渗透，其中e[s]的左右子树是堆*/)   \r\n{   \r\n    int   t,k,j;   \r\n    t=e[s];   \r\n    k=s;   \r\n    j=2*k+1;/*e[k]是e[j]和e[j+1]的父结点*/   \r\n    while(j<n)/*为渗透到页结点*/   \r\n    {   \r\n        if(j<n-1   &&   e[j]>e[j+1])//j<n-1   选出是左子还是右子跟父接点比较\r\n            j++;   /*e[j+1]是e[k]较大的子结点*/   \r\n        if(t>e[j])/*改连续渗透交换为循环传送*/   \r\n        {//               交换每个父接点与子接点，满足大顶堆，同时继续比较子接点\r\n            e[k]=e[j];   \r\n            k=j;   \r\n            j=2*k+1;   \r\n        }   \r\n        else   \r\n            break;/*已是一个堆*/   \r\n    }   \r\n    e[k]=t;   \r\n}   \r\n\r\nvoid   heapsort(int   e[],int   n)   \r\n{   \r\n    int   i,k,t;   \r\n    for(i=n/2-1;i>=0;i--)//  从最后一个非叶子节点开始建堆\r\n        sift(e,n,i);/*建初始堆*/   \r\n    for(k=n-1;k>=1;k--)   \r\n    {   \r\n        t=e[0];/*根结点与堆的末结点交换*/   \r\n        e[0]=e[k];   \r\n        e[k]=t;   \r\n        sift(e,k,0);/*重新建堆*/   \r\n    }   \r\n}   \r\n\r\nint main(){\r\n	int n,k,i;\r\n	int a[50001]={0},d[50001]={0};\r\n		while(scanf("%d %d",&n,&k)==2){\r\n		\r\n		for(i = 0;i < k;i++)scanf("%d",&d[i]);\r\n\r\n		for(i = 0;i < n;i++)scanf("%d",&a[i]);\r\n\r\n		heapsort(a,n);\r\n\r\n		for(i = 0;i < k;i++){\r\n			printf("%d\\n",a[d[i]]);\r\n		}\r\n		printf("\\n");\r\n	}\r\n\r\n	\r\n	return 0;\r\n}\r\n', '', 93, 626688, 4, 1, '2010-12-31 15:52:08', '0001-01-01 00:00:00'),
(1223, 21, 339, 3, '#include<stdio.h>\r\n\r\nvoid  sift(int   e[]/*存储结点序列*/,   \r\n           int   n/*序列的结点个数*/,   \r\n           int   s/*对e[s]做渗透，其中e[s]的左右子树是堆*/)   \r\n{   \r\n    int   t,k,j;   \r\n    t=e[s];   \r\n    k=s;   \r\n    j=2*k+1;/*e[k]是e[j]和e[j+1]的父结点*/   \r\n    while(j<n)/*为渗透到页结点*/   \r\n    {   \r\n        if(j<n-1   &&   e[j]>e[j+1])//j<n-1   选出是左子还是右子跟父接点比较\r\n            j++;   /*e[j+1]是e[k]较大的子结点*/   \r\n        if(t>e[j])/*改连续渗透交换为循环传送*/   \r\n        {//               交换每个父接点与子接点，满足大顶堆，同时继续比较子接点\r\n            e[k]=e[j];   \r\n            k=j;   \r\n            j=2*k+1;   \r\n        }   \r\n        else   \r\n            break;/*已是一个堆*/   \r\n    }   \r\n    e[k]=t;   \r\n}   \r\n\r\nvoid   heapsort(int   e[],int   n)   \r\n{   \r\n    int   i,k,t;   \r\n    for(i=n/2-1;i>=0;i--)//  从最后一个非叶子节点开始建堆\r\n        sift(e,n,i);/*建初始堆*/   \r\n    for(k=n-1;k>=1;k--)   \r\n    {   \r\n        t=e[0];/*根结点与堆的末结点交换*/   \r\n        e[0]=e[k];   \r\n        e[k]=t;   \r\n        sift(e,k,0);/*重新建堆*/   \r\n    }   \r\n}   \r\n\r\nint main(){\r\n	long n;\r\n	int k,i;\r\n	int a[100001]={0},d[50001]={0};\r\n		while(scanf("%ld%d",&n,&k)){\r\n		\r\n		for(i = 0;i < k;i++)scanf("%d",&d[i]);\r\n\r\n		for(long j = 0;j < n;j++)scanf("%d",&a[j]);\r\n\r\n		heapsort(a,n);\r\n\r\n		for(i = 0;i < k;i++){\r\n			printf("%d\\n",a[d[i]]);\r\n		}\r\n	}	\r\n	return 0;\r\n}\r\n', 'Main.c: In function ''main'':\r\nMain.c:49:3: error: ''for'' loop initial declarations are only allowed in C99 mode\r\nMain.c:49:3: note: use option -std=c99 or -std=gnu99 to compile your code\r\n', 0, 0, 2, 1, '2010-12-31 16:04:06', '0001-01-01 00:00:00'),
(1224, 21, 339, 3, '#include<stdio.h>\r\n\r\nvoid  sift(int   e[]/*存储结点序列*/,   \r\n           int   n/*序列的结点个数*/,   \r\n           int   s/*对e[s]做渗透，其中e[s]的左右子树是堆*/)   \r\n{   \r\n    int   t,k,j;   \r\n    t=e[s];   \r\n    k=s;   \r\n    j=2*k+1;/*e[k]是e[j]和e[j+1]的父结点*/   \r\n    while(j<n)/*为渗透到页结点*/   \r\n    {   \r\n        if(j<n-1   &&   e[j]>e[j+1])//j<n-1   选出是左子还是右子跟父接点比较\r\n            j++;   /*e[j+1]是e[k]较大的子结点*/   \r\n        if(t>e[j])/*改连续渗透交换为循环传送*/   \r\n        {//               交换每个父接点与子接点，满足大顶堆，同时继续比较子接点\r\n            e[k]=e[j];   \r\n            k=j;   \r\n            j=2*k+1;   \r\n        }   \r\n        else   \r\n            break;/*已是一个堆*/   \r\n    }   \r\n    e[k]=t;   \r\n}   \r\n\r\nvoid   heapsort(int   e[],int   n)   \r\n{   \r\n    int   i,k,t;   \r\n    for(i=n/2-1;i>=0;i--)//  从最后一个非叶子节点开始建堆\r\n        sift(e,n,i);/*建初始堆*/   \r\n    for(k=n-1;k>=1;k--)   \r\n    {   \r\n        t=e[0];/*根结点与堆的末结点交换*/   \r\n        e[0]=e[k];   \r\n        e[k]=t;   \r\n        sift(e,k,0);/*重新建堆*/   \r\n    }   \r\n}   \r\n\r\nint main(){\r\n	long n,j;\r\n	int k,i;\r\n	int a[100001]={0},d[50001]={0};\r\n		while(scanf("%ld%d",&n,&k)){\r\n		\r\n		for(i = 0;i < k;i++)scanf("%d",&d[i]);\r\n\r\n		for(j = 0;j < n;j++)scanf("%d",&a[j]);\r\n\r\n		heapsort(a,n);\r\n\r\n		for(i = 0;i < k;i++){\r\n			printf("%d\\n",a[d[i]]);\r\n		}\r\n	}	\r\n	return 0;\r\n}\r\n', '', 600, 819200, 5, 1, '2010-12-31 16:05:34', '0001-01-01 00:00:00'),
(1225, 21, 339, 3, '#include<stdio.h>\r\n\r\nvoid  sift(int   e[]/*存储结点序列*/,   \r\n           int   n/*序列的结点个数*/,   \r\n           int   s/*对e[s]做渗透，其中e[s]的左右子树是堆*/)   \r\n{   \r\n    int   t,k,j;   \r\n    t=e[s];   \r\n    k=s;   \r\n    j=2*k+1;/*e[k]是e[j]和e[j+1]的父结点*/   \r\n    while(j<n)/*为渗透到页结点*/   \r\n    {   \r\n        if(j<n-1   &&   e[j]>e[j+1])//j<n-1   选出是左子还是右子跟父接点比较\r\n            j++;   /*e[j+1]是e[k]较大的子结点*/   \r\n        if(t>e[j])/*改连续渗透交换为循环传送*/   \r\n        {//               交换每个父接点与子接点，满足大顶堆，同时继续比较子接点\r\n            e[k]=e[j];   \r\n            k=j;   \r\n            j=2*k+1;   \r\n        }   \r\n        else   \r\n            break;/*已是一个堆*/   \r\n    }   \r\n    e[k]=t;   \r\n}   \r\n\r\nvoid   heapsort(int   e[],int   n)   \r\n{   \r\n    int   i,k,t;   \r\n    for(i=n/2-1;i>=0;i--)//  从最后一个非叶子节点开始建堆\r\n        sift(e,n,i);/*建初始堆*/   \r\n    for(k=n-1;k>=1;k--)   \r\n    {   \r\n        t=e[0];/*根结点与堆的末结点交换*/   \r\n        e[0]=e[k];   \r\n        e[k]=t;   \r\n        sift(e,k,0);/*重新建堆*/   \r\n    }   \r\n}   \r\n\r\nint main(){\r\n	long n,j;\r\n	int k,i;\r\n	int a[100001]={0},d[1001]={0};\r\n		while(scanf("%ld%d",&n,&k)){\r\n		\r\n		for(i = 0;i < k;i++)scanf("%d",&d[i]);\r\n\r\n		for(j = 0;j < n;j++)scanf("%d",&a[j]);\r\n\r\n		heapsort(a,n);\r\n\r\n		for(i = 0;i < k;i++){\r\n			printf("%d\\n",a[d[i]]);\r\n		}\r\n	}	\r\n	return 0;\r\n}\r\n', '', 600, 622592, 5, 1, '2010-12-31 16:06:43', '0001-01-01 00:00:00'),
(1226, 21, 339, 3, '#include<stdio.h>\r\n\r\nvoid swap(int *list, int i,int j)//swap two elements\r\n{\r\n     int temp=list[i];\r\n      list[i]=list[j];\r\n      list[j]=temp;\r\n}\r\n  \r\nint partition(int *list,const int low, const int high)//to find the fixed position of \r\n                                                      //the low elements\r\n{\r\n   int base=list[low];\r\n   int i=low+1,j=high;\r\n    if(high-low==1)//judge directly if there is only two elements\r\n  {\r\n      if(list[low]>list[high])\r\n       swap(list,low,high);\r\n      return high;\r\n  }\r\n   while(i<j)\r\n   {\r\n     while(i<j&&list[i]<=base)i++;//find an element bigger than the base from the beginning\r\n     while(j>low&&list[j]>=base)j--;   //find an element smaller than the base from the end\r\n     if(j>i)\r\n  {\r\n   swap(list,i,j);\r\n      i++,j--;\r\n  }\r\n   }\r\n   swap(list,low,j);//fix the position of the low\r\n   return j;\r\n}\r\nvoid quickSort(int *list,const int left,const int right)\r\n{\r\n  if(left<right)\r\n     {\r\n       int pos=partition(list,left,right);\r\n         quickSort(list,left,pos-1);\r\n         quickSort(list,pos+1,right);\r\n     }\r\n}\r\n\r\n\r\nint main(){\r\n	long n,j;\r\n	int k,i;\r\n	int a[100001]={0},d[1001]={0};\r\n		while(scanf("%ld%d",&n,&k)){\r\n		\r\n		for(i = 0;i < k;i++)scanf("%d",&d[i]);\r\n\r\n		for(j = 0;j < n;j++)scanf("%d",&a[j]);\r\n\r\n		quickSort(a,0,n-1);\r\n\r\n		for(i = 0;i < k;i++){\r\n			printf("%d\\n",a[n-1-d[i]]);\r\n		}\r\n	}	\r\n	return 0;\r\n}\r\n', '', 600, 1384448, 5, 1, '2010-12-31 16:21:29', '0001-01-01 00:00:00'),
(1227, 21, 379, 7, '#include<stdio.h>\r\n#include<string.h>\r\nint n,p,c,l[801][801],cow[501],a[801][801],q[641601],f,e,dis[801],ans;\r\nbool flag[801];\r\n\r\nvoid spfa(int s){\r\n	int st,i,total = 0;\r\n	flag[s] = true;\r\n	while(f <= e)\r\n	{\r\n		st = q[f];\r\n		for(i = 1; i <= l[st][0]; ++ i)\r\n		{\r\n			if(dis[st] + a[st][l[st][i]] < dis[l[st][i]])\r\n			{\r\n				dis[l[st][i]] =  dis[st] + a[st][l[st][i]];\r\n				if(!flag[l[st][i]])\r\n				{\r\n					++ e;\r\n					q[e] = l[st][i];\r\n					flag[l[st][i]] = true;\r\n                }\r\n             }\r\n        }\r\n		flag[st] = false;\r\n		++ f;\r\n     }\r\n	for(i = 1; i <= n; ++ i)\r\n		total += dis[cow[i]];\r\n	if(total < ans)\r\n		ans = total;\r\n}\r\n\r\nint main(){\r\n    int i,j,x,y,z;\r\n    while(scanf("%d%d%d",&n,&p,&c) == 3){\r\n		ans = 0x7FFFFFFF;\r\n		for(i = 1; i <= n; ++ i)\r\n			scanf("%d",&cow[i]);\r\n		for(i = 1; i <= c; ++ i)\r\n		{\r\n			scanf("%d%d%d",&x,&y,&z);\r\n			++ l[x][0];\r\n			a[x][y] = z;\r\n			l[x][l[x][0]] = y; \r\n			++ l[y][0];\r\n			a[y][x] = z; \r\n			l[y][l[y][0]] = x;\r\n		} \r\n		for(i = 1; i <= p; ++ i)\r\n		{\r\n			f = 1; \r\n			e = 1; \r\n			q[1] = i; \r\n			memset(dis,0x7F,sizeof(dis));  \r\n			memset(flag,0,sizeof(flag));\r\n			dis[i] = 0;  \r\n			spfa(i); \r\n		}  \r\n		printf("%d\\n",ans);  	\r\n	}\r\n	\r\n	return 0;\r\n}', 'Main.c:4:6: error: expected ''='', '','', '';'', ''asm'' or ''__attribute__'' before ''flag''\r\nMain.c: In function ''spfa'':\r\nMain.c:8:2: error: ''flag'' undeclared (first use in this function)\r\nMain.c:8:2: note: each undeclared identifier is reported only once for each function it appears in\r\nMain.c:8:12: error: ''true'' undeclared (first use in this function)\r\nMain.c:25:14: error: ''false'' undeclared (first use in this function)\r\nMain.c: In function ''main'':\r\nMain.c:56:11: error: ''flag'' undeclared (first use in t', 0, 0, 2, 1, '2010-12-31 17:18:02', '0001-01-01 00:00:00'),
(1228, 21, 379, 7, '#include<stdio.h>\r\n#include<string.h>\r\nint n,p,c,l[801][801],cow[501],a[801][801],q[641601],f,e,dis[801],ans;\r\nbool flag[801];\r\n\r\nvoid spfa(int s){\r\n	int st,i,total = 0;\r\n	flag[s] = true;\r\n	while(f <= e)\r\n	{\r\n		st = q[f];\r\n		for(i = 1; i <= l[st][0]; ++ i)\r\n		{\r\n			if(dis[st] + a[st][l[st][i]] < dis[l[st][i]])\r\n			{\r\n				dis[l[st][i]] =  dis[st] + a[st][l[st][i]];\r\n				if(!flag[l[st][i]])\r\n				{\r\n					++ e;\r\n					q[e] = l[st][i];\r\n					flag[l[st][i]] = true;\r\n                }\r\n             }\r\n        }\r\n		flag[st] = false;\r\n		++ f;\r\n     }\r\n	for(i = 1; i <= n; ++ i)\r\n		total += dis[cow[i]];\r\n	if(total < ans)\r\n		ans = total;\r\n}\r\n\r\nint main(){\r\n    int i,j,x,y,z;\r\n    while(scanf("%d%d%d",&n,&p,&c) == 3){\r\n		ans = 0x7FFFFFFF;\r\n		for(i = 1; i <= n; ++ i)\r\n			scanf("%d",&cow[i]);\r\n		for(i = 1; i <= c; ++ i)\r\n		{\r\n			scanf("%d%d%d",&x,&y,&z);\r\n			++ l[x][0];\r\n			a[x][y] = z;\r\n			l[x][l[x][0]] = y; \r\n			++ l[y][0];\r\n			a[y][x] = z; \r\n			l[y][l[y][0]] = x;\r\n		} \r\n		for(i = 1; i <= p; ++ i)\r\n		{\r\n			f = 1; \r\n			e = 1; \r\n			q[1] = i; \r\n			memset(dis,0x7F,sizeof(dis));  \r\n			memset(flag,0,sizeof(flag));\r\n			dis[i] = 0;  \r\n			spfa(i); \r\n		}  \r\n		printf("%d\\n",ans);  	\r\n	}\r\n	\r\n	return 0;\r\n}', '', 326, 7979008, 1, 2, '2010-12-31 17:20:01', '0001-01-01 00:00:00'),
(1229, 21, 344, 4, '#include<stdlib.h>\r\n#include<string.h>\r\n#include<stdio.h>\r\ntypedef struct LNode{\r\n	char name[100];\r\n	struct LNode *next;\r\n}LNode,*Linklist;\r\n\r\n\r\n\r\nLinklist init(){\r\n	Linklist L = (Linklist)malloc(sizeof(LNode));\r\n	L->next = NULL;\r\n	strcpy(L->name,"head");\r\n	return L;\r\n}\r\n\r\nvoid append(Linklist L,char* name){\r\n	LNode* p = L;\r\n	LNode* f=NULL;\r\n	while(p->next){\r\n		p = p->next;\r\n		if(0==strcmp(p->name,name)){\r\n			f = p;\r\n		}\r\n	}\r\n	if(f){\r\n		p->next = f;\r\n	}\r\n	else{\r\n		LNode* pnode = (Linklist)malloc(sizeof(LNode));\r\n		strcpy(pnode->name,name);\r\n		p->next = pnode;\r\n		pnode->next = NULL;\r\n	}\r\n	\r\n}\r\n\r\nvoid ClearList(Linklist L)\r\n{\r\n   LNode *p;\r\n   while (L->next){\r\n      p=L->next;      //p指向链表中头结点后面的第一个结点\r\n      L->next=p->next;     //删除p结点\r\n      free(p);     //释放p结点占据的存储空间\r\n   }\r\n}\r\n\r\n\r\nbool IsExitsLoop(Linklist  head)\r\n{\r\n    Linklist  slow = head   ,   fast = head ;\r\n\r\n    while  ( fast  &&  fast -> next ) \r\n    {\r\n        slow  =  slow -> next;\r\n        fast  =  fast -> next -> next;\r\n        if  ( slow  ==  fast )  break ;\r\n    }\r\n\r\n    return   ! (fast  ==  NULL  ||  fast -> next  ==  NULL);\r\n} \r\n\r\nLinklist  FindLoopPort(Linklist head)\r\n{\r\n		Linklist slow  =  head;\r\n		Linklist fast  =  head;\r\n				\r\n		while  ( fast  &&  fast -> next ) \r\n		{\r\n			slow  =  slow -> next;\r\n			fast  =  fast -> next -> next;\r\n			if  ( slow  ==  fast )  break ;\r\n		}\r\n				\r\n		if  (fast  ==  NULL  ||  fast -> next  ==  NULL)\r\n			return  NULL;\r\n				\r\n		slow  =  head;\r\n		while  (slow  !=  fast)\r\n		{\r\n			slow  =  slow -> next;\r\n			fast  =  fast -> next;\r\n		}\r\n		\r\n		return  slow;\r\n} \r\n\r\nint main(){\r\n	Linklist L;\r\n	Linklist p;\r\n	L = init();\r\n	char n[100];\r\n	int k;\r\n	while(scanf("%d",&k)==1){\r\n		for(int i = 0;i < k;i++){\r\n			scanf("%s",n);\r\n			append(L,n);\r\n		}\r\n		int count = 0;\r\n		if(IsExitsLoop(L)){\r\n			Linklist port = FindLoopPort(L);\r\n			p = L->next;\r\n			while(0 != strcmp(p->name,port->name)){\r\n				p = p->next;\r\n			}\r\n			count++;\r\n			while(0 != strcmp(p->next->name,port->name)){\r\n				count++;\r\n				p = p->next;\r\n			}\r\n			p->next = NULL;//解链\r\n		}\r\n\r\n		printf("%d\\n",count);\r\n		ClearList(L);\r\n	}\r\n	return 0;\r\n}\r\n\r\n', 'Main.c:50:6: error: expected ''='', '','', '';'', ''asm'' or ''__attribute__'' before ''IsExitsLoop''\r\nMain.c: In function ''main'':\r\nMain.c:96:3: error: ''for'' loop initial declarations are only allowed in C99 mode\r\nMain.c:96:3: note: use option -std=c99 or -std=gnu99 to compile your code\r\n', 0, 0, 2, 1, '2010-12-31 20:23:52', '0001-01-01 00:00:00'),
(1230, 21, 344, 4, '#include<stdlib.h>\r\n#include<string.h>\r\n#include<stdio.h>\r\ntypedef struct LNode{\r\n	char name[100];\r\n	struct LNode *next;\r\n}LNode,*Linklist;\r\n\r\n\r\n\r\nLinklist init(){\r\n	Linklist L = (Linklist)malloc(sizeof(LNode));\r\n	L->next = NULL;\r\n	strcpy(L->name,"head");\r\n	return L;\r\n}\r\n\r\nvoid append(Linklist L,char* name){\r\n	LNode* p = L;\r\n	LNode* f=NULL;\r\n	while(p->next){\r\n		p = p->next;\r\n		if(0==strcmp(p->name,name)){\r\n			f = p;\r\n		}\r\n	}\r\n	if(f){\r\n		p->next = f;\r\n	}\r\n	else{\r\n		LNode* pnode = (Linklist)malloc(sizeof(LNode));\r\n		strcpy(pnode->name,name);\r\n		p->next = pnode;\r\n		pnode->next = NULL;\r\n	}\r\n	\r\n}\r\n\r\nvoid ClearList(Linklist L)\r\n{\r\n   LNode *p;\r\n   while (L->next){\r\n      p=L->next;      //p指向链表中头结点后面的第一个结点\r\n      L->next=p->next;     //删除p结点\r\n      free(p);     //释放p结点占据的存储空间\r\n   }\r\n}\r\n\r\n\r\nbool IsExitsLoop(Linklist  head)\r\n{\r\n    Linklist slow = head ; \r\n	Linklist fast = head ;\r\n\r\n    while  ( fast  &&  fast -> next ) \r\n    {\r\n        slow  =  slow -> next;\r\n        fast  =  fast -> next -> next;\r\n        if  ( slow  ==  fast )  break ;\r\n    }\r\n\r\n    return   ! (fast  ==  NULL  ||  fast -> next  ==  NULL);\r\n} \r\n\r\nLinklist  FindLoopPort(Linklist head)\r\n{\r\n		Linklist slow  =  head;\r\n		Linklist fast  =  head;\r\n				\r\n		while  ( fast  &&  fast -> next ) \r\n		{\r\n			slow  =  slow -> next;\r\n			fast  =  fast -> next -> next;\r\n			if  ( slow  ==  fast )  break ;\r\n		}\r\n				\r\n		if  (fast  ==  NULL  ||  fast -> next  ==  NULL)\r\n			return  NULL;\r\n				\r\n		slow  =  head;\r\n		while  (slow  !=  fast)\r\n		{\r\n			slow  =  slow -> next;\r\n			fast  =  fast -> next;\r\n		}\r\n		\r\n		return  slow;\r\n} \r\n\r\nint main(){\r\n	Linklist L;\r\n	Linklist p;\r\n	L = init();\r\n	char n[100];\r\n	int k,i;\r\n	while(scanf("%d",&k)==1){\r\n		for(i = 0;i < k;i++){\r\n			scanf("%s",n);\r\n			append(L,n);\r\n		}\r\n		int count = 0;\r\n		if(IsExitsLoop(L)){\r\n			Linklist port = FindLoopPort(L);\r\n			p = L->next;\r\n			while(0 != strcmp(p->name,port->name)){\r\n				p = p->next;\r\n			}\r\n			count++;\r\n			while(0 != strcmp(p->next->name,port->name)){\r\n				count++;\r\n				p = p->next;\r\n			}\r\n			p->next = NULL;//解链\r\n		}\r\n\r\n		printf("%d\\n",count);\r\n		ClearList(L);\r\n	}\r\n	return 0;\r\n}\r\n\r\n', 'Main.c:50:6: error: expected ''='', '','', '';'', ''asm'' or ''__attribute__'' before ''IsExitsLoop''\r\n', 0, 0, 2, 1, '2010-12-31 20:27:12', '0001-01-01 00:00:00'),
(1231, 21, 344, 4, '#include<stdlib.h>\r\n#include<string.h>\r\n#include<stdio.h>\r\ntypedef struct LNode{\r\n	char name[100];\r\n	struct LNode *next;\r\n}LNode,*Linklist;\r\n\r\n\r\n\r\nLinklist init(){\r\n	Linklist L = (Linklist)malloc(sizeof(LNode));\r\n	L->next = NULL;\r\n	strcpy(L->name,"head");\r\n	return L;\r\n}\r\n\r\nvoid append(Linklist L,char* name){\r\n	LNode* p = L;\r\n	LNode* f=NULL;\r\n	while(p->next){\r\n		p = p->next;\r\n		if(0==strcmp(p->name,name)){\r\n			f = p;\r\n		}\r\n	}\r\n	if(f){\r\n		p->next = f;\r\n	}\r\n	else{\r\n		LNode* pnode = (Linklist)malloc(sizeof(LNode));\r\n		strcpy(pnode->name,name);\r\n		p->next = pnode;\r\n		pnode->next = NULL;\r\n	}\r\n	\r\n}\r\n\r\nvoid ClearList(Linklist L)\r\n{\r\n   LNode *p;\r\n   while (L->next){\r\n      p=L->next;      //p指向链表中头结点后面的第一个结点\r\n      L->next=p->next;     //删除p结点\r\n      free(p);     //释放p结点占据的存储空间\r\n   }\r\n}\r\n\r\n\r\nvoid  IsExitsLoop(Linklist  head,bool &b)\r\n{\r\n    Linklist slow = head ; \r\n	Linklist fast = head ;\r\n\r\n    while  ( fast  &&  fast -> next ) \r\n    {\r\n        slow  =  slow -> next;\r\n        fast  =  fast -> next -> next;\r\n        if  ( slow  ==  fast )  break ;\r\n    }\r\n\r\n	 b = ! (fast  ==  NULL  ||  fast -> next  ==  NULL);\r\n} \r\n\r\nLinklist  FindLoopPort(Linklist head)\r\n{\r\n		Linklist slow  =  head;\r\n		Linklist fast  =  head;\r\n				\r\n		while  ( fast  &&  fast -> next ) \r\n		{\r\n			slow  =  slow -> next;\r\n			fast  =  fast -> next -> next;\r\n			if  ( slow  ==  fast )  break ;\r\n		}\r\n				\r\n		if  (fast  ==  NULL  ||  fast -> next  ==  NULL)\r\n			return  NULL;\r\n				\r\n		slow  =  head;\r\n		while  (slow  !=  fast)\r\n		{\r\n			slow  =  slow -> next;\r\n			fast  =  fast -> next;\r\n		}\r\n		\r\n		return  slow;\r\n} \r\n\r\nint main(){\r\n	Linklist L;\r\n	Linklist p;\r\n	L = init();\r\n	char n[100];\r\n	int k,i;\r\n	while(scanf("%d",&k)==1){\r\n		for(i = 0;i < k;i++){\r\n			scanf("%s",n);\r\n			append(L,n);\r\n		}\r\n		int count = 0;\r\n		bool b = 0;\r\n		IsExitsLoop(L,b);\r\n		if(b){\r\n			Linklist port = FindLoopPort(L);\r\n			p = L->next;\r\n			while(0 != strcmp(p->name,port->name)){\r\n				p = p->next;\r\n			}\r\n			count++;\r\n			while(0 != strcmp(p->next->name,port->name)){\r\n				count++;\r\n				p = p->next;\r\n			}\r\n			p->next = NULL;//解链\r\n		}\r\n\r\n		printf("%d\\n",count);\r\n		ClearList(L);\r\n	}\r\n	return 0;\r\n}\r\n\r\n', 'Main.c:50:34: error: expected declaration specifiers or ''...'' before ''bool''\r\nMain.c: In function ''IsExitsLoop'':\r\nMain.c:62:3: error: ''b'' undeclared (first use in this function)\r\nMain.c:62:3: note: each undeclared identifier is reported only once for each function it appears in\r\nMain.c: In function ''main'':\r\nMain.c:102:3: error: ''bool'' undeclared (first use in this function)\r\nMain.c:102:8: error: expected '';'' before ''b''\r\nMain.c:103:17: error: ''b'' undeclared (first use in this function)\r\nMain.c:103', 0, 0, 2, 1, '2010-12-31 20:44:38', '0001-01-01 00:00:00'),
(1232, 21, 344, 4, '#include<stdlib.h>\r\n#include<string.h>\r\n#include<stdio.h>\r\ntypedef struct LNode{\r\n	char name[100];\r\n	struct LNode *next;\r\n}LNode,*Linklist;\r\n\r\n\r\n\r\nLinklist init(){\r\n	Linklist L = (Linklist)malloc(sizeof(LNode));\r\n	L->next = NULL;\r\n	strcpy(L->name,"head");\r\n	return L;\r\n}\r\n\r\nvoid append(Linklist L,char* name){\r\n	LNode* p = L;\r\n	LNode* f=NULL;\r\n	while(p->next){\r\n		p = p->next;\r\n		if(0==strcmp(p->name,name)){\r\n			f = p;\r\n		}\r\n	}\r\n	if(f){\r\n		p->next = f;\r\n	}\r\n	else{\r\n		LNode* pnode = (Linklist)malloc(sizeof(LNode));\r\n		strcpy(pnode->name,name);\r\n		p->next = pnode;\r\n		pnode->next = NULL;\r\n	}\r\n	\r\n}\r\n\r\nvoid ClearList(Linklist L)\r\n{\r\n   LNode *p;\r\n   while (L->next){\r\n      p=L->next;      //p指向链表中头结点后面的第一个结点\r\n      L->next=p->next;     //删除p结点\r\n      free(p);     //释放p结点占据的存储空间\r\n   }\r\n}\r\n\r\n\r\nvoid  IsExitsLoop(Linklist  head,bool *b)\r\n{\r\n    Linklist slow = head ; \r\n	Linklist fast = head ;\r\n\r\n    while  ( fast  &&  fast -> next ) \r\n    {\r\n        slow  =  slow -> next;\r\n        fast  =  fast -> next -> next;\r\n        if  ( slow  ==  fast )  break ;\r\n    }\r\n\r\n	 *b = ! (fast  ==  NULL  ||  fast -> next  ==  NULL);\r\n} \r\n\r\nLinklist  FindLoopPort(Linklist head)\r\n{\r\n		Linklist slow  =  head;\r\n		Linklist fast  =  head;\r\n				\r\n		while  ( fast  &&  fast -> next ) \r\n		{\r\n			slow  =  slow -> next;\r\n			fast  =  fast -> next -> next;\r\n			if  ( slow  ==  fast )  break ;\r\n		}\r\n				\r\n		if  (fast  ==  NULL  ||  fast -> next  ==  NULL)\r\n			return  NULL;\r\n				\r\n		slow  =  head;\r\n		while  (slow  !=  fast)\r\n		{\r\n			slow  =  slow -> next;\r\n			fast  =  fast -> next;\r\n		}\r\n		\r\n		return  slow;\r\n} \r\n\r\nint main(){\r\n	Linklist L;\r\n	Linklist p;\r\n	L = init();\r\n	char n[100];\r\n	int k,i;\r\n	while(scanf("%d",&k)==1){\r\n		for(i = 0;i < k;i++){\r\n			scanf("%s",n);\r\n			append(L,n);\r\n		}\r\n		int count = 0;\r\n		bool b = 0;\r\n		IsExitsLoop(L,&b);\r\n		if(b){\r\n			Linklist port = FindLoopPort(L);\r\n			p = L->next;\r\n			while(0 != strcmp(p->name,port->name)){\r\n				p = p->next;\r\n			}\r\n			count++;\r\n			while(0 != strcmp(p->next->name,port->name)){\r\n				count++;\r\n				p = p->next;\r\n			}\r\n			p->next = NULL;//解链\r\n		}\r\n\r\n		printf("%d\\n",count);\r\n		ClearList(L);\r\n	}\r\n	return 0;\r\n}\r\n\r\n', 'Main.c:50:34: error: expected declaration specifiers or ''...'' before ''bool''\r\nMain.c: In function ''IsExitsLoop'':\r\nMain.c:62:4: error: ''b'' undeclared (first use in this function)\r\nMain.c:62:4: note: each undeclared identifier is reported only once for each function it appears in\r\nMain.c: In function ''main'':\r\nMain.c:102:3: error: ''bool'' undeclared (first use in this function)\r\nMain.c:102:8: error: expected '';'' before ''b''\r\nMain.c:103:18: error: ''b'' undeclared (first use in this function)\r\nMain.c:103', 0, 0, 2, 1, '2010-12-31 20:47:11', '0001-01-01 00:00:00'),
(1233, 12, 336, 2, '#include<stdio.h>\r\n\r\nint bit_count(int n){\r\n	int count;\r\n	for(count = 0; n; n &= n - 1)\r\n	{\r\n       count++;\r\n	}	\r\n	return count;\r\n}\r\n\r\n\r\nint main(){\r\n	int n,a[50000][2],i,j,temp,c;\r\n	while(scanf("%d",&n)==1){\r\n	for(i=0;i<n;i++)\r\n	{\r\n		scanf("%d",&c);\r\n		a[i][0]=c;\r\n		a[i][1]=bit_count(c);\r\n	}\r\n\r\n	for(i=0;i<n-1;i++){\r\n		for(j=0;j<n-1-i;j++){\r\n			if((a[j][1]>a[j+1][1])||((a[j][1]==a[j+1][1])&&(a[j][0]>a[j+1][0]))){\r\n				temp=a[j][0];a[j][0]=a[j+1][0];a[j+1][0]=temp;\r\n				temp=a[j][1];a[j][1]=a[j+1][1];a[j+1][1]=temp;\r\n			}\r\n		}\r\n	}\r\n\r\n	for(i=0;i<n;i++)printf("%d ",a[i][0]); \r\n	printf("\\n");\r\n	}\r\n	return 0;		\r\n}', '', 200, 606208, 5, 1, '2011-01-08 22:40:34', '0001-01-01 00:00:00'),
(1234, 12, 339, 3, '#include<stdio.h>\r\n\r\nvoid  sift(int   e[]/*存储结点序列*/,   \r\n           int   n/*序列的结点个数*/,   \r\n           int   s/*对e[s]做渗透，其中e[s]的左右子树是堆*/)   \r\n{   \r\n    int   t,k,j;   \r\n    t=e[s];   \r\n    k=s;   \r\n    j=2*k+1;/*e[k]是e[j]和e[j+1]的父结点*/   \r\n    while(j<n)/*为渗透到页结点*/   \r\n    {   \r\n        if(j<n-1   &&   e[j]<e[j+1])//j<n-1   选出是左子还是右子跟父接点比较\r\n            j++;   /*e[j+1]是e[k]较大的子结点*/   \r\n        if(t<e[j])/*改连续渗透交换为循环传送*/   \r\n        {//               交换每个父接点与子接点，满足大顶堆，同时继续比较子接点\r\n            e[k]=e[j];   \r\n            k=j;   \r\n            j=2*k+1;   \r\n        }   \r\n        else   \r\n            break;/*已是一个堆*/   \r\n    }   \r\n    e[k]=t;   \r\n}   \r\n\r\nvoid   heapsort(int   e[],int   n)   \r\n{   \r\n    int   i,k,t;   \r\n    for(i=n/2-1;i>=0;i--)//  从最后一个非叶子节点开始建堆\r\n        sift(e,n,i);/*建初始堆*/   \r\n    for(k=n-1;k>=1;k--)   \r\n    {   \r\n        t=e[0];/*根结点与堆的末结点交换*/   \r\n        e[0]=e[k];   \r\n        e[k]=t;   \r\n        sift(e,k,0);/*重新建堆*/   \r\n    }   \r\n}  \r\n\r\n\r\nint main(){\r\n	long n,j;\r\n	int k,i;\r\n	int a[100001]={0},d[1001]={0};\r\n		while(scanf("%ld%d",&n,&k)){\r\n		\r\n		for(i = 0;i < k;i++)scanf("%d",&d[i]);\r\n\r\n		for(j = 0;j < n;j++)scanf("%d",&a[j]);\r\n\r\n		heapsort(a,n);\r\n\r\n		for(i = 0;i < k;i++){\r\n			printf("%d\\n",a[n-1-d[i]]);\r\n		}\r\n	}	\r\n	return 0;\r\n}\r\n', '', 600, 622592, 5, 1, '2011-01-08 22:41:33', '0001-01-01 00:00:00');
INSERT INTO `tbl_submitions` (`id`, `user_id`, `problem_id`, `exercise_id`, `source`, `result`, `used_time`, `used_memory`, `status`, `compiler_id`, `created`, `modified`) VALUES
(1235, 12, 344, 4, '#include<stdlib.h>\r\n#include<string.h>\r\n#include<stdio.h>\r\ntypedef struct LNode{\r\n	char name[100];\r\n	struct LNode *next;\r\n}LNode,*Linklist;\r\n\r\n\r\n\r\nLinklist init(){\r\n	Linklist L = (Linklist)malloc(sizeof(LNode));\r\n	L->next = NULL;\r\n	strcpy(L->name,"head");\r\n	return L;\r\n}\r\n\r\nvoid append(Linklist L,char* name){\r\n	LNode* p = L;\r\n	LNode* f=NULL;\r\n	while(p->next){\r\n		p = p->next;\r\n		if(0==strcmp(p->name,name)){\r\n			f = p;\r\n		}\r\n	}\r\n	if(f){\r\n		p->next = f;\r\n	}\r\n	else{\r\n		LNode* pnode = (Linklist)malloc(sizeof(LNode));\r\n		strcpy(pnode->name,name);\r\n		p->next = pnode;\r\n		pnode->next = NULL;\r\n	}\r\n	\r\n}\r\n\r\nvoid ClearList(Linklist L)\r\n{\r\n   LNode *p;\r\n   while (L->next){\r\n      p=L->next;      //p指向链表中头结点后面的第一个结点\r\n      L->next=p->next;     //删除p结点\r\n      free(p);     //释放p结点占据的存储空间\r\n   }\r\n}\r\n\r\n\r\nbool IsExitsLoop(Linklist  head)\r\n{\r\n    Linklist  slow = head   ,   fast = head ;\r\n\r\n    while  ( fast  &&  fast -> next ) \r\n    {\r\n        slow  =  slow -> next;\r\n        fast  =  fast -> next -> next;\r\n        if  ( slow  ==  fast )  break ;\r\n    }\r\n\r\n    return   ! (fast  ==  NULL  ||  fast -> next  ==  NULL);\r\n} \r\n\r\nLinklist  FindLoopPort(Linklist head)\r\n{\r\n		Linklist slow  =  head;\r\n		Linklist fast  =  head;\r\n				\r\n		while  ( fast  &&  fast -> next ) \r\n		{\r\n			slow  =  slow -> next;\r\n			fast  =  fast -> next -> next;\r\n			if  ( slow  ==  fast )  break ;\r\n		}\r\n				\r\n		if  (fast  ==  NULL  ||  fast -> next  ==  NULL)\r\n			return  NULL;\r\n				\r\n		slow  =  head;\r\n		while  (slow  !=  fast)\r\n		{\r\n			slow  =  slow -> next;\r\n			fast  =  fast -> next;\r\n		}\r\n		\r\n		return  slow;\r\n} \r\n\r\nint main(){\r\n	Linklist L;\r\n	Linklist p;\r\n	L = init();\r\n	char n[100];\r\n	int k;\r\n	while(scanf("%d",&k)==1){\r\n		for(int i = 0;i < k;i++){\r\n			scanf("%s",n);\r\n			append(L,n);\r\n		}\r\n		int count = 0;\r\n		if(IsExitsLoop(L)){\r\n			Linklist port = FindLoopPort(L);\r\n			p = L->next;\r\n			while(0 != strcmp(p->name,port->name)){\r\n				p = p->next;\r\n			}\r\n			count++;\r\n			while(0 != strcmp(p->next->name,port->name)){\r\n				count++;\r\n				p = p->next;\r\n			}\r\n			p->next = NULL;//解链\r\n		}\r\n\r\n		printf("%d\\n",count);\r\n		ClearList(L);\r\n	}\r\n	return 0;\r\n}\r\n\r\n', 'Main.c:50:6: error: expected ''='', '','', '';'', ''asm'' or ''__attribute__'' before ''IsExitsLoop''\r\nMain.c: In function ''main'':\r\nMain.c:96:3: error: ''for'' loop initial declarations are only allowed in C99 mode\r\nMain.c:96:3: note: use option -std=c99 or -std=gnu99 to compile your code\r\n', 0, 0, 2, 1, '2011-01-08 22:42:18', '0001-01-01 00:00:00'),
(1236, 12, 375, 5, '#include<stdio.h>\r\nint main(){\r\n	int n;\r\n	int a[50000] = {0};\r\n	while(scanf("%d",&n)!=-1){\r\n\r\n	for(int i=0;i<n;i++){\r\n		scanf("%d",&(a[i]));\r\n	}\r\n\r\n	int pre;\r\n	int number = 1;\r\n	pre = a[0];\r\n	for(i=1;i<n;i++){\r\n		if(a[i]<pre){\r\n			pre = a[i];\r\n			continue;\r\n		}\r\n		else{\r\n			pre = a[i];\r\n			number++;\r\n		}\r\n	}\r\n	printf("%d\\n",number);\r\n\r\n	}\r\n	\r\n	return 0;\r\n}', 'Main.c: In function ''main'':\r\nMain.c:7:2: error: ''for'' loop initial declarations are only allowed in C99 mode\r\nMain.c:7:2: note: use option -std=c99 or -std=gnu99 to compile your code\r\n', 0, 0, 2, 1, '2011-01-08 22:43:26', '0001-01-01 00:00:00'),
(1237, 12, 376, 5, '#include<stdio.h>\r\nint main(){\r\n	int i;\r\n	int n;\r\n	int a[50000]={0};\r\n\r\n	while(scanf("%d",&n)!=-1){\r\n		long accumulate = 1;\r\n		for(i = 0;i < n;i++){\r\n			scanf("%d",&a[i]);\r\n			accumulate *= a[i];\r\n		}\r\n\r\n		if(accumulate>=0){\r\n			int min = a[0];\r\n			int minid = 0;\r\n			for(i = 1;i < n;i++){\r\n				if(a[i]<min){min=a[i];minid = i;}\r\n			}\r\n			int result=1;\r\n			for(i = 0;i < n;i++){\r\n				if(i!=minid)result *= a[i];\r\n			}\r\n			printf("%d\\n",result);\r\n		}\r\n		else{\r\n			int max = 0;\r\n			int maxid;\r\n			for(i = 0;i < n;i++){\r\n				if(max == 0 && a[i]<0 ){max=a[i];maxid = i;}\r\n				else if(a[i]>max && a[i]<0 ){max = a[i];maxid = i;}\r\n			}\r\n			int result=1;\r\n			for(i = 0;i < n;i++){\r\n				if(i != maxid)result *= a[i];\r\n			}\r\n			printf("%d\\n",result);\r\n		}\r\n\r\n	}\r\n	return 0;\r\n}', '', 78, 421888, 4, 1, '2011-01-08 22:44:37', '0001-01-01 00:00:00'),
(1238, 12, 378, 6, '#include <stdio.h> \r\n#include <math.h> \r\nconst int MAX = 101 ; \r\nstruct point { float x ;float y ; } p[MAX] ; \r\nint main() \r\n{ \r\n	int  n , m , i , sum , t1 , t2 ;\r\n	float f ;\r\n	point t ; \r\n	while ( scanf( "%d" , &n )  ) \r\n	{ \r\n	//	if( prob ++ ) printf ( "\\n" ); \r\n	//	printf ( "Problem %d:\\n" , prob ) ; \r\n		scanf ( "%d" , &m ) ; \r\n		for ( i = 0 ; i < n ; i ++ ) scanf ( "%f%f" , &p[ i ].x , &p[ i ].y ) ; \r\n		p[ n ] = p[ 0 ]  ; \r\n		while ( m -- ) \r\n		{ \r\n			scanf ( "%f%f" , &t.x , &t.y ); \r\n			for ( i = 0 ; i <= n ; i ++ ) p[ i ].x -= t.x , p[ i ].y -= t.y ;    // 坐标平移   \r\n			t1 = p[ 0 ].x>=0 ? ( p[ 0 ].y>=0?0:3 ) : ( p[ 0 ].y>=0?1:2 ) ;        // 计算象限 \r\n			for ( sum = 0 , i = 1 ; i <= n ; i ++ ) \r\n			{ \r\n				if ( !p[ i ].x && !p[ i ].y ){printf("0\\n"); break ;}             \r\n				// 被测点为多边形顶点 \r\n				f = p[ i ].y * p[i-1].x - p[ i ].x * p[ i-1 ].y ;   \r\n				// 计算叉积 \r\n				if ( !f && p[ i-1 ].x*p[ i ].x <= 0 && p[ i-1 ].y*p[i].y <= 0 ){printf("0\\n"); break ;}   // 点在边上 \r\n				t2 = p[ i ].x>=0 ? ( p[ i ].y>=0?0:3 ) : ( p[ i ].y>=0?1:2 ) ;   // 计算象限 \r\n				if ( t2 == ( t1 + 1 ) % 4 ) sum += 1 ;         	// 情况1 \r\n				else if ( t2 == ( t1 + 3 ) % 4 ) sum -= 1 ;   	// 情况2 \r\n				else if ( t2 == ( t1 + 2 ) % 4 )              // 情况3 \r\n				{                                             \r\n					if ( f > 0 ) sum += 2 ; else sum -= 2 ; \r\n				} \r\n				t1 = t2 ; \r\n			} \r\n			if ( i<=n || sum ) printf( "1\\n" ) ; else printf( \r\n				"-1\\n" ) ; \r\n			for ( i = 0 ; i <= n ; i ++ ) p[ i ].x += t.x , p[i].y += t.y ;       // 恢复坐标 \r\n		} \r\n	} \r\n	return 0; \r\n}', 'Main.c:4:37: error: variably modified ''p'' at file scope\r\nMain.c: In function ''main'':\r\nMain.c:9:2: error: ''point'' undeclared (first use in this function)\r\nMain.c:9:2: note: each undeclared identifier is reported only once for each function it appears in\r\nMain.c:9:8: error: expected '';'' before ''t''\r\nMain.c:19:22: error: ''t'' undeclared (first use in this function)\r\n', 0, 0, 2, 1, '2011-01-08 22:47:01', '0001-01-01 00:00:00'),
(1239, 12, 379, 7, '#include<stdio.h>\r\n#include<string.h>\r\nint n,p,c,l[801][801],cow[501],a[801][801],q[641601],f,e,dis[801],ans;\r\nbool flag[801];\r\n\r\nvoid spfa(int s){\r\n	int st,i,total = 0;\r\n	flag[s] = true;\r\n	while(f <= e)\r\n	{\r\n		st = q[f];\r\n		for(i = 1; i <= l[st][0]; ++ i)\r\n		{\r\n			if(dis[st] + a[st][l[st][i]] < dis[l[st][i]])\r\n			{\r\n				dis[l[st][i]] =  dis[st] + a[st][l[st][i]];\r\n				if(!flag[l[st][i]])\r\n				{\r\n					++ e;\r\n					q[e] = l[st][i];\r\n					flag[l[st][i]] = true;\r\n                }\r\n             }\r\n        }\r\n		flag[st] = false;\r\n		++ f;\r\n     }\r\n	for(i = 1; i <= n; ++ i)\r\n		total += dis[cow[i]];\r\n	if(total < ans)\r\n		ans = total;\r\n}\r\n\r\nint main(){\r\n    int i,j,x,y,z;\r\n    while(scanf("%d%d%d",&n,&p,&c) == 3){\r\n		ans = 0x7FFFFFFF;\r\n		for(i = 1; i <= n; ++ i)\r\n			scanf("%d",&cow[i]);\r\n		for(i = 1; i <= c; ++ i)\r\n		{\r\n			scanf("%d%d%d",&x,&y,&z);\r\n			++ l[x][0];\r\n			a[x][y] = z;\r\n			l[x][l[x][0]] = y; \r\n			++ l[y][0];\r\n			a[y][x] = z; \r\n			l[y][l[y][0]] = x;\r\n		} \r\n		for(i = 1; i <= p; ++ i)\r\n		{\r\n			f = 1; \r\n			e = 1; \r\n			q[1] = i; \r\n			memset(dis,0x7F,sizeof(dis));  \r\n			memset(flag,0,sizeof(flag));\r\n			dis[i] = 0;  \r\n			spfa(i); \r\n		}  \r\n		printf("%d\\n",ans);  	\r\n	}\r\n	\r\n	return 0;\r\n}', 'Main.c:4:6: error: expected ''='', '','', '';'', ''asm'' or ''__attribute__'' before ''flag''\r\nMain.c: In function ''spfa'':\r\nMain.c:8:2: error: ''flag'' undeclared (first use in this function)\r\nMain.c:8:2: note: each undeclared identifier is reported only once for each function it appears in\r\nMain.c:8:12: error: ''true'' undeclared (first use in this function)\r\nMain.c:25:14: error: ''false'' undeclared (first use in this function)\r\nMain.c: In function ''main'':\r\nMain.c:56:11: error: ''flag'' undeclared (first use in t', 0, 0, 2, 1, '2011-01-08 22:48:26', '0001-01-01 00:00:00'),
(1240, 12, 404, 9, '#include<stdio.h>\r\ndouble * GG()\r\n{\r\n       double Mod[2][6];\r\n       double (*M)[6];\r\n       M=Mod;\r\n       Mod[0][0]=1;Mod[1][0]=12;\r\n       Mod[0][1]=2;Mod[1][1]=11;\r\n       Mod[0][2]=3;Mod[1][2]=10;\r\n       Mod[0][3]=4;Mod[1][3]=9;\r\n       Mod[0][4]=5;Mod[1][4]=8;\r\n       Mod[0][5]=6;Mod[1][5]=7; \r\n      return M;   \r\n}\r\n\r\n\r\n\r\nmain()\r\n{\r\n    double (*p)[6];                                   \r\n    p=GG();\r\n    printf("%lf",*(*(p+1)+2));\r\n    printf("%lf",p[0][2]);\r\n   \r\n}\r\n', '', 0, 253952, 4, 1, '2011-01-08 22:49:34', '0001-01-01 00:00:00'),
(1241, 39, 1, 0, '#include <iostream>\r\nusing namespace std;\r\nint  main()\r\n{\r\n    int a,b;\r\n    cin >> a >> b;\r\n    cout << a+b << endl;\r\n    return 0;\r\n}', 'Main.c:1:20: fatal error: iostream: No such file or directory\r\ncompilation terminated.\r\n', 0, 0, 2, 1, '2011-01-09 00:04:22', '0001-01-01 00:00:00'),
(1242, 39, 1, 0, '#include <iostream>\r\nusing namespace std;\r\nint  main()\r\n{\r\n    int a,b;\r\n    cin >> a >> b;\r\n    cout << a+b << endl;\r\n    return 0;\r\n}', '', 0, 364544, 3, 2, '2011-01-09 00:04:35', '0001-01-01 00:00:00'),
(1243, 39, 1, 0, '#include <iostream>\r\nusing namespace std;\r\nint  main()\r\n{\r\n    int a,b;\r\n    cin>>a>> b;\r\n    cout<<a+b<<endl;\r\n    return 0;\r\n}', '', 0, 360448, 3, 2, '2011-01-09 00:07:20', '0001-01-01 00:00:00'),
(1244, 39, 1, 0, '#include <iostream>\r\nusing namespace std;\r\n\r\nint main(){\r\n    int a,b;\r\n    cin>>a>>b;\r\n    cout<<a+b<<endl;\r\n    return 0;\r\n}', '', 0, 364544, 3, 2, '2011-01-09 00:09:31', '0001-01-01 00:00:00'),
(1245, 39, 1, 0, '#include <iostream>\r\nusing namespace std;\r\n\r\nint main(){\r\n    int a,b;\r\n    cin>>a>>b;\r\n    cout<<a+b;\r\n    return 0;\r\n}', '', 0, 364544, 1, 2, '2011-01-09 00:10:45', '0001-01-01 00:00:00'),
(1246, 39, 2, 0, '#include <iostream>\r\nusing namespace std;\r\n\r\nint main(){\r\n    int a=0,b=0;\r\n    char c;\r\n    //bool f=0;\r\n    while(cin>>a>>c>>b){\r\n        if(a==0&&b==0) {break;}\r\n        //if(f) cout<<endl; //控制换行 \r\n        if(a<7) cout<<10;\r\n        else if(a>8) cout<<0;\r\n        else if(a==7){\r\n            if(b==1) cout<<10;\r\n            else if(b<=3) cout<<9;\r\n            else if(b<=6) cout<<8;\r\n            else if(b<=10) cout<<7;\r\n            else if(b<=15) cout<<6;\r\n            else if(b<=21) cout<<5;\r\n            else if(b<=28) cout<<4;    \r\n        }\r\n        else if(a==8){\r\n            if(b<=5) cout<<3;\r\n            else if(b<=14) cout<<2;\r\n            else if(b<=24) cout<<1;\r\n            else cout<<0;   \r\n        }\r\n        cout<<endl;//if(!f) f=1;\r\n    }\r\n    return 0;\r\n}', '', 0, 364544, 4, 2, '2011-01-09 00:36:19', '0001-01-01 00:00:00'),
(1247, 39, 2, 0, '#include <iostream>\r\nusing namespace std;\r\n\r\nint main(){\r\n    int a=0,b=0;\r\n    char c;\r\n    while(cin>>a>>c>>b){\r\n        if(a==0&&b==0) {break;}\r\n         if(a<7) cout<<10;\r\n        else if(a>8) cout<<0;\r\n        else if(a==7){\r\n            if(b==1) cout<<10;\r\n            else if(b<=3) cout<<9;\r\n            else if(b<=6) cout<<8;\r\n            else if(b<=10) cout<<7;\r\n            else if(b<=15) cout<<6;\r\n            else if(b<=21) cout<<5;\r\n            else if(b<=28) cout<<4; \r\n            else cout<<3;   \r\n        }\r\n        else if(a==8){\r\n            if(b<=5) cout<<3;\r\n            else if(b<=14) cout<<2;\r\n            else if(b<=24) cout<<1;\r\n            else cout<<0;   \r\n        }\r\n        cout<<endl;\r\n    }\r\n    return 0;\r\n}', '', 0, 364544, 1, 2, '2011-01-09 00:46:27', '0001-01-01 00:00:00'),
(1248, 39, 122, 0, '#include<iostream>\r\nusing namespace std;\r\nint main()\r\n{\r\nint a,b;\r\nwhile(cin>>a>>b){\r\n    cout<<a+b<<endl;                 \r\n}\r\nreturn 0;\r\n}', '', 0, 364544, 1, 2, '2011-01-09 01:42:33', '0001-01-01 00:00:00'),
(1249, 39, 403, 0, '#include <stdio.h>\r\n#include<iostream>\r\nusing namespace std;\r\nint main()\r\n{ \r\n    int n;\r\n    while(cin >> n)\r\n    {\r\n        int a[10000]; //每个元素放5位的数字，也就是可以放50000位，因为10000！有35660位\r\n        a[0]=1;    //特殊的，输入0时，答案为1, \r\n        int t = 0; //标记一个数字在被拆分后放在了数组的几个位置 \r\n        for(int i=1; i<=n; ++i){\r\n         \r\n            int c = 0;  //表示进位，如362880，大于100000了，进位为3，即c=3 \r\n            for(int j = 0; j <= t; ++j)\r\n            {\r\n                a[j] = a[j]*i + c;\r\n                c = a[j] / 100000;//if > 100000了时 \r\n                a[j] %= 100000;\r\n            }  \r\n            if(c!=0)  // 如果有进位\r\n            {\r\n               t++;\r\n               a[t] = c;\r\n            }\r\n        }\r\n        //输出 \r\n        cout << a[t];\r\n        for(int i = t-1; i >= 0; --i){\r\n           printf("%05d",a[i]);}\r\n        cout << endl;\r\n   }\r\n        return 0;\r\n}', '', 546, 368640, 1, 2, '2011-01-09 01:51:12', '0001-01-01 00:00:00'),
(1250, 39, 316, 0, '#include<iostream>\r\nusing namespace std;\r\nint main()\r\n{ \r\n    int n;\r\n    int a1[1000]={0},a2[1000]={0};\r\n    while(cin >> n)\r\n    {\r\n        int cnt=0;\r\n        if(n==0) break;\r\n        for(int i=0;i<n;i++){\r\n            cin>>a1[i]; \r\n        }\r\n        for(int i=0;i<n;i++){\r\n            cin>>a2[i]; \r\n        }\r\n        for(int i=0;i<n;i++){\r\n            if(a1[i]==a2[i]) continue;\r\n            a1[i]>a2[i]?cnt++:cnt--;\r\n        }\r\n        if(cnt>0) cout<<"YES"<<endl;\r\n        else cout<<"NO"<<endl;\r\n    }\r\n        return 0;\r\n}', '', 0, 360448, 4, 2, '2011-01-09 02:06:49', '0001-01-01 00:00:00'),
(1251, 39, 44, 0, '#include <iostream>\r\n#include <stdio.h>\r\nusing namespace std;\r\n\r\nint main(){\r\n    char c[100];\r\n    while(cin.getline(c,100)){\r\n    for(int i=0;i<100;i++){\r\n        if(c[i]==''\\0'') break;\r\n        cout<<(char)((int)c[i]+4);\r\n    }\r\n    cout<<endl;\r\n}\r\n    return 0;   \r\n}', '', 0, 360448, 4, 2, '2011-01-09 02:54:59', '0001-01-01 00:00:00'),
(1252, 39, 44, 0, '#include <iostream>\r\n#include <stdio.h>\r\nusing namespace std;\r\n\r\nint main(){\r\n    char c[100];\r\n    cin.getline(c,100);\r\n    for(int i=0;i<100;i++){\r\n        if(c[i]==''\\0'') break;\r\n        cout<<(char)((int)c[i]+4);\r\n    }\r\n    return 0;   \r\n}', '', 0, 364544, 4, 2, '2011-01-09 02:56:07', '0001-01-01 00:00:00'),
(1253, 39, 44, 0, '#include <iostream>\r\n#include <stdio.h>\r\nusing namespace std;\r\n\r\nint main(){\r\n    char a1,a2,a3,a4,a5;\r\n    cin>>a1>>a2>>a3>>a4>>a5;\r\n    a1+=4;\r\n    a2+=4;\r\n    a3+=4;\r\n    a4+=4;\r\n    a5+=4;\r\n    cout<<a1<<a2<<a3<<a4<<a5;\r\n    system("pause");\r\n    return 0;   \r\n}', 'Main.cpp: In function ''int main()'':\r\nMain.cpp:14:19: error: ''system'' was not declared in this scope\r\n', 0, 0, 2, 2, '2011-01-09 03:02:11', '0001-01-01 00:00:00'),
(1254, 39, 44, 0, '#include <iostream>\r\n#include <stdio.h>\r\nusing namespace std;\r\n\r\nint main(){\r\n    char a1,a2,a3,a4,a5;\r\n    cin>>a1>>a2>>a3>>a4>>a5;\r\n    a1+=4;\r\n    a2+=4;\r\n    a3+=4;\r\n    a4+=4;\r\n    a5+=4;\r\n    cout<<a1<<a2<<a3<<a4<<a5;\r\n    return 0;   \r\n}', '', 0, 364544, 4, 2, '2011-01-09 03:02:25', '0001-01-01 00:00:00'),
(1255, 39, 44, 0, '#include <stdio.h>\r\nint main(){\r\nchar s[1024], *p, c;\r\nwhile (scanf("%s", s) == 1){\r\n   p = s;\r\n   while ((c=*p) != ''\\0''){\r\n    printf("%c", c+4);\r\n    ++p;\r\n   }\r\n   printf("\\n");\r\n}\r\nreturn 0;\r\n}', '', 0, 253952, 4, 2, '2011-01-09 03:06:41', '0001-01-01 00:00:00'),
(1256, 39, 319, 0, '#include<iostream>\r\nusing namespace std;\r\nlong StepCount[41];\r\nint StepNum;\r\nvoid initial()\r\n{\r\n int i=0;\r\n StepCount[1]=1;\r\n StepCount[2]=2;\r\n for(i=3;i<41;i++)\r\n  StepCount[i]=StepCount[i-1]+StepCount[i-2];\r\n}\r\n\r\n \r\nint main()\r\n{\r\n initial();\r\n while(cin>>StepNum,StepNum)\r\n {\r\n  cout<<StepCount[StepNum]<<endl;\r\n }\r\n return 0;\r\n}\r\n\r\n', '', 0, 360448, 1, 2, '2011-01-09 03:11:27', '0001-01-01 00:00:00'),
(1257, 39, 335, 2, '#include <iostream>\r\n#include <string>\r\nusing namespace std;\r\n\r\nint main(){\r\n    int n,m;\r\n    string a="",b="";\r\n    while(cin>>n>>m){\r\n    a="",b="";\r\n    if(n==0) a="0";\r\n    if(m==0) b="0";\r\n    for(int i=n;i;i>>=1){\r\n        a=a+(i%2?''1'':''0'');\r\n    }\r\n    for(int j=m;j;j>>=1){\r\n        b=b+(j%2?''1'':''0'');\r\n    }\r\n    \r\n    int cnt=0;\r\n    if(a.length()>b.length()){\r\n        for(int i=a.length()-1;i>=0;i--){\r\n            if(a[i]!=b[i]) cnt++;\r\n        }                      \r\n    }else{\r\n          for(int i=b.length()-1;i>=0;i--){\r\n            if(a[i]!=b[i]) cnt++;\r\n        } \r\n    }\r\n    cout<<cnt<<endl;\r\n}\r\n    return 0;\r\n       \r\n}', '', 100, 1265664, 5, 2, '2011-01-09 20:44:15', '0001-01-01 00:00:00'),
(1258, 39, 335, 2, '#include <iostream>\r\n#include <string>\r\nusing namespace std;\r\n\r\nint main(){\r\n    int n,m;\r\n    string a,b;\r\n    while(cin>>n>>m){\r\n    a="",b="";\r\n    if(n==0) a="0";\r\n    if(m==0) b="0";\r\n    for(int i=n;i;i>>=1){\r\n        a=a+(i%2?''1'':''0'');\r\n    }\r\n    for(int j=m;j;j>>=1){\r\n        b=b+(j%2?''1'':''0'');\r\n    }\r\n    \r\n    int cnt=0;\r\n    if(n>m){\r\n        for(int i=a.length()-1;i>=0;i--){\r\n            if(a[i]!=b[i]) cnt++;\r\n        }                      \r\n    }else{\r\n          for(int i=b.length()-1;i>=0;i--){\r\n            if(a[i]!=b[i]) cnt++;\r\n        } \r\n    }\r\n    printf("%d\\n",cnt);\r\n}\r\n    return 0;\r\n       \r\n}\r\n', 'Main.cpp: In function ''int main()'':\r\nMain.cpp:29:22: error: ''printf'' was not declared in this scope\r\n', 0, 0, 2, 2, '2011-01-09 20:51:11', '0001-01-01 00:00:00'),
(1259, 39, 335, 2, '#include <iostream>\r\n#include <string>\r\n#include <stdio.h>\r\nusing namespace std;\r\n\r\nint main(){\r\n    int n,m;\r\n    string a,b;\r\n    while(cin>>n>>m){\r\n    a="",b="";\r\n    if(n==0) a="0";\r\n    if(m==0) b="0";\r\n    for(int i=n;i;i>>=1){\r\n        a=a+(i%2?''1'':''0'');\r\n    }\r\n    for(int j=m;j;j>>=1){\r\n        b=b+(j%2?''1'':''0'');\r\n    }\r\n    \r\n    int cnt=0;\r\n    if(n>m){\r\n        for(int i=a.length()-1;i>=0;i--){\r\n            if(a[i]!=b[i]) cnt++;\r\n        }                      \r\n    }else{\r\n          for(int i=b.length()-1;i>=0;i--){\r\n            if(a[i]!=b[i]) cnt++;\r\n        } \r\n    }\r\n    printf("%d\\n",cnt);\r\n}\r\n        return 0;\r\n       \r\n}', '', 100, 1748992, 5, 2, '2011-01-09 20:52:15', '0001-01-01 00:00:00'),
(1260, 39, 335, 2, '#include <iostream>\r\n#include <string>\r\n#include <stdio.h>\r\nusing namespace std;\r\n\r\nint main(){\r\n    int n,m;\r\n    string a,b;\r\n    while(cin>>n>>m){\r\n    a="",b="";\r\n    if(n==0) a="0";\r\n    if(m==0) b="0";\r\n    for(int i=n;i;i>>=1){\r\n        a=a+(i&1?''1'':''0'');\r\n    }\r\n    for(int j=m;j;j>>=1){\r\n        b=b+(j&1?''1'':''0'');\r\n    }\r\n    \r\n    int cnt=0;\r\n    if(n>m){\r\n        for(int i=a.length()-1;i>=0;i--){\r\n            if(a[i]!=b[i]) cnt++;\r\n        }                      \r\n    }else{\r\n          for(int i=b.length()-1;i>=0;i--){\r\n            if(a[i]!=b[i]) cnt++;\r\n        } \r\n    }\r\n    printf("%d\\n",cnt);\r\n}\r\n    return 0;\r\n       \r\n}', '', 100, 1261568, 5, 2, '2011-01-09 20:56:16', '0001-01-01 00:00:00'),
(1261, 39, 335, 2, '#include <iostream>\r\n#include <bitset>\r\n#include <stdio.h>\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n	int i = 0, j = 0;\r\n	while(1){\r\n    	scanf("%d%d",&i,&j);\r\n    	i = i ^ j;\r\n    	int num = 0;\r\n    	while(i)\r\n    	{\r\n    		i &= (i - 1);\r\n    		num++;\r\n    	}\r\n    	cout << num << endl;\r\n    }\r\nreturn 0;\r\n}', '', 100, 360448, 5, 2, '2011-01-09 21:03:08', '0001-01-01 00:00:00'),
(1262, 39, 335, 2, '#include <iostream>\r\n#include <bitset>\r\n#include <stdio.h>\r\nusing namespace std;\r\nint countTable[256] = \r\n\r\n{ \r\n\r\n0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8 \r\n\r\n}; \r\n\r\nint Count(int v) \r\n\r\n{ \r\n   return countTable[v]; \r\n}\r\n\r\nint main()\r\n{\r\n	int i = 0, j = 0;\r\n	bool flag=1;\r\n	while(flag){\r\n    	scanf("%d%d",&i,&j);\r\n    	i = i ^ j;\r\n    	int num = 0;\r\n    	    	cout <<Count(i)<< endl;\r\n    }\r\n	}', '', 100, 368640, 5, 2, '2011-01-09 21:12:49', '0001-01-01 00:00:00'),
(1263, 39, 335, 2, '#include <iostream>\r\n#include <bitset>\r\n#include <stdio.h>\r\nusing namespace std;\r\nint countTable[256] = \r\n\r\n{ \r\n\r\n0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8 \r\n\r\n}; \r\n\r\nint Count(int v) \r\n\r\n{ \r\n   return countTable[v]; \r\n}\r\n\r\nint main()\r\n{\r\n	int i = 0, j = 0;\r\n	bool flag=1;\r\n	while(flag){\r\n    	scanf("%d%d",&i,&j);\r\n    	if(i==j==0) flag=0;\r\n    	i = i ^ j;\r\n    	int num = 0;\r\n    	    	cout <<Count(i)<< endl;\r\n    }\r\n	}', '', 0, 364544, 4, 2, '2011-01-09 21:31:17', '0001-01-01 00:00:00'),
(1264, 39, 335, 2, '#include <iostream>\r\n#include <bitset>\r\n#include <stdio.h>\r\nusing namespace std;\r\nint countTable[256] = \r\n\r\n{ \r\n\r\n0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8 \r\n\r\n}; \r\n\r\nint Count(int v) \r\n\r\n{ \r\n   return countTable[v]; \r\n}\r\n\r\nint main()\r\n{\r\n	int i = 0, j = 0;\r\n	while(scanf("%d%d",&i,&j)){\r\n    	i = i ^ j;\r\n    	cout <<Count(i)<< endl;\r\n    }\r\n	}', '', 100, 368640, 5, 2, '2011-01-09 21:34:47', '0001-01-01 00:00:00'),
(1265, 39, 335, 0, '#include <iostream>\r\n#include <bitset>\r\n#include <stdio.h>\r\nusing namespace std;\r\nint countTable[256] = \r\n{ \r\n0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8 \r\n}; \r\n\r\nint Count(int v) \r\n{ \r\n   return countTable[v]; \r\n}\r\n\r\nint main()\r\n{\r\n	int i = 0, j = 0;\r\n	while(cin>>i>>j){\r\n    	i = i ^ j;\r\n    	cout <<Count(i)<< endl;\r\n    }\r\n	}', '', 0, 364544, 4, 2, '2011-01-09 21:41:34', '0001-01-01 00:00:00'),
(1266, 39, 335, 0, '#include <iostream>\r\n#include <bitset>\r\n#include <stdio.h>\r\nusing namespace std;\r\n\r\n\r\nint main()\r\n{\r\n	int i = 0, j = 0;\r\n	while(cin>>i>>j){\r\n    	i = i ^ j;\r\n    	int num=0;\r\n    	while(i)\r\n	    {\r\n    		i &= (i - 1);\r\n    		num++;\r\n	    }\r\n	    cout<<num<<endl;\r\n\r\n    }\r\n	return 0;}', '', 100, 360448, 5, 2, '2011-01-09 21:45:38', '0001-01-01 00:00:00'),
(1267, 39, 335, 0, '#include <iostream>\r\n#include <bitset>\r\n#include <stdio.h>\r\n#define POW(c) (1<<(c))\r\n#define MASK(c) (((unsigned long)-1) / (POW(POW(c)) + 1))\r\n#define ROUND(n, c) (((n) & MASK(c)) + ((n) >> POW(c) & MASK(c)))\r\nusing namespace std;\r\n\r\n\r\n\r\nint bit_count(unsigned int n)\r\n{\r\nn = ROUND(n, 0);\r\nn = ROUND(n, 1);\r\nn = ROUND(n, 2);\r\nn = ROUND(n, 3);\r\nn = ROUND(n, 4);\r\nreturn n;\r\n}\r\n\r\nint main()\r\n{\r\n	int i = 0, j = 0;\r\n	while(cin>>i>>j){\r\n    	i = i ^ j;\r\n    	cout<<bit_count(i)<<endl;\r\n\r\n    }\r\n	}', '', 100, 360448, 5, 2, '2011-01-09 21:50:52', '0001-01-01 00:00:00'),
(1268, 39, 335, 0, '#include <iostream>\r\n#include <stdio.h>\r\nusing namespace std;\r\n\r\nint countTable[256] = \r\n\r\n{ \r\n\r\n0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8 \r\n\r\n}; \r\n\r\nint Count(int v) \r\n\r\n{ \r\n       return countTable[v]; \r\n} \r\n\r\n\r\n\r\nint main()\r\n{\r\n	int i = 0, j = 0;\r\n	while(cin>>i>>j){\r\n    	i^=j;\r\n    	cout<<Count(i)<<endl;\r\n    }\r\n	}', '', 0, 364544, 4, 2, '2011-01-09 21:54:31', '0001-01-01 00:00:00'),
(1269, 39, 335, 0, '#include <iostream>\r\n#include <stdio.h>\r\nusing namespace std;\r\n\r\nint count_bits(unsigned long n)\r\n{\r\n//0xAAAAAAAA，0x55555555分别是以“1位”为单位提取奇偶位\r\nn = ((n & 0xAAAAAAAA) >> 1) + (n & 0x55555555);\r\n\r\n//0xCCCCCCCC，0x33333333分别是以“2位”为单位提取奇偶位\r\nn = ((n & 0xCCCCCCCC) >> 2) + (n & 0x33333333);\r\n\r\n//0xF0F0F0F0，0x0F0F0F0F分别是以“4位”为单位提取奇偶位\r\nn = ((n & 0xF0F0F0F0) >> 4) + (n & 0x0F0F0F0F);\r\n\r\n//0xFF00FF00，0x00FF00FF分别是以“8位”为单位提取奇偶位\r\nn = ((n & 0xFF00FF00) >> 8) + (n & 0x00FF00FF);\r\n\r\n//0xFFFF0000，0x0000FFFF分别是以“16位”为单位提取奇偶位\r\nn = ((n & 0xFFFF0000) >> 16) + (n & 0x0000FFFF);\r\n\r\nreturn n;\r\n}\r\n\r\n\r\nint main()\r\n{\r\n	int i = 0, j = 0;\r\n	while(cin>>i>>j){\r\n    	i^=j;\r\n    	//cout<<i<<endl;\r\n    	cout<<count_bits(i)<<endl;\r\n    }\r\n	//system("pause");\r\n}', '', 100, 364544, 5, 2, '2011-01-09 22:00:36', '0001-01-01 00:00:00'),
(1270, 39, 335, 0, '#include <iostream>\r\n#include <stdio.h>\r\nusing namespace std;\r\n\r\nint countTable[256] = \r\n\r\n{ \r\n\r\n0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8 \r\n\r\n}; \r\n\r\n\r\nint findone(int n){ \r\n  int i=0;\r\n  for(;n>0;n>>=8){\r\n    i+=countTable[n&255]; }\r\n  return i; \r\n} \r\n\r\n\r\n\r\nint main()\r\n{\r\n	int i = 0, j = 0;\r\n	while(cin>>i>>j){\r\n    	i^=j;\r\n    	cout<<i<<endl;\r\n    	cout<<findone(i)<<endl;\r\n    }\r\n	}', '', 0, 368640, 4, 2, '2011-01-09 22:17:14', '0001-01-01 00:00:00'),
(1271, 39, 335, 0, '#include <iostream>\r\n#include <bitset>\r\n#include <stdio.h>\r\nusing namespace std;\r\n\r\nint countTable[256] = \r\n\r\n{ \r\n\r\n0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8 \r\n\r\n}; \r\n\r\n\r\nint findone(int n){ \r\n  int i=0;\r\n  for(;n>0;n>>=8){\r\n    i+=countTable[n&255]; }\r\n  return i; \r\n} \r\n\r\nlong countone2(unsigned long x) \r\n{ \r\nbitset<32> bb(x); \r\nreturn bb.count(); \r\n\r\n} \r\n\r\n\r\nint main()\r\n{\r\n	long i = 0, j = 0;\r\n	while(cin>>i>>j){\r\n    	i^=j;\r\n    	cout<<countone2(i)<<endl;\r\n    }\r\n	}', '', 100, 368640, 5, 2, '2011-01-09 22:24:23', '0001-01-01 00:00:00'),
(1272, 39, 335, 0, '#include <iostream>\r\n#include <bitset>\r\n#include <stdio.h>\r\nusing namespace std;\r\n\r\nint countTable[256] = \r\n\r\n{ \r\n\r\n0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8 \r\n\r\n}; \r\n\r\n\r\nint findone(int n){ \r\n  int i=0;\r\n  for(;n>0;n>>=8){\r\n    i+=countTable[n&255]; }\r\n  return i; \r\n} \r\n\r\n\r\n\r\nint main()\r\n{\r\n	int i = 0, j = 0;\r\n	while(cin>>i>>j){\r\n    	i^=j;\r\n    	cout<<findone(i)<<endl;\r\n    }\r\n	}', '', 0, 364544, 4, 2, '2011-01-09 22:25:52', '0001-01-01 00:00:00'),
(1273, 10, 374, 5, '#include<stdio.h>\r\n#define N 1000\r\nint main()\r\n{\r\n int i,start,loopsize,size,sum,max,count;\r\n    int max_start,max_end;\r\n int shuzu[N];\r\n bool fushu;\r\n scanf("%d",&loopsize);\r\n for(count=0;count !=loopsize;count++)\r\n {\r\n scanf("%d",&size);\r\n for(i = 0 ; i != size ;++i)\r\n  scanf("%d",&shuzu[i]);\r\n fushu = true;\r\n sum = start = max_start = max_end = 0;\r\n for(i = 0 ; i != size ;++i)\r\n  if(shuzu[i]>0){\r\n   fushu = false;\r\n   break;}\r\n if(fushu)\r\n {\r\n  max = shuzu[0];\r\n  for(i=1;i!=size;++i)\r\n   if(shuzu[i]>max)\r\n   {\r\n    max_start=max_end = i;\r\n    max = shuzu[i];\r\n   }\r\n }\r\n else{\r\n  i = 0;\r\n  max =-1;\r\n  while(i != size)\r\n  {\r\n   \r\n   sum += shuzu[i];\r\n   if(sum < 0)\r\n   {\r\n    start = i+1;\r\n    sum = 0;\r\n   }\r\n   if(sum > max)\r\n   {\r\n    max = sum;\r\n    max_start = start;\r\n    max_end = i;\r\n   }\r\n   ++i;\r\n  }\r\n }//end else\r\n printf("Case %d:\\n",count+1);\r\n printf("%d %d %d\\n",max,max_start+1,max_end+1);\r\n if(count+1 !=loopsize)\r\n  printf("\\n");\r\n }\r\n getchar();\r\n getchar();\r\n return 0;\r\n}', 'Main.c: In function ''main'':\r\nMain.c:8:2: error: ''bool'' undeclared (first use in this function)\r\nMain.c:8:2: note: each undeclared identifier is reported only once for each function it appears in\r\nMain.c:8:7: error: expected '';'' before ''fushu''\r\nMain.c:15:2: error: ''fushu'' undeclared (first use in this function)\r\nMain.c:15:10: error: ''true'' undeclared (first use in this function)\r\nMain.c:19:12: error: ''false'' undeclared (first use in this function)\r\n', 0, 0, 2, 1, '2011-01-10 10:12:48', '0001-01-01 00:00:00'),
(1274, 10, 374, 5, '#include<stdio.h>\r\n#define N 1000\r\nint main()\r\n{\r\n int i,start,loopsize,size,sum,max,count;\r\n    int max_start,max_end;\r\n int shuzu[N];\r\n int fushu;\r\n scanf("%d",&loopsize);\r\n for(count=0;count !=loopsize;count++)\r\n {\r\n scanf("%d",&size);\r\n for(i = 0 ; i != size ;++i)\r\n  scanf("%d",&shuzu[i]);\r\n fushu = 1;\r\n sum = start = max_start = max_end = 0;\r\n for(i = 0 ; i != size ;++i)\r\n  if(shuzu[i]>0){\r\n   fushu = 0;\r\n   break;}\r\n if(fushu)\r\n {\r\n  max = shuzu[0];\r\n  for(i=1;i!=size;++i)\r\n   if(shuzu[i]>max)\r\n   {\r\n    max_start=max_end = i;\r\n    max = shuzu[i];\r\n   }\r\n }\r\n else{\r\n  i = 0;\r\n  max =-1;\r\n  while(i != size)\r\n  {\r\n   \r\n   sum += shuzu[i];\r\n   if(sum < 0)\r\n   {\r\n    start = i+1;\r\n    sum = 0;\r\n   }\r\n   if(sum > max)\r\n   {\r\n    max = sum;\r\n    max_start = start;\r\n    max_end = i;\r\n   }\r\n   ++i;\r\n  }\r\n }//end else\r\n printf("Case %d:\\n",count+1);\r\n printf("%d %d %d\\n",max,max_start+1,max_end+1);\r\n if(count+1 !=loopsize)\r\n  printf("\\n");\r\n }\r\n return 0;\r\n}', '', 0, 258048, 7, 1, '2011-01-10 10:14:05', '0001-01-01 00:00:00'),
(1275, 10, 376, 5, '#include<stdio.h>\r\n#include<algorithm>\r\n#define N 1000\r\nbool cmp(int a,int b)\r\n{\r\n return a>b;\r\n}\r\nint main()\r\n{\r\n int zero_size,positive_size,negative_size,total_size;\r\n    int zero[N],positive[N],negative[N];\r\n int temp,i,sum;\r\n int count,size;\r\n scanf("%d",&size);\r\n    for(count =0;count != size;count++)\r\n {\r\n scanf("%d",&total_size);\r\n zero_size = positive_size = negative_size = 0;\r\n sum =1;\r\n for(i = 0; i != total_size;i++)\r\n {\r\n  scanf("%d",&temp);\r\n  if(0 == temp)\r\n  {\r\n   zero[zero_size] = 0;\r\n   ++zero_size;\r\n  }else if(temp > 0)\r\n  {\r\n   positive[positive_size] = temp;\r\n   ++positive_size;\r\n  }else\r\n  {\r\n   negative[negative_size] = temp;\r\n   ++negative_size;\r\n  }\r\n }//end for\r\n if(zero_size > 1)\r\n  printf("0\\n");\r\n else if(1 == zero_size)\r\n {\r\n  if(negative_size %2 == 1)\r\n   printf("0\\n");\r\n  else\r\n  {\r\n   if(positive_size != 0){\r\n   for(i = 0;i != negative_size;i++)\r\n   sum *= negative[i];\r\n   for(i = 1;i != positive_size;i++)\r\n    sum *= positive[i];\r\n   printf("%d\\n",sum);\r\n   }\r\n   else\r\n   {\r\n   for(i = 0;i != negative_size;i++)\r\n       sum *= negative[i];\r\n   printf("%d\\n",sum);\r\n   }\r\n  }\r\n }else\r\n {\r\n  if(negative_size %2 == 1)\r\n  {\r\n   if(negative_size)\r\n    std::sort(negative,negative + negative_size,cmp);\r\n   for(i = 1;i != negative_size;i++)\r\n    sum *= negative[i];\r\n   for(i = 0;i != positive_size;++i)\r\n    sum *= positive[i];\r\n   printf("%d\\n",sum);\r\n  }else\r\n  {\r\n   if(positive_size != 0)\r\n   {\r\n    if(positive_size != 1)\r\n    {\r\n     std::sort(positive,positive + positive_size,cmp);\r\n     for(i = 1;i != positive_size;++i)\r\n      sum *= positive[i];\r\n     for(i = 0;i != negative_size;i++)\r\n     sum *= negative[i];\r\n     printf("%d\\n",sum);\r\n    }\r\n    else{\r\n     for(i = 0;i != negative_size;i++)\r\n      sum *= negative[i];\r\n     printf("%d\\n",sum);\r\n    }\r\n   }else\r\n   {\r\n    std::sort(negative,negative + negative_size,cmp);\r\n    for(i = 0;i != negative_size-1;i++)\r\n     sum *= negative[i];\r\n    printf("%d\\n",sum);\r\n   }\r\n  }\r\n }//end if else if else\r\n }//end for size\r\n return 0;', 'Main.c:2:20: fatal error: algorithm: No such file or directory\r\ncompilation terminated.\r\n', 0, 0, 2, 1, '2011-01-10 10:14:56', '0001-01-01 00:00:00'),
(1276, 10, 376, 5, '#include<stdio.h>\r\n#include<algorithm>\r\n#define N 1000\r\nbool cmp(int a,int b)\r\n{\r\n return a>b;\r\n}\r\nint main()\r\n{\r\n int zero_size,positive_size,negative_size,total_size;\r\n    int zero[N],positive[N],negative[N];\r\n int temp,i,sum;\r\n int count,size;\r\n scanf("%d",&size);\r\n    for(count =0;count != size;count++)\r\n {\r\n scanf("%d",&total_size);\r\n zero_size = positive_size = negative_size = 0;\r\n sum =1;\r\n for(i = 0; i != total_size;i++)\r\n {\r\n  scanf("%d",&temp);\r\n  if(0 == temp)\r\n  {\r\n   zero[zero_size] = 0;\r\n   ++zero_size;\r\n  }else if(temp > 0)\r\n  {\r\n   positive[positive_size] = temp;\r\n   ++positive_size;\r\n  }else\r\n  {\r\n   negative[negative_size] = temp;\r\n   ++negative_size;\r\n  }\r\n }//end for\r\n if(zero_size > 1)\r\n  printf("0\\n");\r\n else if(1 == zero_size)\r\n {\r\n  if(negative_size %2 == 1)\r\n   printf("0\\n");\r\n  else\r\n  {\r\n   if(positive_size != 0){\r\n   for(i = 0;i != negative_size;i++)\r\n   sum *= negative[i];\r\n   for(i = 1;i != positive_size;i++)\r\n    sum *= positive[i];\r\n   printf("%d\\n",sum);\r\n   }\r\n   else\r\n   {\r\n   for(i = 0;i != negative_size;i++)\r\n       sum *= negative[i];\r\n   printf("%d\\n",sum);\r\n   }\r\n  }\r\n }else\r\n {\r\n  if(negative_size %2 == 1)\r\n  {\r\n   if(negative_size)\r\n    std::sort(negative,negative + negative_size,cmp);\r\n   for(i = 1;i != negative_size;i++)\r\n    sum *= negative[i];\r\n   for(i = 0;i != positive_size;++i)\r\n    sum *= positive[i];\r\n   printf("%d\\n",sum);\r\n  }else\r\n  {\r\n   if(positive_size != 0)\r\n   {\r\n    if(positive_size != 1)\r\n    {\r\n     std::sort(positive,positive + positive_size,cmp);\r\n     for(i = 1;i != positive_size;++i)\r\n      sum *= positive[i];\r\n     for(i = 0;i != negative_size;i++)\r\n     sum *= negative[i];\r\n     printf("%d\\n",sum);\r\n    }\r\n    else{\r\n     for(i = 0;i != negative_size;i++)\r\n      sum *= negative[i];\r\n     printf("%d\\n",sum);\r\n    }\r\n   }else\r\n   {\r\n    std::sort(negative,negative + negative_size,cmp);\r\n    for(i = 0;i != negative_size-1;i++)\r\n     sum *= negative[i];\r\n    printf("%d\\n",sum);\r\n   }\r\n  }\r\n }//end if else if else\r\n }//end for size\r\n return 0;', 'Main.cpp: In function ''int main()'':\r\nMain.cpp:98:10: error: expected ''}'' at end of input\r\n', 0, 0, 2, 2, '2011-01-10 10:15:32', '0001-01-01 00:00:00'),
(1277, 10, 376, 5, '#include<stdio.h>\r\n#include<algorithm>\r\n#define N 1000\r\nbool cmp(int a,int b)\r\n{\r\n return a>b;\r\n}\r\nint main()\r\n{\r\n int zero_size,positive_size,negative_size,total_size;\r\n    int zero[N],positive[N],negative[N];\r\n int temp,i,sum;\r\n int count,size;\r\n scanf("%d",&size);\r\n    for(count =0;count != size;count++)\r\n {\r\n scanf("%d",&total_size);\r\n zero_size = positive_size = negative_size = 0;\r\n sum =1;\r\n for(i = 0; i != total_size;i++)\r\n {\r\n  scanf("%d",&temp);\r\n  if(0 == temp)\r\n  {\r\n   zero[zero_size] = 0;\r\n   ++zero_size;\r\n  }else if(temp > 0)\r\n  {\r\n   positive[positive_size] = temp;\r\n   ++positive_size;\r\n  }else\r\n  {\r\n   negative[negative_size] = temp;\r\n   ++negative_size;\r\n  }\r\n }//end for\r\n if(zero_size > 1)\r\n  printf("0\\n");\r\n else if(1 == zero_size)\r\n {\r\n  if(negative_size %2 == 1)\r\n   printf("0\\n");\r\n  else\r\n  {\r\n   if(positive_size != 0){\r\n   for(i = 0;i != negative_size;i++)\r\n   sum *= negative[i];\r\n   for(i = 1;i != positive_size;i++)\r\n    sum *= positive[i];\r\n   printf("%d\\n",sum);\r\n   }\r\n   else\r\n   {\r\n   for(i = 0;i != negative_size;i++)\r\n       sum *= negative[i];\r\n   printf("%d\\n",sum);\r\n   }\r\n  }\r\n }else\r\n {\r\n  if(negative_size %2 == 1)\r\n  {\r\n   if(negative_size)\r\n    std::sort(negative,negative + negative_size,cmp);\r\n   for(i = 1;i != negative_size;i++)\r\n    sum *= negative[i];\r\n   for(i = 0;i != positive_size;++i)\r\n    sum *= positive[i];\r\n   printf("%d\\n",sum);\r\n  }else\r\n  {\r\n   if(positive_size != 0)\r\n   {\r\n    if(positive_size != 1)\r\n    {\r\n     std::sort(positive,positive + positive_size,cmp);\r\n     for(i = 1;i != positive_size;++i)\r\n      sum *= positive[i];\r\n     for(i = 0;i != negative_size;i++)\r\n     sum *= negative[i];\r\n     printf("%d\\n",sum);\r\n    }\r\n    else{\r\n     for(i = 0;i != negative_size;i++)\r\n      sum *= negative[i];\r\n     printf("%d\\n",sum);\r\n    }\r\n   }else\r\n   {\r\n    std::sort(negative,negative + negative_size,cmp);\r\n    for(i = 0;i != negative_size-1;i++)\r\n     sum *= negative[i];\r\n    printf("%d\\n",sum);\r\n   }\r\n  }\r\n }//end if else if else\r\n }//end for size\r\n return 0;\r\n}', '', 0, 258048, 7, 2, '2011-01-10 10:16:36', '0001-01-01 00:00:00'),
(1278, 10, 3, 1, 'asdf', 'Main.c:1:1: error: expected ''='', '','', '';'', ''asm'' or ''__attribute__'' at end of input\r\n', 0, 0, 2, 1, '2011-01-10 10:20:45', '0001-01-01 00:00:00'),
(1279, 10, 335, 2, 'fghfghfh', 'Main.c:1:1: error: expected ''='', '','', '';'', ''asm'' or ''__attribute__'' at end of input\r\n', 0, 0, 2, 1, '2011-01-10 10:21:10', '0001-01-01 00:00:00'),
(1280, 10, 335, 2, '#include \r\n#define POW(c) (1<<(c))\r\n#define MASK(c) (((unsigned long)-1) / (POW(POW(c)) + 1))\r\n#define ROUND(n, c) (((n) & MASK(c)) + ((n) >> POW(c) & MASK(c)))\r\n\r\nint bit_count(unsigned int n)\r\n{\r\nn = ROUND(n, 0);\r\nn = ROUND(n, 1);\r\nn = ROUND(n, 2);\r\nn = ROUND(n, 3);\r\nn = ROUND(n, 4);\r\nreturn n;\r\n}\r\n\r\nint main()\r\n{\r\n	int num1,num2;\r\n	while(2 == scanf("%d%d",&num1,&num2) )\r\n	{\r\n		printf("%d\\n",bit_count(num1^num2));\r\n	}\r\n	return 0;\r\n}\r\n', 'Main.c:1:10: error: #include expects "FILENAME" or <FILENAME>\r\nMain.c: In function ''main'':\r\nMain.c:19:13: warning: incompatible implicit declaration of built-in function ''scanf''\r\nMain.c:21:3: warning: incompatible implicit declaration of built-in function ''printf''\r\n', 0, 0, 2, 1, '2011-01-10 10:21:52', '0001-01-01 00:00:00'),
(1281, 10, 335, 2, '#include <stdio.h>\r\n#define POW(c) (1<<(c))\r\n#define MASK(c) (((unsigned long)-1) / (POW(POW(c)) + 1))\r\n#define ROUND(n, c) (((n) & MASK(c)) + ((n) >> POW(c) & MASK(c)))\r\n\r\nint bit_count(unsigned int n)\r\n{\r\nn = ROUND(n, 0);\r\nn = ROUND(n, 1);\r\nn = ROUND(n, 2);\r\nn = ROUND(n, 3);\r\nn = ROUND(n, 4);\r\nreturn n;\r\n}\r\n\r\nint main()\r\n{\r\n	int num1,num2;\r\n	while(2 == scanf("%d%d",&num1,&num2) )\r\n	{\r\n		printf("%d\\n",bit_count(num1^num2));\r\n	}\r\n	return 0;\r\n}\r\n', '', 62, 258048, 1, 1, '2011-01-10 10:22:27', '0001-01-01 00:00:00'),
(1282, 10, 374, 5, '#include<stdio.h>\r\n#define N 1000\r\nint main()\r\n{\r\n int i,start,loopsize,size,sum,max,count;\r\n    int max_start,max_end;\r\n int shuzu[N];\r\n int fushu;\r\n scanf("%d",&loopsize);\r\n for(count=0;count !=loopsize;count++)\r\n {\r\n scanf("%d",&size);\r\n for(i = 0 ; i != size ;++i)\r\n  scanf("%d",&shuzu[i]);\r\n fushu = 1;\r\n sum = start = max_start = max_end = 0;\r\n for(i = 0 ; i != size ;++i)\r\n  if(shuzu[i]>0){\r\n   fushu = 0;\r\n   break;}\r\n if(fushu)\r\n {\r\n  max = shuzu[0];\r\n  for(i=1;i!=size;++i)\r\n   if(shuzu[i]>max)\r\n   {\r\n    max_start=max_end = i;\r\n    max = shuzu[i];\r\n   }\r\n }\r\n else{\r\n  i = 0;\r\n  max =-1;\r\n  while(i != size)\r\n  {\r\n   \r\n   sum += shuzu[i];\r\n   if(sum < 0)\r\n   {\r\n    start = i+1;\r\n    sum = 0;\r\n   }\r\n   if(sum > max)\r\n   {\r\n    max = sum;\r\n    max_start = start;\r\n    max_end = i;\r\n   }\r\n   ++i;\r\n  }\r\n }//end else\r\n printf("Case %d:\\n",count+1);\r\n printf("%d %d %d\\n",max,max_start+1,max_end+1);\r\n if(count+1 !=loopsize)\r\n  printf("\\n");\r\n }\r\n\r\n return 0;\r\n}\r\n', '', 0, 258048, 7, 1, '2011-01-10 18:02:08', '0001-01-01 00:00:00'),
(1283, 10, 374, 5, '#include<stdio.h>\r\n#define N 1000\r\nint main()\r\n{\r\n int i,start,loopsize,size,sum,max,count;\r\n    int max_start,max_end;\r\n int shuzu[N];\r\n scanf("%d",&loopsize);\r\n for(count=0;count !=loopsize;count++)\r\n {\r\n scanf("%d",&size);\r\n for(i = 0 ; i != size ;++i)\r\n  scanf("%d",&shuzu[i]);\r\n sum = start = max_start = max_end = 0;\r\n  i = 0;\r\n  max =-1;\r\n  while(i != size)\r\n  {\r\n   \r\n   sum += shuzu[i];\r\n   if(sum < 0)\r\n   {\r\n    start = i+1;\r\n    sum = 0;\r\n   }\r\n   if(sum > max)\r\n   {\r\n    max = sum;\r\n    max_start = start;\r\n    max_end = i;\r\n   }\r\n   ++i;\r\n  }\r\n printf("Case %d:\\n",count+1);\r\n printf("%d %d %d\\n",max,max_start+1,max_end+1);\r\n if(count+1 !=loopsize)\r\n  printf("\\n");\r\n }\r\n\r\n return 0;\r\n}\r\n', '', 0, 253952, 7, 1, '2011-01-10 18:04:46', '0001-01-01 00:00:00'),
(1284, 10, 374, 5, '#include<stdio.h>\r\n#define N 100\r\nint main()\r\n{\r\n int i,start,loopsize,size,sum,max,count;\r\n    int max_start,max_end;\r\n int shuzu[N];\r\n scanf("%d",&loopsize);\r\n for(count=0;count !=loopsize;count++)\r\n {\r\n scanf("%d",&size);\r\n for(i = 0 ; i != size ;++i)\r\n  scanf("%d",&shuzu[i]);\r\n sum = start = max_start = max_end = 0;\r\n  i = 0;\r\n  max =-1;\r\n  while(i != size)\r\n  {\r\n   \r\n   sum += shuzu[i];\r\n   if(sum < 0)\r\n   {\r\n    start = i+1;\r\n    sum = 0;\r\n   }\r\n   if(sum > max)\r\n   {\r\n    max = sum;\r\n    max_start = start;\r\n    max_end = i;\r\n   }\r\n   ++i;\r\n  }\r\n printf("Case %d:\\n",count+1);\r\n printf("%d %d %d\\n",max,max_start+1,max_end+1);\r\n if(count+1 !=loopsize)\r\n  printf("\\n");\r\n }\r\n\r\n return 0;\r\n}\r\n', '', 0, 258048, 7, 1, '2011-01-10 18:05:37', '0001-01-01 00:00:00'),
(1285, 10, 374, 5, '#include<stdio.h>\r\n#define N 20000\r\nint main()\r\n{\r\n int i,start,loopsize,size,sum,max,count;\r\n int max_start,max_end;\r\n int shuzu[N];\r\n scanf("%d",&loopsize);\r\n for(count=0;count !=loopsize;count++)\r\n {\r\n scanf("%d",&size);\r\n for(i = 0 ; i != size ;++i)\r\n  scanf("%d",&shuzu[i]);\r\n sum = start = max_start = max_end = max = 0;\r\n  i = 0;\r\n  while(i != size)\r\n  {\r\n   \r\n   sum += shuzu[i];\r\n   if(sum < 0)\r\n   {\r\n    start = i+1;\r\n    sum = 0;\r\n   }\r\n   if(sum > max)\r\n   {\r\n    max = sum;\r\n    max_start = start;\r\n    max_end = i;\r\n   }\r\n   ++i;\r\n  }\r\n printf("Case %d:\\n",count+1);\r\n printf("%d %d %d\\n",max,max_start+1,max_end+1);\r\n if(count+1 !=loopsize)\r\n  printf("\\n");\r\n }\r\n return 0;\r\n}\r\n', '', 15, 294912, 4, 1, '2011-01-10 18:11:30', '0001-01-01 00:00:00'),
(1286, 10, 374, 5, '#include<stdio.h>\r\n#define N 20000\r\nint main()\r\n{\r\n int i,start,loopsize,size,sum,max,count;\r\n int max_start,max_end;\r\n int shuzu[N];\r\n scanf("%d",&loopsize);\r\n for(count=0;count !=loopsize;count++)\r\n {\r\n scanf("%d",&size);\r\n for(i = 0 ; i != size ;++i)\r\n  scanf("%d",&shuzu[i]);\r\n sum = start = max_start = max_end = max = 0;\r\n  i = 0;\r\n  while(i != size)\r\n  {\r\n   \r\n   sum += shuzu[i];\r\n   if(sum < 0)\r\n   {\r\n    start = i+1;\r\n    sum = 0;\r\n   }\r\n   if(sum > max)\r\n   {\r\n    max = sum;\r\n    max_start = start;\r\n    max_end = i;\r\n   }\r\n   ++i;\r\n  }\r\n printf("Case %d:\\n",count+1);\r\n printf("%d %d %d\\n",max,max_start+1,max_end+1);\r\n if(count+1 !=loopsize)\r\n  printf("\\n");\r\n }\r\n return 0;\r\n}\r\n', '', 15, 299008, 4, 1, '2011-01-10 18:11:56', '0001-01-01 00:00:00');
INSERT INTO `tbl_submitions` (`id`, `user_id`, `problem_id`, `exercise_id`, `source`, `result`, `used_time`, `used_memory`, `status`, `compiler_id`, `created`, `modified`) VALUES
(1287, 10, 374, 5, '#include<stdio.h>\r\n#define N 20000\r\nint main()\r\n{\r\n int i,start,loopsize,size,sum,max,count;\r\n int max_start,max_end;\r\n int shuzu[N];\r\n int fushu;\r\n scanf("%d",&loopsize);\r\n for(count=0;count !=loopsize;count++)\r\n {\r\n scanf("%d",&size);\r\n for(i = 0 ; i != size ;++i)\r\n  scanf("%d",&shuzu[i]);\r\n fushu = 1;\r\n sum = start = max_start = max_end = 0;\r\n for(i = 0 ; i != size ;++i)\r\n  if(shuzu[i]>0){\r\n   fushu = 0;\r\n   break;}\r\n if(fushu)\r\n {\r\n  max = shuzu[0];\r\n  for(i=1;i!=size;++i)\r\n   if(shuzu[i]>max)\r\n   {\r\n    max_start=max_end = i;\r\n    max = shuzu[i];\r\n   }\r\n }\r\n else{\r\n  i = 0;\r\n  max =-1;\r\n  while(i != size)\r\n  {\r\n   \r\n   sum += shuzu[i];\r\n   if(sum < 0)\r\n   {\r\n    start = i+1;\r\n    sum = 0;\r\n   }\r\n   if(sum > max)\r\n   {\r\n    max = sum;\r\n    max_start = start;\r\n    max_end = i;\r\n   }\r\n   ++i;\r\n  }\r\n }//end else\r\n printf("Case %d:\\n",count+1);\r\n printf("%d %d %d\\n",max,max_start+1,max_end+1);\r\n if(count+1 !=loopsize)\r\n  printf("\\n");\r\n }\r\n return 0;\r\n}\r\n', '', 15, 294912, 1, 1, '2011-01-10 18:16:30', '0001-01-01 00:00:00'),
(1288, 10, 376, 5, '#include<stdio.h>\r\n#include<algorithm>\r\n#define N 50000\r\nbool cmp_inc(int a,int b)\r\n{\r\n return a<b;\r\n}\r\nbool cmp_dec(int a,int b)\r\n{\r\n return a>b;\r\n}\r\nint main()\r\n{\r\n int zero_size,positive_size,negative_size,total_size;\r\n int zero[N],positive[N],negative[N];\r\n int temp,i,sum;\r\n while(scanf("%d",&total_size) != EOF)\r\n {\r\n zero_size = positive_size = negative_size = 0;\r\n sum =1;\r\n for(i = 0; i != total_size;i++)\r\n {\r\n  scanf("%d",&temp);\r\n  if(0 == temp)\r\n  {\r\n   zero[zero_size] = 0;\r\n   ++zero_size;\r\n  }else if(temp > 0)\r\n  {\r\n   positive[positive_size] = temp;\r\n   ++positive_size;\r\n  }else\r\n  {\r\n   negative[negative_size] = temp;\r\n   ++negative_size;\r\n  }\r\n }//end for\r\n if(zero_size > 1)\r\n  printf("0\\n");\r\n else if(1 == zero_size)\r\n {\r\n  if(negative_size %2 == 1)\r\n   printf("0\\n");\r\n  else\r\n  {\r\n   if(positive_size != 0){\r\n   for(i = 0;i != negative_size;i++)\r\n   sum *= negative[i];\r\n   for(i = 1;i != positive_size;i++)\r\n    sum *= positive[i];\r\n   printf("%d\\n",sum);\r\n   }\r\n   else\r\n   {\r\n   for(i = 0;i != negative_size;i++)\r\n       sum *= negative[i];\r\n   printf("%d\\n",sum);\r\n   }\r\n  }\r\n }else\r\n {\r\n  if(negative_size %2 == 1)\r\n  {\r\n   if(negative_size)\r\n    std::sort(negative,negative + negative_size,cmp_dec);\r\n   for(i = 1;i != negative_size;i++)\r\n    sum *= negative[i];\r\n   for(i = 0;i != positive_size;++i)\r\n    sum *= positive[i];\r\n   printf("%d\\n",sum);\r\n  }else\r\n  {\r\n   if(positive_size != 0)\r\n   {\r\n    if(positive_size != 1)\r\n    {\r\n     std::sort(positive,positive + positive_size,cmp_inc);\r\n     for(i = 1;i != positive_size;++i)\r\n      sum *= positive[i];\r\n     for(i = 0;i != negative_size;i++)\r\n     sum *= negative[i];\r\n     printf("%d\\n",sum);\r\n    }\r\n    else{\r\n     for(i = 0;i != negative_size;i++)\r\n      sum *= negative[i];\r\n     printf("%d\\n",sum);\r\n    }\r\n   }else\r\n   {\r\n    std::sort(negative,negative + negative_size,cmp_dec);\r\n    for(i = 0;i != negative_size-1;i++)\r\n     sum *= negative[i];\r\n    printf("%d\\n",sum);\r\n   }\r\n  }\r\n }//end if else if else\r\n }//end for while\r\n return 0;\r\n}\r\n', '', 93, 815104, 4, 2, '2011-01-10 18:33:52', '0001-01-01 00:00:00'),
(1289, 10, 376, 5, '#include<stdio.h>\r\n#include<algorithm>\r\n#define N 50000\r\nbool cmp_inc(int a,int b)\r\n{\r\n return a<b;\r\n}\r\nbool cmp_dec(int a,int b)\r\n{\r\n return a>b;\r\n}\r\nint main()\r\n{\r\n int zero_size,positive_size,negative_size,total_size;\r\n int zero[N],positive[N],negative[N];\r\n int temp,i,sum;\r\n while(scanf("%d",&total_size) != EOF)\r\n {\r\n zero_size = positive_size = negative_size = 0;\r\n sum =1;\r\n for(i = 0; i != total_size;i++)\r\n {\r\n  scanf("%d",&temp);\r\n  if(0 == temp)\r\n  {\r\n   zero[zero_size] = 0;\r\n   ++zero_size;\r\n  }else if(temp > 0)\r\n  {\r\n   positive[positive_size] = temp;\r\n   ++positive_size;\r\n  }else\r\n  {\r\n   negative[negative_size] = temp;\r\n   ++negative_size;\r\n  }\r\n }//end for\r\n if(zero_size > 1)\r\n  printf("0\\n");\r\n else if(1 == zero_size)\r\n {\r\n  if(negative_size %2 == 1)\r\n   printf("0\\n");\r\n  else\r\n  {\r\n   if(positive_size != 0){\r\n   for(i = 0;i != negative_size;i++)\r\n   sum *= negative[i];\r\n   for(i = 1;i != positive_size;i++)\r\n    sum *= positive[i];\r\n   printf("%d\\n",sum);\r\n   }\r\n   else\r\n   {\r\n   for(i = 0;i != negative_size;i++)\r\n       sum *= negative[i];\r\n   printf("%d\\n",sum);\r\n   }\r\n  }\r\n }else\r\n {\r\n  if(negative_size %2 == 1)\r\n  {\r\n   if(negative_size)\r\n    std::sort(negative,negative + negative_size,cmp_dec);\r\n   for(i = 1;i != negative_size;i++)\r\n    sum *= negative[i];\r\n   for(i = 0;i != positive_size;++i)\r\n    sum *= positive[i];\r\n   printf("%d\\n",sum);\r\n  }else\r\n  {\r\n   if(positive_size != 0)\r\n   {\r\n    if(positive_size != 1)\r\n    {\r\n     std::sort(positive,positive + positive_size,cmp_inc);\r\n     for(i = 1;i != positive_size;++i)\r\n      sum *= positive[i];\r\n     for(i = 0;i != negative_size;i++)\r\n     sum *= negative[i];\r\n     printf("%d\\n",sum);\r\n    }\r\n    else{\r\n     for(i = 0;i != negative_size;i++)\r\n      sum *= negative[i];\r\n     printf("%d\\n",sum);\r\n    }\r\n   }else\r\n   {\r\n    std::sort(negative,negative + negative_size,cmp_dec);\r\n    for(i = 0;i != negative_size-1;i++)\r\n     sum *= negative[i];\r\n    printf("%d\\n",sum);\r\n   }\r\n  }\r\n }//end if else if else\r\n }//end for while\r\n return 0;\r\n}\r\n', '', 93, 815104, 4, 2, '2011-01-10 18:37:49', '0001-01-01 00:00:00'),
(1290, 10, 376, 5, '#include<stdio.h>\r\n#include<algorithm>\r\n#define N 50000\r\nbool cmp_inc(int a,int b)\r\n{\r\n return a<b;\r\n}\r\nbool cmp_dec(int a,int b)\r\n{\r\n return a>b;\r\n}\r\nint main()\r\n{\r\n int zero_size,positive_size,negative_size,total_size;\r\n int zero[N],positive[N],negative[N];\r\n int temp,i,sum;\r\n while(scanf("%d",&total_size) != EOF)\r\n {\r\n zero_size = positive_size = negative_size = 0;\r\n sum =1;\r\n for(i = 0; i != total_size;i++)\r\n {\r\n  scanf("%d",&temp);\r\n  if(0 == temp)\r\n  {\r\n   zero[zero_size] = 0;\r\n   ++zero_size;\r\n  }else if(temp > 0)\r\n  {\r\n   positive[positive_size] = temp;\r\n   ++positive_size;\r\n  }else\r\n  {\r\n   negative[negative_size] = temp;\r\n   ++negative_size;\r\n  }\r\n }//end for\r\n if(total_size == 1)\r\n  printf("0\\n");\r\n else if(zero_size > 1)\r\n  printf("0\\n");\r\n else if(1 == zero_size)\r\n {\r\n  if(negative_size %2 == 1)\r\n   printf("0\\n");\r\n  else\r\n  {\r\n   if(positive_size != 0){\r\n   for(i = 0;i != negative_size;i++)\r\n   sum *= negative[i];\r\n   for(i = 1;i != positive_size;i++)\r\n    sum *= positive[i];\r\n   printf("%d\\n",sum);\r\n   }\r\n   else\r\n   {\r\n   for(i = 0;i != negative_size;i++)\r\n       sum *= negative[i];\r\n   printf("%d\\n",sum);\r\n   }\r\n  }\r\n }else\r\n {\r\n  if(negative_size %2 == 1)\r\n  {\r\n   if(negative_size)\r\n    std::sort(negative,negative + negative_size,cmp_dec);\r\n   for(i = 1;i != negative_size;i++)\r\n    sum *= negative[i];\r\n   for(i = 0;i != positive_size;++i)\r\n    sum *= positive[i];\r\n   printf("%d\\n",sum);\r\n  }else\r\n  {\r\n   if(positive_size != 0)\r\n   {\r\n    if(positive_size != 1)\r\n    {\r\n     std::sort(positive,positive + positive_size,cmp_inc);\r\n     for(i = 1;i != positive_size;++i)\r\n      sum *= positive[i];\r\n     for(i = 0;i != negative_size;i++)\r\n     sum *= negative[i];\r\n     printf("%d\\n",sum);\r\n    }\r\n    else{\r\n     for(i = 0;i != negative_size;i++)\r\n      sum *= negative[i];\r\n     printf("%d\\n",sum);\r\n    }\r\n   }else\r\n   {\r\n    std::sort(negative,negative + negative_size,cmp_dec);\r\n    for(i = 0;i != negative_size-1;i++)\r\n     sum *= negative[i];\r\n    printf("%d\\n",sum);\r\n   }\r\n  }\r\n }//end if else if else\r\n }//end for while\r\n return 0;\r\n}\r\n', '', 93, 819200, 4, 2, '2011-01-10 18:42:25', '0001-01-01 00:00:00'),
(1291, 10, 376, 5, '#include<stdio.h>\r\n#include<algorithm>\r\n#define N 50000\r\nbool cmp_inc(int a,int b)\r\n{\r\n return a<b;\r\n}\r\nbool cmp_dec(int a,int b)\r\n{\r\n return a>b;\r\n}\r\nint main()\r\n{\r\n int zero_size,positive_size,negative_size,total_size;\r\n int zero[N],positive[N],negative[N];\r\n int temp,i;\r\n __int64 sum;\r\n while(scanf("%d",&total_size) != EOF)\r\n {\r\n zero_size = positive_size = negative_size = 0;\r\n sum =1;\r\n for(i = 0; i != total_size;i++)\r\n {\r\n  scanf("%d",&temp);\r\n  if(0 == temp)\r\n  {\r\n   zero[zero_size] = 0;\r\n   ++zero_size;\r\n  }else if(temp > 0)\r\n  {\r\n   positive[positive_size] = temp;\r\n   ++positive_size;\r\n  }else\r\n  {\r\n   negative[negative_size] = temp;\r\n   ++negative_size;\r\n  }\r\n }//end for\r\n if(total_size == 1)\r\n  printf("0\\n");\r\n else if(zero_size > 1)\r\n  printf("0\\n");\r\n else if(1 == zero_size)\r\n {\r\n  if(negative_size %2 == 1)\r\n   printf("0\\n");\r\n  else\r\n  {\r\n   if(positive_size != 0){\r\n   for(i = 0;i != negative_size;i++)\r\n   sum *= negative[i];\r\n   for(i = 1;i != positive_size;i++)\r\n    sum *= positive[i];\r\n   printf("%d\\n",sum);\r\n   }\r\n   else\r\n   {\r\n   for(i = 0;i != negative_size;i++)\r\n       sum *= negative[i];\r\n   printf("%d\\n",sum);\r\n   }\r\n  }\r\n }else\r\n {\r\n  if(negative_size %2 == 1)\r\n  {\r\n   if(negative_size)\r\n    std::sort(negative,negative + negative_size,cmp_dec);\r\n   for(i = 1;i != negative_size;i++)\r\n    sum *= negative[i];\r\n   for(i = 0;i != positive_size;++i)\r\n    sum *= positive[i];\r\n   printf("%d\\n",sum);\r\n  }else\r\n  {\r\n   if(positive_size != 0)\r\n   {\r\n    if(positive_size != 1)\r\n    {\r\n     std::sort(positive,positive + positive_size,cmp_inc);\r\n     for(i = 1;i != positive_size;++i)\r\n      sum *= positive[i];\r\n     for(i = 0;i != negative_size;i++)\r\n     sum *= negative[i];\r\n     printf("%d\\n",sum);\r\n    }\r\n    else{\r\n     for(i = 0;i != negative_size;i++)\r\n      sum *= negative[i];\r\n     printf("%d\\n",sum);\r\n    }\r\n   }else\r\n   {\r\n    std::sort(negative,negative + negative_size,cmp_dec);\r\n    for(i = 0;i != negative_size-1;i++)\r\n     sum *= negative[i];\r\n    printf("%d\\n",sum);\r\n   }\r\n  }\r\n }//end if else if else\r\n }//end for while\r\n return 0;\r\n}\r\n', '', 93, 815104, 4, 2, '2011-01-10 18:44:39', '0001-01-01 00:00:00'),
(1292, 10, 376, 5, '#include<stdio.h>\r\n#include<algorithm>\r\n#define N 50000\r\nbool cmp_inc(int a,int b)\r\n{\r\n return a<b;\r\n}\r\nbool cmp_dec(int a,int b)\r\n{\r\n return a>b;\r\n}\r\nint main()\r\n{\r\n int zero_size,positive_size,negative_size,total_size;\r\n __int64 zero[N],positive[N],negative[N];\r\n __int64 temp,i;\r\n __int64 sum;\r\n while(scanf("%d",&total_size) != EOF)\r\n {\r\n zero_size = positive_size = negative_size = 0;\r\n sum =1;\r\n for(i = 0; i != total_size;i++)\r\n {\r\n  scanf("%d",&temp);\r\n  if(0 == temp)\r\n  {\r\n   zero[zero_size] = 0;\r\n   ++zero_size;\r\n  }else if(temp > 0)\r\n  {\r\n   positive[positive_size] = temp;\r\n   ++positive_size;\r\n  }else\r\n  {\r\n   negative[negative_size] = temp;\r\n   ++negative_size;\r\n  }\r\n }//end for\r\n if(total_size == 1)\r\n  printf("0\\n");\r\n else if(zero_size > 1)\r\n  printf("0\\n");\r\n else if(1 == zero_size)\r\n {\r\n  if(negative_size %2 == 1)\r\n   printf("0\\n");\r\n  else\r\n  {\r\n   if(positive_size != 0){\r\n   for(i = 0;i != negative_size;i++)\r\n   sum *= negative[i];\r\n   for(i = 1;i != positive_size;i++)\r\n    sum *= positive[i];\r\n   printf("%d\\n",sum);\r\n   }\r\n   else\r\n   {\r\n   for(i = 0;i != negative_size;i++)\r\n       sum *= negative[i];\r\n   printf("%d\\n",sum);\r\n   }\r\n  }\r\n }else\r\n {\r\n  if(negative_size %2 == 1)\r\n  {\r\n   if(negative_size)\r\n    std::sort(negative,negative + negative_size,cmp_dec);\r\n   for(i = 1;i != negative_size;i++)\r\n    sum *= negative[i];\r\n   for(i = 0;i != positive_size;++i)\r\n    sum *= positive[i];\r\n   printf("%d\\n",sum);\r\n  }else\r\n  {\r\n   if(positive_size != 0)\r\n   {\r\n    if(positive_size != 1)\r\n    {\r\n     std::sort(positive,positive + positive_size,cmp_inc);\r\n     for(i = 1;i != positive_size;++i)\r\n      sum *= positive[i];\r\n     for(i = 0;i != negative_size;i++)\r\n     sum *= negative[i];\r\n     printf("%d\\n",sum);\r\n    }\r\n    else{\r\n     for(i = 0;i != negative_size;i++)\r\n      sum *= negative[i];\r\n     printf("%d\\n",sum);\r\n    }\r\n   }else\r\n   {\r\n    std::sort(negative,negative + negative_size,cmp_dec);\r\n    for(i = 0;i != negative_size-1;i++)\r\n     sum *= negative[i];\r\n    printf("%d\\n",sum);\r\n   }\r\n  }\r\n }//end if else if else\r\n }//end for while\r\n return 0;\r\n}\r\n', '', 124, 1421312, 4, 2, '2011-01-10 18:45:39', '0001-01-01 00:00:00'),
(1293, 10, 376, 5, '#include<stdio.h>\r\n#include<algorithm>\r\n#define N 50000\r\nbool cmp_inc(int a,int b)\r\n{\r\n return a<b;\r\n}\r\nbool cmp_dec(int a,int b)\r\n{\r\n return a>b;\r\n}\r\nint main()\r\n{\r\n int zero_size,positive_size,negative_size,total_size;\r\n __int64 zero[N],positive[N],negative[N];\r\n int temp,i;\r\n __int64 sum;\r\n while(scanf("%d",&total_size) != EOF)\r\n {\r\n zero_size = positive_size = negative_size = 0;\r\n sum =1;\r\n for(i = 0; i != total_size;i++)\r\n {\r\n  scanf("%d",&temp);\r\n  if(0 == temp)\r\n  {\r\n   zero[zero_size] = 0;\r\n   ++zero_size;\r\n  }else if(temp > 0)\r\n  {\r\n   positive[positive_size] = temp;\r\n   ++positive_size;\r\n  }else\r\n  {\r\n   negative[negative_size] = temp;\r\n   ++negative_size;\r\n  }\r\n }//end for\r\n if(total_size == 1)\r\n  printf("0\\n");\r\n else if(zero_size > 1)\r\n  printf("0\\n");\r\n else if(1 == zero_size)\r\n {\r\n  if(negative_size %2 == 1)\r\n   printf("0\\n");\r\n  else\r\n  {\r\n   if(positive_size != 0){\r\n   for(i = 0;i != negative_size;i++)\r\n   sum *= negative[i];\r\n   for(i = 1;i != positive_size;i++)\r\n    sum *= positive[i];\r\n   printf("%d\\n",sum);\r\n   }\r\n   else\r\n   {\r\n   for(i = 0;i != negative_size;i++)\r\n       sum *= negative[i];\r\n   printf("%d\\n",sum);\r\n   }\r\n  }\r\n }else\r\n {\r\n  if(negative_size %2 == 1)\r\n  {\r\n   if(negative_size)\r\n    std::sort(negative,negative + negative_size,cmp_dec);\r\n   for(i = 1;i != negative_size;i++)\r\n    sum *= negative[i];\r\n   for(i = 0;i != positive_size;++i)\r\n    sum *= positive[i];\r\n   printf("%d\\n",sum);\r\n  }else\r\n  {\r\n   if(positive_size != 0)\r\n   {\r\n    if(positive_size != 1)\r\n    {\r\n     std::sort(positive,positive + positive_size,cmp_inc);\r\n     for(i = 1;i != positive_size;++i)\r\n      sum *= positive[i];\r\n     for(i = 0;i != negative_size;i++)\r\n     sum *= negative[i];\r\n     printf("%d\\n",sum);\r\n    }\r\n    else{\r\n     for(i = 0;i != negative_size;i++)\r\n      sum *= negative[i];\r\n     printf("%d\\n",sum);\r\n    }\r\n   }else\r\n   {\r\n    std::sort(negative,negative + negative_size,cmp_dec);\r\n    for(i = 0;i != negative_size-1;i++)\r\n     sum *= negative[i];\r\n    printf("%d\\n",sum);\r\n   }\r\n  }\r\n }//end if else if else\r\n }//end for while\r\n return 0;\r\n}\r\n', '', 93, 1417216, 4, 2, '2011-01-10 18:57:24', '0001-01-01 00:00:00'),
(1294, 39, 335, 0, '#include <iostream>\r\n#include <bitset>\r\n#include <stdio.h>\r\nusing namespace std;\r\n\r\nint countTable[256] = \r\n\r\n{ \r\n\r\n0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8 \r\n\r\n}; \r\n\r\n\r\nint findone(unsigned int n){ \r\n  int i=0;\r\n  for(;n>0;n>>=8){\r\n    i+=countTable[n&255]; }\r\n  return i; \r\n} \r\n\r\n\r\n\r\nint main()\r\n{\r\n	unsigned int i = 0, j = 0;\r\n	while(cin>>i>>j){\r\n    	i^=j;\r\n    	cout<<findone(i)<<endl;\r\n    }\r\n}\r\n', '', 100, 368640, 5, 2, '2011-01-10 19:00:38', '0001-01-01 00:00:00'),
(1295, 10, 376, 5, '#include<stdio.h>\r\n#include<algorithm>\r\n#define N 50000\r\nbool cmp_inc(int a,int b)\r\n{\r\n return a<b;\r\n}\r\nbool cmp_dec(int a,int b)\r\n{\r\n return a>b;\r\n}\r\nint main()\r\n{\r\n int zero_size,positive_size,negative_size,total_size;\r\n __int64 zero[N],positive[N],negative[N];\r\n int temp,i;\r\n __int64 sum;\r\n while(scanf("%d",&total_size) != EOF)\r\n {\r\n zero_size = positive_size = negative_size = 0;\r\n sum =1;\r\n for(i = 0; i != total_size;i++)\r\n {\r\n  scanf("%d",&temp);\r\n  if(0 == temp)\r\n  {\r\n   zero[zero_size] = 0;\r\n   ++zero_size;\r\n  }else if(temp > 0)\r\n  {\r\n   positive[positive_size] = temp;\r\n   ++positive_size;\r\n  }else\r\n  {\r\n   negative[negative_size] = temp;\r\n   ++negative_size;\r\n  }\r\n }//end for\r\n if(total_size == 1)\r\n  printf("0\\n");\r\n else if(zero_size > 1)\r\n  printf("0\\n");\r\n else if(1 == zero_size)\r\n {\r\n  if(negative_size %2 == 1)\r\n   printf("0\\n");\r\n  else\r\n  {\r\n   if(positive_size != 0){\r\n   for(i = 0;i != negative_size;i++)\r\n   sum *= negative[i];\r\n   for(i = 0;i != positive_size;i++)\r\n    sum *= positive[i];\r\n   printf("%d\\n",sum);\r\n   }\r\n   else\r\n   {\r\n   for(i = 0;i != negative_size;i++)\r\n       sum *= negative[i];\r\n   printf("%d\\n",sum);\r\n   }\r\n  }\r\n }else\r\n {\r\n  if(negative_size %2 == 1)\r\n  {\r\n   if(negative_size)\r\n    std::sort(negative,negative + negative_size,cmp_dec);\r\n   for(i = 1;i != negative_size;i++)\r\n    sum *= negative[i];\r\n   for(i = 0;i != positive_size;++i)\r\n    sum *= positive[i];\r\n   printf("%d\\n",sum);\r\n  }else\r\n  {\r\n   if(positive_size != 0)\r\n   {\r\n    if(positive_size != 1)\r\n    {\r\n     std::sort(positive,positive + positive_size,cmp_inc);\r\n     for(i = 1;i != positive_size;++i)\r\n      sum *= positive[i];\r\n     for(i = 0;i != negative_size;i++)\r\n     sum *= negative[i];\r\n     printf("%d\\n",sum);\r\n    }\r\n    else{\r\n     for(i = 0;i != negative_size;i++)\r\n      sum *= negative[i];\r\n     printf("%d\\n",sum);\r\n    }\r\n   }else\r\n   {\r\n    std::sort(negative,negative + negative_size,cmp_dec);\r\n    for(i = 0;i != negative_size-1;i++)\r\n     sum *= negative[i];\r\n    printf("%d\\n",sum);\r\n   }\r\n  }\r\n }//end if else if else\r\n }//end for while\r\n return 0;\r\n}\r\n', '', 78, 1421312, 4, 2, '2011-01-10 19:03:08', '0001-01-01 00:00:00'),
(1296, 39, 335, 0, '\r\n#include <stdio.h>\r\n\r\n\r\nint findone(int n){ \r\n  \r\n  int i, cnt = 0;\r\n  for(i = 0; i < 32; i++)\r\n  {\r\n        cnt += ((n>>i)&1);\r\n  }\r\n  //printf("%d %d ", n, cnt);\r\n  return cnt;\r\n} \r\n\r\n\r\n\r\nint main()\r\n{\r\n    int i, j;\r\n    	while(scanf("%d %d", &i, &j)){\r\n                        int t = (i^j);\r\n    	printf("%d\\n",findone(t) );\r\n    }\r\n    return 0;\r\n}\r\n', '', 100, 258048, 5, 1, '2011-01-10 19:27:19', '0001-01-01 00:00:00'),
(1297, 7, 335, 0, '\r\n#include <stdio.h>\r\n\r\n\r\nint findone(long long n){ \r\n  \r\n  int count;\r\n  for(count = 0; n; n &= n - 1)\r\n  {\r\n       count++;\r\n       }\r\nreturn count;\r\n\r\n  //printf("%d %d ", n, cnt);\r\n} \r\n\r\n\r\n\r\nint main()\r\n{\r\n    int i, j;\r\n    	while(scanf("%d %d", &i, &j))\r\n        {\r\n                        \r\n        long long t = (i^j);\r\n        long long n = t;\r\n          int count;\r\n  for(count = 0; n; n &= n - 1)\r\n  {\r\n       count++;\r\n       }\r\n       printf("%d\\n", count);\r\n        \r\n    	//printf("%d\\n",findone(t) );\r\n    }\r\n    return 0;\r\n}\r\n', '', 100, 253952, 5, 1, '2011-01-10 19:37:04', '0001-01-01 00:00:00'),
(1298, 7, 335, 0, '\r\n#include <stdio.h>\r\n\r\n\r\nint findone(long long n){ \r\n  \r\n  int count;\r\n  for(count = 0; n; n &= n - 1)\r\n  {\r\n       count++;\r\n       }\r\nreturn count;\r\n\r\n  //printf("%d %d ", n, cnt);\r\n} \r\n\r\n\r\n\r\nint main()\r\n{\r\n    int i, j;\r\n    	while(scanf("%d %d", &i, &j)==2)\r\n        {\r\n                        \r\n        long long n = (i^j);\r\n          int count;\r\n  for(count = 0; n; n &= n - 1)\r\n  {\r\n       count++;\r\n       }\r\n       printf("%d\\n", count);\r\n        \r\n    	//printf("%d\\n",findone(t) );\r\n    }\r\n    return 0;\r\n}\r\n', '', 0, 253952, 4, 1, '2011-01-10 19:41:31', '0001-01-01 00:00:00'),
(1299, 7, 335, 0, '\r\n#include <stdio.h>\r\n\r\n\r\nint findone(long long n){ \r\n  \r\n  int count;\r\n  for(count = 0; n; n &= n - 1)\r\n  {\r\n       count++;\r\n       }\r\nreturn count;\r\n\r\n  //printf("%d %d ", n, cnt);\r\n} \r\n\r\n\r\n\r\nint main()\r\n{\r\n    int i, j;\r\n    	while(scanf("%d %d", &i, &j)==2)\r\n        {\r\n        int n = (i^j);\r\n          int count;\r\n  for(count = 0; n; n &= n - 1)\r\n  {\r\n       count++;\r\n       }\r\n       printf("%d\\n", count);\r\n        \r\n    	//printf("%d\\n",findone(t) );\r\n    }\r\n    return 0;\r\n}\r\n', '', 62, 258048, 1, 1, '2011-01-10 19:46:54', '0001-01-01 00:00:00'),
(1300, 7, 335, 0, '#include <iostream>\r\n#include <bitset>\r\n#include <stdio.h>\r\nusing namespace std;\r\n\r\nint countTable[256] = \r\n\r\n{ \r\n\r\n0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8 \r\n\r\n}; \r\n\r\n\r\nint findone(int n){ \r\n  int i=0;\r\n  for(;n>0;n>>=8){\r\n    i+=countTable[n&255]; }\r\n  return i; \r\n} \r\n\r\n\r\n\r\nint main()\r\n{\r\n	int i = 0, j = 0;\r\n	while(scanf("%d %d", &i, &j)==2)\r\n	{\r\n    	i^=j;\r\n    	cout<<findone(i)<<endl;\r\n    }\r\n	return 0;\r\n}\r\n', 'Main.c:1:20: fatal error: iostream: No such file or directory\r\ncompilation terminated.\r\n', 0, 0, 2, 1, '2011-01-10 19:51:22', '0001-01-01 00:00:00'),
(1301, 7, 335, 0, '#include <iostream>\r\n#include <bitset>\r\n#include <stdio.h>\r\nusing namespace std;\r\n\r\nint countTable[256] = \r\n\r\n{ \r\n\r\n0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8 \r\n\r\n}; \r\n\r\n\r\nint findone(int n){ \r\n  int i=0;\r\n  for(;n>0;n>>=8){\r\n    i+=countTable[n&255]; }\r\n  return i; \r\n} \r\n\r\n\r\n\r\nint main()\r\n{\r\n	int i = 0, j = 0;\r\n	while(scanf("%d %d", &i, &j)==2)\r\n	{\r\n    	i^=j;\r\n    	cout<<findone(i)<<endl;\r\n    }\r\n	return 0;\r\n}\r\n', '', 0, 364544, 4, 2, '2011-01-10 19:51:38', '0001-01-01 00:00:00'),
(1302, 7, 335, 0, '#include <iostream>\r\n#include <bitset>\r\n#include <stdio.h>\r\nusing namespace std;\r\n\r\nint countTable[256] = \r\n{ \r\n\r\n0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8 \r\n\r\n}; \r\n\r\n\r\nint findone(unsigned int n){ \r\n  int i=0;\r\n  for(;n!=0;n>>=8){\r\n                  //-1  printf("%d, %d\\n", i, (n&255));\r\n    i+=countTable[n&255]; }\r\n  return i; \r\n} \r\n\r\n\r\n\r\nint main()\r\n{\r\n	int i = 0, j = 0;\r\n	while(scanf("%d %d", &i, &j)==2)\r\n	{\r\n    	i^=j;\r\n    	cout<<findone(i)<<endl;\r\n    }\r\n	return 0;\r\n}\r\n', '', 100, 368640, 5, 2, '2011-01-10 20:02:15', '0001-01-01 00:00:00'),
(1303, 7, 335, 0, '#include <iostream>\r\n#include <bitset>\r\n#include <stdio.h>\r\nusing namespace std;\r\n\r\n\r\n\r\n\r\nint main()\r\n{\r\n	int i = 0, j = 0;\r\n	while(scanf("%d %d", &i, &j)==2)\r\n	{\r\n    	unsigned int n = i^j;\r\n    	\r\n    	int cnt = 0;\r\n    	for(; n; n>>=1)\r\n    	{\r\n              cnt += n&1;\r\n        }\r\n        printf("%d\\n", cnt);\r\n    }\r\n	return 0;\r\n}\r\n', '', 62, 360448, 1, 2, '2011-01-10 20:07:17', '0001-01-01 00:00:00'),
(1304, 7, 335, 0, '#include <iostream>\r\n#include <bitset>\r\n#include <stdio.h>\r\nusing namespace std;\r\n\r\nint countTable[256] = \r\n{ \r\n0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8 \r\n}; \r\n\r\n\r\nint findone(unsigned int n){ \r\n  int i=0;\r\n  for(;n>0;n>>=8){\r\n                  int t = n&255;\r\n    i+=*(countTable+t); }\r\n  return i; \r\n} \r\n\r\n\r\n\r\nint main()\r\n{\r\n	unsigned int i = 0, j = 0;\r\n	while(cin>>i>>j){\r\n    	i^=j;\r\n    	cout<<findone(i)<<endl;\r\n    }\r\n}\r\n', '', 100, 368640, 5, 2, '2011-01-10 20:09:45', '0001-01-01 00:00:00'),
(1305, 7, 335, 0, '#include <iostream>\r\n#include <bitset>\r\n#include <stdio.h>\r\nusing namespace std;\r\nint countTable[256] = \r\n{ \r\n0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8 \r\n}; \r\n  \r\nint main()\r\n{\r\n	int i = 0, j = 0;\r\n	while(scanf("%d %d", &i, &j)==2)\r\n	{\r\n    	unsigned int n = i^j;\r\n    	\r\n    	int cnt = 0;\r\n    	for(; n; n>>=8)\r\n    	{\r\n              cnt += countTable[n&255];\r\n        }\r\n        printf("%d\\n", cnt);\r\n    }\r\n	return 0;\r\n}\r\n', '', 62, 368640, 1, 2, '2011-01-10 20:14:15', '0001-01-01 00:00:00'),
(1306, 39, 335, 0, '#include <iostream>\r\n#include <bitset>\r\n#include <stdio.h>\r\nusing namespace std;\r\n\r\nint countTable[256] = \r\n{ \r\n0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8 \r\n}; \r\n\r\n\r\nint findone(unsigned int n){ \r\n  int i=0;\r\n  for(;n>0;n>>=8){\r\n                  int t = n&255;\r\n    i+=*(countTable+t); }\r\n  return i; \r\n} \r\n\r\n\r\n\r\nint main()\r\n{\r\n	unsigned int i = 0, j = 0;\r\n	while(cin>>i>>j){\r\n    	i^=j;\r\n    	cout<<findone(i)<<endl;\r\n    }\r\n}\r\n', '', 100, 368640, 5, 2, '2011-01-10 20:23:01', '0001-01-01 00:00:00'),
(1307, 39, 335, 0, '#include <stdio.h>\r\n\r\nint countTable[256] = \r\n\r\n{ \r\n\r\n0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8 \r\n\r\n}; \r\n\r\n\r\n\r\n\r\nint main()\r\n{\r\n	unsigned int i = 0, j = 0;\r\n	while(scanf("%d%d",&i,&j)){\r\n    	i^=j;\r\n    	int cnt=0;\r\n    	for(;i!=0;i>>=8){\r\n          cnt+=countTable[i&255];\r\n        }\r\n        printf("%d\\n",cnt);\r\n} \r\n    	\r\n    \r\n}', '', 100, 253952, 5, 1, '2011-01-10 20:26:58', '0001-01-01 00:00:00'),
(1308, 39, 335, 0, '#include <stdio.h>\r\n\r\nint countTable[256] = \r\n\r\n{ \r\n\r\n0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8 \r\n\r\n}; \r\n\r\n\r\n\r\n\r\nint main()\r\n{\r\n	int i = 0, j = 0;\r\n	while(scanf("%d%d",&i,&j)==2){\r\n    	i^=j;\r\n    	int cnt=0;\r\n    	for(;i;i>>=8){\r\n          cnt+=countTable[i&255];\r\n        }\r\n        printf("%d\\n",cnt);\r\n} \r\n    	\r\n    \r\n}', '', 100, 253952, 5, 1, '2011-01-10 20:36:50', '0001-01-01 00:00:00'),
(1309, 39, 335, 0, '#include <stdio.h>\r\n\r\nint countTable[256] = \r\n\r\n{ \r\n\r\n0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8 \r\n\r\n}; \r\n\r\n\r\n\r\n\r\nint main()\r\n{\r\n	int i = 0, j = 0;\r\n	while(scanf("%d%d",&i,&j)==2){\r\n             int t=i^j;    	\r\n    	int cnt=0;\r\n    	for(;i;i>>=8){\r\n          cnt+=*(countTable+t);        }\r\n        printf("%d\\n",cnt);\r\n} \r\n    	\r\n    \r\n}', '', 0, 258048, 4, 1, '2011-01-10 20:38:21', '0001-01-01 00:00:00'),
(1310, 39, 335, 0, '#include <stdio.h>\r\n\r\nint countTable[256] = \r\n\r\n{ \r\n\r\n0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8 \r\n\r\n}; \r\n\r\n\r\n\r\n\r\nint main()\r\n{\r\n	int i = 0, j = 0;\r\n	while(scanf("%d%d",&i,&j)==2){\r\n        unsigned int t=i^j;    	\r\n    	int cnt=0;\r\n    	for(;t;t>>=8){\r\n          cnt+=*(countTable+(t&255));        }\r\n        printf("%d\\n",cnt);\r\n} \r\n    	\r\n    \r\n}\r\n', '', 62, 258048, 1, 1, '2011-01-10 20:40:36', '0001-01-01 00:00:00'),
(1311, 10, 376, 5, '#include<stdio.h>\r\n#include<algorithm>\r\n#define N 50000\r\nbool cmp_inc(int a,int b)\r\n{\r\n return a<b;\r\n}\r\nbool cmp_dec(int a,int b)\r\n{\r\n return a>b;\r\n}\r\nint main()\r\n{\r\n int zero_size,positive_size,negative_size,total_size;\r\n __int64 zero[N],positive[N],negative[N];\r\n int temp,i;\r\n __int64 sum;\r\n while(scanf("%d",&total_size) != EOF)\r\n {\r\n zero_size = positive_size = negative_size = 0;\r\n sum =1;\r\n for(i = 0; i != total_size;i++)\r\n {\r\n  scanf("%d",&temp);\r\n  if(0 == temp)\r\n  {\r\n   zero[zero_size] = 0;\r\n   ++zero_size;\r\n  }else if(temp > 0)\r\n  {\r\n   positive[positive_size] = temp;\r\n   ++positive_size;\r\n  }else\r\n  {\r\n   negative[negative_size] = temp;\r\n   ++negative_size;\r\n  }\r\n }//end for\r\n if(total_size == 1)\r\n  printf("0\\n");\r\n else if(zero_size > 1)\r\n  printf("0\\n");\r\n else if(1 == zero_size)\r\n {\r\n  if(negative_size %2 == 1)\r\n   printf("0\\n");\r\n  else\r\n  {\r\n   if(positive_size != 0){\r\n   for(i = 0;i != negative_size;i++)\r\n   sum *= negative[i];\r\n   for(i = 0;i != positive_size;i++)\r\n    sum *= positive[i];\r\n   printf("%I64d\\n",sum);\r\n   }\r\n   else\r\n   {\r\n   for(i = 0;i != negative_size;i++)\r\n       sum *= negative[i];\r\n   printf("%I64d\\n",sum);\r\n   }\r\n  }\r\n }else\r\n {\r\n  if(negative_size %2 == 1)\r\n  {\r\n   if(negative_size)\r\n    std::sort(negative,negative + negative_size,cmp_dec);\r\n   for(i = 1;i != negative_size;i++)\r\n    sum *= negative[i];\r\n   for(i = 0;i != positive_size;++i)\r\n    sum *= positive[i];\r\n   printf("%I64d\\n",sum);\r\n  }else\r\n  {\r\n   if(positive_size != 0)\r\n   {\r\n    if(positive_size != 1)\r\n    {\r\n     std::sort(positive,positive + positive_size,cmp_inc);\r\n     for(i = 1;i != positive_size;++i)\r\n      sum *= positive[i];\r\n     for(i = 0;i != negative_size;i++)\r\n     sum *= negative[i];\r\n     printf("%I64d\\n",sum);\r\n    }\r\n    else{\r\n     for(i = 0;i != negative_size;i++)\r\n      sum *= negative[i];\r\n     printf("%I64d\\n",sum);\r\n    }\r\n   }else\r\n   {\r\n    std::sort(negative,negative + negative_size,cmp_dec);\r\n    for(i = 0;i != negative_size-1;i++)\r\n     sum *= negative[i];\r\n    printf("%I64d\\n",sum);\r\n   }\r\n  }\r\n }//end if else if else\r\n }//end for while\r\n return 0;\r\n}\r\n', 'Main.c:2:20: fatal error: algorithm: No such file or directory\r\ncompilation terminated.\r\n', 0, 0, 2, 1, '2011-01-11 00:45:19', '0001-01-01 00:00:00'),
(1312, 10, 376, 5, '#include<stdio.h>\r\n#include<algorithm>\r\n#define N 50000\r\nbool cmp_inc(int a,int b)\r\n{\r\n return a<b;\r\n}\r\nbool cmp_dec(int a,int b)\r\n{\r\n return a>b;\r\n}\r\nint main()\r\n{\r\n int zero_size,positive_size,negative_size,total_size;\r\n __int64 zero[N],positive[N],negative[N];\r\n int temp,i;\r\n __int64 sum;\r\n while(scanf("%d",&total_size) != EOF)\r\n {\r\n zero_size = positive_size = negative_size = 0;\r\n sum =1;\r\n for(i = 0; i != total_size;i++)\r\n {\r\n  scanf("%d",&temp);\r\n  if(0 == temp)\r\n  {\r\n   zero[zero_size] = 0;\r\n   ++zero_size;\r\n  }else if(temp > 0)\r\n  {\r\n   positive[positive_size] = temp;\r\n   ++positive_size;\r\n  }else\r\n  {\r\n   negative[negative_size] = temp;\r\n   ++negative_size;\r\n  }\r\n }//end for\r\n if(total_size == 1)\r\n  printf("0\\n");\r\n else if(zero_size > 1)\r\n  printf("0\\n");\r\n else if(1 == zero_size)\r\n {\r\n  if(negative_size %2 == 1)\r\n   printf("0\\n");\r\n  else\r\n  {\r\n   if(positive_size != 0){\r\n   for(i = 0;i != negative_size;i++)\r\n   sum *= negative[i];\r\n   for(i = 0;i != positive_size;i++)\r\n    sum *= positive[i];\r\n   printf("%I64d\\n",sum);\r\n   }\r\n   else\r\n   {\r\n   for(i = 0;i != negative_size;i++)\r\n       sum *= negative[i];\r\n   printf("%I64d\\n",sum);\r\n   }\r\n  }\r\n }else\r\n {\r\n  if(negative_size %2 == 1)\r\n  {\r\n   if(negative_size)\r\n    std::sort(negative,negative + negative_size,cmp_dec);\r\n   for(i = 1;i != negative_size;i++)\r\n    sum *= negative[i];\r\n   for(i = 0;i != positive_size;++i)\r\n    sum *= positive[i];\r\n   printf("%I64d\\n",sum);\r\n  }else\r\n  {\r\n   if(positive_size != 0)\r\n   {\r\n    if(positive_size != 1)\r\n    {\r\n     std::sort(positive,positive + positive_size,cmp_inc);\r\n     for(i = 1;i != positive_size;++i)\r\n      sum *= positive[i];\r\n     for(i = 0;i != negative_size;i++)\r\n     sum *= negative[i];\r\n     printf("%I64d\\n",sum);\r\n    }\r\n    else{\r\n     for(i = 0;i != negative_size;i++)\r\n      sum *= negative[i];\r\n     printf("%I64d\\n",sum);\r\n    }\r\n   }else\r\n   {\r\n    std::sort(negative,negative + negative_size,cmp_dec);\r\n    for(i = 0;i != negative_size-1;i++)\r\n     sum *= negative[i];\r\n    printf("%I64d\\n",sum);\r\n   }\r\n  }\r\n }//end if else if else\r\n }//end for while\r\n return 0;\r\n}\r\n', '', 93, 1417216, 1, 2, '2011-01-11 00:45:43', '0001-01-01 00:00:00'),
(1313, 39, 44, 0, '#include <stdio.h>\r\n\r\nint main(){\r\n    char a,b,c,d,e;\r\n    scanf("%c%c%c%c%c",&a,&b,&c,&d,&e); \r\n    short i=(short)a,j=(short)b,k=(short)c,l=(short)d,m=(short)e;\r\n    printf("%c%c%c%c%c",i<91?(i+4<91?i+=4:i-=22):(i+4<123?i+=4:i-=22),j<91?(j+4<91?j+=4:j-=22):(j+4<123?j+=4:j-=22),k<91?(k+4<91?k+=4:k-=22):(k+4<123?k+=4:k-=22),l<91?(l+4<91?l+=4:l-=22):(l+4<123?l+=4:l-=22),m<91?(m+4<91?m+=4:m-=22):(m+4<123?m+=4:m-=22));\r\n        return 0;\r\n}', 'Main.c: In function ''main'':\r\nMain.c:7:5: error: lvalue required as left operand of assignment\r\nMain.c:7:5: error: lvalue required as left operand of assignment\r\nMain.c:7:5: error: lvalue required as left operand of assignment\r\nMain.c:7:5: error: lvalue required as left operand of assignment\r\nMain.c:7:5: error: lvalue required as left operand of assignment\r\nMain.c:7:5: error: lvalue required as left operand of assignment\r\nMain.c:7:5: error: lvalue required as left operand of assignment\r\nMain.c:7:', 0, 0, 2, 1, '2011-01-12 16:44:17', '0001-01-01 00:00:00'),
(1314, 39, 44, 0, '#include <stdio.h>\r\n\r\nint main(){\r\n    char a,b,c,d,e;\r\n    scanf("%c%c%c%c%c",&a,&b,&c,&d,&e); \r\n    short i=(short)a,j=(short)b,k=(short)c,l=(short)d,m=(short)e;\r\n    printf("%c%c%c%c%c",i<91?(i+4<91?i+=4:i-=22):(i+4<123?i+=4:i-=22),j<91?(j+4<91?j+=4:j-=22):(j+4<123?j+=4:j-=22),k<91?(k+4<91?k+=4:k-=22):(k+4<123?k+=4:k-=22),l<91?(l+4<91?l+=4:l-=22):(l+4<123?l+=4:l-=22),m<91?(m+4<91?m+=4:m-=22):(m+4<123?m+=4:m-=22));\r\n    //system("pause");\r\n    return 0;\r\n}', 'Main.c: In function ''main'':\r\nMain.c:7:5: error: lvalue required as left operand of assignment\r\nMain.c:7:5: error: lvalue required as left operand of assignment\r\nMain.c:7:5: error: lvalue required as left operand of assignment\r\nMain.c:7:5: error: lvalue required as left operand of assignment\r\nMain.c:7:5: error: lvalue required as left operand of assignment\r\nMain.c:7:5: error: lvalue required as left operand of assignment\r\nMain.c:7:5: error: lvalue required as left operand of assignment\r\nMain.c:7:', 0, 0, 2, 1, '2011-01-12 16:44:55', '0001-01-01 00:00:00'),
(1315, 39, 44, 0, '#include <stdio.h>\r\n\r\nint main(){\r\n    char a,b,c,d,e;\r\n    scanf("%c%c%c%c%c",&a,&b,&c,&d,&e); \r\n    short i=(short)a,j=(short)b,k=(short)c,l=(short)d,m=(short)e;\r\n    printf("%c%c%c%c%c",i<91?(i+4<91?i+=4:i-=22):(i+4<123?i+=4:i-=22),j<91?(j+4<91?j+=4:j-=22):(j+4<123?j+=4:j-=22),k<91?(k+4<91?k+=4:k-=22):(k+4<123?k+=4:k-=22),l<91?(l+4<91?l+=4:l-=22):(l+4<123?l+=4:l-=22),m<91?(m+4<91?m+=4:m-=22):(m+4<123?m+=4:m-=22));\r\n    //system("pause");\r\n    return 0;\r\n}', '', 0, 253952, 4, 2, '2011-01-12 16:45:39', '0001-01-01 00:00:00'),
(1316, 39, 44, 0, '#include <stdio.h>\r\n\r\nint main(){\r\n    char a,b,c,d,e;\r\n    while(scanf("%c%c%c%c%c",&a,&b,&c,&d,&e)==5)\r\n    {\r\n                                getchar(); \r\n     short i=(short)a,j=(short)b,k=(short)c,l=(short)d,m=(short)e;\r\n     printf("%c%c%c%c%c\\n",i<91?(i+4<91?i+=4:i-=22):(i+4<123?i+=4:i-=22),j<91?(j+4<91?j+=4:j-=22):(j+4<123?j+=4:j-=22),k<91?(k+4<91?k+=4:k-=22):(k+4<123?k+=4:k-=22),l<91?(l+4<91?l+=4:l-=22):(l+4<123?l+=4:l-=22),m<91?(m+4<91?m+=4:m-=22):(m+4<123?m+=4:m-=22));\r\n    }\r\n    //system("pause");\r\n    return 0;\r\n}', '', 0, 253952, 4, 2, '2011-01-12 16:50:34', '0001-01-01 00:00:00'),
(1317, 39, 44, 0, '#include <stdio.h>\r\n\r\nint main(){\r\n    char a[5];\r\n    while(scanf("%c%c%c%c%c",&a[0],&a[1],&a[2],&a[3],&a[4])==5)\r\n    {\r\n                                getchar(); \r\n    // short i=(short)a,j=(short)b,k=(short)c,l=(short)d,m=(short)e;\r\n    // printf("%c%c%c%c%c\\n",i<91?(i+4<91?i+=4:i-=22):(i+4<123?i+=4:i-=22),j<91?(j+4<91?j+=4:j-=22):(j+4<123?j+=4:j-=22),k<91?(k+4<91?k+=4:k-=22):(k+4<123?k+=4:k-=22),l<91?(l+4<91?l+=4:l-=22):(l+4<123?l+=4:l-=22),m<91?(m+4<91?m+=4:m-=22):(m+4<123?m+=4:m-=22));\r\n    for(int i = 0; i < 5; i++)\r\n    {\r\n    if(a[i]>=''x''&&a[i]<=''z'') a[i]-=22;\r\n    else if(a[i]>=''a''&&a[i]<''x'') a[i] += 4;\r\n    \r\n    else if(a[i]>=''X''&&a[i]<=''Z'') a[i]-=22;\r\n    else if(a[i]>=''A''&&a[i]<''X'') a[i] += 4;\r\n}\r\n\r\n    printf("%c%c%c%c%c\\n",a[0],a[1],a[2],a[3],a[4]);\r\n    \r\n    \r\n    }\r\n   // system("pause");\r\n    return 0;\r\n}', '', 0, 253952, 4, 2, '2011-01-12 17:01:23', '0001-01-01 00:00:00'),
(1318, 39, 44, 0, '#include <stdio.h>\r\n\r\nint main(){\r\n    char a[5];\r\n    while(scanf("%c%c%c%c%c",&a[0],&a[1],&a[2],&a[3],&a[4])==5)\r\n    {\r\n                                getchar(); \r\n    // short i=(short)a,j=(short)b,k=(short)c,l=(short)d,m=(short)e;\r\n    // printf("%c%c%c%c%c\\n",i<91?(i+4<91?i+=4:i-=22):(i+4<123?i+=4:i-=22),j<91?(j+4<91?j+=4:j-=22):(j+4<123?j+=4:j-=22),k<91?(k+4<91?k+=4:k-=22):(k+4<123?k+=4:k-=22),l<91?(l+4<91?l+=4:l-=22):(l+4<123?l+=4:l-=22),m<91?(m+4<91?m+=4:m-=22):(m+4<123?m+=4:m-=22));\r\n    for(int i = 0; i < 5; i++)\r\n    {\r\n    if(a[i]>=''w''&&a[i]<=''z'') a[i]-=54;\r\n    else if(a[i]>=''a''&&a[i]<''w'') a[i] += 4;\r\n    \r\n    else if(a[i]>=''W''&&a[i]<=''Z'') a[i]+=10;\r\n    else if(a[i]>=''A''&&a[i]<''W'') a[i] += 4;\r\n}\r\n\r\n    printf("%c%c%c%c%c\\n",a[0],a[1],a[2],a[3],a[4]);\r\n    \r\n    \r\n    }\r\n   // system("pause");\r\n    return 0;\r\n}', '', 0, 258048, 4, 2, '2011-01-12 17:09:36', '0001-01-01 00:00:00'),
(1319, 39, 44, 0, '#include <stdio.h>\r\n\r\nint main(){\r\n    char a[5];\r\n    while(scanf("%c%c%c%c%c",&a[0],&a[1],&a[2],&a[3],&a[4])==5)\r\n    {\r\n        getchar(); \r\n        // short i=(short)a,j=(short)b,k=(short)c,l=(short)d,m=(short)e;\r\n        // printf("%c%c%c%c%c\\n",i<91?(i+4<91?i+=4:i-=22):(i+4<123?i+=4:i-=22),j<91?(j+4<91?j+=4:j-=22):(j+4<123?j+=4:j-=22),k<91?(k+4<91?k+=4:k-=22):(k+4<123?k+=4:k-=22),l<91?(l+4<91?l+=4:l-=22):(l+4<123?l+=4:l-=22),m<91?(m+4<91?m+=4:m-=22):(m+4<123?m+=4:m-=22));\r\n        for(int i = 0; i < 5; i++)\r\n        {\r\n            if(a[i]>=''w''&&a[i]<=''z'') a[i]-=22;\r\n            else if(a[i]>=''a''&&a[i]<''w'') a[i] += 4;\r\n            \r\n            else if(a[i]>=''W''&&a[i]<=''Z'') a[i]-=22;\r\n            else if(a[i]>=''A''&&a[i]<''W'') a[i] += 4;\r\n        }\r\n    \r\n        printf("%c%c%c%c%c\\n",a[0],a[1],a[2],a[3],a[4]);\r\n        \r\n        \r\n    }\r\n   // system("pause");\r\n    return 0;\r\n}', '', 0, 253952, 4, 2, '2011-01-12 17:12:04', '0001-01-01 00:00:00'),
(1320, 39, 43, 0, '#include <stdio.h>\r\n\r\nint main(){\r\n    int a,b,c;\r\n    scanf("%d%d%d",&a,&b,&c);\r\n    if(a>=b&&a>=c) printf("%d\\n",a);\r\n    else if(b>=a&&b>=c) printf("%d\\n",b);\r\n    else if(c>=a&&c>=b) printf("%d\\n",c);\r\n\r\n    return 0;\r\n}', '', 0, 253952, 3, 2, '2011-01-13 15:51:28', '0001-01-01 00:00:00'),
(1321, 39, 43, 0, '#include <stdio.h>\r\n\r\nint main(){\r\n    int a,b,c;\r\n    scanf("%d%d%d",&a,&b,&c);\r\n    if(a>=b&&a>=c) printf("%d",a);\r\n    else if(b>=a&&b>=c) printf("%d",b);\r\n    else if(c>=a&&c>=b) printf("%d",c);\r\n\r\n    return 0;\r\n}', '', 0, 258048, 1, 2, '2011-01-13 15:52:02', '0001-01-01 00:00:00'),
(1322, 39, 50, 0, '#include <stdio.h>\r\n\r\nint main(){\r\n   short cnt=0;\r\n   char c[5]={};\r\n   scanf("%s",&c);\r\n   int i,j;\r\n   for(i=0;i<5;i++){\r\n           if(c[i]!=''\\0'') cnt++;\r\n   }  \r\n   printf("%d\\n",cnt);\r\n   for(j=0;j<cnt;j++){\r\n         if(j==cnt-1){printf("%c\\n",c[j]);}\r\n         else{ printf("%c ",c[j]);}\r\n   }\r\n   for(j=cnt-1;j>=0;j--){\r\n        printf("%c",c[j]);\r\n   }\r\n}', '', 0, 258048, 1, 2, '2011-01-13 16:31:24', '0001-01-01 00:00:00'),
(1323, 39, 49, 0, '#include <stdio.h>\r\n\r\nint main(){\r\n    int a;\r\n    scanf("%d",&a);\r\n    if(a<60) printf("%c",''E'');\r\n    else if(a<70) printf("%c",''D'');\r\n    else if(a<80) printf("%c",''C'');\r\n    else if(a<90) printf("%c",''B'');\r\n    else printf("%c",''A'');\r\n}', '', 0, 258048, 1, 1, '2011-01-13 16:36:18', '0001-01-01 00:00:00'),
(1324, 12, 335, 2, '#include<stdio.h>\r\nint main()\r\n{\r\n	int a,b;\r\n	while(scanf("%d%d",&a,&b)==2)\r\n	{\r\n		int count=0;\r\n		a=a^b;\r\n		while(a)\r\n		{\r\n			a=a&(a-1);\r\n			count++;\r\n		}\r\n		printf("%d\\n",count);\r\n	}   	\r\n  	return 0;\r\n}\r\n\r\n', '', 62, 253952, 1, 1, '2011-01-17 11:07:06', '0001-01-01 00:00:00'),
(1325, 12, 336, 2, '#include<iostream>\r\n#include<vector>\r\n#include<algorithm>\r\n#include<stdio.h>\r\nusing namespace std;\r\n#define N 50000\r\nint getBitCount_method1(int n)\r\n{\r\n    int num = 0;\r\n    while(n)\r\n    {\r\n         n &=(n-1);\r\n         num++;\r\n         }\r\n    return num;\r\n}\r\n\r\nint Cmp(const void*a,const void *b)\r\n{\r\n    return(*(int *)a-*(int *)b);\r\n} \r\n\r\nvector<int> getSortVec(int a[], int count[], int n)\r\n{\r\n  vector<int> rstVec;\r\n  vector<int> vecArray[33]; \r\n  int i;\r\n  int j;\r\n  for ( i = 0; i < n; ++i)\r\n  {\r\n     vecArray[count[i]].push_back(a[i]); \r\n  }\r\n\r\n\r\nfor ( i = 0; i <= 32; ++i)\r\n{\r\n   for ( j = 0; j < vecArray[i].size(); ++j)\r\n   {\r\n    rstVec.push_back(vecArray[i][j]);\r\n   }\r\n}\r\nreturn rstVec;\r\n}\r\nint main()\r\n{\r\n    int n;\r\n    int i;\r\n    int a[N];\r\n    while(scanf("%d",&n)==1)\r\n    {\r\n        for(i=0;i<n;i++)\r\n            scanf("%d",&a[i]);\r\n        qsort(a,n,sizeof(a[0]),Cmp); \r\n        int count[N];\r\n        for ( i = 0; i < n; ++i)\r\n       {\r\n          count[i] = getBitCount_method1(a[i]);\r\n        }\r\n\r\n\r\nvector<int> rstVec = getSortVec(a, count, n);\r\n\r\nfor ( i = 0; i <rstVec.size(); ++i)\r\n{ \r\n	if(i==rstVec.size()-1)\r\n     cout << rstVec[i] ;\r\n   else \r\n    cout << rstVec[i] << " ";\r\n}\r\ncout << endl;\r\n\r\n}\r\nreturn 0;\r\n}\r\n', '', 61, 1728512, 1, 2, '2011-01-17 11:08:06', '0001-01-01 00:00:00');
INSERT INTO `tbl_submitions` (`id`, `user_id`, `problem_id`, `exercise_id`, `source`, `result`, `used_time`, `used_memory`, `status`, `compiler_id`, `created`, `modified`) VALUES
(1326, 12, 338, 3, '#include<stdio.h>\r\nint main()\r\n{\r\n	int a[1000],i,n,k,num;\r\n	int kmin,kmax,kminnumber,kmaxnumber;	\r\n    while(scanf("%d %d",&n,&k)==2){\r\n  		for(i=0;i<1000;++i)	a[i]=0;\r\n		for(i=0;i<n;++i){\r\n			scanf("%d",&num);\r\n			++a[num];\r\n		}\r\n//		for(i=0;i<10;++i)	printf("%d  ",a[i]);\r\n//		printf("\\n");\r\n		kminnumber=-1;\r\n		kmaxnumber=-1;\r\n		for(i=0;i<1000;++i){\r\n			kminnumber+=a[i];\r\n//			printf("%d\\n",kminnumber);\r\n			if(k<=kminnumber) { kmin=i;  break;}			\r\n		}\r\n//		printf("%d\\n",kmin);\r\n		for(i=999;i>0;--i){\r\n			kmaxnumber+=a[i];\r\n			if(k<=kmaxnumber) { kmax=i;  break;}\r\n		}\r\n//		printf("%d\\n",kmax);\r\n		printf("%d\\n",kmax-kmin);\r\n	}\r\n    return 0;\r\n}\r\n\r\n', '', 358, 253952, 1, 1, '2011-01-17 11:09:18', '0001-01-01 00:00:00'),
(1327, 12, 339, 3, '#include<stdio.h>\r\nint countnumber(int n)\r\n{\r\n		int count=0;\r\n		while(n)\r\n		{\r\n			n=n&(n-1);\r\n			count++;\r\n		}\r\n  	return count;\r\n}\r\n\r\nint Partition(int a[],int low,int high)\r\n{\r\n	int pivotkey=a[low];\r\n	a[0]=a[low];\r\n    while(low<high){\r\n		while(low<high && a[high]>=pivotkey) --high;\r\n		a[low]=a[high];\r\n		while(low<high && a[low]<=pivotkey) ++low;\r\n		a[high]=a[low];\r\n	}\r\n	a[low]=a[0];\r\n	return low;\r\n}\r\n\r\nvoid qsort(int a[],int low,int high)\r\n{\r\n	int pivotloc;\r\n	if(low<high){\r\n		pivotloc=Partition(a,low,high);\r\n		qsort(a,low,pivotloc-1);\r\n		qsort(a,pivotloc+1,high);\r\n	}\r\n}\r\n\r\n\r\nint main()\r\n{\r\n	int a[100000],k[1000],i,n,r,num;	\r\n    while(scanf("%d %d",&n,&r)==2){\r\n		for(i=1;i<=r;++i) scanf("%d",&k[i]);\r\n        for(i=1;i<=n;++i) scanf("%d",&a[i]);\r\n//		for(i=0;i<10;++i)	printf("%d  ",a[i]);\r\n//		printf("\\n");\r\n\r\n        qsort(a,1,n);\r\n //       for(i=1;i<=n;++i) printf("%d\\n",a[i]);\r\n        for(i=1;i<=r;++i) printf("%d\\n",a[n-k[i]]);\r\n	}\r\n    return 0;\r\n}\r\n', '', 202, 626688, 1, 2, '2011-01-17 11:09:57', '0001-01-01 00:00:00'),
(1328, 12, 402, 8, '#include<stdio.h>\r\n#include<string>\r\n#include<iostream>\r\nusing namespace std;\r\nint main()\r\n{\r\n	int sum[2002],a[2001],b[2001];\r\n	int T,i,k;\r\n	int n,n1,n2,c;\r\n	string s1,s2;\r\n	scanf("%d",&T);\r\n	for(k=0;k<T;++k){\r\n	   cin>>s1;\r\n	   n1=s1.length();\r\n	   for(i=n1-1;i>=0;--i)  a[i]=s1[n1-i-1]-''0'';\r\n 	   cin>>s2;\r\n	   n2=s2.length();\r\n	   for(i=n2-1;i>=0;--i)  b[i]=s2[n2-i-1]-''0'';\r\n	   \r\n	   c=0;\r\n	   if(n1<n2){\r\n           n=n2;	\r\n    	   for(i=0;i<n1;++i){\r\n    	       sum[i]=a[i]+b[i]+c;\r\n    	       if(sum[i]>9){\r\n    	           sum[i]=sum[i]-10;\r\n                   c=1;\r\n               }else c=0;\r\n           }\r\n           for(;i<n2;++i){\r\n                sum[i]=b[i]+c;\r\n                if(sum[i]>9){\r\n    	           sum[i]=sum[i]-10;\r\n                   c=1;\r\n               }else c=0;\r\n           }\r\n           if(c==1) { sum[i]=1; ++n; }\r\n       }\r\n       else{\r\n               n=n1;\r\n               for(i=0;i<n2;++i){\r\n    	       sum[i]=a[i]+b[i]+c;\r\n    	       if(sum[i]>9){\r\n    	           sum[i]=sum[i]-10;\r\n                   c=1;\r\n               }else c=0;\r\n           }\r\n           for(;i<n1;++i){\r\n                sum[i]=a[i]+c;\r\n                if(sum[i]>9){\r\n    	           sum[i]=sum[i]-10;\r\n                   c=1;\r\n               }else c=0;\r\n           }\r\n           if(c==1) { sum[i]=1;  ++n; }\r\n       }\r\n       printf("Case %d:\\n",k+1);      	   \r\n\r\n//	   for(i=n1-1;i>=0;--i) printf("%d",a[i]);\r\n       cout<<s1;\r\n	   printf(" + ");\r\n//	   for(i=n2-1;i>=0;--i) printf("%d",b[i]);\r\n       cout<<s2;\r\n	   printf(" = ");\r\n\r\n	   for(i=n-1;i>=0;--i) printf("%d",sum[i]);\r\n	   printf("\\n");\r\n	   if(k<T-1) printf("\\n");\r\n    }\r\n	return 0;\r\n}\r\n', '', 93, 364544, 1, 2, '2011-01-17 11:10:57', '0001-01-01 00:00:00'),
(1329, 15, 402, 8, '#include<stdio.h>\r\n#include<string>\r\n#include<iostream>\r\nusing namespace std;\r\nint main()\r\n{\r\n	int sum[2002],a[2001],b[2001];\r\n	int T,i,k;\r\n	int n,n1,n2,c;\r\n	string s1,s2;\r\n	scanf("%d",&T);\r\n	for(k=0;k<T;++k){\r\n	   cin>>s1;\r\n	   n1=s1.length();\r\n	   for(i=n1-1;i>=0;--i)  a[i]=s1[n1-i-1]-''0'';\r\n 	   cin>>s2;\r\n	   n2=s2.length();\r\n	   for(i=n2-1;i>=0;--i)  b[i]=s2[n2-i-1]-''0'';\r\n	   \r\n	   c=0;\r\n	   if(n1<n2){\r\n           n=n2;	\r\n    	   for(i=0;i<n1;++i){\r\n    	       sum[i]=a[i]+b[i]+c;\r\n    	       if(sum[i]>9){\r\n    	           sum[i]=sum[i]-10;\r\n                   c=1;\r\n               }else c=0;\r\n           }\r\n           for(;i<n2;++i){\r\n                sum[i]=b[i]+c;\r\n                if(sum[i]>9){\r\n    	           sum[i]=sum[i]-10;\r\n                   c=1;\r\n               }else c=0;\r\n           }\r\n           if(c==1) { sum[i]=1; ++n; }\r\n       }\r\n       else{\r\n               n=n1;\r\n               for(i=0;i<n2;++i){\r\n    	       sum[i]=a[i]+b[i]+c;\r\n    	       if(sum[i]>9){\r\n    	           sum[i]=sum[i]-10;\r\n                   c=1;\r\n               }else c=0;\r\n           }\r\n           for(;i<n1;++i){\r\n                sum[i]=a[i]+c;\r\n                if(sum[i]>9){\r\n    	           sum[i]=sum[i]-10;\r\n                   c=1;\r\n               }else c=0;\r\n           }\r\n           if(c==1) { sum[i]=1;  ++n; }\r\n       }\r\n       printf("Case %d:\\n",k+1);      	   \r\n\r\n//	   for(i=n1-1;i>=0;--i) printf("%d",a[i]);\r\n       cout<<s1;\r\n	   printf(" + ");\r\n//	   for(i=n2-1;i>=0;--i) printf("%d",b[i]);\r\n       cout<<s2;\r\n	   printf(" = ");\r\n\r\n	   for(i=n-1;i>=0;--i) printf("%d",sum[i]);\r\n	   printf("\\n");\r\n	   if(k<T-1) printf("\\n");\r\n    }\r\n	return 0;\r\n}\r\n', '', 93, 364544, 1, 2, '2011-01-17 11:11:42', '0001-01-01 00:00:00'),
(1330, 12, 375, 5, '#include<stdio.h>\r\nint main()\r\n{\r\n	int a[50000];\r\n	int b[50001]={0};\r\n    int i,j,n,k;\r\n    while(scanf("%d",&n)==1){\r\n    	for(i=0;i<n;++i) scanf("%d",&a[i]);\r\n        k=1;\r\n        b[1]=a[0];\r\n        for(i=1;i<n;i++){\r\n        for(j=k;j>=1 && b[j]>a[i];--j);\r\n        b[j+1]=a[i];\r\n        if(j==k) k++;\r\n        }  \r\n		printf("%d\\n",k);  \r\n    }\r\n    \r\n    return 0;\r\n}\r\n', '', 187, 618496, 1, 2, '2011-01-17 11:11:47', '0001-01-01 00:00:00'),
(1331, 12, 376, 5, '#include<stdio.h>\r\nint main()\r\n{\r\n	long long array[50000],mul[50000],a[50000],b[50000];\r\n	long long max;\r\n	int n,i,count;\r\n //    int x=0;\r\n	while(scanf("%d",&n)==1){\r\n		count=0;\r\n		for(i=0;i<n;++i){\r\n		    scanf("%I64d",&array[i]);\r\n            if(array[i]==0) ++count;\r\n		}\r\n		if(n>1){\r\n	   	  if(count>1)  printf("0");\r\n          else{					\r\n			a[0]=array[0];\r\n			for(i=1;i<n-1;++i)  a[i]=a[i-1]*array[i];\r\n//			printf("%d&\\n",x++);\r\n			b[n-1]=array[n-1];\r\n	//		printf("%d&&\\n",x++);\r\n			for(i=n-2;i>0;--i)  b[i]=b[i+1]*array[i];\r\n			\r\n	//		printf("%d***\\n",x++);\r\n			\r\n			mul[0]=b[1];\r\n			for(i=1;i<n-1;++i) mul[i]=a[i-1]*b[i+1];\r\n			mul[n-1]=a[n-2];\r\n			\r\n	//		printf("%d\\n",x++);\r\n			\r\n			max=mul[0];\r\n			for(i=1;i<n;++i){\r\n				if(max<mul[i])  max=mul[i];\r\n			}\r\n			printf("%I64d",max);		\r\n		 }\r\n	  	 printf("\\n");\r\n		}\r\n	}\r\n	return 0;\r\n}\r\n', '', 78, 1810432, 1, 1, '2011-01-17 11:12:38', '0001-01-01 00:00:00'),
(1332, 15, 403, 8, '#include<stdio.h>\r\n#include<string.h>\r\n#include<stdlib.h>\r\n#define MAX 5\r\nint main()\r\n{\r\n	int n,m,i,j,s_length;\r\n    int a[10000];\r\n    char num_str[50000],str[MAX],s[MAX];\r\n	while(scanf("%d",&n)==1){\r\n		if(n>1){\r\n			m=1;\r\n			a[0]=1;			\r\n			for(i=2;i<=n;++i){\r\n				for(j=0;j<m;++j){\r\n					a[j]*=i;\r\n				}\r\n				for(j=0;j<m-1;++j){\r\n					a[j+1]+=a[j]/10000;\r\n					a[j]=a[j]%10000;\r\n				}\r\n				if(a[j]>=10000){\r\n					a[j+1]=a[j]/10000;\r\n					a[j]=a[j]%10000;\r\n					++m;\r\n				}\r\n		     }\r\n		     \r\n		     strcpy(num_str,"");\r\n		     \r\n      	     itoa(a[m-1],s,10);\r\n             strcat(num_str,s);           \r\n             for(i=m-2;i>=0;--i){\r\n             	strcpy(str,"");\r\n             	itoa(a[i],s,10);\r\n             	switch( strlen(s) )\r\n             	{\r\n             		case 1:\r\n         		       strcat(str,"000");\r\n         		       strcat(str,s);\r\n         		       break;\r\n      		       case 2:\r\n	                   strcat(str,"00");\r\n	                   strcat(str,s);\r\n	                   break;\r\n                   case 3:\r\n                       strcat(str,"0");\r\n                       strcat(str,s);\r\n                       break;\r\n                   default:\r\n                       strcpy(str,s);\r\n             	}                \r\n			    strcat(num_str,str);\r\n             }\r\n             \r\n             printf("%s\\n",num_str);\r\n						\r\n		}else printf("1\\n");\r\n\r\n	}\r\n}\r\n', '', 655, 311296, 1, 1, '2011-01-17 11:13:06', '0001-01-01 00:00:00'),
(1333, 12, 344, 4, '#include <stdio.h>\r\n#include <map>\r\n#include <string>\r\n#include <iostream>\r\nusing namespace std;\r\nint main(int argc, char* argv[])\r\n{\r\n	int n,i;\r\n	string str;\r\n    while(scanf("%d",&n)==1){\r\n		int length=0;\r\n    	map<string,int> m;\r\n    	for(i=1;i<=n;++i){\r\n			cin>>str;\r\n    		if(m.find(str)!=m.end()){\r\n				length=i-m[str];\r\n			}else{   m.insert(pair<string,int>(str,i));  }\r\n		}\r\n    	printf("%d\\n",length);\r\n	}\r\n    return 0;\r\n}\r\n\r\n\r\n查找链表的环和入口\r\n	LNode *slow=head,*fast=head;\r\n	while  ( fast  &&  fast -> next )  {\r\n        slow  =  slow -> next;\r\n        fast  =  fast -> next -> next;\r\n        if  ( slow  ==  fast )  break ;\r\n    }\r\n    if  (fast  ==  NULL  ||  fast -> next  ==  NULL)\r\n        return  1;\r\n    slow  =  head;\r\n	i=0;\r\n    while  (slow  !=  fast) {\r\n		 ++i;\r\n         slow  =  slow -> next;\r\n         fast  =  fast -> next;\r\n    }\r\n	printf("%d\\n",n-i);\r\n}\r\n', 'Main.c:2:15: fatal error: map: No such file or directory\r\ncompilation terminated.\r\n', 0, 0, 2, 1, '2011-01-17 11:14:04', '0001-01-01 00:00:00'),
(1334, 12, 377, 6, '#include <stdio.h>\r\nfloat x1[300],x2[300],y1[300],y2[300];\r\n\r\nint judge(int i,int j)\r\n{\r\n	float a,b;\r\n	a=(x2[j]-x2[i])*(y1[i]-x1[i])-(x1[j]-x1[i])*(y2[i]-x2[i]);\r\n	b=(y2[j]-x2[i])*(y1[i]-x1[i])-(y1[j]-x1[i])*(y2[i]-x2[i]);\r\n	if( (a*b)<0 )   return 1;  \r\n	else if(a*b==0.0){\r\n		if( (x1[j]>=x1[i] && x1[j]<=y1[i]) || (x1[j]<=x1[i] && x1[j]>=y1[i]) ){\r\n		    return 1;\r\n		}\r\n		if( (y1[j]>=x1[i] && y1[j]<=y1[i]) || (y1[j]<=x1[i] && y1[j]>=y1[i]) ){\r\n		    return 1;\r\n		}\r\n	}\r\n	else  return 0;\r\n}\r\n\r\nint judge_intersete(int i,int j)\r\n{\r\n	if(judge(i,j)==1 && judge(j,i)==1)\r\n		return 1;\r\n	else return 0;\r\n}\r\n\r\nint main()\r\n{\r\n	int n,i,j,count;\r\n	while(scanf("%d",&n) && n>0){	\r\n		count=0;\r\n		for(i=0;i<n;++i){\r\n			scanf("%f %f %f %f",&x1[i],&x2[i],&y1[i],&y2[i]);\r\n		}\r\n		for(i=0;i<n-1;++i){\r\n			for(j=i+1;j<n;++j){\r\n				count+=judge_intersete(i,j);\r\n			}\r\n		}\r\n		printf("%d\\n",count);\r\n\r\n	}\r\n	return 0;\r\n}\r\n', '', 61, 262144, 1, 1, '2011-01-17 11:15:05', '0001-01-01 00:00:00'),
(1335, 15, 375, 5, '#include<stdio.h>\r\nint main()\r\n{\r\n	int a[50000];\r\n	int b[50001]={0};\r\n    int i,j,n,k;\r\n    while(scanf("%d",&n)==1){\r\n    	for(i=0;i<n;++i) scanf("%d",&a[i]);\r\n        k=1;\r\n        b[1]=a[0];\r\n        for(i=1;i<n;i++){\r\n        for(j=k;j>=1 && b[j]>a[i];--j);\r\n        b[j+1]=a[i];\r\n        if(j==k) k++;\r\n        }  \r\n		printf("%d\\n",k);  \r\n    }\r\n    \r\n    return 0;\r\n}\r\n', '', 202, 618496, 1, 1, '2011-01-17 20:43:42', '0001-01-01 00:00:00'),
(1336, 15, 344, 4, '#include <stdio.h>\r\n#include <map>\r\n#include <string>\r\n#include <iostream>\r\nusing namespace std;\r\nint main(int argc, char* argv[])\r\n{\r\n	int n,i;\r\n	string str;\r\n    while(scanf("%d",&n)==1){\r\n		int length=0;\r\n    	map<string,int> m;\r\n    	for(i=1;i<=n;++i){\r\n			cin>>str;\r\n    		if(m.find(str)!=m.end()){\r\n				length=i-m[str];\r\n			}else{   m.insert(pair<string,int>(str,i));  }\r\n		}\r\n    	printf("%d\\n",length);\r\n	}\r\n    return 0;\r\n}\r\n\r\n', 'Main.c:2:15: fatal error: map: No such file or directory\r\ncompilation terminated.\r\n', 0, 0, 2, 1, '2011-01-17 20:45:35', '0001-01-01 00:00:00'),
(1337, 15, 338, 3, '#include<stdio.h>\r\nint main()\r\n{\r\n	int a[1000],i,n,k,num;\r\n	int kmin,kmax,kminnumber,kmaxnumber;	\r\n    while(scanf("%d %d",&n,&k)==2){\r\n  		for(i=0;i<1000;++i)	a[i]=0;\r\n		for(i=0;i<n;++i){\r\n			scanf("%d",&num);\r\n			++a[num];\r\n		}\r\n//		for(i=0;i<10;++i)	printf("%d  ",a[i]);\r\n//		printf("\\n");\r\n		kminnumber=-1;\r\n		kmaxnumber=-1;\r\n		for(i=0;i<1000;++i){\r\n			kminnumber+=a[i];\r\n//			printf("%d\\n",kminnumber);\r\n			if(k<=kminnumber) { kmin=i;  break;}			\r\n		}\r\n//		printf("%d\\n",kmin);\r\n		for(i=999;i>0;--i){\r\n			kmaxnumber+=a[i];\r\n			if(k<=kmaxnumber) { kmax=i;  break;}\r\n		}\r\n//		printf("%d\\n",kmax);\r\n		printf("%d\\n",kmax-kmin);\r\n	}\r\n    return 0;\r\n}\r\n', '', 327, 258048, 1, 1, '2011-01-17 20:47:08', '0001-01-01 00:00:00'),
(1338, 15, 377, 6, '#include <stdio.h>\r\nfloat x1[300],x2[300],y1[300],y2[300];\r\n\r\nint judge(int i,int j)\r\n{\r\n	float a,b;\r\n	a=(x2[j]-x2[i])*(y1[i]-x1[i])-(x1[j]-x1[i])*(y2[i]-x2[i]);\r\n	b=(y2[j]-x2[i])*(y1[i]-x1[i])-(y1[j]-x1[i])*(y2[i]-x2[i]);\r\n	if( (a*b)<0 )   return 1;  \r\n	else if(a*b==0.0){\r\n		if( (x1[j]>=x1[i] && x1[j]<=y1[i]) || (x1[j]<=x1[i] && x1[j]>=y1[i]) ){\r\n		    return 1;\r\n		}\r\n		if( (y1[j]>=x1[i] && y1[j]<=y1[i]) || (y1[j]<=x1[i] && y1[j]>=y1[i]) ){\r\n		    return 1;\r\n		}\r\n	}\r\n	else  return 0;\r\n}\r\n\r\nint judge_intersete(int i,int j)\r\n{\r\n	if(judge(i,j)==1 && judge(j,i)==1)\r\n		return 1;\r\n	else return 0;\r\n}\r\n\r\nint main()\r\n{\r\n	int n,i,j,count;\r\n	while(scanf("%d",&n) && n>0){	\r\n		count=0;\r\n		for(i=0;i<n;++i){\r\n			scanf("%f %f %f %f",&x1[i],&x2[i],&y1[i],&y2[i]);\r\n		}\r\n		for(i=0;i<n-1;++i){\r\n			for(j=i+1;j<n;++j){\r\n				count+=judge_intersete(i,j);\r\n			}\r\n		}\r\n		printf("%d\\n",count);\r\n\r\n	}\r\n	return 0;\r\n}\r\n', '', 61, 262144, 1, 1, '2011-01-17 20:49:46', '0001-01-01 00:00:00'),
(1339, 9, 336, 2, '#include<iostream>\r\n#include<vector>\r\n#include<algorithm>\r\n#include<stdio.h>\r\nusing namespace std;\r\n#define N 50000\r\nint getBitCount_method1(int n)\r\n{\r\n    int num = 0;\r\n    while(n)\r\n    {\r\n         n &=(n-1);\r\n         num++;\r\n         }\r\n    return num;\r\n}\r\n\r\nint Cmp(const void*a,const void *b)\r\n{\r\n    return(*(int *)a-*(int *)b);\r\n} \r\n\r\nvector<int> getSortVec(int a[], int count[], int n)\r\n{\r\n  vector<int> rstVec;\r\n  vector<int> vecArray[33]; \r\n  int i;\r\n  int j;\r\n  for ( i = 0; i < n; ++i)\r\n  {\r\n     vecArray[count[i]].push_back(a[i]); \r\n  }\r\n\r\n\r\nfor ( i = 0; i <= 32; ++i)\r\n{\r\n   for ( j = 0; j < vecArray[i].size(); ++j)\r\n   {\r\n    rstVec.push_back(vecArray[i][j]);\r\n   }\r\n}\r\nreturn rstVec;\r\n}\r\nint main()\r\n{\r\n    int n;\r\n    int i;\r\n    int a[N];\r\n    while(scanf("%d",&n)==1)\r\n    {\r\n        for(i=0;i<n;i++)\r\n            scanf("%d",&a[i]);\r\n        qsort(a,n,sizeof(a[0]),Cmp); \r\n        int count[N];\r\n        for ( i = 0; i < n; ++i)\r\n       {\r\n          count[i] = getBitCount_method1(a[i]);\r\n        }\r\n\r\n\r\nvector<int> rstVec = getSortVec(a, count, n);\r\n\r\nfor ( i = 0; i <rstVec.size(); ++i)\r\n{ \r\n	if(i==rstVec.size()-1)\r\n     cout << rstVec[i] ;\r\n   else \r\n    cout << rstVec[i] << " ";\r\n}\r\ncout << endl;\r\n\r\n}\r\nreturn 0;\r\n}\r\n', '', 77, 1728512, 1, 2, '2011-01-17 23:11:31', '0001-01-01 00:00:00'),
(1340, 9, 338, 3, '#include<stdio.h>\r\nint main()\r\n{\r\n	int a[1000],i,n,k,num;\r\n	int kmin,kmax,kminnumber,kmaxnumber;	\r\n    while(scanf("%d %d",&n,&k)==2){\r\n  		for(i=0;i<1000;++i)	a[i]=0;\r\n		for(i=0;i<n;++i){\r\n			scanf("%d",&num);\r\n			++a[num];\r\n		}\r\n//		for(i=0;i<10;++i)	printf("%d  ",a[i]);\r\n//		printf("\\n");\r\n		kminnumber=-1;\r\n		kmaxnumber=-1;\r\n		for(i=0;i<1000;++i){\r\n			kminnumber+=a[i];\r\n//			printf("%d\\n",kminnumber);\r\n			if(k<=kminnumber) { kmin=i;  break;}			\r\n		}\r\n//		printf("%d\\n",kmin);\r\n		for(i=999;i>0;--i){\r\n			kmaxnumber+=a[i];\r\n			if(k<=kmaxnumber) { kmax=i;  break;}\r\n		}\r\n//		printf("%d\\n",kmax);\r\n		printf("%d\\n",kmax-kmin);\r\n	}\r\n    return 0;\r\n}\r\n\r\n\r\n\r\n#include<stdio.h>\r\nint main()\r\n{\r\n	int a[1000],i,n,k,num;\r\n	int kmin,kmax,kminnumber,kmaxnumber;	\r\n    while(scanf("%d %d",&n,&k)==2){\r\n  		for(i=0;i<1000;++i)	a[i]=0;\r\n		for(i=0;i<n;++i){\r\n			scanf("%d",&num);\r\n			++a[num];\r\n		}\r\n//		for(i=0;i<10;++i)	printf("%d  ",a[i]);\r\n//		printf("\\n");\r\n		kminnumber=-1;\r\n		kmaxnumber=-1;\r\n		for(i=0;i<1000;++i){\r\n			kminnumber+=a[i];\r\n//			printf("%d\\n",kminnumber);\r\n			if(k<=kminnumber) { kmin=i;  break;}			\r\n		}\r\n//		printf("%d\\n",kmin);\r\n		for(i=999;i>0;--i){\r\n			kmaxnumber+=a[i];\r\n			if(k<=kmaxnumber) { kmax=i;  break;}\r\n		}\r\n//		printf("%d\\n",kmax);\r\n		printf("%d\\n",kmax-kmin);\r\n	}\r\n    return 0;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n', 'Main.cpp: In function ''int main()'':\r\nMain.cpp:35:5: error: redefinition of ''int main()''\r\nMain.cpp:2:5: error: ''int main()'' previously defined here\r\n', 0, 0, 2, 2, '2011-01-19 11:06:06', '0001-01-01 00:00:00'),
(1341, 9, 344, 4, '#include <stdio.h>\r\n#include <map>\r\n#include <string>\r\n#include <iostream>\r\nusing namespace std;\r\nint main(int argc, char* argv[])\r\n{\r\n	int n,i;\r\n	string str;\r\n    while(scanf("%d",&n)==1){\r\n		int length=0;\r\n    	map<string,int> m;\r\n    	for(i=1;i<=n;++i){\r\n			cin>>str;\r\n    		if(m.find(str)!=m.end()){\r\n				length=i-m[str];\r\n			}else{   m.insert(pair<string,int>(str,i));  }\r\n		}\r\n    	printf("%d\\n",length);\r\n	}\r\n    return 0;\r\n}\r\n\r\n\r\n查找链表的环和入口\r\n	LNode *slow=head,*fast=head;\r\n	while  ( fast  &&  fast -> next )  {\r\n        slow  =  slow -> next;\r\n        fast  =  fast -> next -> next;\r\n        if  ( slow  ==  fast )  break ;\r\n    }\r\n    if  (fast  ==  NULL  ||  fast -> next  ==  NULL)\r\n        return  1;\r\n    slow  =  head;\r\n	i=0;\r\n    while  (slow  !=  fast) {\r\n		 ++i;\r\n         slow  =  slow -> next;\r\n         fast  =  fast -> next;\r\n    }\r\n	printf("%d\\n",n-i);\r\n}\r\n', 'Main.cpp:25:1: error: stray ''\\346'' in program\r\nMain.cpp:25:1: error: stray ''\\237'' in program\r\nMain.cpp:25:1: error: stray ''\\245'' in program\r\nMain.cpp:25:1: error: stray ''\\346'' in program\r\nMain.cpp:25:1: error: stray ''\\211'' in program\r\nMain.cpp:25:1: error: stray ''\\276'' in program\r\nMain.cpp:25:1: error: stray ''\\351'' in program\r\nMain.cpp:25:1: error: stray ''\\223'' in program\r\nMain.cpp:25:1: error: stray ''\\276'' in program\r\nMain.cpp:25:1: error: stray ''\\350'' in program\r\nMain.cpp:25:1: error: stray ''\\', 0, 0, 2, 2, '2011-01-19 11:07:05', '0001-01-01 00:00:00'),
(1342, 9, 339, 3, '#include<stdio.h>\r\nint countnumber(int n)\r\n{\r\n		int count=0;\r\n		while(n)\r\n		{\r\n			n=n&(n-1);\r\n			count++;\r\n		}\r\n  	return count;\r\n}\r\n\r\nint Partition(int a[],int low,int high)\r\n{\r\n	int pivotkey=a[low];\r\n	a[0]=a[low];\r\n    while(low<high){\r\n		while(low<high && a[high]>=pivotkey) --high;\r\n		a[low]=a[high];\r\n		while(low<high && a[low]<=pivotkey) ++low;\r\n		a[high]=a[low];\r\n	}\r\n	a[low]=a[0];\r\n	return low;\r\n}\r\n\r\nvoid qsort(int a[],int low,int high)\r\n{\r\n	int pivotloc;\r\n	if(low<high){\r\n		pivotloc=Partition(a,low,high);\r\n		qsort(a,low,pivotloc-1);\r\n		qsort(a,pivotloc+1,high);\r\n	}\r\n}\r\n\r\n\r\nint main()\r\n{\r\n	int a[100000],k[1000],i,n,r,num;	\r\n    while(scanf("%d %d",&n,&r)==2){\r\n		for(i=1;i<=r;++i) scanf("%d",&k[i]);\r\n        for(i=1;i<=n;++i) scanf("%d",&a[i]);\r\n//		for(i=0;i<10;++i)	printf("%d  ",a[i]);\r\n//		printf("\\n");\r\n\r\n        qsort(a,1,n);\r\n //       for(i=1;i<=n;++i) printf("%d\\n",a[i]);\r\n        for(i=1;i<=r;++i) printf("%d\\n",a[n-k[i]]);\r\n	}\r\n    return 0;\r\n}\r\n', '', 202, 622592, 1, 2, '2011-01-19 11:08:25', '0001-01-01 00:00:00'),
(1343, 9, 345, 4, '#include <stdio.h>\r\n#include <map>\r\n#include <string>\r\n#include <iostream>\r\n\r\nusing namespace std;\r\nint main()\r\n{\r\n	int n1,n2,i;\r\n	string name;\r\n    while(scanf("%d",&n1)==1){\r\n		string same_name1="none";\r\n		string same_name2="none";\r\n    	map<string,int> m;\r\n\r\n    	for(i=1;i<=n1;++i){\r\n			cin>>name;\r\n    		if(m.find(name)!=m.end()){\r\n				for(++i;i<=n1;++i) cin>>name;\r\n			}else{   m.insert(pair<string,int>(name,i));  }\r\n		}\r\n\r\n		scanf("%d",&n2);\r\n		for(i=1;i<=n2;++i){\r\n			cin>>name;\r\n			if( m.find(name)!=m.end()){\r\n			  same_name2=same_name1=name;\r\n			  for(++i;i<=n2;++i){\r\n				cin>>name;\r\n				if(m[name]<m[same_name1])  same_name1=name;\r\n			  }\r\n			}\r\n		}\r\n\r\n		cout<<same_name1<<" "<<same_name2<<endl;\r\n	}\r\n    return 0;\r\n}\r\n', '', 31, 544768, 1, 2, '2011-01-19 11:09:09', '0001-01-01 00:00:00'),
(1344, 9, 375, 5, '#include<stdio.h>\r\nint main()\r\n{\r\n	int a[50000];\r\n	int b[50001]={0};\r\n    int i,j,n,k;\r\n    while(scanf("%d",&n)==1){\r\n    	for(i=0;i<n;++i) scanf("%d",&a[i]);\r\n        k=1;\r\n        b[1]=a[0];\r\n        for(i=1;i<n;i++){\r\n        for(j=k;j>=1 && b[j]>a[i];--j);\r\n        b[j+1]=a[i];\r\n        if(j==k) k++;\r\n        }  \r\n		printf("%d\\n",k);  \r\n    }\r\n    \r\n    return 0;\r\n}\r\n\r\n', '', 202, 618496, 1, 2, '2011-01-19 11:10:00', '0001-01-01 00:00:00'),
(1345, 9, 377, 6, '直线的方程(y-x2)(y1-x1)-(x-x1)(y2-x2)=0\r\n#include <stdio.h>\r\nfloat x1[300],x2[300],y1[300],y2[300];\r\n\r\nint judge(int i,int j)\r\n{\r\n	float a,b;\r\n	a=(x2[j]-x2[i])*(y1[i]-x1[i])-(x1[j]-x1[i])*(y2[i]-x2[i]);\r\n	b=(y2[j]-x2[i])*(y1[i]-x1[i])-(y1[j]-x1[i])*(y2[i]-x2[i]);\r\n	if( (a*b)<0 )   return 1;  \r\n	else if(a*b==0.0){\r\n		if( (x1[j]>=x1[i] && x1[j]<=y1[i]) || (x1[j]<=x1[i] && x1[j]>=y1[i]) ){\r\n		    return 1;\r\n		}\r\n		if( (y1[j]>=x1[i] && y1[j]<=y1[i]) || (y1[j]<=x1[i] && y1[j]>=y1[i]) ){\r\n		    return 1;\r\n		}\r\n	}\r\n	else  return 0;\r\n}\r\n\r\nint judge_intersete(int i,int j)\r\n{\r\n	if(judge(i,j)==1 && judge(j,i)==1)\r\n		return 1;\r\n	else return 0;\r\n}\r\n\r\nint main()\r\n{\r\n	int n,i,j,count;\r\n	while(scanf("%d",&n) && n>0){	\r\n		count=0;\r\n		for(i=0;i<n;++i){\r\n			scanf("%f %f %f %f",&x1[i],&x2[i],&y1[i],&y2[i]);\r\n		}\r\n		for(i=0;i<n-1;++i){\r\n			for(j=i+1;j<n;++j){\r\n				count+=judge_intersete(i,j);\r\n			}\r\n		}\r\n		printf("%d\\n",count);\r\n\r\n	}\r\n	return 0;\r\n}\r\n\r\n2\r\n0.00 0.00 1.00 1.00\r\n0.00 1.00 1.00 0.00\r\n3\r\n0.00 0.00 1.00 1.00\r\n0.00 1.00 1.00 0.000\r\n0.00 0.00 1.00 0.00\r\n2\r\n0.00 0.00 1.00 1.00\r\n1.00 1.00 2.00 2.00\r\n0\r\n\r\n', 'Main.cpp:1:1: error: stray ''\\347'' in program\r\nMain.cpp:1:1: error: stray ''\\233'' in program\r\nMain.cpp:1:1: error: stray ''\\264'' in program\r\nMain.cpp:1:1: error: stray ''\\347'' in program\r\nMain.cpp:1:1: error: stray ''\\272'' in program\r\nMain.cpp:1:1: error: stray ''\\277'' in program\r\nMain.cpp:1:1: error: stray ''\\347'' in program\r\nMain.cpp:1:1: error: stray ''\\232'' in program\r\nMain.cpp:1:1: error: stray ''\\204'' in program\r\nMain.cpp:1:1: error: stray ''\\346'' in program\r\nMain.cpp:1:1: error: stray ''\\226'' in pro', 0, 0, 2, 2, '2011-01-19 11:10:56', '0001-01-01 00:00:00'),
(1346, 9, 403, 8, '#include<stdio.h>\r\n#include<string.h>\r\n#include<stdlib.h>\r\n#define MAX 5\r\nint main()\r\n{\r\n	int n,m,i,j,s_length;\r\n    int a[10000];\r\n    char num_str[50000],str[MAX],s[MAX];\r\n	while(scanf("%d",&n)==1){\r\n		if(n>1){\r\n			m=1;\r\n			a[0]=1;			\r\n			for(i=2;i<=n;++i){\r\n				for(j=0;j<m;++j){\r\n					a[j]*=i;\r\n				}\r\n				for(j=0;j<m-1;++j){\r\n					a[j+1]+=a[j]/10000;\r\n					a[j]=a[j]%10000;\r\n				}\r\n				if(a[j]>=10000){\r\n					a[j+1]=a[j]/10000;\r\n					a[j]=a[j]%10000;\r\n					++m;\r\n				}\r\n		     }\r\n		     \r\n		     strcpy(num_str,"");\r\n		     \r\n      	     itoa(a[m-1],s,10);\r\n             strcat(num_str,s);           \r\n             for(i=m-2;i>=0;--i){\r\n             	strcpy(str,"");\r\n             	itoa(a[i],s,10);\r\n             	switch( strlen(s) )\r\n             	{\r\n             		case 1:\r\n         		       strcat(str,"000");\r\n         		       strcat(str,s);\r\n         		       break;\r\n      		       case 2:\r\n	                   strcat(str,"00");\r\n	                   strcat(str,s);\r\n	                   break;\r\n                   case 3:\r\n                       strcat(str,"0");\r\n                       strcat(str,s);\r\n                       break;\r\n                   default:\r\n                       strcpy(str,s);\r\n             	}                \r\n			    strcat(num_str,str);\r\n             }\r\n             \r\n             printf("%s\\n",num_str);\r\n						\r\n		}else printf("1\\n");\r\n\r\n	}\r\n}\r\n\r\n', '', 670, 311296, 1, 2, '2011-01-19 11:11:48', '0001-01-01 00:00:00'),
(1347, 9, 377, 6, '#include <stdio.h>\r\nfloat x1[300],x2[300],y1[300],y2[300];\r\n\r\nint judge(int i,int j)\r\n{\r\n	float a,b;\r\n	a=(x2[j]-x2[i])*(y1[i]-x1[i])-(x1[j]-x1[i])*(y2[i]-x2[i]);\r\n	b=(y2[j]-x2[i])*(y1[i]-x1[i])-(y1[j]-x1[i])*(y2[i]-x2[i]);\r\n	if( (a*b)<0 )   return 1;  \r\n	else if(a*b==0.0){\r\n		if( (x1[j]>=x1[i] && x1[j]<=y1[i]) || (x1[j]<=x1[i] && x1[j]>=y1[i]) ){\r\n		    return 1;\r\n		}\r\n		if( (y1[j]>=x1[i] && y1[j]<=y1[i]) || (y1[j]<=x1[i] && y1[j]>=y1[i]) ){\r\n		    return 1;\r\n		}\r\n	}\r\n	else  return 0;\r\n}\r\n\r\nint judge_intersete(int i,int j)\r\n{\r\n	if(judge(i,j)==1 && judge(j,i)==1)\r\n		return 1;\r\n	else return 0;\r\n}\r\n\r\nint main()\r\n{\r\n	int n,i,j,count;\r\n	while(scanf("%d",&n) && n>0){	\r\n		count=0;\r\n		for(i=0;i<n;++i){\r\n			scanf("%f %f %f %f",&x1[i],&x2[i],&y1[i],&y2[i]);\r\n		}\r\n		for(i=0;i<n-1;++i){\r\n			for(j=i+1;j<n;++j){\r\n				count+=judge_intersete(i,j);\r\n			}\r\n		}\r\n		printf("%d\\n",count);\r\n\r\n	}\r\n	return 0;\r\n}\r\n', '', 61, 262144, 1, 2, '2011-01-19 11:13:00', '0001-01-01 00:00:00'),
(1348, 15, 379, 7, '#include<stdio.h>\r\n#include<string.h>\r\nint n,p,c,l[801][801],cow[501],a[801][801],q[641601],f,e,dis[801],ans;\r\nbool flag[801];\r\n\r\nvoid spfa(int s){\r\n	int st,i,total = 0;\r\n	flag[s] = true;\r\n	while(f <= e)\r\n	{\r\n		st = q[f];\r\n		for(i = 1; i <= l[st][0]; ++ i)\r\n		{\r\n			if(dis[st] + a[st][l[st][i]] < dis[l[st][i]])\r\n			{\r\n				dis[l[st][i]] =  dis[st] + a[st][l[st][i]];\r\n				if(!flag[l[st][i]])\r\n				{\r\n					++ e;\r\n					q[e] = l[st][i];\r\n					flag[l[st][i]] = true;\r\n                }\r\n             }\r\n        }\r\n		flag[st] = false;\r\n		++ f;\r\n     }\r\n	for(i = 1; i <= n; ++ i)\r\n		total += dis[cow[i]];\r\n	if(total < ans)\r\n		ans = total;\r\n}\r\n\r\nint main(){\r\n    int i,j,x,y,z;\r\n    while(scanf("%d%d%d",&n,&p,&c) == 3){\r\n		ans = 0x7FFFFFFF;\r\n		for(i = 1; i <= n; ++ i)\r\n			scanf("%d",&cow[i]);\r\n		for(i = 1; i <= c; ++ i)\r\n		{\r\n			scanf("%d%d%d",&x,&y,&z);\r\n			++ l[x][0];\r\n			a[x][y] = z;\r\n			l[x][l[x][0]] = y; \r\n			++ l[y][0];\r\n			a[y][x] = z; \r\n			l[y][l[y][0]] = x;\r\n		} \r\n		for(i = 1; i <= p; ++ i)\r\n		{\r\n			f = 1; \r\n			e = 1; \r\n			q[1] = i; \r\n			memset(dis,0x7F,sizeof(dis));  \r\n			memset(flag,0,sizeof(flag));\r\n			dis[i] = 0;  \r\n			spfa(i); \r\n		}  \r\n		printf("%d\\n",ans);  	\r\n	}\r\n	\r\n	return 0;\r\n}', 'Main.c:4:6: error: expected ''='', '','', '';'', ''asm'' or ''__attribute__'' before ''flag''\r\nMain.c: In function ''spfa'':\r\nMain.c:8:2: error: ''flag'' undeclared (first use in this function)\r\nMain.c:8:2: note: each undeclared identifier is reported only once for each function it appears in\r\nMain.c:8:12: error: ''true'' undeclared (first use in this function)\r\nMain.c:25:14: error: ''false'' undeclared (first use in this function)\r\nMain.c: In function ''main'':\r\nMain.c:56:11: error: ''flag'' undeclared (first use in t', 0, 0, 2, 1, '2011-01-19 11:29:02', '0001-01-01 00:00:00'),
(1349, 15, 404, 9, '/*#include<stdio.h>\r\n\r\nint* retangle(int array[][4]){\r\n	int i,j,k,result[4][4];\r\n	for(i=0;i<=3;i++){\r\n		for(j=0;j<=3;j++){\r\n			for(k=0;k<=3;k++){\r\n				result[i][j]+=array[i][k]*array[k][j];\r\n			}\r\n		}\r\n	}\r\n	int (*p)[4] = result;\r\n	return p;\r\n}\r\n\r\nint main(){\r\n	int i,j,k,n,array[4][4];\r\n	int** res;\r\n	for(i=0;i<=3;i++){\r\n		for(j=0;j<=3;j++){\r\n			scanf("%d",&n);\r\n			array[i][j]=n;\r\n		}\r\n	}\r\n\r\n	res = retangle(array);\r\n\r\n	for(i=0;i<=3;i++){\r\n		for(j=0;j<=3;j++){\r\n			printf("%d\\t",res[i][j]);\r\n		}\r\n		printf("\\n");\r\n	}\r\n		\r\n	return 0;\r\n}\r\n*/\r\n\r\n#include<stdio.h>\r\ndouble * GG()\r\n{\r\n       double Mod[2][6];\r\n       double (*M)[6];\r\n       M=Mod;\r\n       Mod[0][0]=1;Mod[1][0]=12;\r\n       Mod[0][1]=2;Mod[1][1]=11;\r\n       Mod[0][2]=3;Mod[1][2]=10;\r\n       Mod[0][3]=4;Mod[1][3]=9;\r\n       Mod[0][4]=5;Mod[1][4]=8;\r\n       Mod[0][5]=6;Mod[1][5]=7; \r\n      return M;   \r\n}\r\n\r\n\r\n\r\nmain()\r\n{\r\n    double (*p)[6];                                   \r\n    p=GG();\r\n    printf("%lf",*(*(p+1)+2));\r\n    printf("%lf",p[0][2]);\r\n   \r\n}\r\n', '', 0, 258048, 4, 1, '2011-01-19 11:31:03', '0001-01-01 00:00:00'),
(1350, 15, 336, 2, '#include<stdio.h>\r\n\r\nint bit_count(int n){\r\n	int count;\r\n	for(count = 0; n; n &= n - 1)\r\n	{\r\n       count++;\r\n	}	\r\n	return count;\r\n}\r\n\r\n\r\nint main(){\r\n	int n,a[50000][2],i,j,temp,c;\r\n	while(scanf("%d",&n)==1){\r\n	for(i=0;i<n;i++)\r\n	{\r\n		scanf("%d",&c);\r\n		a[i][0]=c;\r\n		a[i][1]=bit_count(c);\r\n	}\r\n\r\n	for(i=0;i<n-1;i++){\r\n		for(j=0;j<n-1-i;j++){\r\n			if((a[j][1]>a[j+1][1])||((a[j][1]==a[j+1][1])&&(a[j][0]>a[j+1][0]))){\r\n				temp=a[j][0];a[j][0]=a[j+1][0];a[j+1][0]=temp;\r\n				temp=a[j][1];a[j][1]=a[j+1][1];a[j+1][1]=temp;\r\n			}\r\n		}\r\n	}\r\n\r\n	for(i=0;i<n;i++)printf("%d ",a[i][0]); \r\n	printf("\\n");\r\n	}\r\n	return 0;		\r\n}\r\n', '', 200, 618496, 5, 1, '2011-01-19 11:49:00', '0001-01-01 00:00:00'),
(1351, 39, 52, 0, '#include <stdio.h>\r\n#include <stdlib.h>\r\nint main(){\r\n    int a,b;\r\n    scanf("%d%d",&a,&b);\r\n    if(a>b){\r\n        for(int i=b;i>0;i--){\r\n            if(a%i==0 && b%i==0){\r\n                printf("%d ",i);break;          \r\n            }        \r\n        }\r\n        for(int i=1;;i++){\r\n            if(a*i%b==0){\r\n                printf("%d",a*i);break;\r\n            }\r\n        }\r\n    }else{\r\n         for(int i=a;i>0;i--){\r\n            if(a%i==0 && b%i==0){\r\n                printf("%d ",i);break;          \r\n            }        \r\n        }\r\n        for(int i=1;;i++){\r\n            if(b*i%a==0){\r\n                printf("%d",b*i);break;\r\n            }\r\n        }    \r\n    }\r\n   }', '', 0, 258048, 1, 2, '2011-01-19 14:23:03', '0001-01-01 00:00:00'),
(1352, 39, 54, 0, '#include <stdio.h>\r\n\r\nint main(){\r\n    int n=0,s=2,t=0;\r\n    scanf("%d",&n);\r\n    for(int i=0;i<n;i++){\r\n        t+=s;\r\n        s=s*10+2;\r\n    }\r\n    printf("%d",t);   \r\n}', '', 0, 258048, 1, 2, '2011-01-19 14:29:16', '0001-01-01 00:00:00'),
(1353, 39, 56, 0, '#include <stdio.h>\r\n\r\nint main(){\r\n    int n=0;double s=0;\r\n    scanf("%d",&n);\r\n    for(int i=1;i<=n;i++){\r\n        s+=i;\r\n    }\r\n    scanf("%d",&n);\r\n    for(int i=1;i<=n;i++){\r\n        s+=(i*i);        \r\n    }\r\n    scanf("%d",&n);\r\n    for(int i=1;i<=n;i++){\r\n        double t=1/(double)i;\r\n        s+=t;\r\n    }\r\n    printf("%.2f",s);   \r\n}', '', 0, 253952, 1, 2, '2011-01-19 14:59:56', '0001-01-01 00:00:00'),
(1354, 12, 344, 4, '#include<stdlib.h>\r\n#include<string.h>\r\n#include<stdio.h>\r\ntypedef struct LNode{\r\n	char name[100];\r\n	struct LNode *next;\r\n}LNode,*Linklist;\r\n\r\n\r\n\r\nLinklist init(){\r\n	Linklist L = (Linklist)malloc(sizeof(LNode));\r\n	L->next = NULL;\r\n	strcpy(L->name,"head");\r\n	return L;\r\n}\r\n\r\nvoid append(Linklist L,char* name){\r\n	LNode* p = L;\r\n	LNode* f=NULL;\r\n	while(p->next){\r\n		p = p->next;\r\n		if(0==strcmp(p->name,name)){\r\n			f = p;\r\n		}\r\n	}\r\n	if(f){\r\n		p->next = f;\r\n	}\r\n	else{\r\n		LNode* pnode = (Linklist)malloc(sizeof(LNode));\r\n		strcpy(pnode->name,name);\r\n		p->next = pnode;\r\n		pnode->next = NULL;\r\n	}\r\n	\r\n}\r\n\r\nvoid ClearList(Linklist L)\r\n{\r\n   LNode *p;\r\n   while (L->next){\r\n      p=L->next;      //p指向链表中头结点后面的第一个结点\r\n      L->next=p->next;     //删除p结点\r\n      free(p);     //释放p结点占据的存储空间\r\n   }\r\n}\r\n\r\n\r\nbool IsExitsLoop(Linklist  head)\r\n{\r\n    Linklist  slow = head   ,   fast = head ;\r\n\r\n    while  ( fast  &&  fast -> next ) \r\n    {\r\n        slow  =  slow -> next;\r\n        fast  =  fast -> next -> next;\r\n        if  ( slow  ==  fast )  break ;\r\n    }\r\n\r\n    return   ! (fast  ==  NULL  ||  fast -> next  ==  NULL);\r\n} \r\n\r\nLinklist  FindLoopPort(Linklist head)\r\n{\r\n		Linklist slow  =  head;\r\n		Linklist fast  =  head;\r\n				\r\n		while  ( fast  &&  fast -> next ) \r\n		{\r\n			slow  =  slow -> next;\r\n			fast  =  fast -> next -> next;\r\n			if  ( slow  ==  fast )  break ;\r\n		}\r\n				\r\n		if  (fast  ==  NULL  ||  fast -> next  ==  NULL)\r\n			return  NULL;\r\n				\r\n		slow  =  head;\r\n		while  (slow  !=  fast)\r\n		{\r\n			slow  =  slow -> next;\r\n			fast  =  fast -> next;\r\n		}\r\n		\r\n		return  slow;\r\n} \r\n\r\nint main(){\r\n	Linklist L;\r\n	Linklist p;\r\n	L = init();\r\n	char n[100];\r\n	int k;\r\n	while(scanf("%d",&k)==1){\r\n		for(int i = 0;i < k;i++){\r\n			scanf("%s",n);\r\n			append(L,n);\r\n		}\r\n		int count = 0;\r\n		if(IsExitsLoop(L)){\r\n			Linklist port = FindLoopPort(L);\r\n			p = L->next;\r\n			while(0 != strcmp(p->name,port->name)){\r\n				p = p->next;\r\n			}\r\n			count++;\r\n			while(0 != strcmp(p->next->name,port->name)){\r\n				count++;\r\n				p = p->next;\r\n			}\r\n			p->next = NULL;//解链\r\n		}\r\n\r\n		printf("%d\\n",count);\r\n		ClearList(L);\r\n	}\r\n	return 0;\r\n}\r\n', '', 0, 253952, 7, 2, '2011-01-19 15:02:49', '0001-01-01 00:00:00'),
(1355, 12, 378, 6, '#include <stdio.h> \r\n#include <math.h> \r\nconst int MAX = 101 ; \r\nstruct point { float x ;float y ; } p[MAX] ; \r\nint main() \r\n{ \r\n	int  n , m , i , sum , t1 , t2 ;\r\n	float f ;\r\n	point t ; \r\n	while ( scanf( "%d" , &n )  ) \r\n	{ \r\n	//	if( prob ++ ) printf ( "\\n" ); \r\n	//	printf ( "Problem %d:\\n" , prob ) ; \r\n		scanf ( "%d" , &m ) ; \r\n		for ( i = 0 ; i < n ; i ++ ) scanf ( "%f%f" , &p[ i ].x , &p[ i ].y ) ; \r\n		p[ n ] = p[ 0 ]  ; \r\n		while ( m -- ) \r\n		{ \r\n			scanf ( "%f%f" , &t.x , &t.y ); \r\n			for ( i = 0 ; i <= n ; i ++ ) p[ i ].x -= t.x , p[ i ].y -= t.y ;    // 坐标平移   \r\n			t1 = p[ 0 ].x>=0 ? ( p[ 0 ].y>=0?0:3 ) : ( p[ 0 ].y>=0?1:2 ) ;        // 计算象限 \r\n			for ( sum = 0 , i = 1 ; i <= n ; i ++ ) \r\n			{ \r\n				if ( !p[ i ].x && !p[ i ].y ){printf("0\\n"); break ;}             \r\n				// 被测点为多边形顶点 \r\n				f = p[ i ].y * p[i-1].x - p[ i ].x * p[ i-1 ].y ;   \r\n				// 计算叉积 \r\n				if ( !f && p[ i-1 ].x*p[ i ].x <= 0 && p[ i-1 ].y*p[i].y <= 0 ){printf("0\\n"); break ;}   // 点在边上 \r\n				t2 = p[ i ].x>=0 ? ( p[ i ].y>=0?0:3 ) : ( p[ i ].y>=0?1:2 ) ;   // 计算象限 \r\n				if ( t2 == ( t1 + 1 ) % 4 ) sum += 1 ;         	// 情况1 \r\n				else if ( t2 == ( t1 + 3 ) % 4 ) sum -= 1 ;   	// 情况2 \r\n				else if ( t2 == ( t1 + 2 ) % 4 )              // 情况3 \r\n				{                                             \r\n					if ( f > 0 ) sum += 2 ; else sum -= 2 ; \r\n				} \r\n				t1 = t2 ; \r\n			} \r\n			if ( i<=n || sum ) printf( "1\\n" ) ; else printf( \r\n				"-1\\n" ) ; \r\n			for ( i = 0 ; i <= n ; i ++ ) p[ i ].x += t.x , p[i].y += t.y ;       // 恢复坐标 \r\n		} \r\n	} \r\n	return 0; \r\n}\r\n', '', 1000, 258048, 5, 2, '2011-01-19 15:36:52', '0001-01-01 00:00:00'),
(1356, 12, 403, 8, '#include<stdio.h>\r\n#include<string.h>\r\n#include<stdlib.h>\r\n#define MAX 5\r\nint main()\r\n{\r\n	int n,m,i,j,s_length;\r\n    int a[10000];\r\n    char num_str[50000],str[MAX],s[MAX];\r\n	while(scanf("%d",&n)==1){\r\n		if(n>1){\r\n			m=1;\r\n			a[0]=1;			\r\n			for(i=2;i<=n;++i){\r\n				for(j=0;j<m;++j){\r\n					a[j]*=i;\r\n				}\r\n				for(j=0;j<m-1;++j){\r\n					a[j+1]+=a[j]/10000;\r\n					a[j]=a[j]%10000;\r\n				}\r\n				if(a[j]>=10000){\r\n					a[j+1]=a[j]/10000;\r\n					a[j]=a[j]%10000;\r\n					++m;\r\n				}\r\n		     }\r\n		     \r\n		     strcpy(num_str,"");\r\n		     \r\n      	     itoa(a[m-1],s,10);\r\n             strcat(num_str,s);           \r\n             for(i=m-2;i>=0;--i){\r\n             	strcpy(str,"");\r\n             	itoa(a[i],s,10);\r\n             	switch( strlen(s) )\r\n             	{\r\n             		case 1:\r\n         		       strcat(str,"000");\r\n         		       strcat(str,s);\r\n         		       break;\r\n      		       case 2:\r\n	                   strcat(str,"00");\r\n	                   strcat(str,s);\r\n	                   break;\r\n                   case 3:\r\n                       strcat(str,"0");\r\n                       strcat(str,s);\r\n                       break;\r\n                   default:\r\n                       strcpy(str,s);\r\n             	}                \r\n			    strcat(num_str,str);\r\n             }\r\n             \r\n             printf("%s\\n",num_str);\r\n						\r\n		}else printf("1\\n");\r\n\r\n	}\r\n}\r\n\r\n', '', 670, 307200, 1, 1, '2011-01-19 15:45:58', '0001-01-01 00:00:00'),
(1357, 39, 58, 0, '#include <stdio.h>\r\n#include <vector>\r\n\r\nint main(){\r\n    int n;\r\n    scanf("%d",&n);\r\n    vector<int> a;\r\n    for(int i=2;i<n;i+=2){\r\n          int sum=1;\r\n          for(int j=2;j<i/2+1;j++){\r\n              if(i%j==0){sum+=j;a.push_back(j);}   \r\n          }\r\n          if(i==sum){\r\n              printf("%d its fastors are 1",i);\r\n              for(int k=0;k<a.size();k++){\r\n                  printf(" %d",a[k]);\r\n              }\r\n              printf("\\n"); \r\n          }\r\n          \r\n          a.clear();\r\n    }\r\n}', 'Main.cpp: In function ''int main()'':\r\nMain.cpp:7:5: error: ''vector'' was not declared in this scope\r\nMain.cpp:7:12: error: expected primary-expression before ''int''\r\nMain.cpp:7:12: error: expected '';'' before ''int''\r\nMain.cpp:11:33: error: ''a'' was not declared in this scope\r\nMain.cpp:15:29: error: ''a'' was not declared in this scope\r\nMain.cpp:21:11: error: ''a'' was not declared in this scope\r\n', 0, 0, 2, 2, '2011-01-19 15:47:35', '0001-01-01 00:00:00'),
(1358, 12, 379, 7, '#include<stdio.h>\r\n#include<string.h>\r\nint n,p,c,l[801][801],cow[501],a[801][801],q[641601],f,e,dis[801],ans;\r\nbool flag[801];\r\n\r\nvoid spfa(int s){\r\n	int st,i,total = 0;\r\n	flag[s] = true;\r\n	while(f <= e)\r\n	{\r\n		st = q[f];\r\n		for(i = 1; i <= l[st][0]; ++ i)\r\n		{\r\n			if(dis[st] + a[st][l[st][i]] < dis[l[st][i]])\r\n			{\r\n				dis[l[st][i]] =  dis[st] + a[st][l[st][i]];\r\n				if(!flag[l[st][i]])\r\n				{\r\n					++ e;\r\n					q[e] = l[st][i];\r\n					flag[l[st][i]] = true;\r\n                }\r\n             }\r\n        }\r\n		flag[st] = false;\r\n		++ f;\r\n     }\r\n	for(i = 1; i <= n; ++ i)\r\n		total += dis[cow[i]];\r\n	if(total < ans)\r\n		ans = total;\r\n}\r\n\r\nint main(){\r\n    int i,j,x,y,z;\r\n    while(scanf("%d%d%d",&n,&p,&c) == 3){\r\n		ans = 0x7FFFFFFF;\r\n		for(i = 1; i <= n; ++ i)\r\n			scanf("%d",&cow[i]);\r\n		for(i = 1; i <= c; ++ i)\r\n		{\r\n			scanf("%d%d%d",&x,&y,&z);\r\n			++ l[x][0];\r\n			a[x][y] = z;\r\n			l[x][l[x][0]] = y; \r\n			++ l[y][0];\r\n			a[y][x] = z; \r\n			l[y][l[y][0]] = x;\r\n		} \r\n		for(i = 1; i <= p; ++ i)\r\n		{\r\n			f = 1; \r\n			e = 1; \r\n			q[1] = i; \r\n			memset(dis,0x7F,sizeof(dis));  \r\n			memset(flag,0,sizeof(flag));\r\n			dis[i] = 0;  \r\n			spfa(i); \r\n		}  \r\n		printf("%d\\n",ans);  	\r\n	}\r\n	\r\n	return 0;\r\n}\r\n', 'Main.c:4:6: error: expected ''='', '','', '';'', ''asm'' or ''__attribute__'' before ''flag''\r\nMain.c: In function ''spfa'':\r\nMain.c:8:2: error: ''flag'' undeclared (first use in this function)\r\nMain.c:8:2: note: each undeclared identifier is reported only once for each function it appears in\r\nMain.c:8:12: error: ''true'' undeclared (first use in this function)\r\nMain.c:25:14: error: ''false'' undeclared (first use in this function)\r\nMain.c: In function ''main'':\r\nMain.c:56:11: error: ''flag'' undeclared (first use in t', 0, 0, 2, 1, '2011-01-19 15:48:11', '0001-01-01 00:00:00'),
(1359, 39, 58, 0, '#include <stdio.h>\r\n#include <vector>\r\nusing namespace std;\r\n\r\nint main(){\r\n    int n;\r\n    scanf("%d",&n);\r\n    vector<int> a;\r\n    for(int i=2;i<n;i+=2){\r\n          int sum=1;\r\n          for(int j=2;j<i/2+1;j++){\r\n              if(i%j==0){sum+=j;a.push_back(j);}   \r\n          }\r\n          if(i==sum){\r\n              printf("%d its fastors are 1",i);\r\n              for(int k=0;k<a.size();k++){\r\n                  printf(" %d",a[k]);\r\n              }\r\n              printf("\\n"); \r\n          }\r\n          \r\n          a.clear();    }\r\n}', '', 218, 294912, 3, 2, '2011-01-19 15:48:26', '0001-01-01 00:00:00'),
(1360, 39, 58, 0, '#include <stdio.h>\r\n#include <vector>\r\nusing namespace std;\r\n\r\nint main(){\r\n    int n;\r\n    scanf("%d",&n);\r\n    vector<int> a;\r\n    for(int i=2;i<n;i+=2){\r\n          int sum=1;\r\n          for(int j=2;j<i/2+1;j++){\r\n              if(i%j==0){sum+=j;a.push_back(j);}   \r\n          }\r\n          if(i==sum){\r\n              printf("%d its fastors are 1 ",i);\r\n              for(int k=0;k<a.size();k++){\r\n                  printf("%d ",a[k]);\r\n              }\r\n              printf("\\n"); \r\n          }\r\n          \r\n          a.clear();//清空 \r\n    }\r\n    //system("pause");\r\n}', '', 218, 294912, 1, 2, '2011-01-19 15:49:43', '0001-01-01 00:00:00'),
(1361, 39, 60, 0, '#include <stdio.h>\r\n\r\nint main(){\r\n    int m,n;\r\n    double sum=0,t=0;\r\n    scanf("%d%d",&m,&n);\r\n    sum+=m;\r\n    t=(double)m/2;\r\n    for(int i=2;i<=n;i++){\r\n        sum+=2*t;\r\n        t=(double)t/2;\r\n        \r\n    }\r\n    printf("%.2f ",t);\r\n    printf("%.2f",sum);\r\n}', '', 0, 253952, 1, 2, '2011-01-19 16:06:08', '0001-01-01 00:00:00'),
(1362, 11, 402, 8, 'erwerw', 'Main.c:1:1: error: expected ''='', '','', '';'', ''asm'' or ''__attribute__'' at end of input\r\n', 0, 0, 2, 1, '2011-01-19 20:29:48', '0001-01-01 00:00:00'),
(1363, 24, 377, 6, '#include <iostream>\r\nusing namespace std;\r\n\r\ndouble p[100][2],q[100][2];\r\n\r\nfloat direction(double p[],double q[] ,double r[])\r\n{       \r\n	return ((r[0]-p[0])*(q[1]-p[1])-(r[1]-p[1])*(q[0]-p[0]));\r\n}\r\n\r\nbool segment(double p[],double q[], double r[])\r\n{       \r\n	if(((r[0]-p[0])*(r[0]-q[0])<=0)&&((r[1]-p[1])*(r[1]-q[1])<=0))\r\n		return true;\r\n	else\r\n		return false;\r\n}\r\n\r\nbool judge(int i, int j)\r\n{       \r\n	double d1,d2,d3,d4;   \r\n	d1=direction(p[i],q[i],p[j]); \r\n	d2=direction(p[i],q[i],q[j]);    \r\n	d3=direction(p[j],q[j],p[i]);      \r\n	d4=direction(p[j],q[j],q[i]);     \r\n	if((d1*d2<0)&&(d3*d4<0))              \r\n		return true;    \r\n	else if(d1==0&& segment(p[i],q[i],p[j])==1)    \r\n		return true;      \r\n	else if(d2==0&& segment(p[i],q[i],q[j])==1)     \r\n		return true;   \r\n	else if(d3==0&& segment(p[j],q[j],p[i])==1)   \r\n		return true;   \r\n	else if(d4==0&& segment(p[j],q[j],q[i])==1)    \r\n		return true;  \r\n	else return false;\r\n}\r\n\r\nint main(){  \r\n	int n,i,j,count;     \r\n	while(scanf("%d",&n)){      \r\n		if(n==0)     \r\n			break;      \r\n		for(i=0;i<n;++i){    \r\n			scanf("%lf %lf %lf %lf",&p[i][0],&p[i][1],&q[i][0],&q[i][1]);    \r\n		}   \r\n		for(i=0,count=0;i<n;i++)    \r\n			for(j=i+1;j<n;j++)       \r\n				if(judge(i,j)==1)     \r\n					++count;        \r\n		printf("%d\\n",count);    \r\n	}    \r\n	return 0;\r\n}\r\n', 'Main.cpp: In function ''int main()'':\r\nMain.cpp:41:21: error: ''scanf'' was not declared in this scope\r\nMain.cpp:51:22: error: ''printf'' was not declared in this scope\r\n', 0, 0, 2, 2, '2011-01-19 22:16:28', '0001-01-01 00:00:00'),
(1364, 24, 377, 6, '#include <iostream>\r\nusing namespace std;\r\n\r\ndouble p[100][2],q[100][2];\r\n\r\nfloat direction(double p[],double q[] ,double r[])\r\n{       \r\n	return ((r[0]-p[0])*(q[1]-p[1])-(r[1]-p[1])*(q[0]-p[0]));\r\n}\r\n\r\nbool segment(double p[],double q[], double r[])\r\n{       \r\n	if(((r[0]-p[0])*(r[0]-q[0])<=0)&&((r[1]-p[1])*(r[1]-q[1])<=0))\r\n		return true;\r\n	else\r\n		return false;\r\n}\r\n\r\nbool judge(int i, int j)\r\n{       \r\n	double d1,d2,d3,d4;   \r\n	d1=direction(p[i],q[i],p[j]); \r\n	d2=direction(p[i],q[i],q[j]);    \r\n	d3=direction(p[j],q[j],p[i]);      \r\n	d4=direction(p[j],q[j],q[i]);     \r\n	if((d1*d2<0)&&(d3*d4<0))              \r\n		return true;    \r\n	else if(d1==0&& segment(p[i],q[i],p[j])==1)    \r\n		return true;      \r\n	else if(d2==0&& segment(p[i],q[i],q[j])==1)     \r\n		return true;   \r\n	else if(d3==0&& segment(p[j],q[j],p[i])==1)   \r\n		return true;   \r\n	else if(d4==0&& segment(p[j],q[j],q[i])==1)    \r\n		return true;  \r\n	else return false;\r\n}\r\n\r\nint main(){  \r\n	int n,i,j,count;     \r\n	while(cin>>n){      \r\n		if(n==0)     \r\n			break;      \r\n		for(i=0;i<n;++i){    \r\n			cin>>p[i][0];\r\n			cin>>p[i][1];\r\n			cin>>q[i][0];\r\n			cin>>q[i][1];    \r\n		}   \r\n		for(i=0,count=0;i<n;i++)    \r\n			for(j=i+1;j<n;j++)       \r\n				if(judge(i,j)==1)     \r\n					++count;        \r\n		printf("%d\\n",count);    \r\n	}    \r\n	return 0;\r\n}\r\n', 'Main.cpp: In function ''int main()'':\r\nMain.cpp:54:22: error: ''printf'' was not declared in this scope\r\n', 0, 0, 2, 2, '2011-01-19 22:20:16', '0001-01-01 00:00:00'),
(1365, 24, 377, 6, '#include <iostream>\r\nusing namespace std;\r\n\r\ndouble p[100][2],q[100][2];\r\n\r\nfloat direction(double p[],double q[] ,double r[])\r\n{       \r\n	return ((r[0]-p[0])*(q[1]-p[1])-(r[1]-p[1])*(q[0]-p[0]));\r\n}\r\n\r\nbool segment(double p[],double q[], double r[])\r\n{       \r\n	if(((r[0]-p[0])*(r[0]-q[0])<=0)&&((r[1]-p[1])*(r[1]-q[1])<=0))\r\n		return true;\r\n	else\r\n		return false;\r\n}\r\n\r\nbool judge(int i, int j)\r\n{       \r\n	double d1,d2,d3,d4;   \r\n	d1=direction(p[i],q[i],p[j]); \r\n	d2=direction(p[i],q[i],q[j]);    \r\n	d3=direction(p[j],q[j],p[i]);      \r\n	d4=direction(p[j],q[j],q[i]);     \r\n	if((d1*d2<0)&&(d3*d4<0))              \r\n		return true;    \r\n	else if(d1==0&& segment(p[i],q[i],p[j])==1)    \r\n		return true;      \r\n	else if(d2==0&& segment(p[i],q[i],q[j])==1)     \r\n		return true;   \r\n	else if(d3==0&& segment(p[j],q[j],p[i])==1)   \r\n		return true;   \r\n	else if(d4==0&& segment(p[j],q[j],q[i])==1)    \r\n		return true;  \r\n	else return false;\r\n}\r\n\r\nint main(){  \r\n	int n,i,j,count;     \r\n	while(cin>>n){      \r\n		if(n==0)     \r\n			break;      \r\n		for(i=0;i<n;++i){    \r\n			cin>>p[i][0];\r\n			cin>>p[i][1];\r\n			cin>>q[i][0];\r\n			cin>>q[i][1];    \r\n		}   \r\n		for(i=0,count=0;i<n;i++)    \r\n			for(j=i+1;j<n;j++)       \r\n				if(judge(i,j)==1)     \r\n					++count;        \r\n		count<<count;    \r\n	}    \r\n	return 0;\r\n}\r\n', '', 0, 368640, 4, 2, '2011-01-19 22:20:58', '0001-01-01 00:00:00'),
(1366, 20, 336, 2, '#include<stdio.h>\r\nint a[50000],b[50000];\r\nint count(unsigned int n)\r\n{\r\n	int num;\r\n	for(num = 0; n; n >>= 1)\r\n	{\r\n		num += n & 1;\r\n	}\r\n	return num;\r\n}\r\nint Partition(int a[],int b[],int low,int high)\r\n{\r\n	int pivotkey;\r\n	a[0]=a[low];\r\n	b[0]=b[low];\r\n	pivotkey = b[low];\r\n	while(low<high)\r\n	{\r\n		while(low<high&&b[high]>=pivotkey)--high;\r\n		a[low]=a[high];\r\n		b[low]=b[high];\r\n		while(low<high&&b[high]<=pivotkey)++low;\r\n		a[high]=a[low];\r\n		b[high]=b[low];\r\n	}\r\n	a[low]=a[0];\r\n	b[low]=b[0];\r\n	return low;\r\n}\r\nvoid QSort(int a[],int b[],int low,int high)\r\n{\r\n	int pivotloc;\r\n	if(low<high)\r\n	{\r\n		pivotloc = Partition(a,b,low,high);\r\n		QSort(a,b,low,pivotloc-1);\r\n		QSort(a,b,pivotloc+1,high);\r\n	}\r\n}\r\n\r\nint main()\r\n{\r\n	int n,m,i,k;\r\n	int a[50001],b[50001];\r\n	while(scanf("%d",&n)==1)\r\n	{\r\n		if(n>0)\r\n		{\r\n			a[0]=0;\r\n			b[0]=0;\r\n			for(i=1;i<=n;++i)\r\n			{\r\n				scanf("%d",&a[i]);\r\n				b[i]=count(a[i]);\r\n			}\r\n	\r\n			QSort(a,b,1,n);\r\n		\r\n			for(i=1;i<=n;++i)\r\n			{\r\n				m=b[i];\r\n				k=i;\r\n				while(m==b[i+1])\r\n				++i;\r\n				if(k!=i)\r\n				{\r\n					QSort(b,a,k,i);\r\n				}\r\n			}\r\n		\r\n			for(i=1;i<n;++i)\r\n				printf("%d",a[i]);\r\n			printf("%d",a[i]);\r\n		}\r\n		printf("\\n");\r\n	}\r\n	return 0;			\r\n}\r\n', '', 15, 1024000, 4, 1, '2011-01-19 22:23:13', '0001-01-01 00:00:00'),
(1367, 11, 336, 2, '#include<stdio.h>\r\nmain()\r\n{}', '', 0, 253952, 4, 1, '2011-01-19 23:29:23', '0001-01-01 00:00:00'),
(1368, 11, 338, 3, '#include<stdio.h>\r\nmain(){}', '', 0, 258048, 4, 1, '2011-01-19 23:42:39', '0001-01-01 00:00:00'),
(1369, 11, 344, 4, '#include<stdio.h>\r\nmain(){}', '', 0, 253952, 4, 1, '2011-01-19 23:55:15', '0001-01-01 00:00:00'),
(1370, 11, 402, 8, '#include<stdio.h>\r\nmain(){}', '', 0, 258048, 4, 1, '2011-01-20 00:08:05', '0001-01-01 00:00:00');
INSERT INTO `tbl_submitions` (`id`, `user_id`, `problem_id`, `exercise_id`, `source`, `result`, `used_time`, `used_memory`, `status`, `compiler_id`, `created`, `modified`) VALUES
(1371, 24, 344, 4, '#include <iostream>\r\n#include <map>\r\n#include <string>\r\nusing namespace std;\r\nint main()\r\n{\r\n	int n,i;\r\n	string str;\r\n    while(scanf("%d",&n)==1)\r\n	{\r\n		int count=0;\r\n    	map<string,int> map;\r\n    	for(i=1;i<=n;++i)\r\n		{\r\n			cin>>str;\r\n    		if(map.find(str)!=map.end())\r\n				count=i-map[str];\r\n			else\r\n				map.insert(pair<string,int>(str,i));\r\n		}\r\n    	printf("%d\\n",count);\r\n	}\r\n    return 0;\r\n}', 'Main.cpp: In function ''int main()'':\r\nMain.cpp:9:24: error: ''scanf'' was not declared in this scope\r\nMain.cpp:21:25: error: ''printf'' was not declared in this scope\r\n', 0, 0, 2, 2, '2011-01-20 00:24:36', '0001-01-01 00:00:00'),
(1372, 24, 344, 4, '#include <iostream>\r\n#include <map>\r\n#include <string>\r\nusing namespace std;\r\nint main()\r\n{\r\n	int n,i;\r\n	string str;\r\n    while(scanf("%d",&n)==1)\r\n	{\r\n		int count=0;\r\n    	map<string,int> map;\r\n    	for(i=1;i<=n;++i)\r\n		{\r\n			cin>>str;\r\n    		if(map.find(str)!=map.end())\r\n				count=i-map[str];\r\n			else\r\n				map.insert(pair<string,int>(str,i));\r\n		}\r\n    	printf("%d\\n",count);\r\n	}\r\n    return 0;\r\n}', 'Main.c:1:20: fatal error: iostream: No such file or directory\r\ncompilation terminated.\r\n', 0, 0, 2, 1, '2011-01-20 00:24:56', '0001-01-01 00:00:00'),
(1373, 24, 344, 4, '#include <iostream>\r\n#include <map>\r\n#include <string>\r\n#include <stdio.h>\r\nusing namespace std;\r\nint main()\r\n{\r\n	int n,i;\r\n	string str;\r\n    while(scanf("%d",&n)!=EOF)\r\n	{\r\n		int count=0;\r\n    	map<string,int> map;\r\n    	for(i=1;i<=n;++i)\r\n		{\r\n			cin>>str;\r\n    		if(map.find(str)!=map.end())\r\n				count=i-map[str];\r\n			else\r\n				map.insert(pair<string,int>(str,i));\r\n		}\r\n    	cout<<count;\r\n	}\r\n    return 0;\r\n}', '', 93, 1138688, 3, 2, '2011-01-20 00:30:42', '0001-01-01 00:00:00'),
(1374, 24, 344, 4, '#include <iostream>\r\n#include <map>\r\n#include <string>\r\n#include <stdio.h>\r\n\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n	int n,i;\r\n	string str;\r\n    while((scanf("%d",&n))!=EOF)\r\n	{\r\n		int count=0;\r\n    	map<string,int> map;\r\n    	for(i=1;i<=n;++i)\r\n		{\r\n			cin>>str;\r\n    		if(map.find(str)!=map.end())\r\n				count=i-map[str];\r\n			else\r\n				map.insert(pair<string,int>(str,i));\r\n		}\r\n    	cout<<count;\r\n	}\r\n    return 0;\r\n}', '', 93, 1134592, 3, 2, '2011-01-20 00:32:13', '0001-01-01 00:00:00'),
(1375, 14, 403, 8, '#include<stdio.h>\r\n#include<string.h>\r\n#define true 1\r\n#define false 0\r\n#define MAX 3000\r\n\r\nint main()\r\n{\r\n	int n;\r\n   \r\n    while( scanf("%d",&n) != -1)\r\n    {\r\n		int i,j;\r\n		int num[MAX];\r\n		memset(num,0,sizeof(num));\r\n		\r\n		num[0]=1;\r\n		for(i=1;i<=n;i++)\r\n		{\r\n		    int c=0;\r\n		    for(j=0;j<MAX;j++)\r\n			{\r\n				int temp=num[j]*i+c;\r\n			    num[j]=temp%10;\r\n			    c=temp/10;\r\n			}\r\n		}\r\n\r\n		bool flag=false;\r\n		for(i=MAX-1;i>=0;i--)\r\n		{\r\n			if(flag||num[i])\r\n			{\r\n				flag=true;\r\n				printf("%d",num[i]);\r\n			}\r\n		}\r\n		if(!flag)\r\n		{\r\n			printf("0");\r\n		}\r\n		printf("\\n");\r\n	}\r\n	return 0;\r\n}\r\n', 'Main.c: In function ''main'':\r\nMain.c:29:3: error: ''bool'' undeclared (first use in this function)\r\nMain.c:29:3: note: each undeclared identifier is reported only once for each function it appears in\r\nMain.c:29:8: error: expected '';'' before ''flag''\r\nMain.c:32:7: error: ''flag'' undeclared (first use in this function)\r\n', 0, 0, 2, 1, '2011-01-21 00:02:51', '0001-01-01 00:00:00'),
(1376, 14, 403, 8, '#include<stdio.h>\r\n#include<string.h>\r\n#define true 1\r\n#define false 0\r\n#define MAX 3000\r\n\r\nint main()\r\n{\r\n	int n;\r\n   \r\n    while( scanf("%d",&n) != -1)\r\n    {\r\n		int i,j;\r\n		int num[MAX];\r\n		memset(num,0,sizeof(num));\r\n		\r\n		num[0]=1;\r\n		for(i=1;i<=n;i++)\r\n		{\r\n		    int c=0;\r\n		    for(j=0;j<MAX;j++)\r\n			{\r\n				int temp=num[j]*i+c;\r\n			    num[j]=temp%10;\r\n			    c=temp/10;\r\n			}\r\n		}\r\n\r\n		int flag=false;\r\n		for(i=MAX-1;i>=0;i--)\r\n		{\r\n			if(flag||num[i])\r\n			{\r\n				flag=true;\r\n				printf("%d",num[i]);\r\n			}\r\n		}\r\n		if(!flag)\r\n		{\r\n			printf("0");\r\n		}\r\n		printf("\\n");\r\n	}\r\n	return 0;\r\n}\r\n', '', 483, 258048, 4, 1, '2011-01-21 00:03:30', '0001-01-01 00:00:00'),
(1377, 14, 403, 8, '#include<stdio.h>\r\n#include<string.h>\r\n#define true 1\r\n#define false 0\r\n#define MAX 6000\r\nint num[MAX];\r\n\r\n\r\nint main()\r\n{\r\n	int n;\r\n   \r\n    while( scanf("%d",&n) != -1)\r\n    {\r\n		int i,j;\r\n		memset(num,0,sizeof(num));\r\n		\r\n		num[0]=1;\r\n		for(i=1;i<=n;i++)\r\n		{\r\n		    int c=0;\r\n		    for(j=0;j<MAX;j++)\r\n			{\r\n				int temp=num[j]*i+c;\r\n			    num[j]=temp%10;\r\n			    c=temp/10;\r\n			}\r\n		}\r\n\r\n		int flag=false;\r\n		for(i=MAX-1;i>=0;i--)\r\n		{\r\n			if(flag||num[i])\r\n			{\r\n				flag=true;\r\n				printf("%d",num[i]);\r\n			}\r\n		}\r\n		if(!flag)\r\n		{\r\n			printf("0");\r\n		}\r\n		printf("\\n");\r\n	}\r\n	return 0;\r\n}\r\n', '', 950, 278528, 4, 1, '2011-01-21 00:04:43', '0001-01-01 00:00:00'),
(1378, 14, 403, 8, '#include<stdio.h>\r\n#include<string.h>\r\n#define true 1\r\n#define false 0\r\n#define MAX 10000\r\n\r\nint main()\r\n{\r\n	int n;\r\n   \r\n    while( scanf("%d",&n) != -1)\r\n    {\r\n		int i,j;\r\n		int num[MAX];\r\n		memset(num,0,sizeof(num));\r\n		\r\n		num[0]=1;\r\n		for(i=1;i<=n;i++)\r\n		{\r\n		    int c=0;\r\n		    for(j=0;j<MAX;j++)\r\n			{\r\n				int temp=num[j]*i+c;\r\n			    num[j]=temp%10;\r\n			    c=temp/10;\r\n			}\r\n		}\r\n\r\n		int flag=false;\r\n		for(i=MAX-1;i>=0;i--)\r\n		{\r\n			if(flag||num[i])\r\n			{\r\n				flag=true;\r\n				printf("%d",num[i]);\r\n			}\r\n		}\r\n		if(!flag)\r\n		{\r\n			printf("0");\r\n		}\r\n		printf("\\n");\r\n	}\r\n	return 0;\r\n}\r\n', '', 1622, 258048, 4, 1, '2011-01-21 00:09:04', '0001-01-01 00:00:00'),
(1379, 14, 403, 8, '#include<stdio.h>\r\n#include<string.h>\r\n#define true 1\r\n#define false 0\r\n#define MAX 10000\r\nint num[MAX];\r\n\r\nint main()\r\n{\r\n	int n;\r\n   \r\n    while( scanf("%d",&n) != -1)\r\n    {\r\n		int i,j;\r\n		\r\n		memset(num,0,sizeof(num));\r\n		\r\n		num[0]=1;\r\n		for(i=1;i<=n;i++)\r\n		{\r\n		    int c=0;\r\n		    for(j=0;j<MAX;j++)\r\n			{\r\n				int temp=num[j]*i+c;\r\n			    num[j]=temp%10;\r\n			    c=temp/10;\r\n			}\r\n		}\r\n\r\n		int flag=false;\r\n		for(i=MAX-1;i>=0;i--)\r\n		{\r\n			if(flag||num[i])\r\n			{\r\n				flag=true;\r\n				printf("%d",num[i]);\r\n			}\r\n		}\r\n		if(!flag)\r\n		{\r\n			printf("0");\r\n		}\r\n		printf("\\n");\r\n	}\r\n	return 0;\r\n}\r\n', '', 1622, 294912, 4, 1, '2011-01-21 00:16:59', '0001-01-01 00:00:00'),
(1380, 14, 403, 8, '#include<stdio.h>\r\n#include<string.h>\r\n#define true 1\r\n#define false 0\r\n#define MAX 3000\r\n\r\nint num[MAX];\r\n\r\nint main()\r\n{\r\n	int n;\r\n   \r\n    while( scanf("%d",&n) != -1)\r\n    {\r\n		int i,j;\r\n		\r\n		memset(num,0,sizeof(num));\r\n		\r\n		num[0]=1;\r\n		for(i=1;i<=n;i++)\r\n		{\r\n		    int c=0;\r\n		    for(j=0;j<MAX;j++)\r\n			{\r\n				int temp=num[j]*i+c;\r\n			    num[j]=temp%10;\r\n			    c=temp/10;\r\n				\r\n			}\r\n		}\r\n\r\n\r\n		for(i=MAX-1;i>=0;i--)\r\n		{\r\n			if(flag||num[i])\r\n			{\r\n				printf("%d",num[i]);\r\n			}\r\n		}\r\n\r\n		printf("\\n");\r\n	}\r\n	return 0;\r\n}\r\n', 'Main.c: In function ''main'':\r\nMain.c:35:7: error: ''flag'' undeclared (first use in this function)\r\nMain.c:35:7: note: each undeclared identifier is reported only once for each function it appears in\r\n', 0, 0, 2, 1, '2011-01-21 00:30:50', '0001-01-01 00:00:00'),
(1381, 14, 403, 8, '#include<stdio.h>\r\n#include<string.h>\r\n#define true 1\r\n#define false 0\r\n#define MAX 3000\r\n\r\nint num[MAX];\r\n\r\nint main()\r\n{\r\n	int n;\r\n   \r\n    while( scanf("%d",&n) != -1)\r\n    {\r\n		int i,j;\r\n		\r\n		memset(num,0,sizeof(num));\r\n		\r\n		num[0]=1;\r\n		for(i=1;i<=n;i++)\r\n		{\r\n		    int c=0;\r\n		    for(j=0;j<MAX;j++)\r\n			{\r\n				int temp=num[j]*i+c;\r\n			    num[j]=temp%10;\r\n			    c=temp/10;\r\n				\r\n			}\r\n		}\r\n\r\n\r\n		for(i=MAX-1;i>=0;i--)\r\n		{\r\n			if(num[i]!=0)\r\n			{\r\n				printf("%d",num[i]);\r\n			}\r\n		}\r\n\r\n		printf("\\n");\r\n	}\r\n	return 0;\r\n}\r\n', '', 62, 262144, 4, 1, '2011-01-21 00:31:30', '0001-01-01 00:00:00'),
(1382, 14, 403, 8, '#include<stdio.h>\r\n#include<string.h>\r\n#define true 1\r\n#define false 0\r\n#define MAX 3000\r\n\r\nint num[MAX];\r\n\r\nint main()\r\n{\r\n	int n;\r\n   \r\n    while( scanf("%d",&n) != -1)\r\n    {\r\n		int i,j;\r\n		\r\n		memset(num,0,sizeof(num));\r\n		\r\n		num[0]=1;\r\n		for(i=1;i<=n;i++)\r\n		{\r\n		    int c=0;\r\n		    for(j=0;j<MAX;j++)\r\n			{\r\n				int temp=num[j]*i+c;\r\n			    num[j]=temp%10;\r\n			    c=temp/10;\r\n				\r\n			}\r\n		}\r\n\r\n		int flag = false;\r\n		for(i=MAX-1;i>=0;i--)\r\n		{\r\n			if(num[i] || flag)\r\n			{\r\n				flag=true;\r\n				printf("%d",num[i]);\r\n			}\r\n		}\r\n\r\n		printf("\\n");\r\n	}\r\n	return 0;\r\n}\r\n', '', 483, 266240, 4, 1, '2011-01-21 00:36:10', '0001-01-01 00:00:00'),
(1383, 14, 404, 9, '#include<stdio.h>\r\n#include<string.h>\r\n\r\nvoid matrix(long int num [4][4],long int product[4][4],int c)\r\n{\r\n  int i,j,z;\r\n  long int temp[4][4];\r\n  memset(temp,0,sizeof(temp));\r\n\r\n  for (i=0;i<4;i++)\r\n      for (j=0;j<4;j++)\r\n	  {\r\n		  for (z=0;z<4;z++)\r\n			  temp[i][j] += num[i][z]*num[z][j];\r\n		  \r\n		  temp[i][j] %= 2011;\r\n	  }\r\n\r\n	for(i=0;i<4;i++)\r\n	  for(j=0;j<4;j++)\r\n	  {\r\n		  num[i][j] = temp[i][j];\r\n		  \r\n	  }\r\n\r\n	  if(c ==1 || c==4)\r\n			return;\r\n  memset(temp,0,sizeof(temp));\r\n  for (i=0;i<4;i++)\r\n      for (j=0;j<4;j++)\r\n	  {\r\n		  for (z=0;z<4;z++)\r\n			  temp[i][j] += product[i][z]*num[z][j];\r\n		  \r\n		  temp[i][j] %= 2011;\r\n		  \r\n	  }\r\n\r\n	 for(i=0;i<4;i++)\r\n	  for(j=0;j<4;j++)\r\n	  {\r\n		  product[i][j] = temp[i][j];\r\n		  \r\n	  }\r\n\r\n\r\n  \r\n}\r\n\r\nint main()\r\n{\r\n	int count;\r\n\r\n	while(scanf("%d",&count))\r\n	{\r\n		int i,j,k;\r\n		\r\n		for(k=0;k<count;k++)\r\n		{\r\n			long int num[4][4];\r\n			long int product[4][4];\r\n			memset(product,0,sizeof(product));\r\n\r\n			for (i=0;i<4;i++)\r\n				for (j=0;j<4;j++)\r\n				{\r\n					scanf("%d",&num[i][j]);\r\n					product[i][j] = num[i][j];\r\n				}\r\n\r\n			for(i=0;i<10;i++)\r\n			{\r\n				\r\n				matrix(num,product,i);\r\n			}\r\n\r\n	for(i=0;i<4;i++)\r\n	{\r\n		for(j=0;j<4;j++)\r\n		{\r\n			if(0==j)\r\n				printf("%ld",product[i][j]);\r\n			else\r\n				printf(" %ld",product[i][j]);\r\n		}\r\n		printf("\\n");\r\n	}\r\n	printf("\\n");\r\n\r\n\r\n		}\r\n	}\r\n}', '', 300, 258048, 5, 1, '2011-01-21 03:54:50', '0001-01-01 00:00:00'),
(1384, 14, 404, 9, '#include<stdio.h>\r\n#include<string.h>\r\n\r\nvoid matrix(long int num [4][4],long int product[4][4],int c)\r\n{\r\n  int i,j,z;\r\n  long int temp[4][4];\r\n  memset(temp,0,sizeof(temp));\r\n\r\n  for (i=0;i<4;i++)\r\n      for (j=0;j<4;j++)\r\n	  {\r\n		  for (z=0;z<4;z++)\r\n			  temp[i][j] += num[i][z]*num[z][j];\r\n		  \r\n		  temp[i][j] %= 2011;\r\n	  }\r\n\r\n	for(i=0;i<4;i++)\r\n	  for(j=0;j<4;j++)\r\n	  {\r\n		  num[i][j] = temp[i][j];\r\n		  \r\n	  }\r\n\r\n	  if(c ==1 || c==4)\r\n			return;\r\n  memset(temp,0,sizeof(temp));\r\n  for (i=0;i<4;i++)\r\n      for (j=0;j<4;j++)\r\n	  {\r\n		  for (z=0;z<4;z++)\r\n			  temp[i][j] += product[i][z]*num[z][j];\r\n		  \r\n		  temp[i][j] %= 2011;\r\n		  \r\n	  }\r\n\r\n	 for(i=0;i<4;i++)\r\n	  for(j=0;j<4;j++)\r\n	  {\r\n		  product[i][j] = temp[i][j];\r\n		  \r\n	  }\r\n\r\n\r\n  \r\n}\r\n\r\nint main()\r\n{\r\n	int count;\r\n\r\n	while(scanf("%d",&count)!=-1)\r\n	{\r\n		int i,j,k;\r\n		\r\n		for(k=0;k<count;k++)\r\n		{\r\n			long int num[4][4];\r\n			long int product[4][4];\r\n			memset(product,0,sizeof(product));\r\n\r\n			for (i=0;i<4;i++)\r\n				for (j=0;j<4;j++)\r\n				{\r\n					scanf("%d",&num[i][j]);\r\n					product[i][j] = num[i][j];\r\n				}\r\n\r\n			for(i=0;i<10;i++)\r\n			{\r\n				\r\n				matrix(num,product,i);\r\n			}\r\n\r\n	for(i=0;i<4;i++)\r\n	{\r\n		for(j=0;j<4;j++)\r\n		{\r\n			if(0==j)\r\n				printf("%ld",product[i][j]);\r\n			else\r\n				printf(" %ld",product[i][j]);\r\n		}\r\n		printf("\\n");\r\n	}\r\n	printf("\\n");\r\n\r\n\r\n		}\r\n	}\r\n}', '', 46, 253952, 1, 1, '2011-01-21 03:55:31', '0001-01-01 00:00:00'),
(1385, 14, 403, 8, '#include<stdio.h>\r\n#include<string.h>\r\n#define true 1\r\n#define false 0\r\n#define MAX 3000\r\n\r\nint num[MAX];\r\n\r\nint main()\r\n{\r\n	int n;\r\n   \r\n    while( scanf("%d",&n) != -1)\r\n    {\r\n		int i,j,max=1;\r\n		\r\n		memset(num,0,sizeof(num));\r\n		\r\n		num[0]=1;\r\n		for(i=1;i<=n;i++)\r\n		{\r\n		    int c=0;\r\n		    for(j=0;j<max;j++)\r\n			{\r\n				int temp=num[j]*i+c;\r\n			    num[j]=temp%10;\r\n			    c=temp/10;\r\n				\r\n			}\r\n		\r\n\r\n			while (c)   \r\n			{   \r\n				num[max++] = c % 10;   \r\n				c /= 10;\r\n			}\r\n		}\r\n		\r\n		for(i=max-1;i>=0;i--)\r\n		{\r\n			printf("%d",num[i]);\r\n		}\r\n\r\n		printf("\\n");\r\n	}\r\n	return 0;\r\n}\r\n', '', 61, 262144, 7, 1, '2011-01-21 15:00:03', '0001-01-01 00:00:00'),
(1386, 14, 403, 8, '#include<stdio.h>\r\n#include<string.h>\r\n#define true 1\r\n#define false 0\r\n#define MAX 10000\r\n\r\nint num[MAX];\r\n\r\nint main()\r\n{\r\n	int n;\r\n   \r\n    while( scanf("%d",&n) != -1)\r\n    {\r\n		int i,j,max=1;\r\n		\r\n		memset(num,0,sizeof(num));\r\n		\r\n		num[0]=1;\r\n		for(i=1;i<=n;i++)\r\n		{\r\n		    int c=0;\r\n		    for(j=0;j<max;j++)\r\n			{\r\n				int temp=num[j]*i+c;\r\n			    num[j]=temp%10;\r\n			    c=temp/10;\r\n				\r\n			}\r\n		\r\n\r\n			while (c)   \r\n			{   \r\n				num[max++] = c % 10;   \r\n				c /= 10;\r\n			}\r\n		}\r\n		\r\n		for(i=max-1;i>=0;i--)\r\n		{\r\n			printf("%d",num[i]);\r\n		}\r\n\r\n		printf("\\n");\r\n	}\r\n	return 0;\r\n}\r\n', '', 233, 294912, 7, 1, '2011-01-21 15:00:40', '0001-01-01 00:00:00'),
(1387, 14, 403, 8, '#include<stdio.h>\r\n#include<string.h>\r\n#define true 1\r\n#define false 0\r\n#define MAX 10000\r\n\r\nint num[MAX];\r\n\r\nint main()\r\n{\r\n	int n;\r\n   \r\n    while( scanf("%d",&n) != -1)\r\n    {\r\n		int i,j,max=1;\r\n		\r\n		memset(num,0,sizeof(num));\r\n		\r\n		num[0]=1;\r\n		for(i=1;i<=n;i++)\r\n		{\r\n		    int c=0;\r\n		    for(j=0;j<max;j++)\r\n			{\r\n				int temp=num[j]*i+c;\r\n			    num[j]=temp%10;\r\n			    c=temp/10;\r\n				\r\n			}\r\n		\r\n\r\n			while (c)   \r\n			{   \r\n				num[max++] = c % 10;   \r\n				c /= 10;\r\n			}\r\n		}\r\n		\r\n		for(i=max-1;i>=0;i--)\r\n		{\r\n			printf("%d",num[i]);\r\n		}\r\n\r\n		printf("\\n");\r\n	}\r\n	return 0;\r\n}\r\n', '', 233, 294912, 7, 2, '2011-01-21 15:05:20', '0001-01-01 00:00:00'),
(1388, 14, 403, 8, '#include<stdio.h>\r\n#include<string.h>\r\n#define true 1\r\n#define false 0\r\n#define MAX 40000\r\n\r\nint num[MAX];\r\n\r\nint main()\r\n{\r\n	int n;\r\n   \r\n    while( scanf("%d",&n) != -1)\r\n    {\r\n		int i,j,max=1;\r\n		\r\n		memset(num,0,sizeof(num));\r\n		\r\n		num[0]=1;\r\n		for(i=1;i<=n;i++)\r\n		{\r\n		    int c=0;\r\n		    for(j=0;j<max;j++)\r\n			{\r\n				int temp=num[j]*i+c;\r\n			    num[j]=temp%10;\r\n			    c=temp/10;\r\n				\r\n			}\r\n		\r\n\r\n			while (c)   \r\n			{   \r\n				num[max++] = c % 10;   \r\n				c /= 10;\r\n			}\r\n		}\r\n		\r\n		for(i=max-1;i>=0;i--)\r\n		{\r\n			printf("%d",num[i]);\r\n		}\r\n\r\n		printf("\\n");\r\n	}\r\n	return 0;\r\n}\r\n', '', 1500, 417792, 5, 1, '2011-01-21 15:06:18', '0001-01-01 00:00:00'),
(1389, 14, 403, 8, '#include<stdio.h>\r\n#include<string.h>\r\n#define true 1\r\n#define false 0\r\n#define MAX 20000\r\n\r\nint num[MAX];\r\n\r\nint main()\r\n{\r\n	int n;\r\n   \r\n    while( scanf("%d",&n) != -1)\r\n    {\r\n		int i,j,max=1;\r\n		\r\n		memset(num,0,sizeof(num));\r\n		\r\n		num[0]=1;\r\n		for(i=1;i<=n;i++)\r\n		{\r\n		    int c=0;\r\n		    for(j=0;j<max;j++)\r\n			{\r\n				int temp=num[j]*i+c;\r\n			    num[j]=temp%10;\r\n			    c=temp/10;\r\n				\r\n			}\r\n		\r\n\r\n			while (c)   \r\n			{   \r\n				num[max++] = c % 10;   \r\n				c /= 10;\r\n			}\r\n		}\r\n		\r\n		for(i=max-1;i>=0;i--)\r\n		{\r\n			printf("%d",num[i]);\r\n		}\r\n\r\n		printf("\\n");\r\n	}\r\n	return 0;\r\n}\r\n', '', 654, 335872, 7, 1, '2011-01-21 15:08:27', '0001-01-01 00:00:00'),
(1390, 14, 403, 8, '#include<stdio.h>\r\n#include<string.h>\r\n#define true 1\r\n#define false 0\r\n#define MAX 30000\r\nint num[MAX];\r\n\r\nint main()\r\n{\r\n	int n;\r\n   \r\n    while( scanf("%d",&n) != -1)\r\n    {\r\n		int i,j,max=1;\r\n		\r\n		memset(num,0,sizeof(num));\r\n		\r\n		num[0]=1;\r\n		for(i=1;i<=n;i++)\r\n		{\r\n		    int c=0;\r\n		    for(j=0;j<max;j++)\r\n			{\r\n				int temp=num[j]*i+c;\r\n			    num[j]=temp%10;\r\n			    c=temp/10;\r\n				\r\n			}\r\n		\r\n\r\n			while (c)   \r\n			{   \r\n				num[max++] = c % 10;   \r\n				c /= 10;\r\n			}\r\n		}\r\n		\r\n		for(i=max-1;i>=0;i--)\r\n		{\r\n			printf("%d",num[i]);\r\n		}\r\n\r\n		printf("\\n");\r\n	}\r\n	return 0;\r\n}\r\n', '', 1279, 376832, 7, 1, '2011-01-21 15:09:23', '0001-01-01 00:00:00'),
(1391, 14, 403, 8, '#include <iostream>    \r\n#define MAX 10000\r\n\r\nint result[MAX];\r\nusing namespace std;   \r\n  \r\nint main()   \r\n{   \r\n \r\n \r\n int num;\r\n   \r\n    while( cin >> num)\r\n    {\r\n		int height = 1;\r\n		memset(result,0,sizeof(result));\r\n		result[0] = 1;   \r\n		for (int i=1;i<=num;i++)   \r\n		{   \r\n			int carry = 0; //进位    \r\n			for (int j=0;j<height;j++)   \r\n			{   \r\n				int buf = result[j] * i + carry;     \r\n				result[j] = buf % 10;       \r\n		        carry = buf / 10;   //计算进位    \r\n			}   \r\n			while (carry)   \r\n			{   \r\n				result[height++] = carry % 10;    \r\n				carry /= 10;    \r\n			}   \r\n  \r\n		}\r\n		for (int k=height-1;k>=0;k--)   \r\n		{   \r\n			cout<<result[k];   \r\n		}   \r\n		cout<<endl;   \r\n	}\r\n	return 0;\r\n}', 'Main.cpp: In function ''int main()'':\r\nMain.cpp:16:33: error: ''memset'' was not declared in this scope\r\n', 0, 0, 2, 2, '2011-01-21 15:21:46', '0001-01-01 00:00:00'),
(1392, 14, 403, 8, '#include <iostream> \r\n#include<string.h>\r\n#define MAX 10000\r\n\r\nint result[MAX];\r\nusing namespace std;   \r\n  \r\nint main()   \r\n{   \r\n \r\n \r\n int num;\r\n   \r\n    while( cin >> num)\r\n    {\r\n		int height = 1;\r\n		memset(result,0,sizeof(result));\r\n		result[0] = 1;   \r\n		for (int i=1;i<=num;i++)   \r\n		{   \r\n			int carry = 0; //进位    \r\n			for (int j=0;j<height;j++)   \r\n			{   \r\n				int buf = result[j] * i + carry;     \r\n				result[j] = buf % 10;       \r\n		        carry = buf / 10;   //计算进位    \r\n			}   \r\n			while (carry)   \r\n			{   \r\n				result[height++] = carry % 10;    \r\n				carry /= 10;    \r\n			}   \r\n  \r\n		}\r\n		for (int k=height-1;k>=0;k--)   \r\n		{   \r\n			cout<<result[k];   \r\n		}   \r\n		cout<<endl;   \r\n	}\r\n	return 0;\r\n}', '', 280, 401408, 7, 2, '2011-01-21 15:22:20', '0001-01-01 00:00:00'),
(1393, 20, 336, 2, '#include<stdio.h>\r\nint a[50000],b[50000];\r\nint count(unsigned int n)\r\n{\r\n	int num;\r\n	for(num = 0; n; n >>= 1)\r\n	{\r\n		num += n & 1;\r\n	}\r\n	return num;\r\n}\r\nint Partition(int a[],int b[],int low,int high)\r\n{\r\n	int pivotkey;\r\n	a[0]=a[low];\r\n	b[0]=b[low];\r\n	pivotkey = b[low];\r\n	while(low<high)\r\n	{\r\n		while(low<high&&b[high]>=pivotkey)--high;\r\n		a[low]=a[high];\r\n		b[low]=b[high];\r\n		while(low<high&&b[high]<=pivotkey)++low;\r\n		a[high]=a[low];\r\n		b[high]=b[low];\r\n	}\r\n	a[low]=a[0];\r\n	b[low]=b[0];\r\n	return low;\r\n}\r\nvoid QSort(int a[],int b[],int low,int high)\r\n{\r\n	int pivotloc;\r\n	if(low<high)\r\n	{\r\n		pivotloc = Partition(a,b,low,high);\r\n		QSort(a,b,low,pivotloc-1);\r\n		QSort(a,b,pivotloc+1,high);\r\n	}\r\n}\r\n\r\nint main()\r\n{\r\n	int n,m,i,k;\r\n	int a[50001],b[50001];\r\n	while(scanf("%d",&n)==1)\r\n	{\r\n		if(n>0)\r\n		{\r\n			a[0]=0;\r\n			b[0]=0;\r\n			for(i=1;i<=n;++i)\r\n			{\r\n				scanf("%d",&a[i]);\r\n				b[i]=count(a[i]);\r\n			}\r\n	\r\n			QSort(a,b,1,n);\r\n		\r\n			for(i=1;i<=n;++i)\r\n			{\r\n				m=b[i];\r\n				k=i;\r\n				while(m==b[i+1])\r\n				++i;\r\n				if(k!=i)\r\n				{\r\n					QSort(b,a,k,i);\r\n				}\r\n			}\r\n		\r\n			for(i=1;i<n;++i)\r\n				printf("%d",a[i]);\r\n			printf("%d",a[i]);\r\n		}\r\n		printf("\\n");\r\n	}\r\n	return 0;			\r\n}\r\n', '', 15, 1024000, 4, 2, '2011-01-21 23:34:22', '0001-01-01 00:00:00'),
(1394, 23, 344, 4, '#include<iostream>\r\n#include<map>\r\n#include<string>\r\nusing namespace std;\r\nint main()\r\n{\r\n	int n;\r\n        int i,num;\r\n        string snake;\r\n	while(cin>>n)\r\n	{\r\n		num=0;\r\n		map<string,int>snakes;\r\n		cin >> snake;\r\n		snakes.insert(pair<string,int>(snake,1));\r\n		for(i=2;i<=n;++i)\r\n		{  \r\n		    cin >> snake;\r\n            map<string,int>::iterator iter;\r\n            iter = snakes.find(snake);\r\n            if(iter != snakes.end())\r\n			{\r\n               num=i-iter->second;\r\n            }\r\n			snakes.insert(pair<string,int>(snake,i));\r\n	        }\r\n	        cout << num << endl;\r\n	}\r\n	return 0;\r\n}\r\n', '', 108, 1134592, 1, 2, '2011-01-22 00:46:54', '0001-01-01 00:00:00'),
(1395, 20, 338, 3, '#include<stdio.h>\r\n#define N 50001\r\n#define MAXN 1001\r\nint max(int b[],int n)\r\n{   \r\n	int i;\r\n    int v;\r\n	for(i = 0, v = MAXN - 1; v >= 0; v--)  \r\n	 {  \r\n\r\n			i += b[v];\r\n            if(i >= n+1)         \r\n             break;\r\n		\r\n	 }  \r\n	return v;\r\n}\r\nint min(int b[],int n)\r\n{\r\n	int j;\r\n	int c;	\r\n	for(j=0,c=0; c<=MAXN-1; c++)\r\n	{ \r\n\r\n		\r\n\r\n		 j += b[c];\r\n		 if(j>=n+1)\r\n			break;\r\n		\r\n	}\r\n	return c;\r\n}\r\nint main()\r\n{\r\n\r\n    int k,i;\r\n	int n;\r\n	int km,kc;\r\n	int a[N];	\r\n	while(scanf("%d%d",&n,&k)!=EOF)\r\n	{ \r\n	  int count[N]={0};\r\n      for(i=0;i<n;i++)\r\n	  {\r\n		  scanf("%d",&a[i]);\r\n	      count[a[i]]++;\r\n	  }\r\n    km=max(count,k);\r\n	kc=min(count,k);\r\n	 printf("%d\\n",km-kc);\r\n	}\r\n return 0;\r\n}', '', 390, 618496, 1, 1, '2011-01-22 01:02:13', '0001-01-01 00:00:00'),
(1396, 20, 339, 3, '#include<stdio.h>\r\n#include<stdlib.h>\r\n#define N 100000\r\n#define M 1001\r\nint cmp(const void* x1,const void* x2)\r\n{  \r\n	return *((int*)x2)-*((int*)x1);\r\n}\r\nint main()\r\n{\r\n   	int n,r;\r\n   	int i;\r\n   	int array[N];\r\n   	int k[M];\r\n   	while(scanf("%d%d",&n,&r)!=EOF)\r\n  	{	    \r\n	 	for( i=0;i<r;++i)\r\n	 	{\r\n		 	scanf("%d",&k[i]);\r\n	 	}\r\n	 	for( i=0;i<n;i++)\r\n	 	{\r\n             		scanf("%d",&array[i]);\r\n     		}\r\n 		qsort(array,n,sizeof(array[0]),cmp);   \r\n 		for(i=0;i< r;i++)  \r\n 		{      \r\n			printf("%d\\n",array[k[i]]);        \r\n		}\r\n	}\r\n	return 0;\r\n} \r\n', '', 202, 622592, 1, 1, '2011-01-22 01:09:31', '0001-01-01 00:00:00'),
(1397, 23, 377, 6, '#include<iostream>\r\nusing namespace std;\r\ndouble p[100][2],q[100][2];\r\ndouble direction(double p[],double q[] ,double r[]){ \r\n      return ((r[0]-p[0])*(q[1]-p[1])-(r[1]-p[1])*(q[0]-p[0]));\r\n}\r\nbool onsegment(double p[],double q[], double r[]){\r\n       if(((r[0]-p[0])*(r[0]-q[0])<=0)&&((r[1]-p[1])*(r[1]-q[1])<=0))\r\n           return true;\r\n       else return false;\r\n}\r\nbool judge(int i, int j){\r\n       double d1,d2,d3,d4;\r\n       d1=direction(p[i],q[i],p[j]);\r\n       d2=direction(p[i],q[i],q[j]);\r\n       d3=direction(p[j],q[j],p[i]);\r\n       d4=direction(p[j],q[j],q[i]);\r\n       if((d1*d2<0)&&(d3*d4<0))\r\n                 return true;\r\n       else if(d1==0&& onsegment(p[i],q[i],p[j])==1)\r\n           return true;\r\n       else if(d2==0&& onsegment(p[i],q[i],q[j])==1)\r\n           return true;\r\n       else if(d3==0&& onsegment(p[j],q[j],p[i])==1)\r\n           return true;\r\n       else if(d4==0&& onsegment(p[j],q[j],q[i])==1)\r\n           return true;\r\n       else return false;\r\n}\r\nint main(){\r\n       int n,i,j,count;\r\n       while(scanf("%d",&n)){\r\n           if(n==0)       break;\r\n           for(i=0;i<n;++i){\r\n               scanf("%lf %lf %lf %lf",&p[i][0],&p[i][1],&q[i][0],&q[i][1]);\r\n           }\r\n           for(i=0,count=0;i<n;i++)\r\n               for(j=i+1;j<n;j++)\r\n                   if(judge(i,j)==1)\r\n                       ++count;\r\n           printf("%d\\n",count);\r\n       }\r\n       return 0;\r\n}', 'Main.cpp: In function ''int main()'':\r\nMain.cpp:32:27: error: ''scanf'' was not declared in this scope\r\nMain.cpp:41:31: error: ''printf'' was not declared in this scope\r\n', 0, 0, 2, 2, '2011-01-22 01:25:36', '0001-01-01 00:00:00'),
(1398, 23, 377, 6, '#include<iostream>\r\nusing namespace std;\r\ndouble p[100][2],q[100][2];\r\ndouble direction(double p[],double q[] ,double r[]){ \r\n      return ((r[0]-p[0])*(q[1]-p[1])-(r[1]-p[1])*(q[0]-p[0]));\r\n}\r\nbool onsegment(double p[],double q[], double r[]){\r\n       if(((r[0]-p[0])*(r[0]-q[0])<=0)&&((r[1]-p[1])*(r[1]-q[1])<=0))\r\n           return true;\r\n       else return false;\r\n}\r\nbool judge(int i, int j){\r\n       double d1,d2,d3,d4;\r\n       d1=direction(p[i],q[i],p[j]);\r\n       d2=direction(p[i],q[i],q[j]);\r\n       d3=direction(p[j],q[j],p[i]);\r\n       d4=direction(p[j],q[j],q[i]);\r\n       if((d1*d2<0)&&(d3*d4<0))\r\n                 return true;\r\n       else if(d1==0&& onsegment(p[i],q[i],p[j])==1)\r\n           return true;\r\n       else if(d2==0&& onsegment(p[i],q[i],q[j])==1)\r\n           return true;\r\n       else if(d3==0&& onsegment(p[j],q[j],p[i])==1)\r\n           return true;\r\n       else if(d4==0&& onsegment(p[j],q[j],q[i])==1)\r\n           return true;\r\n       else return false;\r\n}\r\nint main(){\r\n       int n,i,j,count;\r\n       while(scanf("%d",&n)){\r\n           if(n==0)       break;\r\n           for(i=0;i<n;++i){\r\n               scanf("%lf %lf %lf %lf",&p[i][0],&p[i][1],&q[i][0],&q[i][1]);\r\n           }\r\n           for(i=0,count=0;i<n;i++)\r\n               for(j=i+1;j<n;j++)\r\n                   if(judge(i,j)==1)\r\n                       ++count;\r\n           printf("%d\\n",count);\r\n       }\r\n       return 0;\r\n}', 'Main.cpp: In function ''int main()'':\r\nMain.cpp:32:27: error: ''scanf'' was not declared in this scope\r\nMain.cpp:41:31: error: ''printf'' was not declared in this scope\r\n', 0, 0, 2, 2, '2011-01-22 01:26:12', '0001-01-01 00:00:00'),
(1399, 23, 377, 6, '#include<stdio.h>\r\ndouble p[100][2],q[100][2];\r\ndouble direction(double p[],double q[],double r[])\r\n{\r\n    return((r[0]-p[0])*(q[1]-p[1])-(r[1]-p[1])*(q[0]-p[0]));\r\n}\r\nint onsegment(double p[],double q[], double r[])\r\n{\r\n    if(((r[0]-p[0])*(r[0]-q[0])<=0)&&((r[1]-p[1])*(r[1]-q[1])<=0))\r\n        return 1;\r\n    else \r\n        return 0;\r\n}\r\n\r\nint judge(int i, int j)\r\n{\r\n    double d1,d2,d3,d4;\r\n    d1=direction(p[i],q[i],p[j]);\r\n    d2=direction(p[i],q[i],q[j]);\r\n    d3=direction(p[j],q[j],p[i]);\r\n    d4=direction(p[j],q[j],q[i]);\r\n    if((d1*d2<0)&&(d3*d4<0))\r\n        return 1;\r\n    else if(d1==0&&onsegment(p[i],q[i],p[j])==1)\r\n        return 1;\r\n    else if(d2==0&&onsegment(p[i],q[i],q[j])==1)\r\n        return 1;\r\n    else if(d3==0&&onsegment(p[j],q[j],p[i])==1)\r\n        return 1;\r\n    else if(d4==0&&onsegment(p[j],q[j],q[i])==1)\r\n        return 1;\r\n    else return 0;\r\n}\r\n\r\nint main()\r\n{\r\n    int n,i,j,count;\r\n    while(scanf("%d",&n)&&n!=0)\r\n    {\r\n        for(i=0;i<n;i++)\r\n        {\r\n            scanf("%lf%lf%lf%lf",&p[i][0],&p[i][1],&q[i][0],&q[i][1]);\r\n        }\r\n        for(i=0,count=0;i<n;i++)\r\n            for(j=i+1;j<n;j++)\r\n                if(judge(i,j)==1)\r\n                    count++;\r\n        printf("%d\\n",count);\r\n    }\r\n    return 0;\r\n}', '', 30, 258048, 7, 2, '2011-01-22 01:27:35', '0001-01-01 00:00:00'),
(1400, 20, 344, 4, '#include<iostream>\r\n#include<map>\r\n#include<string>\r\nusing namespace std;\r\nint main()\r\n{\r\n	int n;\r\n        int i,num;\r\n        string link;\r\n	while(cin>>n)\r\n	{\r\n		num=0;\r\n		map<string,int>links;\r\n		cin >> link;\r\n		links.insert(pair<string,int>(link,1));\r\n		for(i=2;i<=n;++i)\r\n		{  \r\n		    cin >> link;\r\n            map<string,int>::iterator iter;\r\n            iter = links.find(link);\r\n            if(iter != links.end())\r\n			{\r\n               num=i-iter->second;\r\n            }\r\n			links.insert(pair<string,int>(link,i));\r\n	        }\r\n	        cout << num << endl;\r\n	}\r\n	return 0;\r\n}\r\n', 'Main.c:1:19: fatal error: iostream: No such file or directory\r\ncompilation terminated.\r\n', 0, 0, 2, 1, '2011-01-22 01:35:09', '0001-01-01 00:00:00'),
(1401, 20, 344, 4, '#include<iostream>\r\n#include<map>\r\n#include<string>\r\nusing namespace std;\r\nint main()\r\n{\r\n	int n;\r\n        int i,num;\r\n        string link;\r\n	while(cin>>n)\r\n	{\r\n		num=0;\r\n		map<string,int>links;\r\n		cin >> link;\r\n		links.insert(pair<string,int>(link,1));\r\n		for(i=2;i<=n;++i)\r\n		{  \r\n		    cin >> link;\r\n            map<string,int>::iterator iter;\r\n            iter = links.find(link);\r\n            if(iter != links.end())\r\n			{\r\n               num=i-iter->second;\r\n            }\r\n			links.insert(pair<string,int>(link,i));\r\n	        }\r\n	        cout << num << endl;\r\n	}\r\n	return 0;\r\n}\r\n', 'Main.c:1:19: fatal error: iostream: No such file or directory\r\ncompilation terminated.\r\n', 0, 0, 2, 1, '2011-01-22 01:35:09', '0001-01-01 00:00:00'),
(1402, 20, 344, 4, '#include<iostream>\r\n#include<map>\r\n#include<string>\r\nusing namespace std;\r\nint main()\r\n{\r\n	int n;\r\n        int i,num;\r\n        string link;\r\n	while(cin>>n)\r\n	{\r\n		num=0;\r\n		map<string,int>links;\r\n		cin >> link;\r\n		links.insert(pair<string,int>(link,1));\r\n		for(i=2;i<=n;++i)\r\n		{  \r\n		    cin >> link;\r\n            map<string,int>::iterator iter;\r\n            iter = links.find(link);\r\n            if(iter != links.end())\r\n			{\r\n               num=i-iter->second;\r\n            }\r\n			links.insert(pair<string,int>(link,i));\r\n	        }\r\n	        cout << num << endl;\r\n	}\r\n	return 0;\r\n}\r\n', '', 93, 1134592, 1, 2, '2011-01-22 01:35:26', '0001-01-01 00:00:00'),
(1403, 20, 374, 5, '#include<stdio.h>\r\n#include<stdlib.h>\r\n#define MAX 100001\r\nvoid MSum(int *a,int n)\r\n{       int i;\r\n		int sum=0,maxnum=-1001,first =0, last = 0, temp = 1;\r\n		for (i=0;i<n;i++)\r\n		{\r\n			sum += a[i];\r\n			if (sum > maxnum)\r\n			{\r\n				maxnum = sum;first = temp;last = i+1;\r\n			}\r\n			if (sum < 0)\r\n			{\r\n				sum = 0;temp = i+2;\r\n			}\r\n		}\r\n	printf("%d %d %d\\n",maxnum,first,last);\r\n    return ;\r\n}  \r\nint main()\r\n{   \r\n    int A[MAX];\r\n    int n,i,j,m;\r\n    int num;\r\n    num=1;\r\n    scanf("%d",&m);\r\n    while(m--)\r\n    {\r\n        scanf("%d",&n);\r\n        for(i=0;i<n;i++)\r\n          scanf("%d",&A[i]);\r\n        printf("Case %d:\\n",num);\r\n        MSum(A,n);\r\n        if(m!=0)printf("\\n");\r\n        num++;\r\n    }\r\n    system("pause");\r\n    return 0;\r\n}   \r\n    \r\n', '', 15, 618496, 4, 1, '2011-01-22 01:57:22', '0001-01-01 00:00:00'),
(1404, 23, 379, 7, '#include <stdio.h>\r\n#include <string.h>\r\n#define max 99999\r\nvoid Floyd_Warshall(int *w,int p)\r\n{\r\n    int n=p,k,i,j;\r\n    for (k=0;k<n;k++)\r\n    {\r\n        for (i=0;i<n;i++)\r\n        {\r\n            for (j=0;j<n;j++)\r\n            {\r\n                w[i*n+j]=w[i*n+j]<w[i*n+k]+w[k*n+j]?w[i*n+j]:w[i*n+k]+w[k*n+j];\r\n            }\r\n        }\r\n    }\r\n}\r\nint main()\r\n{\r\n    int n,p,c,i,j,k,*f,m,*w,u,v;\r\n    scanf("%d%d%d",&n,&p,&c);\r\n    f=new int[p];\r\n    w=new int[p*p];\r\n    memset(f,0,sizeof(f));\r\n    for (i=0;i<p;i++)\r\n    {\r\n        for (j=0;j<p;j++)\r\n        {\r\n            if (i==j)\r\n            {\r\n                w[i*p+j]=0;\r\n            }\r\n            else w[i*p+j]=max;\r\n        }\r\n    }\r\n    for (i=0;i<n;i++)\r\n    {\r\n        scanf("%d",&k);\r\n        f[k-1]++;\r\n    }\r\n    for (i=0;i<c;i++)\r\n    {\r\n        scanf("%d%d%d",&u,&v,&k);\r\n        u--;v--;\r\n        w[u*p+v]=k;\r\n        w[v*p+u]=k;\r\n    }\r\n    Floyd_Warshall(w,p);\r\n    int _min=max,_min2;\r\n    for (i=0;i<p;i++)\r\n    {\r\n        _min2=0;\r\n        for (j=0;j<p;j++)\r\n        {\r\n            _min2+=w[i*p+j]*f[j];\r\n        }\r\n        if (_min2<_min)\r\n        {\r\n            _min=_min2;\r\n        }\r\n    }\r\n    printf("%d\\n",_min);\r\n    \r\n} \r\n', 'Main.c: In function ''main'':\r\nMain.c:22:7: error: ''new'' undeclared (first use in this function)\r\nMain.c:22:7: note: each undeclared identifier is reported only once for each function it appears in\r\nMain.c:22:11: error: expected '';'' before ''int''\r\nMain.c:23:11: error: expected '';'' before ''int''\r\n', 0, 0, 2, 1, '2011-01-22 02:14:54', '0001-01-01 00:00:00'),
(1405, 20, 378, 6, '#include<stdio.h>\r\n#include<math.h>\r\n#define M 301\r\ntypedef struct Point\r\n{\r\n        double x;\r\n        double y;\r\n}Point;\r\nPoint mul_pat[M];\r\nint judge(Point p3,Point p1,Point p2)\r\n{\r\n    double k;\r\n    k=(p2.x-p1.x)*(p3.y-p1.y)-(p2.y-p1.y)*(p3.x-p1.x);\r\n    if(k>0)\r\n      return 1;\r\n    else if(k==0)\r\n      return 0;\r\n    else if(k<0)\r\n      return -1;\r\n}\r\n\r\nint main()\r\n{\r\n    int n,m;\r\n    int i,j;\r\n    Point test;\r\n    int count1,count2,count3;\r\n    while(scanf("%d",&n)!=EOF)\r\n    {\r\n      scanf("%d",&m);\r\n      for(i=0;i<n;i++)\r\n        {\r\n                      scanf("%lf%lf",&mul_pat[i].x,&mul_pat[i].y);\r\n          \r\n                      }\r\n      while(m--)\r\n      {   \r\n          count1=count2=count3=0;\r\n          scanf("%lf%lf",&test.x,&test.y);\r\n          for(i=0;i<n;i++)\r\n          {   \r\n              if(judge(test,mul_pat[i],mul_pat[(i+1)%n])==1)\r\n              count1++;\r\n              else if(judge(test,mul_pat[i],mul_pat[(i+1)%n])==0)\r\n              count2++;\r\n              else \r\n              count3++;\r\n          }\r\n          if(count1==n)\r\n            printf("1\\n");\r\n          else if(count3!=0)\r\n           printf("-1\\n");\r\n          else \r\n           printf("0\\n");\r\n       }\r\n       }\r\n       return 0;\r\n}\r\n              \r\n    \r\n', '', 0, 262144, 4, 1, '2011-01-22 02:20:42', '0001-01-01 00:00:00'),
(1406, 20, 379, 7, '#include <stdio.h>\r\n#include <string.h>\r\n#define max 99999\r\nvoid Floyd_Warshall(int *w,int p)\r\n{\r\n    int n=p,k,i,j;\r\n    for (k=0;k<n;k++)\r\n    {\r\n        for (i=0;i<n;i++)\r\n        {\r\n            for (j=0;j<n;j++)\r\n            {\r\n                w[i*n+j]=w[i*n+j]<w[i*n+k]+w[k*n+j]?w[i*n+j]:w[i*n+k]+w[k*n+j];\r\n            }\r\n        }\r\n    }\r\n}\r\nint main()\r\n{\r\n    int n,p,c,i,j,k,*f,m,*w,u,v;\r\n    scanf("%d%d%d",&n,&p,&c);\r\n    f=new int[p];\r\n    w=new int[p*p];\r\n    memset(f,0,sizeof(f));\r\n    for (i=0;i<p;i++)\r\n    {\r\n        for (j=0;j<p;j++)\r\n        {\r\n            if (i==j)\r\n            {\r\n                w[i*p+j]=0;\r\n            }\r\n            else w[i*p+j]=max;\r\n        }\r\n    }\r\n    for (i=0;i<n;i++)\r\n    {\r\n        scanf("%d",&k);\r\n        f[k-1]++;\r\n    }\r\n    for (i=0;i<c;i++)\r\n    {\r\n        scanf("%d%d%d",&u,&v,&k);\r\n        u--;v--;\r\n        w[u*p+v]=k;\r\n        w[v*p+u]=k;\r\n    }\r\n    Floyd_Warshall(w,p);\r\n    int _min=max,_min2;\r\n    for (i=0;i<p;i++)\r\n    {\r\n        _min2=0;\r\n        for (j=0;j<p;j++)\r\n        {\r\n            _min2+=w[i*p+j]*f[j];\r\n        }\r\n        if (_min2<_min)\r\n        {\r\n            _min=_min2;\r\n        }\r\n    }\r\n    printf("%d\\n",_min);\r\n    \r\n} ', 'Main.c: In function ''main'':\r\nMain.c:22:7: error: ''new'' undeclared (first use in this function)\r\nMain.c:22:7: note: each undeclared identifier is reported only once for each function it appears in\r\nMain.c:22:11: error: expected '';'' before ''int''\r\nMain.c:23:11: error: expected '';'' before ''int''\r\n', 0, 0, 2, 1, '2011-01-22 02:48:31', '0001-01-01 00:00:00'),
(1407, 20, 379, 7, '#include<stdio.h>\r\n#include<iostream>\r\nusing namespace std;\r\n#define M 301\r\n\r\ntypedef struct point{\r\n        double x1,y1;\r\n        double x2,y2;\r\n}Point;\r\nPoint seg[M];\r\nint cal(Point p0,Point p1)\r\n{   \r\n     double z1,z2;\r\n     if(p0.x1==p0.x2&&p0.y1==p0.y2&&p1.x2==p1.x1&&p1.y2==p1.y1&&p1.x1!=p0.x2)\r\n     return 0;\r\n     z1=(p0.x1-p1.x1)*(p1.y2-p1.y1)-(p0.y1-p1.y1)*(p1.x2-p1.x1);\r\n     z2=(p1.x2-p1.x1)*(p0.y2-p1.y1)-(p1.y2-p1.y1)*(p0.x2-p1.x1);\r\n     if(z1*z2>=0)\r\n       return 1;\r\n     else \r\n     return 0;\r\n}         \r\nint main()\r\n{\r\n    int i,test,j;\r\n    int count;\r\n    while(scanf("%d",&test)&&test!=0)\r\n    {   \r\n        count=0;\r\n        for(i=0;i<test;i++)\r\n          cin>>seg[i].x1>>seg[i].y1>>seg[i].x2>>seg[i].y2;\r\n        for(i=0;i<test;i++)\r\n         for(j=i+1;j<test;j++)\r\n          if(cal(seg[i],seg[j])&&cal(seg[j],seg[i]))\r\n           count++;\r\n        printf("%d\\n",count);\r\n    }\r\n}\r\n', 'Main.c:2:19: fatal error: iostream: No such file or directory\r\ncompilation terminated.\r\n', 0, 0, 2, 1, '2011-01-22 02:49:38', '0001-01-01 00:00:00'),
(1408, 23, 404, 9, '#include <iostream>\r\n#include <cstring>\r\n#include <cstdio>\r\nusing namespace std;\r\nconst int MAXN = 31;\r\nstruct mat_T {\r\n    int matrix[MAXN][MAXN];\r\n};\r\nmat_T mat;\r\nint n, mod;\r\n\r\nmat_T mul(mat_T a, mat_T b) \r\n{\r\n    int i, j, k;\r\n    mat_T c;\r\n    for(i = 0; i < n; i ++) {\r\n        for(j = 0; j < n; j ++) {\r\n            c.matrix[i][j] = 0;\r\n            for(k = 0; k < n; k ++) {\r\n                c.matrix[i][j] += a.matrix[i][k] * b.matrix[k][j];\r\n                c.matrix[i][j] %= mod;\r\n            }\r\n        }\r\n    }\r\n    return c;\r\n}\r\n \r\nmat_T myPow(int k) \r\n{\r\n    if(k == 1) {\r\n        return mat;\r\n    }else if(k % 2) {\r\n        return mul(myPow(k - 1), mat);\r\n    }else {\r\n        mat_T mt = myPow(k /  2);\r\n        return mul(mt, mt);\r\n    }\r\n}\r\n \r\n\r\nint main() \r\n{\r\n    int i, j, k;\r\n    scanf("%d%d%d", &n, &k, &mod);\r\n    for(i = 0; i < n; i ++)\r\n        for(j = 0; j < n; j ++)\r\n            scanf("%d", &mat.matrix[i][j]);\r\n    mat_T mt = myPow(k);\r\n    for(i = 0; i < n; i ++) {\r\n        for(j = 0; j < n - 1; j ++)\r\n            printf("%d ", mt.matrix[i][j]);\r\n        printf("%d\\n", mt.matrix[i][j]);\r\n    }\r\n    system("pause");\r\n    return(0);\r\n}\r\n', 'Main.c:1:20: fatal error: iostream: No such file or directory\r\ncompilation terminated.\r\n', 0, 0, 2, 1, '2011-01-22 02:53:28', '0001-01-01 00:00:00'),
(1409, 20, 404, 9, '#include <iostream>\r\n#include <cstring>\r\n#include <cstdio>\r\nusing namespace std;\r\nconst int MAXN = 100;\r\nstruct mat_T {\r\n    int matrix[MAXN][MAXN];\r\n};\r\nmat_T mat;\r\nint n, mod;\r\n\r\nmat_T mul(mat_T a, mat_T b) \r\n{\r\n    int i, j, k;\r\n    mat_T c;\r\n    for(i = 0; i < n; i ++) {\r\n        for(j = 0; j < n; j ++) {\r\n            c.matrix[i][j] = 0;\r\n            for(k = 0; k < n; k ++) {\r\n                c.matrix[i][j] += a.matrix[i][k] * b.matrix[k][j];\r\n                c.matrix[i][j] %= mod;\r\n            }\r\n        }\r\n    }\r\n    return c;\r\n}\r\n \r\nmat_T myPow(int k) \r\n{\r\n    if(k == 1) {\r\n        return mat;\r\n    }else if(k % 2) {\r\n        return mul(myPow(k - 1), mat);\r\n    }else {\r\n        mat_T mt = myPow(k /  2);\r\n        return mul(mt, mt);\r\n    }\r\n}\r\n \r\n\r\nint main() \r\n{\r\n    int i, j, k;\r\n    scanf("%d%d%d", &n, &k, &mod);\r\n    for(i = 0; i < n; i ++)\r\n        for(j = 0; j < n; j ++)\r\n            scanf("%d", &mat.matrix[i][j]);\r\n    mat_T mt = myPow(k);\r\n    for(i = 0; i < n; i ++) {\r\n        for(j = 0; j < n - 1; j ++)\r\n            printf("%d ", mt.matrix[i][j]);\r\n        printf("%d\\n", mt.matrix[i][j]);\r\n    }\r\n    system("pause");\r\n    return(0);\r\n}\r\n', 'Main.c:1:20: fatal error: iostream: No such file or directory\r\ncompilation terminated.\r\n', 0, 0, 2, 1, '2011-01-22 03:30:01', '0001-01-01 00:00:00'),
(1410, 6, 345, 4, '#include <stdio.h>\r\n\r\n#include <string.h>\r\n\r\n#include <algorithm>\r\n\r\nusing namespace std;\r\n\r\n#define N 10010\r\n\r\nstruct Node\r\n\r\n{\r\n\r\n   char str[105];\r\n\r\n}qa[N],qb[N],ta[N],tb[N];\r\n\r\n\r\n\r\nbool cmp(const Node& a,const Node& b)\r\n\r\n{\r\n\r\n    return strcmp(a.str,b.str)<0;\r\n\r\n}\r\n\r\n\r\n\r\nint find(char s[],Node q[],int n)\r\n\r\n{\r\n\r\n    int mid,low=0,high=n-1,t;\r\n\r\n    while(low<=high)\r\n\r\n    {\r\n\r\n        mid=(low+high)>>1;\r\n\r\n        int t=strcmp(q[mid].str,s);\r\n\r\n        if(t==0) return mid;\r\n\r\n        else if(t<0) low=mid+1;\r\n\r\n        else         high=mid-1; \r\n\r\n    }\r\n\r\n    return -1;\r\n\r\n}\r\n\r\n\r\n\r\nint main()\r\n\r\n{\r\n\r\n    int i,n,m,t;\r\n\r\n    while(scanf("%d",&n)!=EOF)\r\n\r\n    {\r\n\r\n        for(i=0;i<n;++i)\r\n\r\n        {\r\n\r\n            scanf("%s",&qa[i].str);\r\n\r\n            strcpy(ta[i].str,qa[i].str);\r\n\r\n        }\r\n\r\n        \r\n\r\n        scanf("%d",&m);\r\n\r\n        for(i=0;i<m;++i)\r\n\r\n        {\r\n\r\n            scanf("%s",&qb[i].str);\r\n\r\n            strcpy(tb[i].str,qb[i].str);\r\n\r\n        }\r\n\r\n        \r\n\r\n        sort(ta,ta+n,cmp);\r\n\r\n        sort(tb,tb+m,cmp);\r\n\r\n        \r\n\r\n        for(i=0;i<n;++i)\r\n\r\n        {\r\n\r\n            t=find(qa[i].str,tb,m);\r\n\r\n            if(t!=-1) break;\r\n\r\n        }\r\n\r\n        if(t==-1) printf("none ");\r\n\r\n        else      printf("%s ",tb[t].str);\r\n\r\n        \r\n\r\n        for(i=0;i<m;++i)\r\n\r\n        {\r\n\r\n            t=find(qb[i].str,ta,n);\r\n\r\n            if(t!=-1) break;\r\n\r\n        }\r\n\r\n        if(t==-1) printf("none\\n");\r\n\r\n        else      printf("%s\\n",ta[t].str);\r\n\r\n    }\r\n\r\n    return 0;\r\n\r\n}', '', 15, 4468736, 1, 2, '2011-01-22 15:36:10', '0001-01-01 00:00:00'),
(1411, 27, 404, 9, '//#include "stdafx.h"\r\n#include <stdio.h>\r\nint a[4][4],b[4][4],c[4][4];\r\n\r\nvoid multi()\r\n{\r\n	int i,j,k,save;\r\n	for(i=0;i<4;++i){\r\n		for(j=0;j<4;++j){\r\n			save=0;\r\n			for(k=0;k<4;++k){\r\n				save+=(a[i][k]*b[k][j]);\r\n			}\r\n			c[i][j]=save%2011;\r\n		}\r\n	}\r\n	for(i=0;i<4;++i){\r\n		for(j=0;j<4;++j){\r\n			a[i][j]=c[i][j];\r\n		}\r\n	}\r\n}\r\n\r\nint main(int argc, char* argv[])\r\n{\r\n	int i,j,k,n;\r\n	scanf("%d",&n);\r\n	for(i=0;i<n;++i){\r\n		for(j=0;j<4;++j){\r\n			for(k=0;k<4;++k){\r\n			    scanf("%d",&a[j][k]);\r\n			    b[j][k]=a[j][k];\r\n			}\r\n		}\r\n		for(j=1;j<2011;++j){\r\n			multi();\r\n		}\r\n		printf("\\n");\r\n		for(j=0;j<4;++j){\r\n			for(k=0;k<4;++k){\r\n				if(k!=3){ printf("%d ",a[j][k]); }\r\n				else printf("%d\\n",a[j][k]);		    \r\n			}\r\n		}\r\n		\r\n	}\r\n	return 0;\r\n}\r\n', '', 300, 258048, 5, 1, '2011-01-22 16:35:50', '0001-01-01 00:00:00'),
(1412, 27, 404, 9, '#include <stdio.h>\r\nint a[4][4],b[4][4],c[4][4];\r\n\r\nvoid multi()\r\n{\r\n	int i,j,k,save;\r\n	for(i=0;i<4;++i){\r\n		for(j=0;j<4;++j){\r\n			save=0;\r\n			for(k=0;k<4;++k){\r\n				save+=(a[i][k]*b[k][j]);\r\n			}\r\n			c[i][j]=save%2011;\r\n		}\r\n	}\r\n	for(i=0;i<4;++i){\r\n		for(j=0;j<4;++j){\r\n			a[i][j]=c[i][j];\r\n		}\r\n	}\r\n}\r\n\r\nint main(int argc, char* argv[])\r\n{\r\n	int i,j,k,n;\r\n	scanf("%d",&n);\r\n	for(i=0;i<n;++i){\r\n		for(j=0;j<4;++j){\r\n			for(k=0;k<4;++k){\r\n			    scanf("%d",&a[j][k]);\r\n			    b[j][k]=a[j][k];\r\n			}\r\n		}\r\n		for(j=1;j<201;++j){\r\n			multi();\r\n		}\r\n		printf("\\n");\r\n		for(j=0;j<4;++j){\r\n			for(k=0;k<4;++k){\r\n				if(k!=3){ printf("%d ",a[j][k]); }\r\n				else printf("%d\\n",a[j][k]);		    \r\n			}\r\n		}\r\n		\r\n	}\r\n	return 0;\r\n}\r\n', '', 46, 253952, 4, 1, '2011-01-22 16:38:05', '0001-01-01 00:00:00'),
(1413, 27, 404, 9, '#include <stdio.h>\r\nint a[4][4],b[4][4],c[4][4];\r\n\r\nvoid multi()\r\n{\r\n	int i,j,k,save;\r\n	for(i=0;i<4;++i){\r\n		for(j=0;j<4;++j){\r\n/*			save=0;\r\n			for(k=0;k<4;++k){\r\n				save+=(a[i][k]*b[k][j]);\r\n			}\r\n*/			save=a[i][0]*b[0][j]+a[i][1]*b[1][j]+a[i][2]*b[2][j]+a[i][3]*b[3][j];\r\n            c[i][j]=save%2011;\r\n		}\r\n	}\r\n	for(i=0;i<4;++i){\r\n		for(j=0;j<4;++j){\r\n			a[i][j]=c[i][j];\r\n		}\r\n	}\r\n}\r\n\r\nint main(int argc, char* argv[])\r\n{\r\n	int i,j,k,n;\r\n	scanf("%d",&n);\r\n	for(i=0;i<n;++i){\r\n		for(j=0;j<4;++j){\r\n			for(k=0;k<4;++k){\r\n			    scanf("%d",&a[j][k]);\r\n			    b[j][k]=a[j][k];\r\n			}\r\n		}\r\n		for(j=1;j<2011;++j){\r\n			multi();\r\n		}\r\n		printf("\\n");\r\n		for(j=0;j<4;++j){\r\n			for(k=0;k<4;++k){\r\n				if(k!=3){ printf("%d ",a[j][k]); }\r\n				else printf("%d\\n",a[j][k]);		    \r\n			}\r\n		}\r\n		\r\n	}\r\n	return 0;\r\n}\r\n', '', 218, 258048, 3, 1, '2011-01-22 16:42:50', '0001-01-01 00:00:00'),
(1414, 27, 404, 9, '#include <stdio.h>\r\nint a[4][4],b[4][4],c[4][4];\r\n\r\nvoid multi()\r\n{\r\n	int i,j,k,save;\r\n	for(i=0;i<4;++i){\r\n		for(j=0;j<4;++j){\r\n/*			save=0;\r\n			for(k=0;k<4;++k){\r\n				save+=(a[i][k]*b[k][j]);\r\n			}\r\n*/			save=a[i][0]*b[0][j]+a[i][1]*b[1][j]+a[i][2]*b[2][j]+a[i][3]*b[3][j];\r\n            c[i][j]=save%2011;\r\n		}\r\n	}\r\n	for(i=0;i<4;++i){\r\n		for(j=0;j<4;++j){\r\n			a[i][j]=c[i][j];\r\n		}\r\n	}\r\n}\r\n\r\nint main(int argc, char* argv[])\r\n{\r\n	int i,j,k,n;\r\n	scanf("%d",&n);\r\n	for(i=0;i<n;++i){\r\n		for(j=0;j<4;++j){\r\n			for(k=0;k<4;++k){\r\n			    scanf("%d",&a[j][k]);\r\n			    b[j][k]=a[j][k];\r\n			}\r\n		}\r\n		for(j=1;j<2011;++j){\r\n			multi();\r\n		}\r\n		printf("\\n");\r\n		for(j=0;j<4;++j){\r\n			for(k=0;k<4;++k){\r\n				if(k!=3){ printf("%d ",a[j][k]); }\r\n				else printf("%d\\n",a[j][k]);		    \r\n			}\r\n		}\r\n		printf("\\n");\r\n	}\r\n	return 0;\r\n}\r\n', '', 218, 253952, 3, 1, '2011-01-22 16:47:37', '0001-01-01 00:00:00'),
(1415, 27, 404, 9, '#include <stdio.h>\r\nint a[4][4],b[4][4],c[4][4];\r\n\r\nvoid multi()\r\n{\r\n	int i,j,k,save;\r\n	for(i=0;i<4;++i){\r\n		for(j=0;j<4;++j){\r\n/*			save=0;\r\n			for(k=0;k<4;++k){\r\n				save+=(a[i][k]*b[k][j]);\r\n			}\r\n*/			save=a[i][0]*b[0][j]+a[i][1]*b[1][j]+a[i][2]*b[2][j]+a[i][3]*b[3][j];\r\n            c[i][j]=save%2011;\r\n		}\r\n	}\r\n	for(i=0;i<4;++i){\r\n		for(j=0;j<4;++j){\r\n			a[i][j]=c[i][j];\r\n		}\r\n	}\r\n}\r\n\r\nint main(int argc, char* argv[])\r\n{\r\n	int i,j,k,n;\r\n	scanf("%d",&n);\r\n	for(i=0;i<n;++i){\r\n		for(j=0;j<4;++j){\r\n			for(k=0;k<4;++k){\r\n			    scanf("%d",&a[j][k]);\r\n			    b[j][k]=a[j][k];\r\n			}\r\n		}\r\n		for(j=1;j<2011;++j){\r\n			multi();\r\n		}\r\n//		printf("\\n");\r\n		for(j=0;j<4;++j){\r\n			for(k=0;k<4;++k){\r\n				if(k!=3){ printf("%d ",a[j][k]); }\r\n				else printf("%d\\n",a[j][k]);		    \r\n			}\r\n		}\r\n		printf("\\n");\r\n	}\r\n	return 0;\r\n}\r\n', '', 300, 258048, 5, 1, '2011-01-22 16:51:44', '0001-01-01 00:00:00'),
(1416, 27, 404, 9, '#include <stdio.h>\r\nint a[4][4],b[4][4],c[4][4];\r\n\r\nvoid multi(int choose)\r\n{\r\n	int i,j,k,save;\r\n	if(choose==1){\r\n    	for(i=0;i<4;++i){\r\n    		for(j=0;j<4;++j){\r\n/*			save=0;\r\n			for(k=0;k<4;++k){\r\n				save+=(a[i][k]*b[k][j]);\r\n			}\r\n*/  			save=a[i][0]*a[0][j]+a[i][1]*a[1][j]+a[i][2]*a[2][j]+a[i][3]*a[3][j];\r\n                c[i][j]=save%2011;\r\n     		}\r\n    	}\r\n	}\r\n	else {\r\n		for(i=0;i<4;++i){\r\n    		for(j=0;j<4;++j){\r\n/*			save=0;\r\n			for(k=0;k<4;++k){\r\n				save+=(a[i][k]*b[k][j]);\r\n			}\r\n*/  			save=a[i][0]*b[0][j]+a[i][1]*b[1][j]+a[i][2]*b[2][j]+a[i][3]*b[3][j];\r\n                c[i][j]=save%2011;\r\n     		}\r\n    	}\r\n	}\r\n	for(i=0;i<4;++i){\r\n		for(j=0;j<4;++j){\r\n			a[i][j]=c[i][j];\r\n		}\r\n	}\r\n}\r\n\r\nint main(int argc, char* argv[])\r\n{\r\n	int i,j,k,n;\r\n	scanf("%d",&n);\r\n	for(i=0;i<n;++i){\r\n		for(j=0;j<4;++j){\r\n			for(k=0;k<4;++k){\r\n			    scanf("%d",&a[j][k]);\r\n			    b[j][k]=a[j][k];\r\n			}\r\n		}\r\n		for(j=2011;j>1;){\r\n			if(j&1==0){\r\n				multi(1);\r\n				j=j/2;\r\n			}else{\r\n			    multi(2);\r\n			    --j;\r\n			}\r\n		}\r\n		printf("\\n");//\r\n		for(j=0;j<4;++j){\r\n			for(k=0;k<4;++k){\r\n				if(k!=3){ printf("%d ",a[j][k]); }\r\n				else printf("%d\\n",a[j][k]);		    \r\n			}\r\n		}\r\n		printf("\\n");\r\n	}\r\n	return 0;\r\n}\r\n', '', 234, 258048, 3, 1, '2011-01-22 17:28:16', '0001-01-01 00:00:00'),
(1417, 27, 404, 9, '#include <stdio.h>\r\nint a[4][4],b[4][4],c[4][4];\r\n\r\nvoid multi(int choose)\r\n{\r\n	int i,j,k,save;\r\n	if(choose==1){\r\n    	for(i=0;i<4;++i){\r\n    		for(j=0;j<4;++j){\r\n/*			save=0;\r\n			for(k=0;k<4;++k){\r\n				save+=(a[i][k]*b[k][j]);\r\n			}\r\n*/  			save=a[i][0]*a[0][j]+a[i][1]*a[1][j]+a[i][2]*a[2][j]+a[i][3]*a[3][j];\r\n                c[i][j]=save%2011;\r\n     		}\r\n    	}\r\n	}\r\n	else {\r\n		for(i=0;i<4;++i){\r\n    		for(j=0;j<4;++j){\r\n/*			save=0;\r\n			for(k=0;k<4;++k){\r\n				save+=(a[i][k]*b[k][j]);\r\n			}\r\n*/  			save=a[i][0]*b[0][j]+a[i][1]*b[1][j]+a[i][2]*b[2][j]+a[i][3]*b[3][j];\r\n                c[i][j]=save%2011;\r\n     		}\r\n    	}\r\n	}\r\n	for(i=0;i<4;++i){\r\n		for(j=0;j<4;++j){\r\n			a[i][j]=c[i][j];\r\n		}\r\n	}\r\n}\r\n\r\nint main(int argc, char* argv[])\r\n{\r\n	int i,j,k,n;\r\n	scanf("%d",&n);\r\n	for(i=0;i<n;++i){\r\n		for(j=0;j<4;++j){\r\n			for(k=0;k<4;++k){\r\n			    scanf("%d",&a[j][k]);\r\n			    b[j][k]=a[j][k];\r\n			}\r\n		}\r\n		for(j=2011;j>1;){\r\n			if(j&1==0){\r\n				multi(1);\r\n				j=j/2;\r\n			}else{\r\n			    multi(2);\r\n			    --j;\r\n			}\r\n		}\r\n//		printf("\\n");//\r\n		for(j=0;j<4;++j){\r\n			for(k=0;k<4;++k){\r\n				if(k!=3){ printf("%d ",a[j][k]); }\r\n				else printf("%d\\n",a[j][k]);		    \r\n			}\r\n		}\r\n		printf("\\n");\r\n	}\r\n	return 0;\r\n}\r\n', '', 300, 258048, 5, 1, '2011-01-22 17:28:49', '0001-01-01 00:00:00');
INSERT INTO `tbl_submitions` (`id`, `user_id`, `problem_id`, `exercise_id`, `source`, `result`, `used_time`, `used_memory`, `status`, `compiler_id`, `created`, `modified`) VALUES
(1418, 27, 404, 9, '#include <stdio.h>\r\nint a[4][4],b[4][4],c[4][4];\r\n\r\nvoid multi(int choose)\r\n{\r\n	int i,j,k,save;\r\n	if(choose==1){\r\n    	for(i=0;i<4;++i){\r\n    		for(j=0;j<4;++j){\r\n  		    	save=a[i][0]*a[0][j]+a[i][1]*a[1][j]+a[i][2]*a[2][j]+a[i][3]*a[3][j];\r\n                c[i][j]=save%2011;\r\n     		}\r\n    	}\r\n	}\r\n	else {\r\n		for(i=0;i<4;++i){\r\n    		for(j=0;j<4;++j){\r\n  		    	save=a[i][0]*b[0][j]+a[i][1]*b[1][j]+a[i][2]*b[2][j]+a[i][3]*b[3][j];\r\n                c[i][j]=save%2011;\r\n     		}\r\n    	}\r\n	}\r\n	for(i=0;i<4;++i){\r\n		for(j=0;j<4;++j){\r\n			a[i][j]=c[i][j];\r\n		}\r\n	}\r\n}\r\n\r\nint main(int argc, char* argv[])\r\n{\r\n	int i,j,k,n;\r\n	scanf("%d",&n);\r\n	for(i=0;i<n;++i){\r\n		for(j=0;j<4;++j){\r\n			for(k=0;k<4;++k){\r\n			    scanf("%d",&a[j][k]);\r\n			    b[j][k]=a[j][k];\r\n			}\r\n		}\r\n		for(j=2011;j>1;){\r\n			if(j&1==0){\r\n				multi(1);\r\n				j=j/2;\r\n			}else{\r\n			    multi(2);\r\n			    --j;\r\n			}\r\n		}\r\n//		printf("\\n");//\r\n		for(j=0;j<4;++j){\r\n			for(k=0;k<4;++k){\r\n				if(k!=3){ printf("%d ",a[j][k]); }\r\n				else printf("%d\\n",a[j][k]);		    \r\n			}\r\n		}\r\n		printf("\\n");\r\n	}\r\n	return 0;\r\n}\r\n', '', 300, 258048, 5, 1, '2011-01-22 17:36:56', '0001-01-01 00:00:00'),
(1419, 27, 379, 7, '#include <stdio.h>\r\n#include <string.h>\r\n#define max 99999\r\nvoid Floyd_Warshall(int *w,int p)\r\n{\r\n    int n=p,k,i,j;\r\n    for (k=0;k<n;k++)\r\n    {\r\n        for (i=0;i<n;i++)\r\n        {\r\n            for (j=0;j<n;j++)\r\n            {\r\n                w[i*n+j]=w[i*n+j]<w[i*n+k]+w[k*n+j]?w[i*n+j]:w[i*n+k]+w[k*n+j];\r\n            }\r\n        }\r\n    }\r\n}\r\nint main()\r\n{\r\n    int n,p,c,i,j,k,*f,m,*w,u,v;\r\n    scanf("%d%d%d",&n,&p,&c);\r\n    f=new int[p];\r\n    w=new int[p*p];\r\n    memset(f,0,sizeof(f));\r\n    for (i=0;i<p;i++)\r\n    {\r\n        for (j=0;j<p;j++)\r\n        {\r\n            if (i==j)\r\n            {\r\n                w[i*p+j]=0;\r\n            }\r\n            else w[i*p+j]=max;\r\n        }\r\n    }\r\n    for (i=0;i<n;i++)\r\n    {\r\n        scanf("%d",&k);\r\n        f[k-1]++;\r\n    }\r\n    for (i=0;i<c;i++)\r\n    {\r\n        scanf("%d%d%d",&u,&v,&k);\r\n        u--;v--;\r\n        w[u*p+v]=k;\r\n        w[v*p+u]=k;\r\n    }\r\n    Floyd_Warshall(w,p);\r\n    int _min=max,_min2;\r\n    for (i=0;i<p;i++)\r\n    {\r\n        _min2=0;\r\n        for (j=0;j<p;j++)\r\n        {\r\n            _min2+=w[i*p+j]*f[j];\r\n        }\r\n        if (_min2<_min)\r\n        {\r\n            _min=_min2;\r\n        }\r\n    }\r\n    printf("%d\\n",_min-1);\r\n    \r\n} \r\n', 'Main.c: In function ''main'':\r\nMain.c:22:7: error: ''new'' undeclared (first use in this function)\r\nMain.c:22:7: note: each undeclared identifier is reported only once for each function it appears in\r\nMain.c:22:11: error: expected '';'' before ''int''\r\nMain.c:23:11: error: expected '';'' before ''int''\r\n', 0, 0, 2, 1, '2011-01-22 18:42:06', '0001-01-01 00:00:00'),
(1420, 27, 379, 7, '#include <stdio.h>\r\n#include <string.h>\r\n#define max 99999\r\nvoid Floyd_Warshall(int *w,int p)\r\n{\r\n    int n=p,k,i,j;\r\n    for (k=0;k<n;k++)\r\n    {\r\n        for (i=0;i<n;i++)\r\n        {\r\n            for (j=0;j<n;j++)\r\n            {\r\n                w[i*n+j]=w[i*n+j]<w[i*n+k]+w[k*n+j]?w[i*n+j]:w[i*n+k]+w[k*n+j];\r\n            }\r\n        }\r\n    }\r\n}\r\nint main()\r\n{\r\n    int n,p,c,i,j,k,*f,m,*w,u,v;\r\n    scanf("%d%d%d",&n,&p,&c);\r\n    f=new int[p];\r\n    w=new int[p*p];\r\n    memset(f,0,sizeof(f));\r\n    for (i=0;i<p;i++)\r\n    {\r\n        for (j=0;j<p;j++)\r\n        {\r\n            if (i==j)\r\n            {\r\n                w[i*p+j]=0;\r\n            }\r\n            else w[i*p+j]=max;\r\n        }\r\n    }\r\n    for (i=0;i<n;i++)\r\n    {\r\n        scanf("%d",&k);\r\n        f[k-1]++;\r\n    }\r\n    for (i=0;i<c;i++)\r\n    {\r\n        scanf("%d%d%d",&u,&v,&k);\r\n        u--;v--;\r\n        w[u*p+v]=k;\r\n        w[v*p+u]=k;\r\n    }\r\n    Floyd_Warshall(w,p);\r\n    int _min=max,_min2;\r\n    for (i=0;i<p;i++)\r\n    {\r\n        _min2=0;\r\n        for (j=0;j<p;j++)\r\n        {\r\n            _min2+=w[i*p+j]*f[j];\r\n        }\r\n        if (_min2<_min)\r\n        {\r\n            _min=_min2;\r\n        }\r\n    }\r\n    printf("%d\\n",_min-1);\r\n    \r\n} \r\n', '', 0, 278528, 4, 2, '2011-01-22 18:42:25', '0001-01-01 00:00:00'),
(1421, 10, 377, 6, '#include<stdio.h>\r\n\r\n#define MAX 300\r\ntypedef struct point\r\n{\r\n	double x;\r\n	double y;\r\n}point;\r\n\r\ntypedef struct line\r\n{\r\n	point x;\r\n	point y;\r\n}line;\r\n\r\npoint minus(point a,point b)\r\n{\r\n	point temp;\r\n	temp.x = a.x - b.x;\r\n	temp.y = a.y - b.y;\r\n\r\n	return temp;\r\n}\r\nint judge(point p1,point p2,point q1,point q2)\r\n{\r\n	point p1_q1,p2_q1,q2_q1;\r\n	point q1_p1,p2_p1,q2_p1;\r\n\r\n	p1_q1 = minus(p1,q1);\r\n	p2_q1 = minus(p2,q1);\r\n	q2_q1 = minus(q2,q1);\r\n\r\n	q1_p1 = minus(q1,p1);\r\n	p2_p1 = minus(p2,p1);\r\n	q2_p1 = minus(q2,p1);\r\n\r\n	if(((p1_q1.x * q2_q1.y - q2_q1.x * p1_q1.y) *\r\n		(p2_q1.x * q2_q1.y - p2_q1.y * q2_q1.x) < 0)\r\n		&&\r\n	   ((q1_p1.x * p2_p1.y - p2_p1.x * q1_p1.y) *\r\n		(q2_p1.x * p2_p1.y - p2_p1.x * q2_p1.y) < 0))\r\n	    return 1;\r\n	else\r\n		return 0;\r\n}\r\n\r\nint main()\r\n{\r\n	int i,j,size;\r\n	int count=0;\r\n	line shuzu[MAX];\r\n	scanf("%d",&size);\r\n\r\n	for(i=0;i != size;++i)\r\n	{\r\n		scanf("%lf %lf",&shuzu[i].x.x,&shuzu[i].x.y);\r\n		scanf("%lf %lf",&shuzu[i].y.x,&shuzu[i].y.y);\r\n	}\r\n\r\n    i = 0;\r\n	while(i+1 != size)\r\n	{\r\n		j= i+1;\r\n		while(j != size)\r\n		{\r\n			if ((shuzu[i].x.x == shuzu[j].x.x && shuzu[i].x.y == shuzu[j].x.y)||\r\n				(shuzu[i].x.x == shuzu[j].y.x && shuzu[i].x.y == shuzu[j].y.y)||\r\n				(shuzu[i].y.x == shuzu[j].x.x && shuzu[i].y.y == shuzu[j].x.y)||\r\n				(shuzu[i].y.x == shuzu[j].y.x && shuzu[i].y.y == shuzu[j].y.y)||\r\n				(1 == judge(shuzu[i].x,shuzu[i].y,shuzu[j].x,shuzu[j].y)))\r\n			count++;\r\n		++j;\r\n		}\r\n		++i;\r\n	}\r\n	printf("%d\\n",count);\r\n	return 0;\r\n}\r\n\r\n', '', 0, 258048, 4, 1, '2011-01-23 21:49:18', '0001-01-01 00:00:00'),
(1422, 10, 377, 6, '#include<stdio.h>\r\n\r\n#define MAX 300\r\ntypedef struct point\r\n{\r\n	double x;\r\n	double y;\r\n}point;\r\n\r\ntypedef struct line\r\n{\r\n	point x;\r\n	point y;\r\n}line;\r\n\r\npoint minus(point a,point b)\r\n{\r\n	point temp;\r\n	temp.x = a.x - b.x;\r\n	temp.y = a.y - b.y;\r\n\r\n	return temp;\r\n}\r\nint judge(point p1,point p2,point q1,point q2)\r\n{\r\n	point p1_q1,p2_q1,q2_q1;\r\n	point q1_p1,p2_p1,q2_p1;\r\n\r\n	p1_q1 = minus(p1,q1);\r\n	p2_q1 = minus(p2,q1);\r\n	q2_q1 = minus(q2,q1);\r\n\r\n	q1_p1 = minus(q1,p1);\r\n	p2_p1 = minus(p2,p1);\r\n	q2_p1 = minus(q2,p1);\r\n\r\n	if(((p1_q1.x * q2_q1.y - q2_q1.x * p1_q1.y) *\r\n		(p2_q1.x * q2_q1.y - p2_q1.y * q2_q1.x) <= 0)\r\n		&&\r\n	   ((q1_p1.x * p2_p1.y - p2_p1.x * q1_p1.y) *\r\n		(q2_p1.x * p2_p1.y - p2_p1.x * q2_p1.y) <= 0))\r\n	    return 1;\r\n	else\r\n		return 0;\r\n}\r\n\r\nint main()\r\n{\r\n	int i,j,size;\r\n	int count=0;\r\n	line shuzu[MAX];\r\n	scanf("%d",&size);\r\n\r\n	for(i=0;i != size;++i)\r\n	{\r\n		scanf("%lf %lf",&shuzu[i].x.x,&shuzu[i].x.y);\r\n		scanf("%lf %lf",&shuzu[i].y.x,&shuzu[i].y.y);\r\n	}\r\n\r\n	/*(shuzu[i].x.x == shuzu[j].x.x && shuzu[i].x.y == shuzu[j].x.y)||\r\n				(shuzu[i].x.x == shuzu[j].y.x && shuzu[i].x.y == shuzu[j].y.y)||\r\n				(shuzu[i].y.x == shuzu[j].x.x && shuzu[i].y.y == shuzu[j].x.y)||\r\n				(shuzu[i].y.x == shuzu[j].y.x && shuzu[i].y.y == shuzu[j].y.y)||\r\n				*/\r\n    i = 0;\r\n	while(i+1 != size)\r\n	{\r\n		j= i+1;\r\n		while(j != size)\r\n		{\r\n			if ((1 == judge(shuzu[i].x,shuzu[i].y,shuzu[j].x,shuzu[j].y)))\r\n			count++;\r\n		++j;\r\n		}\r\n		++i;\r\n	}\r\n	printf("%d\\n",count);\r\n	return 0;\r\n}\r\n\r\n', '', 0, 253952, 4, 1, '2011-01-23 21:56:24', '0001-01-01 00:00:00'),
(1423, 10, 377, 6, '#include<stdio.h>\r\n\r\n#define MAX 300\r\ntypedef struct point\r\n{\r\n	double x;\r\n	double y;\r\n}point;\r\n\r\ntypedef struct line\r\n{\r\n	point x;\r\n	point y;\r\n}line;\r\n\r\npoint minus(point a,point b)\r\n{\r\n	point temp;\r\n	temp.x = a.x - b.x;\r\n	temp.y = a.y - b.y;\r\n\r\n	return temp;\r\n}\r\nint judge(point p1,point p2,point q1,point q2)\r\n{\r\n	point p1_q1,p2_q1,q2_q1;\r\n	point q1_p1,p2_p1,q2_p1;\r\n\r\n	p1_q1 = minus(p1,q1);\r\n	p2_q1 = minus(p2,q1);\r\n	q2_q1 = minus(q2,q1);\r\n\r\n	q1_p1 = minus(q1,p1);\r\n	p2_p1 = minus(p2,p1);\r\n	q2_p1 = minus(q2,p1);\r\n\r\n	if(((p1_q1.x * q2_q1.y - q2_q1.x * p1_q1.y) *\r\n		(p2_q1.x * q2_q1.y - p2_q1.y * q2_q1.x) <= 0)\r\n		&&\r\n	   ((q1_p1.x * p2_p1.y - p2_p1.x * q1_p1.y) *\r\n		(q2_p1.x * p2_p1.y - p2_p1.x * q2_p1.y) <= 0))\r\n	    return 1;\r\n	else\r\n		return 0;\r\n}\r\n\r\nint main()\r\n{\r\n	int i,j,size;\r\n	int count=0;\r\n	line shuzu[MAX];\r\n	while(1)\r\n	{\r\n	scanf("%d",&size);\r\n	if (0 == size)\r\n		break;\r\n\r\n	for(i=0;i != size;++i)\r\n	{\r\n		scanf("%lf %lf",&shuzu[i].x.x,&shuzu[i].x.y);\r\n		scanf("%lf %lf",&shuzu[i].y.x,&shuzu[i].y.y);\r\n	}\r\n\r\n	count = 0;\r\n	/*(shuzu[i].x.x == shuzu[j].x.x && shuzu[i].x.y == shuzu[j].x.y)||\r\n				(shuzu[i].x.x == shuzu[j].y.x && shuzu[i].x.y == shuzu[j].y.y)||\r\n				(shuzu[i].y.x == shuzu[j].x.x && shuzu[i].y.y == shuzu[j].x.y)||\r\n				(shuzu[i].y.x == shuzu[j].y.x && shuzu[i].y.y == shuzu[j].y.y)||\r\n				*/\r\n    i = 0;\r\n	while(i+1 != size)\r\n	{\r\n		j= i+1;\r\n		while(j != size)\r\n		{\r\n			if ((1 == judge(shuzu[i].x,shuzu[i].y,shuzu[j].x,shuzu[j].y)))\r\n			count++;\r\n		++j;\r\n		}\r\n		++i;\r\n	}\r\n	printf("%d\\n",count);\r\n	}\r\n	return 0;\r\n}\r\n\r\n', '', 0, 258048, 4, 1, '2011-01-23 22:05:57', '0001-01-01 00:00:00'),
(1424, 10, 377, 6, '#include<stdio.h>\r\n\r\n#define MAX 300\r\ntypedef struct point\r\n{\r\n	double x;\r\n	double y;\r\n}point;\r\n\r\ntypedef struct line\r\n{\r\n	point x;\r\n	point y;\r\n}line;\r\n\r\npoint minus(point a,point b)\r\n{\r\n	point temp;\r\n	temp.x = a.x - b.x;\r\n	temp.y = a.y - b.y;\r\n\r\n	return temp;\r\n}\r\nint judge_1(point p1,point p2,point q1,point q2)\r\n{\r\n	if( (((p1.x <= q1.x) && (q1.x<= p2.x)) && ((p1.y <= q1.y) && (q1.y <= p2.y)))||\r\n		(((p1.x <= q1.x) && (q1.x <= p2.x)) && ((p2.y <= q1.y) && (q1.y <= p1.y)))||\r\n		(((p2.x <= q1.x) && (q1.x <= p1.x)) && ((p1.y <= q1.y) && (q1.y <= p2.y)))||\r\n		(((p2.x <= q1.x) && (q1.x <= p1.x)) && ((p2.y <= q1.y) && (q1.y <= p1.y))))\r\n		return 1;\r\n	else \r\n		return 0;\r\n}\r\nint judge_2(point p1,point p2,point q1,point q2)\r\n{\r\n	point p1_q1,p2_q1,q2_q1;\r\n	point q1_p1,p2_p1,q2_p1;\r\n\r\n	p1_q1 = minus(p1,q1);\r\n	p2_q1 = minus(p2,q1);\r\n	q2_q1 = minus(q2,q1);\r\n\r\n	q1_p1 = minus(q1,p1);\r\n	p2_p1 = minus(p2,p1);\r\n	q2_p1 = minus(q2,p1);\r\n\r\n	if(((p1_q1.x * q2_q1.y - q2_q1.x * p1_q1.y) *\r\n		(p2_q1.x * q2_q1.y - p2_q1.y * q2_q1.x) <= 0)\r\n		&&\r\n	   ((q1_p1.x * p2_p1.y - p2_p1.x * q1_p1.y) *\r\n		(q2_p1.x * p2_p1.y - p2_p1.x * q2_p1.y) <= 0))\r\n	    return 1;\r\n	else\r\n		return 0;\r\n}\r\n\r\nint main()\r\n{\r\n	int i,j,size;\r\n	int count=0;\r\n	line shuzu[MAX];\r\n	while(1)\r\n	{\r\n	scanf("%d",&size);\r\n	if (0 == size)\r\n		break;\r\n\r\n	for(i=0;i != size;++i)\r\n	{\r\n		scanf("%lf %lf",&shuzu[i].x.x,&shuzu[i].x.y);\r\n		scanf("%lf %lf",&shuzu[i].y.x,&shuzu[i].y.y);\r\n	}\r\n\r\n	count = 0;\r\n	/*(shuzu[i].x.x == shuzu[j].x.x && shuzu[i].x.y == shuzu[j].x.y)||\r\n				(shuzu[i].x.x == shuzu[j].y.x && shuzu[i].x.y == shuzu[j].y.y)||\r\n				(shuzu[i].y.x == shuzu[j].x.x && shuzu[i].y.y == shuzu[j].x.y)||\r\n				(shuzu[i].y.x == shuzu[j].y.x && shuzu[i].y.y == shuzu[j].y.y)||\r\n				*/\r\n    i = 0;\r\n	while(i+1 != size)\r\n	{\r\n		j= i+1;\r\n		while(j != size)\r\n		{\r\n			if (judge_1(shuzu[i].x,shuzu[i].y,shuzu[j].x,shuzu[j].y) &&\r\n				judge_2(shuzu[i].x,shuzu[i].y,shuzu[j].x,shuzu[j].y))\r\n			count++;\r\n		++j;\r\n		}\r\n		++i;\r\n	}\r\n	printf("%d\\n",count);\r\n	}\r\n	return 0;\r\n}\r\n\r\n', '', 31, 253952, 4, 1, '2011-01-23 23:15:41', '0001-01-01 00:00:00'),
(1425, 10, 377, 6, '#include<stdio.h>\r\n\r\n#define MAX 300\r\ntypedef struct point\r\n{\r\n	double x;\r\n	double y;\r\n}point;\r\n\r\ntypedef struct line\r\n{\r\n	point x;\r\n	point y;\r\n}line;\r\n\r\npoint minus(point a,point b)\r\n{\r\n	point temp;\r\n	temp.x = a.x - b.x;\r\n	temp.y = a.y - b.y;\r\n\r\n	return temp;\r\n}\r\nint judge_1(point p1,point p2,point q1,point q2)\r\n{\r\n	if( (((p1.x <= q1.x) && (q1.x <= p2.x)) && ((p1.y <= q1.y) && (q1.y <= p2.y)))||\r\n		(((p1.x <= q1.x) && (q1.x <= p2.x)) && ((p2.y <= q1.y) && (q1.y <= p1.y)))||\r\n		(((p2.x <= q1.x) && (q1.x <= p1.x)) && ((p1.y <= q1.y) && (q1.y <= p2.y)))||\r\n		(((p2.x <= q1.x) && (q1.x <= p1.x)) && ((p2.y <= q1.y) && (q1.y <= p1.y)))||\r\n		(((p1.x <= q2.x) && (q2.x <= p2.x)) && ((p1.y <= q2.y) && (q2.y <= p2.y)))||\r\n		(((p1.x <= q2.x) && (q2.x <= p2.x)) && ((p2.y <= q2.y) && (q2.y <= p1.y)))||\r\n		(((p2.x <= q2.x) && (q2.x <= p1.x)) && ((p1.y <= q2.y) && (q2.y <= p2.y)))||\r\n		(((p2.x <= q2.x) && (q2.x <= p1.x)) && ((p2.y <= q2.y) && (q2.y <= p1.y)))||\r\n		(((q1.x <= p1.x) && (p1.x <= q2.x)) && ((q1.y <= p1.y) && (p1.y <= q2.y)))||\r\n		(((q1.x <= p1.x) && (p1.x <= q2.x)) && ((q2.y <= p1.y) && (p1.y <= q1.y)))||\r\n		(((q2.x <= p1.x) && (p1.x <= q1.x)) && ((q1.y <= p1.y) && (p1.y <= q2.y)))||\r\n		(((q2.x <= p1.x) && (p1.x <= q1.x)) && ((q2.y <= p1.y) && (p1.y <= q1.y)))||\r\n		(((q1.x <= p2.x) && (p2.x <= q2.x)) && ((q1.y <= p2.y) && (p2.y <= q2.y)))||\r\n		(((q1.x <= p2.x) && (p2.x <= q2.x)) && ((q2.y <= p2.y) && (p2.y <= q1.y)))||\r\n		(((q2.x <= p2.x) && (p2.x <= q1.x)) && ((q1.y <= p2.y) && (p2.y <= q2.y)))||\r\n		(((q2.x <= p2.x) && (p2.x <= q1.x)) && ((q2.y <= p2.y) && (p2.y <= q1.y))) )\r\n		return 1;\r\n	else \r\n		return 0;\r\n}\r\nint judge_2(point p1,point p2,point q1,point q2)\r\n{\r\n	point p1_q1,p2_q1,q2_q1;\r\n	point q1_p1,p2_p1,q2_p1;\r\n\r\n	p1_q1 = minus(p1,q1);\r\n	p2_q1 = minus(p2,q1);\r\n	q2_q1 = minus(q2,q1);\r\n\r\n	q1_p1 = minus(q1,p1);\r\n	p2_p1 = minus(p2,p1);\r\n	q2_p1 = minus(q2,p1);\r\n\r\n	if(((p1_q1.x * q2_q1.y - q2_q1.x * p1_q1.y) *\r\n		(p2_q1.x * q2_q1.y - p2_q1.y * q2_q1.x) <= 0)\r\n		&&\r\n	   ((q1_p1.x * p2_p1.y - p2_p1.x * q1_p1.y) *\r\n		(q2_p1.x * p2_p1.y - p2_p1.x * q2_p1.y) <= 0))\r\n	    return 1;\r\n	else\r\n		return 0;\r\n}\r\n\r\nint main()\r\n{\r\n	int i,j,size;\r\n	int count=0;\r\n	line shuzu[MAX];\r\n	while(1)\r\n	{\r\n	scanf("%d",&size);\r\n	if (0 == size)\r\n		break;\r\n\r\n	for(i=0;i != size;++i)\r\n	{\r\n		scanf("%lf %lf",&shuzu[i].x.x,&shuzu[i].x.y);\r\n		scanf("%lf %lf",&shuzu[i].y.x,&shuzu[i].y.y);\r\n	}\r\n\r\n	count = 0;\r\n	/*(shuzu[i].x.x == shuzu[j].x.x && shuzu[i].x.y == shuzu[j].x.y)||\r\n				(shuzu[i].x.x == shuzu[j].y.x && shuzu[i].x.y == shuzu[j].y.y)||\r\n				(shuzu[i].y.x == shuzu[j].x.x && shuzu[i].y.y == shuzu[j].x.y)||\r\n				(shuzu[i].y.x == shuzu[j].y.x && shuzu[i].y.y == shuzu[j].y.y)||\r\n				*/\r\n    i = 0;\r\n	while(i+1 != size)\r\n	{\r\n		j= i+1;\r\n		while(j != size)\r\n		{\r\n			if ((judge_1(shuzu[i].x,shuzu[i].y,shuzu[j].x,shuzu[j].y) &&\r\n			      judge_2(shuzu[i].x,shuzu[i].y,shuzu[j].x,shuzu[j].y)))\r\n			count++;\r\n		++j;\r\n		}\r\n		++i;\r\n	}\r\n	printf("%d\\n",count);\r\n	}\r\n	return 0;\r\n}\r\n\r\n', '', 46, 258048, 4, 1, '2011-01-24 00:00:06', '0001-01-01 00:00:00'),
(1426, 30, 404, 9, '#include <stdio.h>\r\n#include <string.h>\r\n#define Type int \r\n#define MAXN 5\r\nint Mod, Size;\r\nstruct Matrix {\r\n	Type Mat[MAXN][MAXN];\r\n	Matrix() {\r\n		memset(Mat, 0, sizeof(Mat));\r\n	}\r\n	void Init() { \r\n		for (int i = 0; i < Size; ++i) {\r\n			for (int j = 0; j < Size; ++j)\r\n				scanf("%d",&Mat[i][j]);\r\n		}\r\n	}\r\n	void Unit() {\r\n		for (int i = 0; i < Size; ++i) {\r\n			for (int j = 0; j < Size; ++j) \r\n				Mat[i][j] = (i == j);\r\n		}\r\n	}\r\n	void Print() {\r\n		int i, j;\r\n		for (i = 0; i < Size; ++i) {\r\n			for (j = 0; j < (Size - 1) ; ++j)\r\n				printf("%d ",Mat[i][j]);\r\n			printf("%d\\n",Mat[i][j]);\r\n		}\r\n		printf("\\n");\r\n	}\r\n};\r\n\r\n//矩阵相乘\r\nMatrix MMul(Matrix& A,Matrix& B) \r\n{\r\n	Matrix Ans;\r\n	for (int i = 0; i < Size; ++i) {\r\n		for (int x = 0; x < Size; ++x) {\r\n			if (!A.Mat[x][i]) continue;\r\n			for (int y = 0; y < Size; ++y) {\r\n				if (!B.Mat[i][y]) continue;\r\n				Ans.Mat[x][y] += (A.Mat[x][i] * B.Mat[i][y])%Mod;\r\n				if (Ans.Mat[x][y] >= Mod || Ans.Mat[x][y] <= -Mod) {\r\n                    Ans.Mat[x][y] %= Mod;\r\n				}\r\n				Ans.Mat[x][y] %= Mod;\r\n			}\r\n		}\r\n	}\r\n	return Ans;\r\n}\r\n\r\n//矩阵二分求幂\r\nMatrix MPow(Matrix& Mat, int Pow) \r\n{\r\n	Matrix Ans, Tmp(Mat);\r\n	for (Ans.Unit(); Pow ; Pow >>= 1) {\r\n		//printf("22222\\n");\r\n		if ((Pow & 1))\r\n			Ans = MMul(Ans, Tmp);\r\n		Tmp = MMul(Tmp, Tmp);\r\n   }\r\n   return Ans;\r\n}\r\n\r\nint main() \r\n{\r\n   int T;\r\n   Matrix Mat, Tmp;\r\n   Mod = 2011, Size = 4;\r\n   scanf("%d",&T);\r\n   while (T--) {\r\n	   Mat.Init();\r\n	   //printf("111\\n");\r\n	   Mat = MPow(Mat, 2011);\r\n	   Mat.Print();\r\n   }\r\n   return 0;\r\n}', '', 61, 258048, 1, 2, '2011-01-24 17:29:58', '0001-01-01 00:00:00'),
(1427, 30, 374, 5, '#include <stdio.h>\r\n\r\n\r\n\r\nint main()\r\n\r\n{\r\n\r\n	int T,cnt=0,rs,rt,ts,tt,res,tmp,v,i,n;\r\n\r\n	scanf("%d",&T);\r\n\r\n	while(T--)\r\n\r\n	{\r\n\r\n	   scanf("%d",&n);\r\n\r\n	   for(i=1;i<=n;++i)\r\n\r\n	   {\r\n\r\n		   scanf("%d",&v);\r\n\r\n		   if(i==1)\r\n\r\n		   {\r\n\r\n			  tmp=res=v;\r\n\r\n			  rs=rt=ts=tt=i;\r\n\r\n		   }\r\n\r\n		   else\r\n\r\n		   {\r\n\r\n		     if(tmp<0) \r\n\r\n			 {\r\n\r\n				tmp=v;\r\n\r\n				ts=tt=i;\r\n\r\n			 }\r\n\r\n			 else tmp+=v,tt++;\r\n\r\n\r\n\r\n			 if(tmp>res)\r\n\r\n			 {\r\n\r\n				res=tmp;\r\n\r\n				rs=ts;\r\n\r\n				rt=tt;\r\n\r\n			 }\r\n\r\n		   }\r\n\r\n	   }\r\n\r\n	   if(cnt!=0) printf("\\n"); \r\n\r\n	   printf("Case %d:\\n",++cnt);\r\n\r\n	   printf("%d %d %d\\n",res,rs,rt);\r\n\r\n	}\r\n\r\n	return 0;\r\n\r\n}', '', 15, 258048, 1, 2, '2011-01-24 17:39:23', '0001-01-01 00:00:00'),
(1428, 30, 402, 8, '#include <stdio.h>\r\n\r\n#include <string.h>\r\n\r\n#define N 1005\r\n\r\nchar str_a[N], str_b[N], str_c[N];\r\n\r\nint  a[N], b[N];\r\n\r\n\r\n\r\nvoid cal()\r\n\r\n{\r\n\r\n	int i, j, car;\r\n\r\n	memset(a, 0, N*sizeof(int));\r\n\r\n	memset(b, 0, N*sizeof(int));\r\n\r\n	a[0] = strlen(str_a);\r\n\r\n	b[0] = strlen(str_b);\r\n\r\n\r\n\r\n	for (i = a[0] - 1, j = 0; i >= 0; --i)\r\n\r\n		a[++j] = str_a[i] - ''0''; \r\n\r\n	for (i = b[0] - 1, j = 0; i >= 0; --i)\r\n\r\n		b[++j] = str_b[i] - ''0'';\r\n\r\n	a[0] = a[0] > b[0] ? a[0] : b[0];\r\n\r\n\r\n\r\n	i = 1, car = 0;\r\n\r\n	while (i <= a[0]) {\r\n\r\n		a[i] += ( b[i] + car);\r\n\r\n		car = a[i] / 10;\r\n\r\n		a[i] %= 10;\r\n\r\n		++i;\r\n\r\n	}\r\n\r\n	\r\n\r\n	while (car) {\r\n\r\n		a[i] += car;\r\n\r\n		car = a[i] / 10;\r\n\r\n		a[i] %= 10;\r\n\r\n		++i;\r\n\r\n	}\r\n\r\n	a[0] = i - 1;\r\n\r\n	\r\n\r\n	j = 0, i = a[0];\r\n\r\n	while (i >= 1)\r\n\r\n		str_c[j++] = a[i--] + ''0'';\r\n\r\n	str_c[j] = ''\\0'';\r\n\r\n}\r\n\r\n\r\n\r\nint main()\r\n\r\n{\r\n\r\n	int T, i;\r\n\r\n	scanf("%d",&T);\r\n\r\n	for (i = 1; i <= T; ++i) {\r\n\r\n	    scanf("%s %s",str_a,str_b);\r\n\r\n		cal();\r\n\r\n		printf("Case %d:\\n",i);\r\n\r\n		printf("%s + %s = %s\\n",str_a,str_b,str_c);\r\n\r\n		if (i != T) printf("\\n");\r\n\r\n	}\r\n\r\n	return 0;\r\n\r\n}\r\n', '', 15, 262144, 1, 1, '2011-01-24 17:40:52', '0001-01-01 00:00:00'),
(1429, 30, 375, 5, '#include <stdio.h> \r\n\r\n#define M 100000 \r\n\r\nint x[M],y[M]; \r\n\r\nint main() \r\n\r\n{ \r\n\r\n    int n,i,j,c; \r\n\r\n    y[0]=0; \r\n\r\n    while(scanf("%d",&n)!=EOF) \r\n\r\n    { \r\n\r\n                              c=1; \r\n\r\n                              for(i=0;i<n;i++) \r\n\r\n                              { \r\n\r\n                                               scanf("%d",&x[i]); \r\n\r\n                                               for(j=0;j<c;j++) \r\n\r\n                                                     if(x[i]<y[j]) { y[j]=x[i];break;} \r\n\r\n                                               if(j==c) {y[c]=x[i];c++;} \r\n\r\n                              }                                         \r\n\r\n                              printf("%d\\n",c-1);                        \r\n\r\n    } \r\n\r\n    return 0; \r\n\r\n}', '', 249, 1056768, 1, 2, '2011-01-24 18:04:58', '0001-01-01 00:00:00'),
(1430, 30, 379, 7, '#include <stdio.h>\r\n\r\n#include <string.h>\r\n\r\n#define N 850\r\n\r\n#define M 3000\r\n\r\n#define INF 1<<30\r\n\r\nstruct Edge {\r\n\r\n   int v;\r\n\r\n   int w;\r\n\r\n   int next;\r\n\r\n}et[M];\r\n\r\nint head[N], mp, n, m, t;\r\n\r\nint in[N], dis[N], cow[N], Q[N*10];\r\n\r\n\r\n\r\nvoid add(int u, int v, int w)\r\n\r\n{\r\n\r\n    et[mp].v = v;\r\n\r\n    et[mp].w = w;\r\n\r\n    et[mp].next = head[u];\r\n\r\n    head[u] = mp++; \r\n\r\n}\r\n\r\n\r\n\r\nvoid add_e(int u, int v, int w)\r\n\r\n{\r\n\r\n    add(u, v, w);\r\n\r\n    add(v, u, w);\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\nint spfa(int s)\r\n\r\n{\r\n\r\n    int i, front, rear, u, v, w, total;\r\n\r\n    for(i = 1; i <= n; ++i)\r\n\r\n        dis[i] = INF;\r\n\r\n    \r\n\r\n    memset(in, 0, sizeof(in));\r\n\r\n    front = rear = 0;\r\n\r\n    dis[s] = 0;\r\n\r\n    in[s] = 1;\r\n\r\n    Q[rear++] = s;\r\n\r\n    while(front < rear) {\r\n\r\n        u = Q[front++];\r\n\r\n        in[u] = 0;\r\n\r\n        \r\n\r\n        for(i = head[u]; i != -1; i=et[i].next) {\r\n\r\n            v = et[i].v;\r\n\r\n            w = et[i].w;\r\n\r\n            if(dis[v] > dis[u]+w) {\r\n\r\n               dis[v] = dis[u]+w;\r\n\r\n               if(in[v] == 0) {\r\n\r\n                  in[v] = 1;\r\n\r\n                  Q[rear++] = v;\r\n\r\n               }\r\n\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n    \r\n\r\n    total = 0;\r\n\r\n    for(i = 1; i <= m; ++i) \r\n\r\n        total += dis[cow[i]];\r\n\r\n    return total;\r\n\r\n}\r\n\r\n\r\n\r\nint main()\r\n\r\n{\r\n\r\n    int i, a, b, c, res;\r\n\r\n    while(scanf("%d %d %d",&m,&n,&t) == 3) {\r\n\r\n       for(i = 1; i <= m; ++i)\r\n\r\n           scanf("%d",&cow[i]);\r\n\r\n       mp = 0;\r\n\r\n       memset(head, -1, sizeof(head));\r\n\r\n       while(t--) {\r\n\r\n          scanf("%d %d %d",&a,&b,&c);\r\n\r\n          add_e(a,b,c);\r\n\r\n       }\r\n\r\n       \r\n\r\n       res = INF;\r\n\r\n       for(i = 1; i <= n; ++i) {\r\n\r\n           c = spfa(i);\r\n\r\n           if(res > c)\r\n\r\n              res = c;\r\n\r\n       }\r\n\r\n       printf("%d\\n",res);\r\n\r\n    }\r\n\r\n    return 0;\r\n\r\n}\r\n', '', 248, 339968, 1, 2, '2011-01-24 18:29:55', '0001-01-01 00:00:00'),
(1431, 10, 377, 6, '#include<stdio.h>\r\n\r\n#define MAX 300\r\ntypedef struct point\r\n{\r\n	float x;\r\n	float y;\r\n}point;\r\n\r\ntypedef struct line\r\n{\r\n	point x;\r\n	point y;\r\n}line;\r\n\r\npoint minus(point a,point b)\r\n{\r\n	point temp;\r\n	temp.x = a.x - b.x;\r\n	temp.y = a.y - b.y;\r\n\r\n	return temp;\r\n}\r\nint judge_1(point p1,point p2,point q1,point q2)\r\n{\r\n	if( (((p1.x <= q1.x) && (q1.x <= p2.x)) && ((p1.y <= q1.y) && (q1.y <= p2.y)))||\r\n		(((p1.x <= q1.x) && (q1.x <= p2.x)) && ((p2.y <= q1.y) && (q1.y <= p1.y)))||\r\n		(((p2.x <= q1.x) && (q1.x <= p1.x)) && ((p1.y <= q1.y) && (q1.y <= p2.y)))||\r\n		(((p2.x <= q1.x) && (q1.x <= p1.x)) && ((p2.y <= q1.y) && (q1.y <= p1.y)))||\r\n		(((p1.x <= q2.x) && (q2.x <= p2.x)) && ((p1.y <= q2.y) && (q2.y <= p2.y)))||\r\n		(((p1.x <= q2.x) && (q2.x <= p2.x)) && ((p2.y <= q2.y) && (q2.y <= p1.y)))||\r\n		(((p2.x <= q2.x) && (q2.x <= p1.x)) && ((p1.y <= q2.y) && (q2.y <= p2.y)))||\r\n		(((p2.x <= q2.x) && (q2.x <= p1.x)) && ((p2.y <= q2.y) && (q2.y <= p1.y)))||\r\n		(((q1.x <= p1.x) && (p1.x <= q2.x)) && ((q1.y <= p1.y) && (p1.y <= q2.y)))||\r\n		(((q1.x <= p1.x) && (p1.x <= q2.x)) && ((q2.y <= p1.y) && (p1.y <= q1.y)))||\r\n		(((q2.x <= p1.x) && (p1.x <= q1.x)) && ((q1.y <= p1.y) && (p1.y <= q2.y)))||\r\n		(((q2.x <= p1.x) && (p1.x <= q1.x)) && ((q2.y <= p1.y) && (p1.y <= q1.y)))||\r\n		(((q1.x <= p2.x) && (p2.x <= q2.x)) && ((q1.y <= p2.y) && (p2.y <= q2.y)))||\r\n		(((q1.x <= p2.x) && (p2.x <= q2.x)) && ((q2.y <= p2.y) && (p2.y <= q1.y)))||\r\n		(((q2.x <= p2.x) && (p2.x <= q1.x)) && ((q1.y <= p2.y) && (p2.y <= q2.y)))||\r\n		(((q2.x <= p2.x) && (p2.x <= q1.x)) && ((q2.y <= p2.y) && (p2.y <= q1.y))) )\r\n		return 1;\r\n	else \r\n		return 0;\r\n}\r\nint judge_2(point p1,point p2,point q1,point q2)\r\n{\r\n	point p1_q1,p2_q1,q2_q1;\r\n	point q1_p1,p2_p1,q2_p1;\r\n\r\n	p1_q1 = minus(p1,q1);\r\n	p2_q1 = minus(p2,q1);\r\n	q2_q1 = minus(q2,q1);\r\n\r\n	q1_p1 = minus(q1,p1);\r\n	p2_p1 = minus(p2,p1);\r\n	q2_p1 = minus(q2,p1);\r\n\r\n	if(((p1_q1.x * q2_q1.y - q2_q1.x * p1_q1.y) *\r\n		(p2_q1.x * q2_q1.y - p2_q1.y * q2_q1.x) <= 0)\r\n		&&\r\n	   ((q1_p1.x * p2_p1.y - p2_p1.x * q1_p1.y) *\r\n		(q2_p1.x * p2_p1.y - p2_p1.x * q2_p1.y) <= 0))\r\n	    return 1;\r\n	else\r\n		return 0;\r\n}\r\n\r\nint main()\r\n{\r\n	int i,j,size;\r\n	int count=0;\r\n	line shuzu[MAX];\r\n	while(1)\r\n	{\r\n	scanf("%d",&size);\r\n	if (0 == size)\r\n		break;\r\n\r\n	for(i=0;i != size;++i)\r\n	{\r\n		scanf("%f %f",&shuzu[i].x.x,&shuzu[i].x.y);\r\n		scanf("%f %f",&shuzu[i].y.x,&shuzu[i].y.y);\r\n	}\r\n\r\n	count = 0;\r\n    i = 0;\r\n	while(i+1 != size)\r\n	{\r\n		j= i+1;\r\n		while(j != size)\r\n		{\r\n			if ((judge_1(shuzu[i].x,shuzu[i].y,shuzu[j].x,shuzu[j].y) &&\r\n			      judge_2(shuzu[i].x,shuzu[i].y,shuzu[j].x,shuzu[j].y)))\r\n			count++;\r\n		++j;\r\n		}\r\n		++i;\r\n	}\r\n	printf("%d\\n",count);\r\n	}\r\n	return 0;\r\n}\r\n\r\n', '', 31, 258048, 4, 1, '2011-01-24 18:31:31', '0001-01-01 00:00:00'),
(1432, 30, 345, 4, '#include <stdio.h>\r\n\r\n#include <string.h>\r\n\r\n#include <algorithm>\r\n\r\nusing namespace std;\r\n\r\n#define N 10010\r\n\r\nstruct Node\r\n\r\n{\r\n\r\n   char str[105];\r\n\r\n}qa[N],qb[N],ta[N],tb[N];\r\n\r\n\r\n\r\nbool cmp(const Node& a,const Node& b)\r\n\r\n{\r\n\r\n    return strcmp(a.str,b.str)<0;\r\n\r\n}\r\n\r\n\r\n\r\nint find(char s[],Node q[],int n)\r\n\r\n{\r\n\r\n    int mid,low=0,high=n-1,t;\r\n\r\n    while(low<=high)\r\n\r\n    {\r\n\r\n        mid=(low+high)>>1;\r\n\r\n        int t=strcmp(q[mid].str,s);\r\n\r\n        if(t==0) return mid;\r\n\r\n        else if(t<0) low=mid+1;\r\n\r\n        else         high=mid-1; \r\n\r\n    }\r\n\r\n    return -1;\r\n\r\n}\r\n\r\n\r\n\r\nint main()\r\n\r\n{\r\n\r\n    int i,n,m,t;\r\n\r\n    while(scanf("%d",&n)!=EOF)\r\n\r\n    {\r\n\r\n        for(i=0;i<n;++i)\r\n\r\n        {\r\n\r\n            scanf("%s",&qa[i].str);\r\n\r\n            strcpy(ta[i].str,qa[i].str);\r\n\r\n        }\r\n\r\n        \r\n\r\n        scanf("%d",&m);\r\n\r\n        for(i=0;i<m;++i)\r\n\r\n        {\r\n\r\n            scanf("%s",&qb[i].str);\r\n\r\n            strcpy(tb[i].str,qb[i].str);\r\n\r\n        }\r\n\r\n        \r\n\r\n        sort(ta,ta+n,cmp);\r\n\r\n        sort(tb,tb+m,cmp);\r\n\r\n        \r\n\r\n        for(i=0;i<n;++i)\r\n\r\n        {\r\n\r\n            t=find(qa[i].str,tb,m);\r\n\r\n            if(t!=-1) break;\r\n\r\n        }\r\n\r\n        if(t==-1) printf("none ");\r\n\r\n        else      printf("%s ",tb[t].str);\r\n\r\n        \r\n\r\n        for(i=0;i<m;++i)\r\n\r\n        {\r\n\r\n            t=find(qb[i].str,ta,n);\r\n\r\n            if(t!=-1) break;\r\n\r\n        }\r\n\r\n        if(t==-1) printf("none\\n");\r\n\r\n        else      printf("%s\\n",ta[t].str);\r\n\r\n    }\r\n\r\n    return 0;\r\n\r\n}', '', 0, 4468736, 1, 2, '2011-01-24 18:41:41', '0001-01-01 00:00:00'),
(1433, 10, 377, 6, '#include<stdio.h>\r\n\r\n#define MAX 300\r\n\r\ntypedef struct point\r\n{\r\n	float x;\r\n	float y;\r\n}point;\r\n\r\ntypedef struct line\r\n{\r\n	point x;\r\n	point y;\r\n}line;\r\n\r\npoint minus(point a,point b)\r\n{\r\n	point temp;\r\n	temp.x = a.x - b.x;\r\n	temp.y = a.y - b.y;\r\n\r\n	return temp;\r\n}\r\nfloat max(float a,float b)\r\n{\r\n	if(a >= b)\r\n		return a;\r\n	else\r\n		return b;\r\n}\r\nfloat min(float a,float b)\r\n{\r\n	if(a <= b)\r\n		return a;\r\n	else\r\n		return b;\r\n}\r\nint judge_1(point p1,point p2,point q1,point q2)\r\n{\r\n	if ((max(p1.x,p2.x) >= min(q1.x,q2.x))&&\r\n		(max(q1.x,q2.x) >= min(p1.x,p2.x))&&\r\n		(max(p1.y,p2.y) >= min(q1.y,q2.y))&&\r\n		(max(q1.y,q2.y) >= min(p1.y,p2.y)))\r\n		return 1;\r\n	else \r\n		return 0;\r\n}\r\nint judge_2(point p1,point p2,point q1,point q2)\r\n{\r\n	point p1_q1,p2_q1,q2_q1;\r\n	point q1_p1,p2_p1,q2_p1;\r\n\r\n	p1_q1 = minus(p1,q1);\r\n	p2_q1 = minus(p2,q1);\r\n	q2_q1 = minus(q2,q1);\r\n\r\n	q1_p1 = minus(q1,p1);\r\n	p2_p1 = minus(p2,p1);\r\n	q2_p1 = minus(q2,p1);\r\n\r\n	if(((p1_q1.x * q2_q1.y - q2_q1.x * p1_q1.y) *\r\n		(p2_q1.x * q2_q1.y - p2_q1.y * q2_q1.x) <= 0)\r\n		&&\r\n	   ((q1_p1.x * p2_p1.y - p2_p1.x * q1_p1.y) *\r\n		(q2_p1.x * p2_p1.y - p2_p1.x * q2_p1.y) <= 0))\r\n	    return 1;\r\n	else\r\n		return 0;\r\n}\r\n\r\nint main()\r\n{\r\n	int i,j,size;\r\n	int count=0;\r\n	line shuzu[MAX];\r\n	while(1)\r\n	{\r\n	scanf("%d",&size);\r\n	if (0 == size)\r\n		break;\r\n\r\n	for(i=0;i != size;++i)\r\n	{\r\n		scanf("%f %f",&shuzu[i].x.x,&shuzu[i].x.y);\r\n		scanf("%f %f",&shuzu[i].y.x,&shuzu[i].y.y);\r\n	}\r\n\r\n	count = 0;\r\n    i = 0;\r\n	while(i+1 != size)\r\n	{\r\n		j= i+1;\r\n		while(j != size)\r\n		{\r\n			if (((judge_1(shuzu[i].x,shuzu[i].y,shuzu[j].x,shuzu[j].y)) &&\r\n			      judge_2(shuzu[i].x,shuzu[i].y,shuzu[j].x,shuzu[j].y)))\r\n			count++;\r\n		++j;\r\n		}\r\n		++i;\r\n	}\r\n	printf("%d\\n",count);\r\n	}\r\n	return 0;\r\n}\r\n\r\n', '', 109, 258048, 1, 1, '2011-01-24 20:32:30', '0001-01-01 00:00:00'),
(1434, 11, 374, 5, '#include <iostream> \r\n#include<cstdio>     \r\nusing namespace std;      \r\nint main()      \r\n{      \r\n    int j,i,k,n,m,t;      \r\n    int a[100002];      \r\n    scanf("%d",&t);      \r\n    for (j=1;j<=t;j++)      \r\n    {      \r\n        scanf("%d",&n);      \r\n        for (i=0;i<n;i++)      \r\n        {      \r\n            scanf("%d",&a[i]);      \r\n        }      \r\n        int sum=0,maxnum=-1001,first =0, last = 0, temp = 1;      \r\n        for (i=0;i<n;i++)      \r\n        {      \r\n            sum += a[i];      \r\n            if (sum > maxnum)      \r\n            {      \r\n                maxnum = sum;first = temp;last = i+1;      \r\n            }      \r\n            if (sum < 0)      \r\n            {      \r\n                sum = 0;temp = i+2;      \r\n            }      \r\n        }      \r\n     \r\n        printf("Case %d:\\n%d %d %d\\n",j,maxnum,first,last);      \r\n        if (j!=t)      \r\n        {      \r\n            printf("\\n");      \r\n        }      \r\n    }      \r\n          \r\n  }', '', 15, 729088, 1, 2, '2011-01-24 21:09:48', '0001-01-01 00:00:00'),
(1435, 11, 377, 6, '#include <stdio.h>\r\n#include <stdlib.h>\r\n// 此函数判断交点坐标是否在线段坐标范围内,即判断交点是否落在线段上\r\nint between(float u, float v, float w)\r\n{ float max,min;\r\n  max=(v>w)?v:w;\r\n  min=(v<w)?v:w;\r\n  return ((u<=max&&u>=min)?1:0);\r\n}\r\nint main()\r\n{ \r\n  int n,i,j,num; //n为线段条数\r\n  float x1[100],y1[100],x2[100],y2[100],a[100],b[100],c[100],jx,jy;\r\n  while(scanf("%d",&n)&&n!=0)\r\n  {   \r\n   num=0;    \r\n   for(i=0;i<n;++i)\r\n   { scanf("%f%f%f%f",&x1[i],&y1[i],&x2[i],&y2[i]);\r\n     if(x1[i]==x2[i])\r\n     { \r\n       a[i]=1;b[i]=0;c[i]=-x1[i];\r\n     }\r\n     else\r\n     { \r\n       a[i]=(y2[i]-y1[i])/(x1[i]-x2[i]);b[i]=1;\r\n       c[i]=(x1[i]*y2[i]-x2[i]*y1[i])/(x2[i]-x1[i]);\r\n     }\r\n   }\r\n   for(i=0;i<n;++i)\r\n   { \r\n      for(j=i+1;j<n;++j)\r\n      { \r\n         if(a[i]*b[j]-a[j]*b[i]!=0)\r\n        { \r\n          jx=(b[i]*c[j]-b[j]*c[i])/(a[i]*b[j]-a[j]*b[i]);\r\n          jy=(c[i]*a[j]-c[j]*a[i])/(a[i]*b[j]-a[j]*b[i]);\r\n          if(between(jx,x1[i],x2[i])&&between(jx,x1[j],x2[j])&&between(jy,y1[i],y2[i])&&between(jy,y1[j],y2[j]))\r\n          //printf("(%f,%f)\\n ",jx,jy);\r\n          num++;\r\n       }\r\n      }\r\n   }\r\n   printf("%d\\n",num);\r\n  }\r\n  return 0;\r\n}\r\n/* 程序说明\r\n程序中的几个变量:\r\n*x1为初始点横坐标*y1为初始点纵坐标\r\n*x2为终止点横坐标*y2为终止点纵坐标\r\n*a为所在直线解析式中x项系数*b为所在直线解析式中y项系数\r\n*c为所在直线解析式中常数项 jx为所在直线交点横坐标\r\n用函数between判断两条线段所在直线交点\r\n在线段上，若是，则输出结果。*/\r\n', '', 0, 253952, 4, 2, '2011-01-24 21:14:15', '0001-01-01 00:00:00'),
(1436, 11, 379, 7, ' #include<stdio.h>\r\n#include<string.h>\r\nint n,p,c,l[801][801],cow[501],a[801][801],q[641601],f,e,dis[801],ans;\r\nbool flag[801];\r\nvoid spfa(int s){\r\n     int st,i,total = 0;\r\n     flag[s] = true;\r\n     while(f <= e)\r\n     {\r\n            st = q[f];\r\n            for(i = 1; i <= l[st][0]; ++ i) \r\n           {\r\n                  if(dis[st] + a[st][l[st][i]] < dis[l[st][i]])\r\n                  { \r\n                            dis[l[st][i]] =  dis[st] + a[st][l[st][i]];\r\n                             if(!flag[l[st][i]]) \r\n                            { \r\n                                                     ++ e; \r\n                                                     q[e] = l[st][i];\r\n                                                      flag[l[st][i]] = true;\r\n                             }\r\n                  }\r\n            }\r\n            flag[st] = false; \r\n           ++ f;\r\n     }\r\n     for(i = 1; i <= n; ++ i) \r\n          total += dis[cow[i]];  \r\n   if(total < ans) \r\n    ans = total;\r\n}\r\nint main()\r\n{\r\n    freopen("butter.in","r",stdin);\r\n    freopen("butter.out","w",stdout);  \r\n  int i,j,x,y,z; \r\n   scanf("%d%d%d",&n,&p,&c);  \r\n  ans = 0x7FFFFFFF;\r\n    for(i = 1; i <= n; ++ i) \r\n   scanf("%d",&cow[i]);\r\n    for(i = 1; i <= c; ++ i)  \r\n  {         \r\n scanf("%d%d%d",&x,&y,&z);  \r\n        ++ l[x][0];\r\n          a[x][y] = z;  \r\n        l[x][l[x][0]] = y;  \r\n        ++ l[y][0];\r\n          a[y][x] = z;  \r\n        l[y][l[y][0]] = x; \r\n   }    for(i = 1; i <= p; ++ i)\r\n    {\r\n          f = 1;          e = 1;          q[1] = i; \r\n         memset(dis,0x7F,sizeof(dis)); \r\n\r\n         memset(flag,0,sizeof(flag));\r\n          dis[i] = 0;          spfa(i);   \r\n }    printf("%d\\n",ans);  \r\n  return 0;\r\n}\r\n', '', 263, 7979008, 1, 2, '2011-01-24 21:16:00', '0001-01-01 00:00:00'),
(1437, 11, 404, 9, '#include <iostream>\r\n#include <cstdio>\r\n#include <ctime>\r\n#include <cmath>\r\nusing namespace std;\r\n\r\n__int64 n;\r\nint dp[4];\r\nint dp1[4];\r\nint temp[4][4] = {{2,1,1,0},{1,2,0,1},{1,0,2,1},{0,1,1,2}};\r\nint temp1[4][4];\r\n\r\nvoid Init()\r\n{\r\n int i,j;\r\n dp[0] = dp[1] = dp[2] = 0;\r\n dp[3] = 1;\r\n for (j = 0; j < 4; j ++)\r\n  for (i = 0; i < 4; i ++)\r\n   if (i == j)\r\n    temp1[i][j] = 1;\r\n   else\r\n    temp1[i][j] = 0;\r\n}\r\nvoid Multiply(int x[][4],int y[][4])\r\n{\r\n int i,j,k;\r\n int c[4][4];\r\n for (i = 0; i < 4; i ++)\r\n  for (j = 0;j < 4; j ++)\r\n  {\r\n   c[i][j] = 0;\r\n   for (k = 0; k < 4; k ++)\r\n    c[i][j] = (c[i][j] + x[i][k] * y[k][j]) % 2011;\r\n  }\r\n\r\n for (i = 0; i < 4; i ++)\r\n  for (j = 0; j < 4; j ++)\r\n   x[i][j] = c[i][j];\r\n}\r\nint GetW()\r\n{\r\n int i = n,count = 0;\r\n while (i)\r\n {\r\n  i /= 2;\r\n  count ++;\r\n }\r\n return count;\r\n}\r\nvoid Dp()\r\n{\r\n int i;\r\n Init();\r\n int ct = GetW() - 1;\r\n while (ct >= 0)\r\n {\r\n  Multiply(temp1,temp1);\r\n  if ((n & (1 << ct)) != 0)\r\n   Multiply(temp1,temp);\r\n  ct --;\r\n }\r\n //dp*temp1[i][3]\r\n int ans = 0;\r\n for (i = 0; i < 4; i ++)\r\n  ans = (ans + dp[i] * temp1[i][3]) % 2011;\r\n printf("%d\\n",ans);\r\n}\r\nint main(void)\r\n{\r\n //start = clock();\r\n int t;\r\n scanf("%d",&t);\r\n while (t --)\r\n {\r\n  scanf("%I64d",&n);\r\n  Dp();\r\n }\r\n return 0;\r\n}\r\n', '', 15, 364544, 4, 2, '2011-01-24 21:18:38', '0001-01-01 00:00:00'),
(1438, 16, 335, 2, '#include <stdio.h>\r\n\r\nint main()\r\n{\r\n	int i,j,num;\r\n	while(scanf("%d %d",&i,&j)!=EOF)\r\n	{\r\n	   i = i ^ j;\r\n	   num = 0;\r\n	   while(i)\r\n	   {\r\n		   i &= (i - 1);\r\n		   num++;\r\n	  }\r\n	   printf("%d\\n",num);\r\n	}\r\n	return 0;\r\n}\r\n', '', 78, 253952, 1, 2, '2011-01-26 15:41:10', '0001-01-01 00:00:00'),
(1439, 16, 338, 3, '#include <stdio.h>\r\n#include <string.h>\r\n#define N 1010\r\nint v[N];\r\n\r\nint main()\r\n{\r\n    int n,k,i,max_v,min_v,cnt,t1,t2;\r\n    while(scanf("%d %d",&n,&k)!=EOF)\r\n    {\r\n       memset(v,0,sizeof(v));\r\n       k++,max_v=-1,min_v=N;\r\n       for(i=0;i<n;++i)\r\n       {\r\n           scanf("%d",&t1);\r\n           v[ t1 ]++;\r\n           if(t1>max_v) max_v=t1;\r\n           if(t1<min_v) min_v=t1;\r\n       }\r\n       \r\n       cnt=0;\r\n       for(i=min_v;i<=max_v;++i)\r\n       {\r\n           cnt+=v[i];\r\n           if(cnt>=k) \r\n           {\r\n              t1=i;\r\n              break;\r\n           }\r\n       }\r\n\r\n       cnt=0;\r\n       for(i=max_v;i>=min_v;--i)\r\n       {\r\n           cnt+=v[i];\r\n           if(cnt>=k) \r\n           {\r\n              t2=i;\r\n              break;\r\n           }\r\n       }\r\n       printf("%d\\n",t2-t1);\r\n    }\r\n    return 0;\r\n}\r\n', '', 374, 258048, 1, 2, '2011-01-26 15:48:01', '0001-01-01 00:00:00'),
(1440, 16, 339, 3, '//快排 \r\n#include <stdio.h>\r\n#include <algorithm>\r\n#define N 100010\r\n#define M 1010\r\nusing namespace std;\r\nint a[N],q[M];\r\n\r\nbool cmp(int u,int v)\r\n{\r\n      return u>v;\r\n}\r\n\r\nint main()\r\n{\r\n    int i,n,m;\r\n    while(scanf("%d %d",&n,&m)!=EOF)\r\n    {\r\n        for(i=0;i<m;++i) scanf("%d",q+i);\r\n        for(i=0;i<n;++i) scanf("%d",a+i);\r\n        \r\n        sort(a,a+n,cmp);\r\n        for(i=0;i<m;++i)\r\n            printf("%d\\n",a[ q[i] ]);\r\n    }\r\n    return 0;\r\n}\r\n', '', 217, 655360, 1, 2, '2011-01-26 15:48:32', '0001-01-01 00:00:00'),
(1441, 16, 344, 4, '#include <stdio.h>\r\n#include <string.h>\r\n#include <algorithm>\r\nusing namespace std;\r\n#define M 101\r\n#define N 20001\r\n\r\nstruct Node\r\n{\r\n   char str[M];\r\n   int  pos;\r\n}que[N];\r\n\r\nbool cmp(const Node& a,const Node& b)\r\n{\r\n   int t=strcmp(a.str,b.str);\r\n   if(t==0) return a.pos<b.pos;\r\n   else     return t>0;\r\n}\r\n\r\nint main()\r\n{\r\n    int n,i,ans;\r\n    while(scanf("%d",&n)!=EOF)\r\n    {\r\n        ans=0;\r\n        for(i=0;i<n;++i)\r\n        {\r\n            scanf("%s",que[i].str);\r\n            que[i].pos=i;\r\n        }\r\n        sort(que,que+n,cmp);\r\n        \r\n        for(i=1;i<n;++i)\r\n        {\r\n            if(strcmp(que[i].str,que[i-1].str)==0)\r\n            {\r\n               ans=que[i].pos-que[i-1].pos;\r\n               break;\r\n            }\r\n        }\r\n        printf("%d\\n",ans);\r\n    }\r\n    return 0;\r\n}\r\n', '', 0, 2097152, 6, 2, '2011-01-26 15:49:40', '0001-01-01 00:00:00'),
(1442, 16, 344, 4, '#include <stdio.h>\r\n#include <string.h>\r\n#include <algorithm>\r\nusing namespace std;\r\n#define M 101\r\n#define N 20001\r\n\r\nstruct Node\r\n{\r\n   char str[M];\r\n   int  pos;\r\n}que[N];\r\n\r\nbool cmp(const Node& a,const Node& b)\r\n{\r\n   int t=strcmp(a.str,b.str);\r\n   if(t==0) return a.pos<b.pos;\r\n   else     return t>0;\r\n}\r\n\r\nint main()\r\n{\r\n    int n,i,ans;\r\n    while(scanf("%d",&n)!=EOF)\r\n    {\r\n        ans=0;\r\n        for(i=0;i<n;++i)\r\n        {\r\n            scanf("%s",que[i].str);\r\n            que[i].pos=i;\r\n        }\r\n        sort(que,que+n,cmp);\r\n        \r\n        for(i=1;i<n;++i)\r\n        {\r\n            if(strcmp(que[i].str,que[i-1].str)==0)\r\n            {\r\n               ans=que[i].pos-que[i-1].pos;\r\n               break;\r\n            }\r\n        }\r\n        printf("%d\\n",ans);\r\n    }\r\n    return 0;\r\n}\r\n', '', 0, 2097152, 6, 2, '2011-01-26 15:52:30', '0001-01-01 00:00:00'),
(1443, 16, 374, 5, '#include <stdio.h>\r\n\r\n\r\n\r\nint main()\r\n\r\n{\r\n\r\n	int T,cnt=0,rs,rt,ts,tt,res,tmp,v,i,n;\r\n\r\n	scanf("%d",&T);\r\n\r\n	while(T--)\r\n\r\n	{\r\n\r\n	   scanf("%d",&n);\r\n\r\n	   for(i=1;i<=n;++i)\r\n\r\n	   {\r\n\r\n		   scanf("%d",&v);\r\n\r\n		   if(i==1)\r\n\r\n		   {\r\n\r\n			  tmp=res=v;\r\n\r\n			  rs=rt=ts=tt=i;\r\n\r\n		   }\r\n\r\n		   else\r\n\r\n		   {\r\n\r\n		     if(tmp<0) \r\n\r\n			 {\r\n\r\n				tmp=v;\r\n\r\n				ts=tt=i;\r\n\r\n			 }\r\n\r\n			 else tmp+=v,tt++;\r\n\r\n\r\n\r\n			 if(tmp>res)\r\n\r\n			 {\r\n\r\n				res=tmp;\r\n\r\n				rs=ts;\r\n\r\n				rt=tt;\r\n\r\n			 }\r\n\r\n		   }\r\n\r\n	   }\r\n\r\n	   if(cnt!=0) printf("\\n"); \r\n\r\n	   printf("Case %d:\\n",++cnt);\r\n\r\n	   printf("%d %d %d\\n",res,rs,rt);\r\n\r\n	}\r\n\r\n	return 0;\r\n\r\n}', '', 15, 258048, 1, 2, '2011-01-26 15:55:19', '0001-01-01 00:00:00'),
(1444, 16, 402, 8, '#include <stdio.h>\r\n\r\n#include <string.h>\r\n\r\n#define N 1005\r\n\r\nchar str_a[N], str_b[N], str_c[N];\r\n\r\nint  a[N], b[N];\r\n\r\n\r\n\r\nvoid cal()\r\n\r\n{\r\n\r\n	int i, j, car;\r\n\r\n	memset(a, 0, N*sizeof(int));\r\n\r\n	memset(b, 0, N*sizeof(int));\r\n\r\n	a[0] = strlen(str_a);\r\n\r\n	b[0] = strlen(str_b);\r\n\r\n\r\n\r\n	for (i = a[0] - 1, j = 0; i >= 0; --i)\r\n\r\n		a[++j] = str_a[i] - ''0''; \r\n\r\n	for (i = b[0] - 1, j = 0; i >= 0; --i)\r\n\r\n		b[++j] = str_b[i] - ''0'';\r\n\r\n	a[0] = a[0] > b[0] ? a[0] : b[0];\r\n\r\n\r\n\r\n	i = 1, car = 0;\r\n\r\n	while (i <= a[0]) {\r\n\r\n		a[i] += ( b[i] + car);\r\n\r\n		car = a[i] / 10;\r\n\r\n		a[i] %= 10;\r\n\r\n		++i;\r\n\r\n	}\r\n\r\n	\r\n\r\n	while (car) {\r\n\r\n		a[i] += car;\r\n\r\n		car = a[i] / 10;\r\n\r\n		a[i] %= 10;\r\n\r\n		++i;\r\n\r\n	}\r\n\r\n	a[0] = i - 1;\r\n\r\n	\r\n\r\n	j = 0, i = a[0];\r\n\r\n	while (i >= 1)\r\n\r\n		str_c[j++] = a[i--] + ''0'';\r\n\r\n	str_c[j] = ''\\0'';\r\n\r\n}\r\n\r\n\r\n\r\nint main()\r\n\r\n{\r\n\r\n	int T, i;\r\n\r\n	scanf("%d",&T);\r\n\r\n	for (i = 1; i <= T; ++i) {\r\n\r\n	    scanf("%s %s",str_a,str_b);\r\n\r\n		cal();\r\n\r\n		printf("Case %d:\\n",i);\r\n\r\n		printf("%s + %s = %s\\n",str_a,str_b,str_c);\r\n\r\n		if (i != T) printf("\\n");\r\n\r\n	}\r\n\r\n	return 0;\r\n\r\n}\r\n', '', 0, 262144, 1, 2, '2011-01-26 16:00:02', '0001-01-01 00:00:00'),
(1445, 16, 404, 9, '#include <stdio.h>\r\n#include <string.h>\r\n#define Type int \r\n#define MAXN 5\r\nint Mod, Size;\r\nstruct Matrix {\r\n	Type Mat[MAXN][MAXN];\r\n	Matrix() {\r\n		memset(Mat, 0, sizeof(Mat));\r\n	}\r\n	void Init() { \r\n		for (int i = 0; i < Size; ++i) {\r\n			for (int j = 0; j < Size; ++j)\r\n				scanf("%d",&Mat[i][j]);\r\n		}\r\n	}\r\n	void Unit() {\r\n		for (int i = 0; i < Size; ++i) {\r\n			for (int j = 0; j < Size; ++j) \r\n				Mat[i][j] = (i == j);\r\n		}\r\n	}\r\n	void Print() {\r\n		int i, j;\r\n		for (i = 0; i < Size; ++i) {\r\n			for (j = 0; j < (Size - 1) ; ++j)\r\n				printf("%d ",Mat[i][j]);\r\n			printf("%d\\n",Mat[i][j]);\r\n		}\r\n		printf("\\n");\r\n	}\r\n};\r\n\r\n//矩阵相乘\r\nMatrix MMul(Matrix& A,Matrix& B) \r\n{\r\n	Matrix Ans;\r\n	for (int i = 0; i < Size; ++i) {\r\n		for (int x = 0; x < Size; ++x) {\r\n			if (!A.Mat[x][i]) continue;\r\n			for (int y = 0; y < Size; ++y) {\r\n				if (!B.Mat[i][y]) continue;\r\n				Ans.Mat[x][y] += (A.Mat[x][i] * B.Mat[i][y])%Mod;\r\n				if (Ans.Mat[x][y] >= Mod || Ans.Mat[x][y] <= -Mod) {\r\n                    Ans.Mat[x][y] %= Mod;\r\n				}\r\n				Ans.Mat[x][y] %= Mod;\r\n			}\r\n		}\r\n	}\r\n	return Ans;\r\n}\r\n\r\n//矩阵二分求幂\r\nMatrix MPow(Matrix& Mat, int Pow) \r\n{\r\n	Matrix Ans, Tmp(Mat);\r\n	for (Ans.Unit(); Pow ; Pow >>= 1) {\r\n		//printf("22222\\n");\r\n		if ((Pow & 1))\r\n			Ans = MMul(Ans, Tmp);\r\n		Tmp = MMul(Tmp, Tmp);\r\n   }\r\n   return Ans;\r\n}\r\n\r\nint main() \r\n{\r\n   int T;\r\n   Matrix Mat, Tmp;\r\n   Mod = 2011, Size = 4;\r\n   scanf("%d",&T);\r\n   while (T--) {\r\n	   Mat.Init();\r\n	   //printf("111\\n");\r\n	   Mat = MPow(Mat, 2011);\r\n	   Mat.Print();\r\n   }\r\n   return 0;\r\n}', '', 46, 258048, 1, 2, '2011-01-26 16:02:11', '0001-01-01 00:00:00'),
(1446, 1, 1, 0, '1', '', 0, 0, 0, 1, '2011-02-13 01:24:46', '2011-02-13 01:24:46');

-- --------------------------------------------------------

--
-- 表的结构 `tbl_users`
--

DROP TABLE IF EXISTS `tbl_users`;
CREATE TABLE IF NOT EXISTS `tbl_users` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `username` varchar(20) NOT NULL,
  `password` varchar(128) NOT NULL,
  `email` varchar(128) NOT NULL,
  `activkey` varchar(128) NOT NULL DEFAULT '',
  `createtime` int(10) NOT NULL DEFAULT '0',
  `lastvisit` int(10) NOT NULL DEFAULT '0',
  `superuser` int(1) NOT NULL DEFAULT '0',
  `status` int(1) NOT NULL DEFAULT '0',
  PRIMARY KEY (`id`),
  UNIQUE KEY `username` (`username`),
  UNIQUE KEY `email` (`email`),
  KEY `status` (`status`),
  KEY `superuser` (`superuser`)
) ENGINE=InnoDB  DEFAULT CHARSET=utf8 AUTO_INCREMENT=40 ;

--
-- 转存表中的数据 `tbl_users`
--

INSERT INTO `tbl_users` (`id`, `username`, `password`, `email`, `activkey`, `createtime`, `lastvisit`, `superuser`, `status`) VALUES
(1, 'admin', 'c83f15a3a261e87c83645d411e5c4219', 'shpchen@sina.com', '467a4c5cb7ab60850a56d6287c4f2d33', 1265604084, 1297448282, 1, 1),
(2, 'casper', 'c83f15a3a261e87c83645d411e5c4219', 'shpchen@ustc.edu.cn', '82607c1f01dabfc99b505b27287dbefb', 1273012536, 1273012536, 1, 1),
(3, 'foxhu', '28b41e3fc59fad1cd03afa5d1bfd3d9671489050', '920764993@qq.com', '28b41e3fc59fad1cd03afa5d1bfd3d9671489050', 1281152204, 1284635024, 0, 1),
(4, 'hu', '39b5469212012ac47d277e3fae3173ec2e4d3e84', 'humaoli@163.com', '39b5469212012ac47d277e3fae3173ec2e4d3e84', 1281152258, 1281152258, 0, 1),
(5, 'Mountain', '7f135151489d7cb9e251f4d491f379f7eae911ca', 'i_believe_you123@yahoo.cn', '7f135151489d7cb9e251f4d491f379f7eae911ca', 1281162945, 1281162945, 0, 1),
(6, 'ljz1989', 'dc3463e841039da7aca02351f29a7207ffddadbe', 'liaojiazhao@yahoo.com.cn', 'dc3463e841039da7aca02351f29a7207ffddadbe', 1282838097, 1285849912, 0, 1),
(7, 'mwkfeng', '390739774be1f8c059aeb08ed0c77c9af46149ba', 'mwkfeng@gmail.com', '390739774be1f8c059aeb08ed0c77c9af46149ba', 1282838285, 1283762243, 0, 1),
(8, 'test', 'dc3463e841039da7aca02351f29a7207ffddadbe', '13798995045@139.com', 'dc3463e841039da7aca02351f29a7207ffddadbe', 1282841818, 1282841818, 0, 1),
(9, 'rayjancy', '2ffcebaa95c2d059ccbebfcee289f5334d2dbb59', '245878781@qq.com', '2ffcebaa95c2d059ccbebfcee289f5334d2dbb59', 1284595422, 1284595422, 0, 1),
(10, 'lahm', '0a184b035c9ede3070a71325422d05380c8f3d0e', 'chenquan3232@163.com', '0a184b035c9ede3070a71325422d05380c8f3d0e', 1284595445, 1284595445, 0, 1),
(11, '2008052506', '13b1aad680b0b48858adaf016d5cc6c9d4813379', '516233464@qq.com', '13b1aad680b0b48858adaf016d5cc6c9d4813379', 1284595448, 1284595448, 0, 1),
(12, '罗海铭', '1972cc245c56f8fcc1912711249004100d0bd3bd', '519335436@qq.com', '1972cc245c56f8fcc1912711249004100d0bd3bd', 1284595468, 1284601631, 0, 1),
(13, 'liyang', '4bec196ea4f2800575a771dffe433058f6faf2d8', 'kapo0342@yahoo.com.cn', '4bec196ea4f2800575a771dffe433058f6faf2d8', 1284595468, 1293063636, 0, 1),
(14, 'zhujiasheng', 'b3208b3af69297ddf965bf0ffe30837022f88707', '809214263@qq.com', 'b3208b3af69297ddf965bf0ffe30837022f88707', 1284595477, 1284595477, 0, 1),
(15, 'Tinsy', '4b9b30d8c5aea10bdb7b88fca7cd0d004d9d1adb', '376409964@qq.com', '4b9b30d8c5aea10bdb7b88fca7cd0d004d9d1adb', 1284595487, 1293063647, 0, 1),
(16, 'rdfe222', '06a6275a520d7cb8ffe33c2c299a95330aaee748', '489635196@qq.com', '06a6275a520d7cb8ffe33c2c299a95330aaee748', 1284595501, 1284595501, 0, 1),
(17, 'santahang', '2363d639f9011fc7c5285800397c3a98ecef80e0', 'jacksonwithyou@yahoo.cn', '2363d639f9011fc7c5285800397c3a98ecef80e0', 1284595502, 1284595502, 0, 1),
(18, 'chenyifan', 'cfbac160e2ec316f66bded5a941cd60a1bc6007c', '594249891@qq.com', 'cfbac160e2ec316f66bded5a941cd60a1bc6007c', 1284595518, 1284595518, 0, 1),
(19, 'seven', 'e55db55d7cfcd10a06ab6fa1b9b81214db96c9fa', '32641495@qq.com', 'e55db55d7cfcd10a06ab6fa1b9b81214db96c9fa', 1284595548, 1284595548, 0, 1),
(20, '2008052867', '0267cfbf6dc43b4067636df1f3abd8502d74b9cd', 'happy-cmx@163.com', '0267cfbf6dc43b4067636df1f3abd8502d74b9cd', 1284595606, 1284595606, 0, 1),
(21, 'asd302830', '3e90c7c6a19449ec77a2d240cf903784cbf4227e', '451157443@qq.com', '3e90c7c6a19449ec77a2d240cf903784cbf4227e', 1284595633, 1284595633, 0, 1),
(22, '真理', '3e0d04f614b8568ca84f35c8e88c8b56c55212d5', '1033397599@qq.com', '3e0d04f614b8568ca84f35c8e88c8b56c55212d5', 1284595666, 1284595666, 0, 1),
(23, '2008052503', '9d02ca27ac88722ce361bbc4e7875254637c8a8e', 'benzero2010@hotmail.com', '9d02ca27ac88722ce361bbc4e7875254637c8a8e', 1284595730, 1284595730, 0, 1),
(24, 'wuhao', '1934b97169caa45b0e5adde92c1b4bad6bc7c829', 'wuhaogzr@vip.qq.com', '1934b97169caa45b0e5adde92c1b4bad6bc7c829', 1284595731, 1293955008, 0, 1),
(25, 'AC_Crush', '3365ea17e05af8e0945e73b1519fc82b6a40639b', '854153483@qq.com', '3365ea17e05af8e0945e73b1519fc82b6a40639b', 1284595745, 1284595745, 0, 1),
(26, '梁海瑞', '66e8abcd2d305e4df3b272a63e4504d9297eab97', '1025369416@qq.com', '66e8abcd2d305e4df3b272a63e4504d9297eab97', 1284596434, 1293610097, 0, 1),
(27, '吴豪波', '88a979ac1261ba8934daa19cf1c2c0db01b5cf51', '928896617@qq.com', '88a979ac1261ba8934daa19cf1c2c0db01b5cf51', 1284596473, 1284596473, 0, 1),
(28, 'lhm15', 'dd1677534156c080f4bbfa9fbc3015997a8c5a17', 'rolfm@163.com', 'dd1677534156c080f4bbfa9fbc3015997a8c5a17', 1284817985, 1284817985, 0, 1),
(29, 'lion', '1bdc34978960a4fd199b56b1560fcc0570b3908f', 'xiaoduan@qq.com', '1bdc34978960a4fd199b56b1560fcc0570b3908f', 1285774515, 1285774515, 0, 1),
(30, 'mengsifan', 'e55db55d7cfcd10a06ab6fa1b9b81214db96c9fa', '714206320@qq.com', 'e55db55d7cfcd10a06ab6fa1b9b81214db96c9fa', 1285805315, 1285805315, 0, 1),
(31, '2008052505', '301bab851c804a6e9e5a5b4e650179a091d00d29', '657202492@qq.com', '301bab851c804a6e9e5a5b4e650179a091d00d29', 1285805386, 1285805386, 0, 1),
(32, 'jnu405', '488690380519d15570e50e11a3a9fe5172f2ead9', '991011715@qq.com', '488690380519d15570e50e11a3a9fe5172f2ead9', 1286000225, 1286000225, 0, 1),
(33, 'jnu123', '7c14902093e3375bb64bc78604cf7ef782cb3faa', '523087924@qq.com', '7c14902093e3375bb64bc78604cf7ef782cb3faa', 1286349948, 1286354453, 0, 1),
(34, 'Cololabis saira', '39b5469212012ac47d277e3fae3173ec2e4d3e84', '947083374@qq.com', '39b5469212012ac47d277e3fae3173ec2e4d3e84', 1286606600, 1286606639, 0, 1),
(35, '库比浪', 'a9eb7ab81ad9e46c6c072ce59b3413ffff56053d', 'wq_yeah@sina.com', 'a9eb7ab81ad9e46c6c072ce59b3413ffff56053d', 1288224189, 1289436849, 0, 1),
(36, 'boo', '0f993e210d5fde043209b76886fdce901c8d9856', '237024302@qq.com', '0f993e210d5fde043209b76886fdce901c8d9856', 1288248439, 1288248439, 0, 1),
(37, 'fresher', 'e9e4ac9fe68374e833347ab2ff21a148c36d94c2', '363234737@qq.com', 'e9e4ac9fe68374e833347ab2ff21a148c36d94c2', 1289872853, 1289872853, 0, 1),
(38, 'lhr', '66e8abcd2d305e4df3b272a63e4504d9297eab97', 'lhr2050@163.com', '66e8abcd2d305e4df3b272a63e4504d9297eab97', 1293610204, 1293610204, 0, 1),
(39, 'yujammyy', '52fbe127b6d4aaac0c1c1420df692bee2fc9689b', '895176142@qq.com', '52fbe127b6d4aaac0c1c1420df692bee2fc9689b', 1294496497, 1294569519, 0, 1);

--
-- 限制导出的表
--

--
-- 限制表 `authassignment`
--
ALTER TABLE `authassignment`
  ADD CONSTRAINT `authassignment_ibfk_1` FOREIGN KEY (`itemname`) REFERENCES `authitem` (`name`) ON DELETE CASCADE ON UPDATE CASCADE;

--
-- 限制表 `authitemchild`
--
ALTER TABLE `authitemchild`
  ADD CONSTRAINT `authitemchild_ibfk_1` FOREIGN KEY (`parent`) REFERENCES `authitem` (`name`) ON DELETE CASCADE ON UPDATE CASCADE,
  ADD CONSTRAINT `authitemchild_ibfk_2` FOREIGN KEY (`child`) REFERENCES `authitem` (`name`) ON DELETE CASCADE ON UPDATE CASCADE;
